/*! Built with http://stenciljs.com */
warpview.loadBundle("chunk-4d253462.js", ["exports", "./chunk-97216db3.js"], function (t, e) { window.warpview.h; var i, n = { noop: function () { }, uid: (i = 0, function () { return i++; }), isNullOrUndef: function (t) { return null === t || void 0 === t; }, isArray: Array.isArray ? Array.isArray : function (t) { return "[object Array]" === Object.prototype.toString.call(t); }, isObject: function (t) { return null !== t && "[object Object]" === Object.prototype.toString.call(t); }, valueOrDefault: function (t, e) { return void 0 === t ? e : t; }, valueAtIndexOrDefault: function (t, e, i) { return n.valueOrDefault(n.isArray(t) ? t[e] : t, i); }, callback: function (t, e, i) { if (t && "function" == typeof t.call)
        return t.apply(i, e); }, each: function (t, e, i, a) { var o, r, l; if (n.isArray(t))
        if (r = t.length, a)
            for (o = r - 1; o >= 0; o--)
                e.call(i, t[o], o);
        else
            for (o = 0; o < r; o++)
                e.call(i, t[o], o);
    else if (n.isObject(t))
        for (r = (l = Object.keys(t)).length, o = 0; o < r; o++)
            e.call(i, t[l[o]], l[o]); }, arrayEquals: function (t, e) { var i, a, o, r; if (!t || !e || t.length !== e.length)
        return !1; for (i = 0, a = t.length; i < a; ++i)
        if (o = t[i], r = e[i], o instanceof Array && r instanceof Array) {
            if (!n.arrayEquals(o, r))
                return !1;
        }
        else if (o !== r)
            return !1; return !0; }, clone: function (t) { if (n.isArray(t))
        return t.map(n.clone); if (n.isObject(t)) {
        for (var e = {}, i = Object.keys(t), a = i.length, o = 0; o < a; ++o)
            e[i[o]] = n.clone(t[i[o]]);
        return e;
    } return t; }, _merger: function (t, e, i, a) { var o = e[t], r = i[t]; n.isObject(o) && n.isObject(r) ? n.merge(o, r, a) : e[t] = n.clone(r); }, _mergerIf: function (t, e, i) { var a = e[t], o = i[t]; n.isObject(a) && n.isObject(o) ? n.mergeIf(a, o) : e.hasOwnProperty(t) || (e[t] = n.clone(o)); }, merge: function (t, e, i) { var a, o, r, l, s, d = n.isArray(e) ? e : [e], u = d.length; if (!n.isObject(t))
        return t; for (a = (i = i || {}).merger || n._merger, o = 0; o < u; ++o)
        if (e = d[o], n.isObject(e))
            for (s = 0, l = (r = Object.keys(e)).length; s < l; ++s)
                a(r[s], t, e, i); return t; }, mergeIf: function (t, e) { return n.merge(t, e, { merger: n._mergerIf }); }, extend: function (t) { for (var e = function (e, i) { t[i] = e; }, i = 1, a = arguments.length; i < a; ++i)
        n.each(arguments[i], e); return t; }, inherits: function (t) { var e = this, i = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments); }, a = function () { this.constructor = i; }; return a.prototype = e.prototype, i.prototype = new a, i.extend = n.inherits, t && n.extend(i.prototype, t), i.__super__ = e.prototype, i; } }, a = n; n.callCallback = n.callback, n.indexOf = function (t, e, i) { return Array.prototype.indexOf.call(t, e, i); }, n.getValueOrDefault = n.valueOrDefault, n.getValueAtIndexOrDefault = n.valueAtIndexOrDefault; var o = Object.freeze({ default: a, __moduleExports: a }), l = o && a || o, s = { linear: function (t) { return t; }, easeInQuad: function (t) { return t * t; }, easeOutQuad: function (t) { return -t * (t - 2); }, easeInOutQuad: function (t) { return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1); }, easeInCubic: function (t) { return t * t * t; }, easeOutCubic: function (t) { return (t -= 1) * t * t + 1; }, easeInOutCubic: function (t) { return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2); }, easeInQuart: function (t) { return t * t * t * t; }, easeOutQuart: function (t) { return -((t -= 1) * t * t * t - 1); }, easeInOutQuart: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2); }, easeInQuint: function (t) { return t * t * t * t * t; }, easeOutQuint: function (t) { return (t -= 1) * t * t * t * t + 1; }, easeInOutQuint: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2); }, easeInSine: function (t) { return 1 - Math.cos(t * (Math.PI / 2)); }, easeOutSine: function (t) { return Math.sin(t * (Math.PI / 2)); }, easeInOutSine: function (t) { return -.5 * (Math.cos(Math.PI * t) - 1); }, easeInExpo: function (t) { return 0 === t ? 0 : Math.pow(2, 10 * (t - 1)); }, easeOutExpo: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t); }, easeInOutExpo: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t)); }, easeInCirc: function (t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1); }, easeOutCirc: function (t) { return Math.sqrt(1 - (t -= 1) * t); }, easeInOutCirc: function (t) { return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }, easeInElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)); }, easeOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1); }, easeInOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = .45), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * .5 + 1); }, easeInBack: function (t) { var e = 1.70158; return t * t * ((e + 1) * t - e); }, easeOutBack: function (t) { var e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1; }, easeInOutBack: function (t) { var e = 1.70158; return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2); }, easeInBounce: function (t) { return 1 - s.easeOutBounce(1 - t); }, easeOutBounce: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375; }, easeInOutBounce: function (t) { return t < .5 ? .5 * s.easeInBounce(2 * t) : .5 * s.easeOutBounce(2 * t - 1) + .5; } }, d = { effects: s }; l.easingEffects = s; var u = d.effects, h = Object.freeze({ default: d, __moduleExports: d, effects: u }), c = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function f(t, e) { return t(e = { exports: {} }, e.exports), e.exports; } var p = f(function (t) { var e = t.exports = { clear: function (t) { t.ctx.clearRect(0, 0, t.width, t.height); }, roundedRect: function (t, e, i, n, a, o) { if (o) {
        var r = Math.min(o, n / 2), l = Math.min(o, a / 2);
        t.moveTo(e + r, i), t.lineTo(e + n - r, i), t.quadraticCurveTo(e + n, i, e + n, i + l), t.lineTo(e + n, i + a - l), t.quadraticCurveTo(e + n, i + a, e + n - r, i + a), t.lineTo(e + r, i + a), t.quadraticCurveTo(e, i + a, e, i + a - l), t.lineTo(e, i + l), t.quadraticCurveTo(e, i, e + r, i);
    }
    else
        t.rect(e, i, n, a); }, drawPoint: function (t, e, i, n, a) { var o, r, l, s, d, u; if (!e || "object" != typeof e || "[object HTMLImageElement]" !== (o = e.toString()) && "[object HTMLCanvasElement]" !== o) {
        if (!(isNaN(i) || i <= 0)) {
            switch (e) {
                default:
                    t.beginPath(), t.arc(n, a, i, 0, 2 * Math.PI), t.closePath(), t.fill();
                    break;
                case "triangle":
                    t.beginPath(), d = (r = 3 * i / Math.sqrt(3)) * Math.sqrt(3) / 2, t.moveTo(n - r / 2, a + d / 3), t.lineTo(n + r / 2, a + d / 3), t.lineTo(n, a - 2 * d / 3), t.closePath(), t.fill();
                    break;
                case "rect":
                    u = 1 / Math.SQRT2 * i, t.beginPath(), t.fillRect(n - u, a - u, 2 * u, 2 * u), t.strokeRect(n - u, a - u, 2 * u, 2 * u);
                    break;
                case "rectRounded":
                    var h = i / Math.SQRT2, c = n - h, f = a - h, g = Math.SQRT2 * i;
                    t.beginPath(), this.roundedRect(t, c, f, g, g, i / 2), t.closePath(), t.fill();
                    break;
                case "rectRot":
                    u = 1 / Math.SQRT2 * i, t.beginPath(), t.moveTo(n - u, a), t.lineTo(n, a + u), t.lineTo(n + u, a), t.lineTo(n, a - u), t.closePath(), t.fill();
                    break;
                case "cross":
                    t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath();
                    break;
                case "crossRot":
                    t.beginPath(), l = Math.cos(Math.PI / 4) * i, s = Math.sin(Math.PI / 4) * i, t.moveTo(n - l, a - s), t.lineTo(n + l, a + s), t.moveTo(n - l, a + s), t.lineTo(n + l, a - s), t.closePath();
                    break;
                case "star":
                    t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), l = Math.cos(Math.PI / 4) * i, s = Math.sin(Math.PI / 4) * i, t.moveTo(n - l, a - s), t.lineTo(n + l, a + s), t.moveTo(n - l, a + s), t.lineTo(n + l, a - s), t.closePath();
                    break;
                case "line":
                    t.beginPath(), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath();
                    break;
                case "dash": t.beginPath(), t.moveTo(n, a), t.lineTo(n + i, a), t.closePath();
            }
            t.stroke();
        }
    }
    else
        t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height); }, clipArea: function (t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip(); }, unclipArea: function (t) { t.restore(); }, lineTo: function (t, e, i, n) { if (i.steppedLine)
        return "after" === i.steppedLine && !n || "after" !== i.steppedLine && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y), void t.lineTo(i.x, i.y); i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y); } }; l.clear = e.clear, l.drawRoundedRectangle = function (t) { t.beginPath(), e.roundedRect.apply(e, arguments), t.closePath(); }; }), m = p.clear, v = p.roundedRect, x = p.drawPoint, y = p.clipArea, k = p.unclipArea, w = p.lineTo, M = Object.freeze({ default: p, __moduleExports: p, clear: m, roundedRect: v, drawPoint: x, clipArea: y, unclipArea: k, lineTo: w }), _ = { toLineHeight: function (t, e) { var i = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!i || "normal" === i[1])
        return 1.2 * e; switch (t = +i[2], i[3]) {
        case "px": return t;
        case "%": t /= 100;
    } return e * t; }, toPadding: function (t) { var e, i, n, a; return l.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, n = +t.bottom || 0, a = +t.left || 0) : e = i = n = a = +t || 0, { top: e, right: i, bottom: n, left: a, height: e + n, width: a + i }; }, resolve: function (t, e, i) { var n, a, o; for (n = 0, a = t.length; n < a; ++n)
        if (void 0 !== (o = t[n]) && (void 0 !== e && "function" == typeof o && (o = o(e)), void 0 !== i && l.isArray(o) && (o = o[i]), void 0 !== o))
            return o; } }, S = _.toLineHeight, C = _.toPadding, D = _.resolve, I = Object.freeze({ default: _, __moduleExports: _, toLineHeight: S, toPadding: C, resolve: D }), A = l, P = h && d || h, O = M && p || M, T = I && _ || I; A.easing = P, A.canvas = O, A.options = T; var F = Object.freeze({ default: A, __moduleExports: A, easing: P, canvas: O, options: T }), z = F && A || F, R = { _set: function (t, e) { return z.merge(this[t] || (this[t] = {}), e); } }, L = R._set, B = Object.freeze({ default: R, __moduleExports: R, _set: L }), E = B && R || B; E._set("global", { responsive: !0, responsiveAnimationDuration: 0, maintainAspectRatio: !0, events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"], hover: { onHover: null, mode: "nearest", intersect: !0, animationDuration: 400 }, onClick: null, defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", showLines: !0, elements: {}, layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } } }); var W = function () { var t = function (t, e) { return this.construct(t, e), this; }; return t.Chart = t, t; }, N = Object.freeze({ default: W, __moduleExports: W }), V = { rgb2hsl: H, rgb2hsv: j, rgb2hwb: q, rgb2cmyk: Y, rgb2keyword: U, rgb2xyz: X, rgb2lab: K, rgb2lch: function (t) { return it(K(t)); }, hsl2rgb: G, hsl2hsv: function (t) { var e = t[0], i = t[1] / 100, n = t[2] / 100; return 0 === n ? [0, 0, 0] : [e, 2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i) * 100, (n + i) / 2 * 100]; }, hsl2hwb: function (t) { return q(G(t)); }, hsl2cmyk: function (t) { return Y(G(t)); }, hsl2keyword: function (t) { return U(G(t)); }, hsv2rgb: J, hsv2hsl: function (t) { var e, i, n = t[0], a = t[1] / 100, o = t[2] / 100; return e = a * o, [n, 100 * (e = (e /= (i = (2 - a) * o) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)]; }, hsv2hwb: function (t) { return q(J(t)); }, hsv2cmyk: function (t) { return Y(J(t)); }, hsv2keyword: function (t) { return U(J(t)); }, hwb2rgb: Z, hwb2hsl: function (t) { return H(Z(t)); }, hwb2hsv: function (t) { return j(Z(t)); }, hwb2cmyk: function (t) { return Y(Z(t)); }, hwb2keyword: function (t) { return U(Z(t)); }, cmyk2rgb: Q, cmyk2hsl: function (t) { return H(Q(t)); }, cmyk2hsv: function (t) { return j(Q(t)); }, cmyk2hwb: function (t) { return q(Q(t)); }, cmyk2keyword: function (t) { return U(Q(t)); }, keyword2rgb: ot, keyword2hsl: function (t) { return H(ot(t)); }, keyword2hsv: function (t) { return j(ot(t)); }, keyword2hwb: function (t) { return q(ot(t)); }, keyword2cmyk: function (t) { return Y(ot(t)); }, keyword2lab: function (t) { return K(ot(t)); }, keyword2xyz: function (t) { return X(ot(t)); }, xyz2rgb: $, xyz2lab: tt, xyz2lch: function (t) { return it(tt(t)); }, lab2xyz: et, lab2rgb: nt, lab2lch: it, lch2lab: at, lch2xyz: function (t) { return et(at(t)); }, lch2rgb: function (t) { return nt(at(t)); } }; function H(t) { var e, i, n = t[0] / 255, a = t[1] / 255, o = t[2] / 255, r = Math.min(n, a, o), l = Math.max(n, a, o), s = l - r; return l == r ? e = 0 : n == l ? e = (a - o) / s : a == l ? e = 2 + (o - n) / s : o == l && (e = 4 + (n - a) / s), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (r + l) / 2, [e, 100 * (l == r ? 0 : i <= .5 ? s / (l + r) : s / (2 - l - r)), 100 * i]; } function j(t) { var e, i, n = t[0], a = t[1], o = t[2], r = Math.min(n, a, o), l = Math.max(n, a, o), s = l - r; return i = 0 == l ? 0 : s / l * 1e3 / 10, l == r ? e = 0 : n == l ? e = (a - o) / s : a == l ? e = 2 + (o - n) / s : o == l && (e = 4 + (n - a) / s), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, l / 255 * 1e3 / 10]; } function q(t) { var e = t[0], i = t[1], n = t[2]; return [H(t)[0], 1 / 255 * Math.min(e, Math.min(i, n)) * 100, 100 * (n = 1 - 1 / 255 * Math.max(e, Math.max(i, n)))]; } function Y(t) { var e, i = t[0] / 255, n = t[1] / 255, a = t[2] / 255; return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - a))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * e]; } function U(t) { return lt[JSON.stringify(t)]; } function X(t) { var e = t[0] / 255, i = t[1] / 255, n = t[2] / 255; return [100 * (.4124 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92)), 100 * (.2126 * e + .7152 * i + .0722 * n), 100 * (.0193 * e + .1192 * i + .9505 * n)]; } function K(t) { var e = X(t), i = e[0], n = e[1], a = e[2]; return n /= 100, a /= 108.883, i = (i /= 95.047) > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))]; } function G(t) { var e, i, n, a, o, r = t[0] / 360, l = t[1] / 100, s = t[2] / 100; if (0 == l)
    return [o = 255 * s, o, o]; e = 2 * s - (i = s < .5 ? s * (1 + l) : s + l - s * l), a = [0, 0, 0]; for (var d = 0; d < 3; d++)
    (n = r + 1 / 3 * -(d - 1)) < 0 && n++, n > 1 && n--, o = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, a[d] = 255 * o; return a; } function J(t) { var e = t[0] / 60, i = t[1] / 100, n = t[2] / 100, a = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * n * (1 - i), l = 255 * n * (1 - i * o), s = 255 * n * (1 - i * (1 - o)); switch (n *= 255, a) {
    case 0: return [n, s, r];
    case 1: return [l, n, r];
    case 2: return [r, n, s];
    case 3: return [r, l, n];
    case 4: return [s, r, n];
    case 5: return [n, r, l];
} } function Z(t) { var e, i, n, a, o = t[0] / 360, l = t[1] / 100, s = t[2] / 100, d = l + s; switch (d > 1 && (l /= d, s /= d), i = 1 - s, n = 6 * o - (e = Math.floor(6 * o)), 0 != (1 & e) && (n = 1 - n), a = l + n * (i - l), e) {
    default:
    case 6:
    case 0:
        r = i, g = a, b = l;
        break;
    case 1:
        r = a, g = i, b = l;
        break;
    case 2:
        r = l, g = i, b = a;
        break;
    case 3:
        r = l, g = a, b = i;
        break;
    case 4:
        r = a, g = l, b = i;
        break;
    case 5: r = i, g = l, b = a;
} return [255 * r, 255 * g, 255 * b]; } function Q(t) { var e = t[0] / 100, i = t[1] / 100, n = t[2] / 100, a = t[3] / 100; return [255 * (1 - Math.min(1, e * (1 - a) + a)), 255 * (1 - Math.min(1, i * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a))]; } function $(t) { var e, i, n, a = t[0] / 100, o = t[1] / 100, r = t[2] / 100; return i = -.9689 * a + 1.8758 * o + .0415 * r, n = .0557 * a + -.204 * o + 1.057 * r, e = (e = 3.2406 * a + -1.5372 * o + -.4986 * r) > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i *= 12.92, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))]; } function tt(t) { var e = t[0], i = t[1], n = t[2]; return i /= 100, n /= 108.883, e = (e /= 95.047) > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))]; } function et(t) { var e, i, n, a, o = t[0], r = t[1], l = t[2]; return o <= 8 ? a = (i = 100 * o / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * Math.pow((o + 16) / 116, 3), a = Math.pow(i / 100, 1 / 3)), [e = e / 95.047 <= .008856 ? e = 95.047 * (r / 500 + a - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + a, 3), i, n = n / 108.883 <= .008859 ? n = 108.883 * (a - l / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(a - l / 200, 3)]; } function it(t) { var e, i = t[0], n = t[1], a = t[2]; return (e = 360 * Math.atan2(a, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + a * a), e]; } function nt(t) { return $(et(t)); } function at(t) { var e, i = t[0], n = t[1]; return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)]; } function ot(t) { return rt[t]; } var rt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, lt = {}; for (var st in rt)
    lt[JSON.stringify(rt[st])] = st; var dt = V.rgb2hsl, ut = V.rgb2hsv, ht = V.rgb2hwb, ct = V.rgb2cmyk, ft = V.rgb2keyword, gt = V.rgb2xyz, pt = V.rgb2lab, mt = V.rgb2lch, vt = V.hsl2rgb, bt = V.hsl2hsv, xt = V.hsl2hwb, yt = V.hsl2cmyk, kt = V.hsl2keyword, wt = V.hsv2rgb, Mt = V.hsv2hsl, _t = V.hsv2hwb, St = V.hsv2cmyk, Ct = V.hsv2keyword, Dt = V.hwb2rgb, It = V.hwb2hsl, At = V.hwb2hsv, Pt = V.hwb2cmyk, Ot = V.hwb2keyword, Tt = V.cmyk2rgb, Ft = V.cmyk2hsl, zt = V.cmyk2hsv, Rt = V.cmyk2hwb, Lt = V.cmyk2keyword, Bt = V.keyword2rgb, Et = V.keyword2hsl, Wt = V.keyword2hsv, Nt = V.keyword2hwb, Vt = V.keyword2cmyk, Ht = V.keyword2lab, jt = V.keyword2xyz, qt = V.xyz2rgb, Yt = V.xyz2lab, Ut = V.xyz2lch, Xt = V.lab2xyz, Kt = V.lab2rgb, Gt = V.lab2lch, Jt = V.lch2lab, Zt = V.lch2xyz, Qt = V.lch2rgb, $t = Object.freeze({ default: V, __moduleExports: V, rgb2hsl: dt, rgb2hsv: ut, rgb2hwb: ht, rgb2cmyk: ct, rgb2keyword: ft, rgb2xyz: gt, rgb2lab: pt, rgb2lch: mt, hsl2rgb: vt, hsl2hsv: bt, hsl2hwb: xt, hsl2cmyk: yt, hsl2keyword: kt, hsv2rgb: wt, hsv2hsl: Mt, hsv2hwb: _t, hsv2cmyk: St, hsv2keyword: Ct, hwb2rgb: Dt, hwb2hsl: It, hwb2hsv: At, hwb2cmyk: Pt, hwb2keyword: Ot, cmyk2rgb: Tt, cmyk2hsl: Ft, cmyk2hsv: zt, cmyk2hwb: Rt, cmyk2keyword: Lt, keyword2rgb: Bt, keyword2hsl: Et, keyword2hsv: Wt, keyword2hwb: Nt, keyword2cmyk: Vt, keyword2lab: Ht, keyword2xyz: jt, xyz2rgb: qt, xyz2lab: Yt, xyz2lch: Ut, lab2xyz: Xt, lab2rgb: Kt, lab2lch: Gt, lch2lab: Jt, lch2xyz: Zt, lch2rgb: Qt }), te = $t && V || $t, ee = function () { return new re; }; for (var ie in te) {
    ee[ie + "Raw"] = function (t) { return function (e) { return "number" == typeof e && (e = Array.prototype.slice.call(arguments)), te[t](e); }; }(ie);
    var ne = /(\w+)2(\w+)/.exec(ie), ae = ne[1], oe = ne[2];
    (ee[ae] = ee[ae] || {})[oe] = ee[ie] = function (t) { return function (e) { "number" == typeof e && (e = Array.prototype.slice.call(arguments)); var i = te[t](e); if ("string" == typeof i || void 0 === i)
        return i; for (var n = 0; n < i.length; n++)
        i[n] = Math.round(i[n]); return i; }; }(ie);
} var re = function () { this.convs = {}; }; re.prototype.routeSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i)); }, re.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this; }, re.prototype.getValues = function (t) { var e = this.convs[t]; if (!e) {
    var i = this.space, n = this.convs[i];
    e = ee[i][t](n), this.convs[t] = e;
} return e; }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (t) { re.prototype[t] = function (e) { return this.routeSpace(t, arguments); }; }); var le = ee, se = Object.freeze({ default: le, __moduleExports: le }), de = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, ue = Object.freeze({ default: de, __moduleExports: de }), he = ue && de || ue, ce = { getRgba: fe, getHsla: ge, getRgb: function (t) { var e = fe(t); return e && e.slice(0, 3); }, getHsl: function (t) { var e = ge(t); return e && e.slice(0, 3); }, getHwb: pe, getAlpha: function (t) { var e = fe(t); return e ? e[3] : (e = ge(t)) ? e[3] : (e = pe(t)) ? e[3] : void 0; }, hexString: function (t) { return "#" + ye(t[0]) + ye(t[1]) + ye(t[2]); }, rgbString: function (t, e) { return e < 1 || t[3] && t[3] < 1 ? me(t, e) : "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")"; }, rgbaString: me, percentString: function (t, e) { return e < 1 || t[3] && t[3] < 1 ? ve(t, e) : "rgb(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%)"; }, percentaString: ve, hslString: function (t, e) { return e < 1 || t[3] && t[3] < 1 ? be(t, e) : "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)"; }, hslaString: be, hwbString: function (t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")"; }, keyword: function (t) { return ke[t.slice(0, 3)]; } }; function fe(t) { if (t) {
    var e = [0, 0, 0], i = 1, n = t.match(/^#([a-fA-F0-9]{3})$/i);
    if (n) {
        n = n[1];
        for (var a = 0; a < e.length; a++)
            e[a] = parseInt(n[a] + n[a], 16);
    }
    else if (n = t.match(/^#([a-fA-F0-9]{6})$/i))
        for (n = n[1], a = 0; a < e.length; a++)
            e[a] = parseInt(n.slice(2 * a, 2 * a + 2), 16);
    else if (n = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
        for (a = 0; a < e.length; a++)
            e[a] = parseInt(n[a + 1]);
        i = parseFloat(n[4]);
    }
    else if (n = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
        for (a = 0; a < e.length; a++)
            e[a] = Math.round(2.55 * parseFloat(n[a + 1]));
        i = parseFloat(n[4]);
    }
    else if (n = t.match(/(\w+)/)) {
        if ("transparent" == n[1])
            return [0, 0, 0, 0];
        if (!(e = he[n[1]]))
            return;
    }
    for (a = 0; a < e.length; a++)
        e[a] = xe(e[a], 0, 255);
    return i = i || 0 == i ? xe(i, 0, 1) : 1, e[3] = i, e;
} } function ge(t) { if (t) {
    var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
    if (e) {
        var i = parseFloat(e[4]);
        return [xe(parseInt(e[1]), 0, 360), xe(parseFloat(e[2]), 0, 100), xe(parseFloat(e[3]), 0, 100), xe(isNaN(i) ? 1 : i, 0, 1)];
    }
} } function pe(t) { if (t) {
    var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
    if (e) {
        var i = parseFloat(e[4]);
        return [xe(parseInt(e[1]), 0, 360), xe(parseFloat(e[2]), 0, 100), xe(parseFloat(e[3]), 0, 100), xe(isNaN(i) ? 1 : i, 0, 1)];
    }
} } function me(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")"; } function ve(t, e) { return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")"; } function be(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")"; } function xe(t, e, i) { return Math.min(Math.max(e, t), i); } function ye(t) { var e = t.toString(16).toUpperCase(); return e.length < 2 ? "0" + e : e; } var ke = {}; for (var we in he)
    ke[he[we]] = we; var Me = ce.getRgba, _e = ce.getHsla, Se = ce.getRgb, Ce = ce.getHsl, De = ce.getHwb, Ie = ce.getAlpha, Ae = ce.hexString, Pe = ce.rgbString, Oe = ce.rgbaString, Te = ce.percentString, Fe = ce.percentaString, ze = ce.hslString, Re = ce.hslaString, Le = ce.hwbString, Be = ce.keyword, Ee = Object.freeze({ default: ce, __moduleExports: ce, getRgba: Me, getHsla: _e, getRgb: Se, getHsl: Ce, getHwb: De, getAlpha: Ie, hexString: Ae, rgbString: Pe, rgbaString: Oe, percentString: Te, percentaString: Fe, hslString: ze, hslaString: Re, hwbString: Le, keyword: Be }), We = se && le || se, Ne = Ee && ce || Ee, Ve = function (t) { return t instanceof Ve ? t : this instanceof Ve ? (this.valid = !1, this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 }, void ("string" == typeof t ? (e = Ne.getRgba(t)) ? this.setValues("rgb", e) : (e = Ne.getHsla(t)) ? this.setValues("hsl", e) : (e = Ne.getHwb(t)) && this.setValues("hwb", e) : "object" == typeof t && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new Ve(t); var e; }; Ve.prototype = { isValid: function () { return this.valid; }, rgb: function () { return this.setSpace("rgb", arguments); }, hsl: function () { return this.setSpace("hsl", arguments); }, hsv: function () { return this.setSpace("hsv", arguments); }, hwb: function () { return this.setSpace("hwb", arguments); }, cmyk: function () { return this.setSpace("cmyk", arguments); }, rgbArray: function () { return this.values.rgb; }, hslArray: function () { return this.values.hsl; }, hsvArray: function () { return this.values.hsv; }, hwbArray: function () { var t = this.values; return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb; }, cmykArray: function () { return this.values.cmyk; }, rgbaArray: function () { var t = this.values; return t.rgb.concat([t.alpha]); }, hslaArray: function () { var t = this.values; return t.hsl.concat([t.alpha]); }, alpha: function (t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this); }, red: function (t) { return this.setChannel("rgb", 0, t); }, green: function (t) { return this.setChannel("rgb", 1, t); }, blue: function (t) { return this.setChannel("rgb", 2, t); }, hue: function (t) { return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t); }, saturation: function (t) { return this.setChannel("hsl", 1, t); }, lightness: function (t) { return this.setChannel("hsl", 2, t); }, saturationv: function (t) { return this.setChannel("hsv", 1, t); }, whiteness: function (t) { return this.setChannel("hwb", 1, t); }, blackness: function (t) { return this.setChannel("hwb", 2, t); }, value: function (t) { return this.setChannel("hsv", 2, t); }, cyan: function (t) { return this.setChannel("cmyk", 0, t); }, magenta: function (t) { return this.setChannel("cmyk", 1, t); }, yellow: function (t) { return this.setChannel("cmyk", 2, t); }, black: function (t) { return this.setChannel("cmyk", 3, t); }, hexString: function () { return Ne.hexString(this.values.rgb); }, rgbString: function () { return Ne.rgbString(this.values.rgb, this.values.alpha); }, rgbaString: function () { return Ne.rgbaString(this.values.rgb, this.values.alpha); }, percentString: function () { return Ne.percentString(this.values.rgb, this.values.alpha); }, hslString: function () { return Ne.hslString(this.values.hsl, this.values.alpha); }, hslaString: function () { return Ne.hslaString(this.values.hsl, this.values.alpha); }, hwbString: function () { return Ne.hwbString(this.values.hwb, this.values.alpha); }, keyword: function () { return Ne.keyword(this.values.rgb, this.values.alpha); }, rgbNumber: function () { var t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2]; }, luminosity: function () { for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) {
        var n = t[i] / 255;
        e[i] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4);
    } return .2126 * e[0] + .7152 * e[1] + .0722 * e[2]; }, contrast: function (t) { var e = this.luminosity(), i = t.luminosity(); return e > i ? (e + .05) / (i + .05) : (i + .05) / (e + .05); }, level: function (t) { var e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : ""; }, dark: function () { var t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128; }, light: function () { return !this.dark(); }, negate: function () { for (var t = [], e = 0; e < 3; e++)
        t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this; }, lighten: function (t) { var e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this; }, darken: function (t) { var e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this; }, saturate: function (t) { var e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this; }, desaturate: function (t) { var e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this; }, whiten: function (t) { var e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this; }, blacken: function (t) { var e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this; }, greyscale: function () { var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2]; return this.setValues("rgb", [e, e, e]), this; }, clearer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e - e * t), this; }, opaquer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e + e * t), this; }, rotate: function (t) { var e = this.values.hsl, i = (e[0] + t) % 360; return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this; }, mix: function (t, e) { var i = t, n = void 0 === e ? .5 : e, a = 2 * n - 1, o = this.alpha() - i.alpha(), r = ((a * o == -1 ? a : (a + o) / (1 + a * o)) + 1) / 2, l = 1 - r; return this.rgb(r * this.red() + l * i.red(), r * this.green() + l * i.green(), r * this.blue() + l * i.blue()).alpha(this.alpha() * n + i.alpha() * (1 - n)); }, toJSON: function () { return this.rgb(); }, clone: function () { var t, e, i = new Ve, n = this.values, a = i.values; for (var o in n)
        n.hasOwnProperty(o) && (t = n[o], "[object Array]" === (e = {}.toString.call(t)) ? a[o] = t.slice(0) : "[object Number]" === e ? a[o] = t : console.error("unexpected color value:", t)); return i; } }, Ve.prototype.spaces = { rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"] }, Ve.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] }, Ve.prototype.getValues = function (t) { for (var e = this.values, i = {}, n = 0; n < t.length; n++)
    i[t.charAt(n)] = e[t][n]; return 1 !== e.alpha && (i.a = e.alpha), i; }, Ve.prototype.setValues = function (t, e) { var i, n, a = this.values, o = this.spaces, r = this.maxes, l = 1; if (this.valid = !0, "alpha" === t)
    l = e;
else if (e.length)
    a[t] = e.slice(0, t.length), l = e[t.length];
else if (void 0 !== e[t.charAt(0)]) {
    for (i = 0; i < t.length; i++)
        a[t][i] = e[t.charAt(i)];
    l = e.a;
}
else if (void 0 !== e[o[t][0]]) {
    var s = o[t];
    for (i = 0; i < t.length; i++)
        a[t][i] = e[s[i]];
    l = e.alpha;
} if (a.alpha = Math.max(0, Math.min(1, void 0 === l ? a.alpha : l)), "alpha" === t)
    return !1; for (i = 0; i < t.length; i++)
    n = Math.max(0, Math.min(r[t][i], a[t][i])), a[t][i] = Math.round(n); for (var d in o)
    d !== t && (a[d] = We[t][d](a[t])); return !0; }, Ve.prototype.setSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this); }, Ve.prototype.setChannel = function (t, e, i) { var n = this.values[t]; return void 0 === i ? n[e] : i === n[e] ? this : (n[e] = i, this.setValues(t, n), this); }, "undefined" != typeof window && (window.Color = Ve); var He = Ve, je = Object.freeze({ default: He, __moduleExports: He }), qe = je && He || je, Ye = function (t) { function e(t, e, i) { var n; return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n; } function i(t) { return void 0 !== t && null !== t && "none" !== t; } function n(t, n, a) { var o = document.defaultView, r = t.parentNode, l = o.getComputedStyle(t)[n], s = o.getComputedStyle(r)[n], d = i(l), u = i(s), h = Number.POSITIVE_INFINITY; return d || u ? Math.min(d ? e(l, t, a) : h, u ? e(s, r, a) : h) : "none"; } z.configMerge = function () { return z.merge(z.clone(arguments[0]), [].slice.call(arguments, 1), { merger: function (e, i, n, a) { var o = i[e] || {}, r = n[e]; "scales" === e ? i[e] = z.scaleMerge(o, r) : "scale" === e ? i[e] = z.merge(o, [t.scaleService.getScaleDefaults(r.type), r]) : z._merger(e, i, n, a); } }); }, z.scaleMerge = function () { return z.merge(z.clone(arguments[0]), [].slice.call(arguments, 1), { merger: function (e, i, n, a) { if ("xAxes" === e || "yAxes" === e) {
        var o, r, l, s = n[e].length;
        for (i[e] || (i[e] = []), o = 0; o < s; ++o)
            l = n[e][o], r = z.valueOrDefault(l.type, "xAxes" === e ? "category" : "linear"), o >= i[e].length && i[e].push({}), !i[e][o].type || l.type && l.type !== i[e][o].type ? z.merge(i[e][o], [t.scaleService.getScaleDefaults(r), l]) : z.merge(i[e][o], l);
    }
    else
        z._merger(e, i, n, a); } }); }, z.where = function (t, e) { if (z.isArray(t) && Array.prototype.filter)
    return t.filter(e); var i = []; return z.each(t, function (t) { e(t) && i.push(t); }), i; }, z.findIndex = Array.prototype.findIndex ? function (t, e, i) { return t.findIndex(e, i); } : function (t, e, i) { i = void 0 === i ? t : i; for (var n = 0, a = t.length; n < a; ++n)
    if (e.call(i, t[n], n, t))
        return n; return -1; }, z.findNextWhere = function (t, e, i) { z.isNullOrUndef(i) && (i = -1); for (var n = i + 1; n < t.length; n++) {
    var a = t[n];
    if (e(a))
        return a;
} }, z.findPreviousWhere = function (t, e, i) { z.isNullOrUndef(i) && (i = t.length); for (var n = i - 1; n >= 0; n--) {
    var a = t[n];
    if (e(a))
        return a;
} }, z.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t); }, z.almostEquals = function (t, e, i) { return Math.abs(t - e) < i; }, z.almostWhole = function (t, e) { var i = Math.round(t); return i - e < t && i + e > t; }, z.max = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.max(t, e); }, Number.NEGATIVE_INFINITY); }, z.min = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.min(t, e); }, Number.POSITIVE_INFINITY); }, z.sign = Math.sign ? function (t) { return Math.sign(t); } : function (t) { return 0 == (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1; }, z.log10 = Math.log10 ? function (t) { return Math.log10(t); } : function (t) { var e = Math.log(t) * Math.LOG10E, i = Math.round(e); return t === Math.pow(10, i) ? i : e; }, z.toRadians = function (t) { return t * (Math.PI / 180); }, z.toDegrees = function (t) { return t * (180 / Math.PI); }, z.getAngleFromPoint = function (t, e) { var i = e.x - t.x, n = e.y - t.y, a = Math.sqrt(i * i + n * n), o = Math.atan2(n, i); return o < -.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: a }; }, z.distanceBetweenPoints = function (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)); }, z.aliasPixel = function (t) { return t % 2 == 0 ? 0 : .5; }, z.splineCurve = function (t, e, i, n) { var a = t.skip ? e : t, o = e, r = i.skip ? e : i, l = Math.sqrt(Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2)), s = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)), d = l / (l + s), u = s / (l + s), h = n * (d = isNaN(d) ? 0 : d), c = n * (u = isNaN(u) ? 0 : u); return { previous: { x: o.x - h * (r.x - a.x), y: o.y - h * (r.y - a.y) }, next: { x: o.x + c * (r.x - a.x), y: o.y + c * (r.y - a.y) } }; }, z.EPSILON = Number.EPSILON || 1e-14, z.splineCurveMonotone = function (t) { var e, i, n, a, o, r, l, s, d, u = (t || []).map(function (t) { return { model: t._model, deltaK: 0, mK: 0 }; }), h = u.length; for (e = 0; e < h; ++e)
    if (!(n = u[e]).model.skip) {
        if (i = e > 0 ? u[e - 1] : null, (a = e < h - 1 ? u[e + 1] : null) && !a.model.skip) {
            var c = a.model.x - n.model.x;
            n.deltaK = 0 !== c ? (a.model.y - n.model.y) / c : 0;
        }
        !i || i.model.skip ? n.mK = n.deltaK : !a || a.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2;
    } for (e = 0; e < h - 1; ++e)
    n = u[e], a = u[e + 1], n.model.skip || a.model.skip || (z.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = a.mK = 0 : (o = n.mK / n.deltaK, r = a.mK / n.deltaK, (s = Math.pow(o, 2) + Math.pow(r, 2)) <= 9 || (l = 3 / Math.sqrt(s), n.mK = o * l * n.deltaK, a.mK = r * l * n.deltaK))); for (e = 0; e < h; ++e)
    (n = u[e]).model.skip || (i = e > 0 ? u[e - 1] : null, a = e < h - 1 ? u[e + 1] : null, i && !i.model.skip && (d = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - d, n.model.controlPointPreviousY = n.model.y - d * n.mK), a && !a.model.skip && (d = (a.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + d, n.model.controlPointNextY = n.model.y + d * n.mK)); }, z.nextItem = function (t, e, i) { return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1]; }, z.previousItem = function (t, e, i) { return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1]; }, z.niceNum = function (t, e) { var i = Math.floor(z.log10(t)), n = t / Math.pow(10, i); return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, i); }, z.requestAnimFrame = "undefined" == typeof window ? function (t) { t(); } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60); }, z.getRelativePosition = function (t, e) { var i, n, a = t.originalEvent || t, o = t.currentTarget || t.srcElement, r = o.getBoundingClientRect(), l = a.touches; l && l.length > 0 ? (i = l[0].clientX, n = l[0].clientY) : (i = a.clientX, n = a.clientY); var s = parseFloat(z.getStyle(o, "padding-left")), d = parseFloat(z.getStyle(o, "padding-top")), u = parseFloat(z.getStyle(o, "padding-right")), h = parseFloat(z.getStyle(o, "padding-bottom")), c = r.right - r.left - s - u, f = r.bottom - r.top - d - h; return { x: i = Math.round((i - r.left - s) / c * o.width / e.currentDevicePixelRatio), y: n = Math.round((n - r.top - d) / f * o.height / e.currentDevicePixelRatio) }; }, z.getConstraintWidth = function (t) { return n(t, "max-width", "clientWidth"); }, z.getConstraintHeight = function (t) { return n(t, "max-height", "clientHeight"); }, z.getMaximumWidth = function (t) { var e = t.parentNode; if (!e)
    return t.clientWidth; var i = parseInt(z.getStyle(e, "padding-left"), 10), n = parseInt(z.getStyle(e, "padding-right"), 10), a = e.clientWidth - i - n, o = z.getConstraintWidth(t); return isNaN(o) ? a : Math.min(a, o); }, z.getMaximumHeight = function (t) { var e = t.parentNode; if (!e)
    return t.clientHeight; var i = parseInt(z.getStyle(e, "padding-top"), 10), n = parseInt(z.getStyle(e, "padding-bottom"), 10), a = e.clientHeight - i - n, o = z.getConstraintHeight(t); return isNaN(o) ? a : Math.min(a, o); }, z.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e); }, z.retinaScale = function (t, e) { var i = t.currentDevicePixelRatio = e || window.devicePixelRatio || 1; if (1 !== i) {
    var n = t.canvas, a = t.height, o = t.width;
    n.height = a * i, n.width = o * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = a + "px", n.style.width = o + "px");
} }, z.fontString = function (t, e, i) { return e + " " + t + "px " + i; }, z.longestText = function (t, e, i, n) { var a = (n = n || {}).data = n.data || {}, o = n.garbageCollect = n.garbageCollect || []; n.font !== e && (a = n.data = {}, o = n.garbageCollect = [], n.font = e), t.font = e; var r = 0; z.each(i, function (e) { void 0 !== e && null !== e && !0 !== z.isArray(e) ? r = z.measureText(t, a, o, r, e) : z.isArray(e) && z.each(e, function (e) { void 0 === e || null === e || z.isArray(e) || (r = z.measureText(t, a, o, r, e)); }); }); var l = o.length / 2; if (l > i.length) {
    for (var s = 0; s < l; s++)
        delete a[o[s]];
    o.splice(0, l);
} return r; }, z.measureText = function (t, e, i, n, a) { var o = e[a]; return o || (o = e[a] = t.measureText(a).width, i.push(a)), o > n && (n = o), n; }, z.numberOfLabelLines = function (t) { var e = 1; return z.each(t, function (t) { z.isArray(t) && t.length > e && (e = t.length); }), e; }, z.color = qe ? function (t) { return t instanceof CanvasGradient && (t = E.global.defaultColor), qe(t); } : function (t) { return console.error("Color.js not found!"), t; }, z.getHoverColor = function (t) { return t instanceof CanvasPattern ? t : z.color(t).saturate(.5).darken(.1).rgbString(); }; }, Ue = Object.freeze({ default: Ye, __moduleExports: Ye }), Xe = function (t) { z.extend(this, t), this.initialize.apply(this, arguments); }; z.extend(Xe.prototype, { initialize: function () { this.hidden = !1; }, pivot: function () { var t = this; return t._view || (t._view = z.clone(t._model)), t._start = {}, t; }, transition: function (t) { var e = this, i = e._model, n = e._start, a = e._view; return i && 1 !== t ? (a || (a = e._view = {}), n || (n = e._start = {}), function (t, e, i, n) { var a, o, r, l, s, d, u, h, c, f = Object.keys(i); for (a = 0, o = f.length; a < o; ++a)
        if (d = i[r = f[a]], e.hasOwnProperty(r) || (e[r] = d), (l = e[r]) !== d && "_" !== r[0]) {
            if (t.hasOwnProperty(r) || (t[r] = l), (u = typeof d) == typeof (s = t[r]))
                if ("string" === u) {
                    if ((h = qe(s)).valid && (c = qe(d)).valid) {
                        e[r] = c.mix(h, n).rgbString();
                        continue;
                    }
                }
                else if ("number" === u && isFinite(s) && isFinite(d)) {
                    e[r] = s + (d - s) * n;
                    continue;
                }
            e[r] = d;
        } }(n, a, i, t), e) : (e._view = i, e._start = null, e); }, tooltipPosition: function () { return { x: this._model.x, y: this._model.y }; }, hasValue: function () { return z.isNumber(this._model.x) && z.isNumber(this._model.y); } }), Xe.extend = z.inherits; var Ke = Xe, Ge = Object.freeze({ default: Ke, __moduleExports: Ke }), Je = Ge && Ke || Ge; E._set("global", { elements: { arc: { backgroundColor: E.global.defaultColor, borderColor: "#fff", borderWidth: 2 } } }); var Ze = Je.extend({ inLabelRange: function (t) { var e = this._view; return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2); }, inRange: function (t, e) { var i = this._view; if (i) {
        for (var n = z.getAngleFromPoint(i, { x: t, y: e }), a = n.angle, o = n.distance, r = i.startAngle, l = i.endAngle; l < r;)
            l += 2 * Math.PI;
        for (; a > l;)
            a -= 2 * Math.PI;
        for (; a < r;)
            a += 2 * Math.PI;
        var s = a >= r && a <= l, d = o >= i.innerRadius && o <= i.outerRadius;
        return s && d;
    } return !1; }, getCenterPoint: function () { var t = this._view, e = (t.startAngle + t.endAngle) / 2, i = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i }; }, getArea: function () { var t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2)); }, tooltipPosition: function () { var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i }; }, draw: function () { var t = this._chart.ctx, e = this._view, i = e.startAngle, n = e.endAngle; t.beginPath(), t.arc(e.x, e.y, e.outerRadius, i, n), t.arc(e.x, e.y, e.innerRadius, n, i, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = "bevel", e.borderWidth && t.stroke(); } }), Qe = Object.freeze({ default: Ze, __moduleExports: Ze }), $e = E.global; E._set("global", { elements: { line: { tension: .4, backgroundColor: $e.defaultColor, borderWidth: 3, borderColor: $e.defaultColor, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0 } } }); var ti = Je.extend({ draw: function () { var t, e, i, n, a = this._view, o = this._chart.ctx, r = a.spanGaps, l = this._children.slice(), s = $e.elements.line, d = -1; for (this._loop && l.length && l.push(l[0]), o.save(), o.lineCap = a.borderCapStyle || s.borderCapStyle, o.setLineDash && o.setLineDash(a.borderDash || s.borderDash), o.lineDashOffset = a.borderDashOffset || s.borderDashOffset, o.lineJoin = a.borderJoinStyle || s.borderJoinStyle, o.lineWidth = a.borderWidth || s.borderWidth, o.strokeStyle = a.borderColor || $e.defaultColor, o.beginPath(), d = -1, t = 0; t < l.length; ++t)
        e = l[t], i = z.previousItem(l, t), n = e._view, 0 === t ? n.skip || (o.moveTo(n.x, n.y), d = t) : (i = -1 === d ? i : l[d], n.skip || (d !== t - 1 && !r || -1 === d ? o.moveTo(n.x, n.y) : z.canvas.lineTo(o, i._view, e._view), d = t)); o.stroke(), o.restore(); } }), ei = Object.freeze({ default: ti, __moduleExports: ti }), ii = E.global.defaultColor; function ni(t) { var e = this._view; return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius; } E._set("global", { elements: { point: { radius: 3, pointStyle: "circle", backgroundColor: ii, borderColor: ii, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 } } }); var ai = Je.extend({ inRange: function (t, e) { var i = this._view; return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2); }, inLabelRange: ni, inXRange: ni, inYRange: function (t) { var e = this._view; return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius; }, getCenterPoint: function () { var t = this._view; return { x: t.x, y: t.y }; }, getArea: function () { return Math.PI * Math.pow(this._view.radius, 2); }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth }; }, draw: function (t) { var e = this._view, i = this._model, n = this._chart.ctx, a = e.pointStyle, o = e.radius, r = e.x, l = e.y, s = z.color, d = 0; e.skip || (n.strokeStyle = e.borderColor || ii, n.lineWidth = z.valueOrDefault(e.borderWidth, E.global.elements.point.borderWidth), n.fillStyle = e.backgroundColor || ii, void 0 !== t && (i.x < t.left || 1.01 * t.right < i.x || i.y < t.top || 1.01 * t.bottom < i.y) && (i.x < t.left ? d = (r - i.x) / (t.left - i.x) : 1.01 * t.right < i.x ? d = (i.x - r) / (i.x - t.right) : i.y < t.top ? d = (l - i.y) / (t.top - i.y) : 1.01 * t.bottom < i.y && (d = (i.y - l) / (i.y - t.bottom)), d = Math.round(100 * d) / 100, n.strokeStyle = s(n.strokeStyle).alpha(d).rgbString(), n.fillStyle = s(n.fillStyle).alpha(d).rgbString()), z.canvas.drawPoint(n, a, o, r, l)); } }), oi = Object.freeze({ default: ai, __moduleExports: ai }); function ri(t) { return void 0 !== t._view.width; } function li(t) { var e, i, n, a, o = t._view; if (ri(t)) {
    var r = o.width / 2;
    e = o.x - r, i = o.x + r, n = Math.min(o.y, o.base), a = Math.max(o.y, o.base);
}
else {
    var l = o.height / 2;
    e = Math.min(o.x, o.base), i = Math.max(o.x, o.base), n = o.y - l, a = o.y + l;
} return { left: e, top: n, right: i, bottom: a }; } E._set("global", { elements: { rectangle: { backgroundColor: E.global.defaultColor, borderColor: E.global.defaultColor, borderSkipped: "bottom", borderWidth: 0 } } }); var si = Je.extend({ draw: function () { var t, e, i, n, a, o, r, l = this._chart.ctx, s = this._view, d = s.borderWidth; if (s.horizontal ? (t = s.base, e = s.x, i = s.y - s.height / 2, n = s.y + s.height / 2, a = e > t ? 1 : -1, o = 1, r = s.borderSkipped || "left") : (t = s.x - s.width / 2, e = s.x + s.width / 2, i = s.y, a = 1, o = (n = s.base) > i ? 1 : -1, r = s.borderSkipped || "bottom"), d) {
        var u = Math.min(Math.abs(t - e), Math.abs(i - n)), h = (d = d > u ? u : d) / 2, c = t + ("left" !== r ? h * a : 0), f = e + ("right" !== r ? -h * a : 0), g = i + ("top" !== r ? h * o : 0), p = n + ("bottom" !== r ? -h * o : 0);
        c !== f && (i = g, n = p), g !== p && (t = c, e = f);
    } l.beginPath(), l.fillStyle = s.backgroundColor, l.strokeStyle = s.borderColor, l.lineWidth = d; var m = [[t, n], [t, i], [e, i], [e, n]], v = ["bottom", "left", "top", "right"].indexOf(r, 0); function b(t) { return m[(v + t) % 4]; } -1 === v && (v = 0); var x = b(0); l.moveTo(x[0], x[1]); for (var y = 1; y < 4; y++)
        x = b(y), l.lineTo(x[0], x[1]); l.fill(), d && l.stroke(); }, height: function () { var t = this._view; return t.base - t.y; }, inRange: function (t, e) { var i = !1; if (this._view) {
        var n = li(this);
        i = t >= n.left && t <= n.right && e >= n.top && e <= n.bottom;
    } return i; }, inLabelRange: function (t, e) { if (!this._view)
        return !1; var i = li(this); return ri(this) ? t >= i.left && t <= i.right : e >= i.top && e <= i.bottom; }, inXRange: function (t) { var e = li(this); return t >= e.left && t <= e.right; }, inYRange: function (t) { var e = li(this); return t >= e.top && t <= e.bottom; }, getCenterPoint: function () { var t, e, i = this._view; return ri(this) ? (t = i.x, e = (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, e = i.y), { x: t, y: e }; }, getArea: function () { var t = this._view; return t.width * Math.abs(t.y - t.base); }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y }; } }), di = Object.freeze({ default: si, __moduleExports: si }), ui = {}, hi = Qe && Ze || Qe, ci = ei && ti || ei, fi = oi && ai || oi, gi = di && si || di; ui.Arc = hi, ui.Line = ci, ui.Point = fi, ui.Rectangle = gi; var pi = Object.freeze({ default: ui, __moduleExports: ui, Arc: hi, Line: ci, Point: fi, Rectangle: gi }); function mi(t, e) { return t.native ? { x: t.x, y: t.y } : z.getRelativePosition(t, e); } function vi(t, e) { var i, n, a, o, r; for (n = 0, o = t.data.datasets.length; n < o; ++n)
    if (t.isDatasetVisible(n))
        for (a = 0, r = (i = t.getDatasetMeta(n)).data.length; a < r; ++a) {
            var l = i.data[a];
            l._view.skip || e(l);
        } } function bi(t, e) { var i = []; return vi(t, function (t) { t.inRange(e.x, e.y) && i.push(t); }), i; } function xi(t, e, i, n) { var a = Number.POSITIVE_INFINITY, o = []; return vi(t, function (t) { if (!i || t.inRange(e.x, e.y)) {
    var r = t.getCenterPoint(), l = n(e, r);
    l < a ? (o = [t], a = l) : l === a && o.push(t);
} }), o; } function yi(t) { var e = -1 !== t.indexOf("x"), i = -1 !== t.indexOf("y"); return function (t, n) { var a = e ? Math.abs(t.x - n.x) : 0, o = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2)); }; } function ki(t, e, i) { var n = mi(e, t); i.axis = i.axis || "x"; var a = yi(i.axis), o = i.intersect ? bi(t, n) : xi(t, n, !1, a), r = []; return o.length ? (t.data.datasets.forEach(function (e, i) { if (t.isDatasetVisible(i)) {
    var n = t.getDatasetMeta(i).data[o[0]._index];
    n && !n._view.skip && r.push(n);
} }), r) : []; } var wi = { modes: { single: function (t, e) { var i = mi(e, t), n = []; return vi(t, function (t) { if (t.inRange(i.x, i.y))
            return n.push(t), n; }), n.slice(0, 1); }, label: ki, index: ki, dataset: function (t, e, i) { var n = mi(e, t); i.axis = i.axis || "xy"; var a = yi(i.axis), o = i.intersect ? bi(t, n) : xi(t, n, !1, a); return o.length > 0 && (o = t.getDatasetMeta(o[0]._datasetIndex).data), o; }, "x-axis": function (t, e) { return ki(t, e, { intersect: !1 }); }, point: function (t, e) { return bi(t, mi(e, t)); }, nearest: function (t, e, i) { var n = mi(e, t); i.axis = i.axis || "xy"; var a = yi(i.axis), o = xi(t, n, i.intersect, a); return o.length > 1 && o.sort(function (t, e) { var i = t.getArea() - e.getArea(); return 0 === i && (i = t._datasetIndex - e._datasetIndex), i; }), o.slice(0, 1); }, x: function (t, e, i) { var n = mi(e, t), a = [], o = !1; return vi(t, function (t) { t.inXRange(n.x) && a.push(t), t.inRange(n.x, n.y) && (o = !0); }), i.intersect && !o && (a = []), a; }, y: function (t, e, i) { var n = mi(e, t), a = [], o = !1; return vi(t, function (t) { t.inYRange(n.y) && a.push(t), t.inRange(n.x, n.y) && (o = !0); }), i.intersect && !o && (a = []), a; } } }, Mi = wi.modes, _i = Object.freeze({ default: wi, __moduleExports: wi, modes: Mi }); function Si(t, e) { return z.where(t, function (t) { return t.position === e; }); } function Ci(t, e) { t.forEach(function (t, e) { return t._tmpIndex_ = e, t; }), t.sort(function (t, i) { var n = e ? i : t, a = e ? t : i; return n.weight === a.weight ? n._tmpIndex_ - a._tmpIndex_ : n.weight - a.weight; }), t.forEach(function (t) { delete t._tmpIndex_; }); } var Di = { defaults: {}, addBox: function (t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e); }, removeBox: function (t, e) { var i = t.boxes ? t.boxes.indexOf(e) : -1; -1 !== i && t.boxes.splice(i, 1); }, configure: function (t, e, i) { for (var n, a = ["fullWidth", "position", "weight"], o = a.length, r = 0; r < o; ++r)
        n = a[r], i.hasOwnProperty(n) && (e[n] = i[n]); }, update: function (t, e, i) { if (t) {
        var n = t.options.layout || {}, a = z.options.toPadding(n.padding), o = a.left, r = a.right, l = a.top, s = a.bottom, d = Si(t.boxes, "left"), u = Si(t.boxes, "right"), h = Si(t.boxes, "top"), c = Si(t.boxes, "bottom"), f = Si(t.boxes, "chartArea");
        Ci(d, !0), Ci(u, !1), Ci(h, !0), Ci(c, !1);
        var g = e - o - r, p = i - l - s, m = p / 2, v = (e - g / 2) / (d.length + u.length), b = (i - m) / (h.length + c.length), x = g, y = p, k = [];
        z.each(d.concat(u, h, c), function (t) { var e, i = t.isHorizontal(); i ? (e = t.update(t.fullWidth ? g : x, b), y -= e.height) : (e = t.update(v, y), x -= e.width), k.push({ horizontal: i, minSize: e, box: t }); });
        var w = 0, M = 0, _ = 0, S = 0;
        z.each(h.concat(c), function (t) { if (t.getPadding) {
            var e = t.getPadding();
            w = Math.max(w, e.left), M = Math.max(M, e.right);
        } }), z.each(d.concat(u), function (t) { if (t.getPadding) {
            var e = t.getPadding();
            _ = Math.max(_, e.top), S = Math.max(S, e.bottom);
        } });
        var C = o, D = r, I = l, A = s;
        z.each(d.concat(u), B), z.each(d, function (t) { C += t.width; }), z.each(u, function (t) { D += t.width; }), z.each(h.concat(c), B), z.each(h, function (t) { I += t.height; }), z.each(c, function (t) { A += t.height; }), z.each(d.concat(u), function (t) { var e = z.findNextWhere(k, function (e) { return e.box === t; }), i = { left: 0, right: 0, top: I, bottom: A }; e && t.update(e.minSize.width, y, i); }), C = o, D = r, I = l, A = s, z.each(d, function (t) { C += t.width; }), z.each(u, function (t) { D += t.width; }), z.each(h, function (t) { I += t.height; }), z.each(c, function (t) { A += t.height; });
        var P = Math.max(w - C, 0);
        C += P, D += Math.max(M - D, 0);
        var O = Math.max(_ - I, 0);
        I += O, A += Math.max(S - A, 0);
        var T = i - I - A, F = e - C - D;
        F === x && T === y || (z.each(d, function (t) { t.height = T; }), z.each(u, function (t) { t.height = T; }), z.each(h, function (t) { t.fullWidth || (t.width = F); }), z.each(c, function (t) { t.fullWidth || (t.width = F); }), y = T, x = F);
        var R = o + P, L = l + O;
        z.each(d.concat(h), E), R += x, L += y, z.each(u, E), z.each(c, E), t.chartArea = { left: C, top: I, right: C + x, bottom: I + y }, z.each(f, function (e) { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(x, y); });
    } function B(t) { var e = z.findNextWhere(k, function (e) { return e.box === t; }); if (e)
        if (t.isHorizontal()) {
            var i = { left: Math.max(C, w), right: Math.max(D, M), top: 0, bottom: 0 };
            t.update(t.fullWidth ? g : x, p / 2, i);
        }
        else
            t.update(e.minSize.width, y); } function E(t) { t.isHorizontal() ? (t.left = t.fullWidth ? o : C, t.right = t.fullWidth ? e - r : C + x, t.top = L, t.bottom = L + t.height, L = t.bottom) : (t.left = R, t.right = R + t.width, t.top = I, t.bottom = I + y, R = t.right); } } }, Ii = Di.defaults, Ai = Di.addBox, Pi = Di.removeBox, Oi = Di.configure, Ti = Di.update, Fi = Object.freeze({ default: Di, __moduleExports: Di, defaults: Ii, addBox: Ai, removeBox: Pi, configure: Oi, update: Ti }), zi = { acquireContext: function (t) { return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null; } }, Ri = zi.acquireContext, Li = Object.freeze({ default: zi, __moduleExports: zi, acquireContext: Ri }), Bi = "$chartjs", Ei = "chartjs-", Wi = Ei + "render-monitor", Ni = Ei + "render-animation", Vi = ["animationstart", "webkitAnimationStart"], Hi = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }; function ji(t, e) { var i = z.getStyle(t, e), n = i && i.match(/^(\d+)(\.\d+)?px$/); return n ? Number(n[1]) : void 0; } var qi = !!function () { var t = !1; try {
    var e = Object.defineProperty({}, "passive", { get: function () { t = !0; } });
    window.addEventListener("e", null, e);
}
catch (t) { } return t; }() && { passive: !0 }; function Yi(t, e, i) { t.addEventListener(e, i, qi); } function Ui(t, e, i) { t.removeEventListener(e, i, qi); } function Xi(t, e, i, n, a) { return { type: t, chart: e, native: a || null, x: void 0 !== i ? i : null, y: void 0 !== n ? n : null }; } var Ki = { _enabled: "undefined" != typeof window && "undefined" != typeof document, initialize: function () { var t, e, i = "from{opacity:0.99}to{opacity:1}"; t = "@-webkit-keyframes " + Ni + "{" + i + "}@keyframes " + Ni + "{" + i + "}." + Wi + "{-webkit-animation:" + Ni + " 0.001s;animation:" + Ni + " 0.001s;}", e = this._style || document.createElement("style"), this._style || (this._style = e, t = "/* Chart.js */\n" + t, e.setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(e)), e.appendChild(document.createTextNode(t)); }, acquireContext: function (t, e) { "string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas); var i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (function (t, e) { var i = t.style, n = t.getAttribute("height"), a = t.getAttribute("width"); if (t[Bi] = { initial: { height: n, width: a, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || "block", null === a || "" === a) {
        var o = ji(t, "width");
        void 0 !== o && (t.width = o);
    } if (null === n || "" === n)
        if ("" === t.style.height)
            t.height = t.width / (e.options.aspectRatio || 2);
        else {
            var r = ji(t, "height");
            void 0 !== o && (t.height = r);
        } }(t, e), i) : null; }, releaseContext: function (t) { var e = t.canvas; if (e[Bi]) {
        var i = e[Bi].initial;
        ["height", "width"].forEach(function (t) { var n = i[t]; z.isNullOrUndef(n) ? e.removeAttribute(t) : e.setAttribute(t, n); }), z.each(i.style || {}, function (t, i) { e.style[i] = t; }), e.width = e.width, delete e[Bi];
    } }, addEventListener: function (t, e, i) { var n = t.canvas; if ("resize" !== e) {
        var a = i[Bi] || (i[Bi] = {});
        Yi(n, e, (a.proxies || (a.proxies = {}))[t.id + "_" + e] = function (e) { i(function (t, e) { var i = Hi[t.type] || t.type, n = z.getRelativePosition(t, e); return Xi(i, e, n.x, n.y, t); }(e, t)); });
    }
    else
        !function (t, e, i) { var n, a, o, r, l = t[Bi] || (t[Bi] = {}), s = l.resizer = function (t) { var e = document.createElement("div"), i = Ei + "size-monitor", n = "position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;"; e.style.cssText = n, e.className = i, e.innerHTML = '<div class="' + i + '-expand" style="' + n + '"><div style="position:absolute;width:1000000px;height:1000000px;left:0;top:0"></div></div><div class="' + i + '-shrink" style="' + n + '"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>'; var a = e.childNodes[0], o = e.childNodes[1]; e._reset = function () { a.scrollLeft = 1e6, a.scrollTop = 1e6, o.scrollLeft = 1e6, o.scrollTop = 1e6; }; var r = function () { e._reset(), t(); }; return Yi(a, "scroll", r.bind(a, "expand")), Yi(o, "scroll", r.bind(o, "shrink")), e; }((n = function () { if (l.resizer)
            return e(Xi("resize", i)); }, o = !1, r = [], function () { r = Array.prototype.slice.call(arguments), a = a || this, o || (o = !0, z.requestAnimFrame.call(window, function () { o = !1, n.apply(a, r); })); })); !function (t, e) { var i = t[Bi] || (t[Bi] = {}), n = i.renderProxy = function (t) { t.animationName === Ni && e(); }; z.each(Vi, function (e) { Yi(t, e, n); }), i.reflow = !!t.offsetParent, t.classList.add(Wi); }(t, function () { if (l.resizer) {
            var e = t.parentNode;
            e && e !== s.parentNode && e.insertBefore(s, e.firstChild), s._reset();
        } }); }(n, i, t); }, removeEventListener: function (t, e, i) { var n, a, o, r = t.canvas; if ("resize" !== e) {
        var l = ((i[Bi] || {}).proxies || {})[t.id + "_" + e];
        l && Ui(r, e, l);
    }
    else
        a = (n = r)[Bi] || {}, o = a.resizer, delete a.resizer, function (t) { var e = t[Bi] || {}, i = e.renderProxy; i && (z.each(Vi, function (e) { Ui(t, e, i); }), delete e.renderProxy), t.classList.remove(Wi); }(n), o && o.parentNode && o.parentNode.removeChild(o); } }; z.addEvent = Yi, z.removeEvent = Ui; var Gi = Ki._enabled, Ji = Ki.initialize, Zi = Ki.acquireContext, Qi = Ki.releaseContext, $i = Ki.addEventListener, tn = Ki.removeEventListener, en = Object.freeze({ default: Ki, __moduleExports: Ki, _enabled: Gi, initialize: Ji, acquireContext: Zi, releaseContext: Qi, addEventListener: $i, removeEventListener: tn }), nn = Li && zi || Li, an = en && Ki || en, on = an._enabled ? an : nn, rn = z.extend({ initialize: function () { }, acquireContext: function () { }, releaseContext: function () { }, addEventListener: function () { }, removeEventListener: function () { } }, on), ln = Object.freeze({ default: rn, __moduleExports: rn }); E._set("global", { plugins: {} }); var sn = { _plugins: [], _cacheId: 0, register: function (t) { var e = this._plugins; [].concat(t).forEach(function (t) { -1 === e.indexOf(t) && e.push(t); }), this._cacheId++; }, unregister: function (t) { var e = this._plugins; [].concat(t).forEach(function (t) { var i = e.indexOf(t); -1 !== i && e.splice(i, 1); }), this._cacheId++; }, clear: function () { this._plugins = [], this._cacheId++; }, count: function () { return this._plugins.length; }, getAll: function () { return this._plugins; }, notify: function (t, e, i) { var n, a, o, r, l, s = this.descriptors(t), d = s.length; for (n = 0; n < d; ++n)
        if ("function" == typeof (l = (o = (a = s[n]).plugin)[e]) && ((r = [t].concat(i || [])).push(a.options), !1 === l.apply(o, r)))
            return !1; return !0; }, descriptors: function (t) { var e = t.$plugins || (t.$plugins = {}); if (e.id === this._cacheId)
        return e.descriptors; var i = [], n = [], a = t && t.config || {}, o = a.options && a.options.plugins || {}; return this._plugins.concat(a.plugins || []).forEach(function (t) { if (-1 === i.indexOf(t)) {
        var e = t.id, a = o[e];
        !1 !== a && (!0 === a && (a = z.clone(E.global.plugins[e])), i.push(t), n.push({ plugin: t, options: a || {} }));
    } }), e.descriptors = n, e.id = this._cacheId, n; }, _invalidate: function (t) { delete t.$plugins; } }, dn = sn._plugins, un = sn._cacheId, hn = sn.register, cn = sn.unregister, fn = sn.clear, gn = sn.count, pn = sn.getAll, mn = sn.notify, vn = sn.descriptors, bn = sn._invalidate, xn = Object.freeze({ default: sn, __moduleExports: sn, _plugins: dn, _cacheId: un, register: hn, unregister: cn, clear: fn, count: gn, getAll: pn, notify: mn, descriptors: vn, _invalidate: bn }), yn = { formatters: { values: function (t) { return z.isArray(t) ? t : "" + t; }, linear: function (t, e, i) { var n = i.length > 3 ? i[2] - i[1] : i[1] - i[0]; Math.abs(n) > 1 && t !== Math.floor(t) && (n = t - Math.floor(t)); var a = z.log10(Math.abs(n)), o = ""; if (0 !== t) {
            var r = -1 * Math.floor(a);
            r = Math.max(Math.min(r, 20), 0), o = t.toFixed(r);
        }
        else
            o = "0"; return o; }, logarithmic: function (t, e, i) { var n = t / Math.pow(10, Math.floor(z.log10(t))); return 0 === t ? "0" : 1 === n || 2 === n || 5 === n || 0 === e || e === i.length - 1 ? t.toExponential() : ""; } } }, kn = yn.formatters, wn = Object.freeze({ default: yn, __moduleExports: yn, formatters: kn }); E._set("global", { animation: { duration: 1e3, easing: "easeOutQuart", onProgress: z.noop, onComplete: z.noop } }); var Mn = function (t) { t.Animation = Je.extend({ chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null }), t.animationService = { frameDuration: 17, animations: [], dropFrames: 0, request: null, addAnimation: function (t, e, i, n) { var a, o, r = this.animations; for (e.chart = t, n || (t.animating = !0), a = 0, o = r.length; a < o; ++a)
        if (r[a].chart === t)
            return void (r[a] = e); r.push(e), 1 === r.length && this.requestAnimationFrame(); }, cancelAnimation: function (t) { var e = z.findIndex(this.animations, function (e) { return e.chart === t; }); -1 !== e && (this.animations.splice(e, 1), t.animating = !1); }, requestAnimationFrame: function () { var t = this; null === t.request && (t.request = z.requestAnimFrame.call(window, function () { t.request = null, t.startDigest(); })); }, startDigest: function () { var t = this, e = Date.now(), i = 0; t.dropFrames > 1 && (i = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1), t.advance(1 + i); var n = Date.now(); t.dropFrames += (n - e) / t.frameDuration, t.animations.length > 0 && t.requestAnimationFrame(); }, advance: function (t) { for (var e, i, n = this.animations, a = 0; a < n.length;)
        i = (e = n[a]).chart, e.currentStep = (e.currentStep || 0) + t, e.currentStep = Math.min(e.currentStep, e.numSteps), z.callback(e.render, [i, e], i), z.callback(e.onAnimationProgress, [e], i), e.currentStep >= e.numSteps ? (z.callback(e.onAnimationComplete, [e], i), i.animating = !1, n.splice(a, 1)) : ++a; } }, Object.defineProperty(t.Animation.prototype, "animationObject", { get: function () { return this; } }), Object.defineProperty(t.Animation.prototype, "chartInstance", { get: function () { return this.chart; }, set: function (t) { this.chart = t; } }); }, _n = Object.freeze({ default: Mn, __moduleExports: Mn }), Sn = _i && wi || _i, Cn = Fi && Di || Fi, Dn = ln && rn || ln, In = xn && sn || xn, An = function (t) { function e(t) { return "top" === t || "bottom" === t; } t.types = {}, t.instances = {}, t.controllers = {}, z.extend(t.prototype, { construct: function (e, i) { var n = this; i = function (t) { var e = (t = t || {}).data = t.data || {}; return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = z.configMerge(E.global, E[t.type], t.options || {}), t; }(i); var a = Dn.acquireContext(e, i), o = a && a.canvas, r = o && o.height, l = o && o.width; n.id = z.uid(), n.ctx = a, n.canvas = o, n.config = i, n.width = l, n.height = r, n.aspectRatio = r ? l / r : null, n.options = i.options, n._bufferedRender = !1, n.chart = n, n.controller = n, t.instances[n.id] = n, Object.defineProperty(n, "data", { get: function () { return n.config.data; }, set: function (t) { n.config.data = t; } }), a && o ? (n.initialize(), n.update()) : console.error("Failed to create chart: can't acquire context from the given item"); }, initialize: function () { var t = this; return In.notify(t, "beforeInit"), z.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.initToolTip(), In.notify(t, "afterInit"), t; }, clear: function () { return z.canvas.clear(this), this; }, stop: function () { return t.animationService.cancelAnimation(this), this; }, resize: function (t) { var e = this, i = e.options, n = e.canvas, a = i.maintainAspectRatio && e.aspectRatio || null, o = Math.max(0, Math.floor(z.getMaximumWidth(n))), r = Math.max(0, Math.floor(a ? o / a : z.getMaximumHeight(n))); if ((e.width !== o || e.height !== r) && (n.width = e.width = o, n.height = e.height = r, n.style.width = o + "px", n.style.height = r + "px", z.retinaScale(e, i.devicePixelRatio), !t)) {
        var l = { width: o, height: r };
        In.notify(e, "resize", [l]), e.options.onResize && e.options.onResize(e, l), e.stop(), e.update(e.options.responsiveAnimationDuration);
    } }, ensureScalesHaveIDs: function () { var t = this.options, e = t.scales || {}, i = t.scale; z.each(e.xAxes, function (t, e) { t.id = t.id || "x-axis-" + e; }), z.each(e.yAxes, function (t, e) { t.id = t.id || "y-axis-" + e; }), i && (i.id = i.id || "scale"); }, buildOrUpdateScales: function () { var i = this, n = i.options, a = i.scales || {}, o = [], r = Object.keys(a).reduce(function (t, e) { return t[e] = !1, t; }, {}); n.scales && (o = o.concat((n.scales.xAxes || []).map(function (t) { return { options: t, dtype: "category", dposition: "bottom" }; }), (n.scales.yAxes || []).map(function (t) { return { options: t, dtype: "linear", dposition: "left" }; }))), n.scale && o.push({ options: n.scale, dtype: "radialLinear", isDefault: !0, dposition: "chartArea" }), z.each(o, function (n) { var o = n.options, l = o.id, s = z.valueOrDefault(o.type, n.dtype); e(o.position) !== e(n.dposition) && (o.position = n.dposition), r[l] = !0; var d = null; if (l in a && a[l].type === s)
        (d = a[l]).options = o, d.ctx = i.ctx, d.chart = i;
    else {
        var u = t.scaleService.getScaleConstructor(s);
        if (!u)
            return;
        d = new u({ id: l, type: s, options: o, ctx: i.ctx, chart: i }), a[d.id] = d;
    } d.mergeTicksOptions(), n.isDefault && (i.scale = d); }), z.each(r, function (t, e) { t || delete a[e]; }), i.scales = a, t.scaleService.addScalesToLayout(this); }, buildOrUpdateControllers: function () { var e = this, i = [], n = []; return z.each(e.data.datasets, function (a, o) { var r = e.getDatasetMeta(o), l = a.type || e.config.type; if (r.type && r.type !== l && (e.destroyDatasetMeta(o), r = e.getDatasetMeta(o)), r.type = l, i.push(r.type), r.controller)
        r.controller.updateIndex(o), r.controller.linkScales();
    else {
        var s = t.controllers[r.type];
        if (void 0 === s)
            throw new Error('"' + r.type + '" is not a chart type.');
        r.controller = new s(e, o), n.push(r.controller);
    } }, e), n; }, resetElements: function () { var t = this; z.each(t.data.datasets, function (e, i) { t.getDatasetMeta(i).controller.reset(); }, t); }, reset: function () { this.resetElements(), this.tooltip.initialize(); }, update: function (e) { var i, n, a = this; if (e && "object" == typeof e || (e = { duration: e, lazy: arguments[1] }), n = (i = a).options, z.each(i.scales, function (t) { Cn.removeBox(i, t); }), n = z.configMerge(t.defaults.global, t.defaults[i.config.type], n), i.options = i.config.options = n, i.ensureScalesHaveIDs(), i.buildOrUpdateScales(), i.tooltip._options = n.tooltips, i.tooltip.initialize(), In._invalidate(a), !1 !== In.notify(a, "beforeUpdate")) {
        a.tooltip._data = a.data;
        var o = a.buildOrUpdateControllers();
        z.each(a.data.datasets, function (t, e) { a.getDatasetMeta(e).controller.buildOrUpdateElements(); }, a), a.updateLayout(), a.options.animation && a.options.animation.duration && z.each(o, function (t) { t.reset(); }), a.updateDatasets(), a.tooltip.initialize(), a.lastActive = [], In.notify(a, "afterUpdate"), a._bufferedRender ? a._bufferedRequest = { duration: e.duration, easing: e.easing, lazy: e.lazy } : a.render(e);
    } }, updateLayout: function () { !1 !== In.notify(this, "beforeLayout") && (Cn.update(this, this.width, this.height), In.notify(this, "afterScaleUpdate"), In.notify(this, "afterLayout")); }, updateDatasets: function () { if (!1 !== In.notify(this, "beforeDatasetsUpdate")) {
        for (var t = 0, e = this.data.datasets.length; t < e; ++t)
            this.updateDataset(t);
        In.notify(this, "afterDatasetsUpdate");
    } }, updateDataset: function (t) { var e = this.getDatasetMeta(t), i = { meta: e, index: t }; !1 !== In.notify(this, "beforeDatasetUpdate", [i]) && (e.controller.update(), In.notify(this, "afterDatasetUpdate", [i])); }, render: function (e) { var i = this; e && "object" == typeof e || (e = { duration: e, lazy: arguments[1] }); var n = e.duration, a = e.lazy; if (!1 !== In.notify(i, "beforeRender")) {
        var o = i.options.animation, r = function (t) { In.notify(i, "afterRender"), z.callback(o && o.onComplete, [t], i); };
        if (o && (void 0 !== n && 0 !== n || void 0 === n && 0 !== o.duration)) {
            var l = new t.Animation({ numSteps: (n || o.duration) / 16.66, easing: e.easing || o.easing, render: function (t, e) { var i = z.easing.effects[e.easing], n = e.currentStep, a = n / e.numSteps; t.draw(i(a), a, n); }, onAnimationProgress: o.onProgress, onAnimationComplete: r });
            t.animationService.addAnimation(i, l, n, a);
        }
        else
            i.draw(), r(new t.Animation({ numSteps: 0, chart: i }));
        return i;
    } }, draw: function (t) { var e = this; e.clear(), z.isNullOrUndef(t) && (t = 1), e.transition(t), !1 !== In.notify(e, "beforeDraw", [t]) && (z.each(e.boxes, function (t) { t.draw(e.chartArea); }, e), e.scale && e.scale.draw(), e.drawDatasets(t), e._drawTooltip(t), In.notify(e, "afterDraw", [t])); }, transition: function (t) { for (var e = 0, i = (this.data.datasets || []).length; e < i; ++e)
        this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t); this.tooltip.transition(t); }, drawDatasets: function (t) { var e = this; if (!1 !== In.notify(e, "beforeDatasetsDraw", [t])) {
        for (var i = (e.data.datasets || []).length - 1; i >= 0; --i)
            e.isDatasetVisible(i) && e.drawDataset(i, t);
        In.notify(e, "afterDatasetsDraw", [t]);
    } }, drawDataset: function (t, e) { var i = this.getDatasetMeta(t), n = { meta: i, index: t, easingValue: e }; !1 !== In.notify(this, "beforeDatasetDraw", [n]) && (i.controller.draw(e), In.notify(this, "afterDatasetDraw", [n])); }, _drawTooltip: function (t) { var e = this.tooltip, i = { tooltip: e, easingValue: t }; !1 !== In.notify(this, "beforeTooltipDraw", [i]) && (e.draw(), In.notify(this, "afterTooltipDraw", [i])); }, getElementAtEvent: function (t) { return Sn.modes.single(this, t); }, getElementsAtEvent: function (t) { return Sn.modes.label(this, t, { intersect: !0 }); }, getElementsAtXAxis: function (t) { return Sn.modes["x-axis"](this, t, { intersect: !0 }); }, getElementsAtEventForMode: function (t, e, i) { var n = Sn.modes[e]; return "function" == typeof n ? n(this, t, i) : []; }, getDatasetAtEvent: function (t) { return Sn.modes.dataset(this, t, { intersect: !0 }); }, getDatasetMeta: function (t) { var e = this.data.datasets[t]; e._meta || (e._meta = {}); var i = e._meta[this.id]; return i || (i = e._meta[this.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null }), i; }, getVisibleDatasetCount: function () { for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e)
        this.isDatasetVisible(e) && t++; return t; }, isDatasetVisible: function (t) { var e = this.getDatasetMeta(t); return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden; }, generateLegend: function () { return this.options.legendCallback(this); }, destroyDatasetMeta: function (t) { var e = this.id, i = this.data.datasets[t], n = i._meta && i._meta[e]; n && (n.controller.destroy(), delete i._meta[e]); }, destroy: function () { var e, i, n = this, a = n.canvas; for (n.stop(), e = 0, i = n.data.datasets.length; e < i; ++e)
        n.destroyDatasetMeta(e); a && (n.unbindEvents(), z.canvas.clear(n), Dn.releaseContext(n.ctx), n.canvas = null, n.ctx = null), In.notify(n, "destroy"), delete t.instances[n.id]; }, toBase64Image: function () { return this.canvas.toDataURL.apply(this.canvas, arguments); }, initToolTip: function () { var e = this; e.tooltip = new t.Tooltip({ _chart: e, _chartInstance: e, _data: e.data, _options: e.options.tooltips }, e); }, bindEvents: function () { var t = this, e = t._listeners = {}, i = function () { t.eventHandler.apply(t, arguments); }; z.each(t.options.events, function (n) { Dn.addEventListener(t, n, i), e[n] = i; }), t.options.responsive && (i = function () { t.resize(); }, Dn.addEventListener(t, "resize", i), e.resize = i); }, unbindEvents: function () { var t = this, e = t._listeners; e && (delete t._listeners, z.each(e, function (e, i) { Dn.removeEventListener(t, i, e); })); }, updateHoverStyle: function (t, e, i) { var n, a, o, r = i ? "setHoverStyle" : "removeHoverStyle"; for (a = 0, o = t.length; a < o; ++a)
        (n = t[a]) && this.getDatasetMeta(n._datasetIndex).controller[r](n); }, eventHandler: function (t) { var e = this, i = e.tooltip; if (!1 !== In.notify(e, "beforeEvent", [t])) {
        e._bufferedRender = !0, e._bufferedRequest = null;
        var n = e.handleEvent(t);
        i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), In.notify(e, "afterEvent", [t]);
        var a = e._bufferedRequest;
        return a ? e.render(a) : n && !e.animating && (e.stop(), e.render(e.options.hover.animationDuration, !0)), e._bufferedRender = !1, e._bufferedRequest = null, e;
    } }, handleEvent: function (t) { var e, i = this, n = i.options || {}, a = n.hover; return i.lastActive = i.lastActive || [], "mouseout" === t.type ? i.active = [] : i.active = i.getElementsAtEventForMode(t, a.mode, a), z.callback(n.onHover || n.hover.onHover, [t.native, i.active], i), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, a.mode, !1), i.active.length && a.mode && i.updateHoverStyle(i.active, a.mode, !0), e = !z.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, e; } }), t.Controller = t; }, Pn = Object.freeze({ default: An, __moduleExports: An }), On = function (t) { var e = ["push", "pop", "shift", "splice", "unshift"]; function i(t, i) { var n = t._chartjs; if (n) {
    var a = n.listeners, o = a.indexOf(i);
    -1 !== o && a.splice(o, 1), a.length > 0 || (e.forEach(function (e) { delete t[e]; }), delete t._chartjs);
} } t.DatasetController = function (t, e) { this.initialize(t, e); }, z.extend(t.DatasetController.prototype, { datasetElementType: null, dataElementType: null, initialize: function (t, e) { this.chart = t, this.index = e, this.linkScales(), this.addElements(); }, updateIndex: function (t) { this.index = t; }, linkScales: function () { var t = this, e = t.getMeta(), i = t.getDataset(); null !== e.xAxisID && e.xAxisID in t.chart.scales || (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id), null !== e.yAxisID && e.yAxisID in t.chart.scales || (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id); }, getDataset: function () { return this.chart.data.datasets[this.index]; }, getMeta: function () { return this.chart.getDatasetMeta(this.index); }, getScaleForId: function (t) { return this.chart.scales[t]; }, reset: function () { this.update(!0); }, destroy: function () { this._data && i(this._data, this); }, createMetaDataset: function () { var t = this.datasetElementType; return t && new t({ _chart: this.chart, _datasetIndex: this.index }); }, createMetaData: function (t) { var e = this.dataElementType; return e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t }); }, addElements: function () { var t, e, i = this.getMeta(), n = this.getDataset().data || [], a = i.data; for (t = 0, e = n.length; t < e; ++t)
        a[t] = a[t] || this.createMetaData(t); i.dataset = i.dataset || this.createMetaDataset(); }, addElementAndReset: function (t) { var e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0); }, buildOrUpdateElements: function () { var t, n, a = this, o = a.getDataset(), r = o.data || (o.data = []); a._data !== r && (a._data && i(a._data, a), n = a, (t = r)._chartjs ? t._chartjs.listeners.push(n) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [n] } }), e.forEach(function (e) { var i = "onData" + e.charAt(0).toUpperCase() + e.slice(1), n = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: function () { var e = Array.prototype.slice.call(arguments), a = n.apply(this, e); return z.each(t._chartjs.listeners, function (t) { "function" == typeof t[i] && t[i].apply(t, e); }), a; } }); })), a._data = r), a.resyncElements(); }, update: z.noop, transition: function (t) { for (var e = this.getMeta(), i = e.data || [], n = i.length, a = 0; a < n; ++a)
        i[a].transition(t); e.dataset && e.dataset.transition(t); }, draw: function () { var t = this.getMeta(), e = t.data || [], i = e.length, n = 0; for (t.dataset && t.dataset.draw(); n < i; ++n)
        e[n].draw(); }, removeHoverStyle: function (t, e) { var i = this.chart.data.datasets[t._datasetIndex], n = t._index, a = t.custom || {}, o = z.valueAtIndexOrDefault, r = t._model; r.backgroundColor = a.backgroundColor ? a.backgroundColor : o(i.backgroundColor, n, e.backgroundColor), r.borderColor = a.borderColor ? a.borderColor : o(i.borderColor, n, e.borderColor), r.borderWidth = a.borderWidth ? a.borderWidth : o(i.borderWidth, n, e.borderWidth); }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = z.valueAtIndexOrDefault, o = z.getHoverColor, r = t._model; r.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : a(e.hoverBackgroundColor, i, o(r.backgroundColor)), r.borderColor = n.hoverBorderColor ? n.hoverBorderColor : a(e.hoverBorderColor, i, o(r.borderColor)), r.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : a(e.hoverBorderWidth, i, r.borderWidth); }, resyncElements: function () { var t = this.getMeta(), e = this.getDataset().data, i = t.data.length, n = e.length; n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i); }, insertElements: function (t, e) { for (var i = 0; i < e; ++i)
        this.addElementAndReset(t + i); }, onDataPush: function () { this.insertElements(this.getDataset().data.length - 1, arguments.length); }, onDataPop: function () { this.getMeta().data.pop(); }, onDataShift: function () { this.getMeta().data.shift(); }, onDataSplice: function (t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2); }, onDataUnshift: function () { this.insertElements(0, arguments.length); } }), t.DatasetController.extend = z.inherits; }, Tn = Object.freeze({ default: On, __moduleExports: On }), Fn = function (t) { t.scaleService = { constructors: {}, defaults: {}, registerScaleType: function (t, e, i) { this.constructors[t] = e, this.defaults[t] = z.clone(i); }, getScaleConstructor: function (t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0; }, getScaleDefaults: function (t) { return this.defaults.hasOwnProperty(t) ? z.merge({}, [E.scale, this.defaults[t]]) : {}; }, updateScaleDefaults: function (t, e) { this.defaults.hasOwnProperty(t) && (this.defaults[t] = z.extend(this.defaults[t], e)); }, addScalesToLayout: function (t) { z.each(t.scales, function (e) { e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, Cn.addBox(t, e); }); } }; }, zn = Object.freeze({ default: Fn, __moduleExports: Fn }), Rn = wn && yn || wn; function Ln(t) { var e, i, n = []; for (e = 0, i = t.length; e < i; ++e)
    n.push(t[e].label); return n; } function Bn(t, e, i) { var n = t.getPixelForTick(e); return i && (n -= 0 === e ? (t.getPixelForTick(1) - n) / 2 : (n - t.getPixelForTick(e - 1)) / 2), n; } E._set("scale", { display: !0, position: "left", offset: !1, gridLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: !1, borderDash: [], borderDashOffset: 0 }, scaleLabel: { display: !1, labelString: "", lineHeight: 1.2, padding: { top: 4, bottom: 4 } }, ticks: { beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: Rn.formatters.values, minor: {}, major: {} } }); var En = function (t) { function e(t, e, i) { return z.isArray(e) ? z.longestText(t, i, e) : t.measureText(e).width; } function i(t) { var e = z.valueOrDefault, i = E.global, n = e(t.fontSize, i.defaultFontSize), a = e(t.fontStyle, i.defaultFontStyle), o = e(t.fontFamily, i.defaultFontFamily); return { size: n, style: a, family: o, font: z.fontString(n, a, o) }; } function n(t) { return z.options.toLineHeight(z.valueOrDefault(t.lineHeight, 1.2), z.valueOrDefault(t.fontSize, E.global.defaultFontSize)); } t.Scale = Je.extend({ getPadding: function () { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 }; }, getTicks: function () { return this._ticks; }, mergeTicksOptions: function () { var t = this.options.ticks; for (var e in !1 === t.minor && (t.minor = { display: !1 }), !1 === t.major && (t.major = { display: !1 }), t)
        "major" !== e && "minor" !== e && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e])); }, beforeUpdate: function () { z.callback(this.options.beforeUpdate, [this]); }, update: function (t, e, i) { var n, a, o, r, l, s, d = this; for (d.beforeUpdate(), d.maxWidth = t, d.maxHeight = e, d.margins = z.extend({ left: 0, right: 0, top: 0, bottom: 0 }, i), d.longestTextCache = d.longestTextCache || {}, d.beforeSetDimensions(), d.setDimensions(), d.afterSetDimensions(), d.beforeDataLimits(), d.determineDataLimits(), d.afterDataLimits(), d.beforeBuildTicks(), l = d.buildTicks() || [], d.afterBuildTicks(), d.beforeTickToLabelConversion(), o = d.convertTicksToLabels(l) || d.ticks, d.afterTickToLabelConversion(), d.ticks = o, n = 0, a = o.length; n < a; ++n)
        r = o[n], (s = l[n]) ? s.label = r : l.push(s = { label: r, major: !1 }); return d._ticks = l, d.beforeCalculateTickRotation(), d.calculateTickRotation(), d.afterCalculateTickRotation(), d.beforeFit(), d.fit(), d.afterFit(), d.afterUpdate(), d.minSize; }, afterUpdate: function () { z.callback(this.options.afterUpdate, [this]); }, beforeSetDimensions: function () { z.callback(this.options.beforeSetDimensions, [this]); }, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0; }, afterSetDimensions: function () { z.callback(this.options.afterSetDimensions, [this]); }, beforeDataLimits: function () { z.callback(this.options.beforeDataLimits, [this]); }, determineDataLimits: z.noop, afterDataLimits: function () { z.callback(this.options.afterDataLimits, [this]); }, beforeBuildTicks: function () { z.callback(this.options.beforeBuildTicks, [this]); }, buildTicks: z.noop, afterBuildTicks: function () { z.callback(this.options.afterBuildTicks, [this]); }, beforeTickToLabelConversion: function () { z.callback(this.options.beforeTickToLabelConversion, [this]); }, convertTicksToLabels: function () { var t = this.options.ticks; this.ticks = this.ticks.map(t.userCallback || t.callback, this); }, afterTickToLabelConversion: function () { z.callback(this.options.afterTickToLabelConversion, [this]); }, beforeCalculateTickRotation: function () { z.callback(this.options.beforeCalculateTickRotation, [this]); }, calculateTickRotation: function () { var t = this, e = t.ctx, n = t.options.ticks, a = Ln(t._ticks), o = i(n); e.font = o.font; var r = n.minRotation || 0; if (a.length && t.options.display && t.isHorizontal())
        for (var l, s = z.longestText(e, o.font, a, t.longestTextCache), d = s, u = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; d > u && r < n.maxRotation;) {
            var h = z.toRadians(r);
            if (l = Math.cos(h), Math.sin(h) * s > t.maxHeight) {
                r--;
                break;
            }
            r++, d = l * s;
        } t.labelRotation = r; }, afterCalculateTickRotation: function () { z.callback(this.options.afterCalculateTickRotation, [this]); }, beforeFit: function () { z.callback(this.options.beforeFit, [this]); }, fit: function () { var t = this, a = t.minSize = { width: 0, height: 0 }, o = Ln(t._ticks), r = t.options, l = r.ticks, s = r.scaleLabel, d = r.gridLines, u = r.display, h = t.isHorizontal(), c = i(l), f = r.gridLines.tickMarkLength; if (a.width = h ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : u && d.drawTicks ? f : 0, a.height = h ? u && d.drawTicks ? f : 0 : t.maxHeight, s.display && u) {
        var g = n(s) + z.options.toPadding(s.padding).height;
        h ? a.height += g : a.width += g;
    } if (l.display && u) {
        var p = z.longestText(t.ctx, c.font, o, t.longestTextCache), m = z.numberOfLabelLines(o), v = .5 * c.size, b = t.options.ticks.padding;
        if (h) {
            t.longestLabelWidth = p;
            var x = z.toRadians(t.labelRotation), y = Math.cos(x), k = Math.sin(x) * p + c.size * m + v * (m - 1) + v;
            a.height = Math.min(t.maxHeight, a.height + k + b), t.ctx.font = c.font;
            var w = e(t.ctx, o[0], c.font), M = e(t.ctx, o[o.length - 1], c.font);
            0 !== t.labelRotation ? (t.paddingLeft = "bottom" === r.position ? y * w + 3 : y * v + 3, t.paddingRight = "bottom" === r.position ? y * v + 3 : y * M + 3) : (t.paddingLeft = w / 2 + 3, t.paddingRight = M / 2 + 3);
        }
        else
            l.mirror ? p = 0 : p += b + v, a.width = Math.min(t.maxWidth, a.width + p), t.paddingTop = c.size / 2, t.paddingBottom = c.size / 2;
    } t.handleMargins(), t.width = a.width, t.height = a.height; }, handleMargins: function () { var t = this; t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)); }, afterFit: function () { z.callback(this.options.afterFit, [this]); }, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position; }, isFullWidth: function () { return this.options.fullWidth; }, getRightValue: function (t) { if (z.isNullOrUndef(t))
        return NaN; if ("number" == typeof t && !isFinite(t))
        return NaN; if (t)
        if (this.isHorizontal()) {
            if (void 0 !== t.x)
                return this.getRightValue(t.x);
        }
        else if (void 0 !== t.y)
            return this.getRightValue(t.y); return t; }, getLabelForIndex: z.noop, getPixelForValue: z.noop, getValueForPixel: z.noop, getPixelForTick: function (t) { var e = this, i = e.options.offset; if (e.isHorizontal()) {
        var n = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (i ? 0 : 1), 1), a = n * t + e.paddingLeft;
        return i && (a += n / 2), e.left + Math.round(a) + (e.isFullWidth() ? e.margins.left : 0);
    } var o = e.height - (e.paddingTop + e.paddingBottom); return e.top + t * (o / (e._ticks.length - 1)); }, getPixelForDecimal: function (t) { var e = this; if (e.isHorizontal()) {
        var i = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft;
        return e.left + Math.round(i) + (e.isFullWidth() ? e.margins.left : 0);
    } return e.top + t * e.height; }, getBasePixel: function () { return this.getPixelForValue(this.getBaseValue()); }, getBaseValue: function () { var t = this.min, e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0; }, _autoSkip: function (t) { var e, i, n, a, o = this, r = o.isHorizontal(), l = o.options.ticks.minor, s = t.length, d = z.toRadians(o.labelRotation), u = Math.cos(d), h = o.longestLabelWidth * u, c = []; for (l.maxTicksLimit && (a = l.maxTicksLimit), r && (e = !1, (h + l.autoSkipPadding) * s > o.width - (o.paddingLeft + o.paddingRight) && (e = 1 + Math.floor((h + l.autoSkipPadding) * s / (o.width - (o.paddingLeft + o.paddingRight)))), a && s > a && (e = Math.max(e, Math.floor(s / a)))), i = 0; i < s; i++)
        n = t[i], (e > 1 && i % e > 0 || i % e == 0 && i + e >= s) && i !== s - 1 && delete n.label, c.push(n); return c; }, draw: function (t) { var e = this, a = e.options; if (a.display) {
        var o = e.ctx, r = E.global, l = a.ticks.minor, s = a.ticks.major || l, d = a.gridLines, u = a.scaleLabel, h = 0 !== e.labelRotation, c = e.isHorizontal(), f = l.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(), g = z.valueOrDefault(l.fontColor, r.defaultFontColor), p = i(l), m = z.valueOrDefault(s.fontColor, r.defaultFontColor), v = i(s), b = d.drawTicks ? d.tickMarkLength : 0, x = z.valueOrDefault(u.fontColor, r.defaultFontColor), y = i(u), k = z.options.toPadding(u.padding), w = z.toRadians(e.labelRotation), M = [], _ = e.options.gridLines.lineWidth, S = "right" === a.position ? e.right : e.right - _ - b, C = "right" === a.position ? e.right + b : e.right, D = "bottom" === a.position ? e.top + _ : e.bottom - b - _, I = "bottom" === a.position ? e.top + _ + b : e.bottom + _;
        if (z.each(f, function (i, n) { if (!z.isNullOrUndef(i.label)) {
            var o, s, u, g, p, m, v, x, y, k, A, P, O, T, F = i.label;
            n === e.zeroLineIndex && a.offset === d.offsetGridLines ? (o = d.zeroLineWidth, s = d.zeroLineColor, u = d.zeroLineBorderDash, g = d.zeroLineBorderDashOffset) : (o = z.valueAtIndexOrDefault(d.lineWidth, n), s = z.valueAtIndexOrDefault(d.color, n), u = z.valueOrDefault(d.borderDash, r.borderDash), g = z.valueOrDefault(d.borderDashOffset, r.borderDashOffset));
            var R = "middle", L = "middle", B = l.padding;
            if (c) {
                var E = b + B;
                "bottom" === a.position ? (L = h ? "middle" : "top", R = h ? "right" : "center", T = e.top + E) : (L = h ? "middle" : "bottom", R = h ? "left" : "center", T = e.bottom - E);
                var W = Bn(e, n, d.offsetGridLines && f.length > 1);
                W < e.left && (s = "rgba(0,0,0,0)"), W += z.aliasPixel(o), O = e.getPixelForTick(n) + l.labelOffset, p = v = y = A = W, m = D, x = I, k = t.top, P = t.bottom + _;
            }
            else {
                var N, V = "left" === a.position;
                l.mirror ? (R = V ? "left" : "right", N = B) : (R = V ? "right" : "left", N = b + B), O = V ? e.right - N : e.left + N;
                var H = Bn(e, n, d.offsetGridLines && f.length > 1);
                H < e.top && (s = "rgba(0,0,0,0)"), H += z.aliasPixel(o), T = e.getPixelForTick(n) + l.labelOffset, p = S, v = C, y = t.left, A = t.right + _, m = x = k = P = H;
            }
            M.push({ tx1: p, ty1: m, tx2: v, ty2: x, x1: y, y1: k, x2: A, y2: P, labelX: O, labelY: T, glWidth: o, glColor: s, glBorderDash: u, glBorderDashOffset: g, rotation: -1 * w, label: F, major: i.major, textBaseline: L, textAlign: R });
        } }), z.each(M, function (t) { if (d.display && (o.save(), o.lineWidth = t.glWidth, o.strokeStyle = t.glColor, o.setLineDash && (o.setLineDash(t.glBorderDash), o.lineDashOffset = t.glBorderDashOffset), o.beginPath(), d.drawTicks && (o.moveTo(t.tx1, t.ty1), o.lineTo(t.tx2, t.ty2)), d.drawOnChartArea && (o.moveTo(t.x1, t.y1), o.lineTo(t.x2, t.y2)), o.stroke(), o.restore()), l.display) {
            o.save(), o.translate(t.labelX, t.labelY), o.rotate(t.rotation), o.font = t.major ? v.font : p.font, o.fillStyle = t.major ? m : g, o.textBaseline = t.textBaseline, o.textAlign = t.textAlign;
            var i = t.label;
            if (z.isArray(i))
                for (var n = i.length, a = 1.5 * p.size, r = e.isHorizontal() ? 0 : -a * (n - 1) / 2, s = 0; s < n; ++s)
                    o.fillText("" + i[s], 0, r), r += a;
            else
                o.fillText(i, 0, 0);
            o.restore();
        } }), u.display) {
            var A, P, O = 0, T = n(u) / 2;
            if (c)
                A = e.left + (e.right - e.left) / 2, P = "bottom" === a.position ? e.bottom - T - k.bottom : e.top + T + k.top;
            else {
                var F = "left" === a.position;
                A = F ? e.left + T + k.top : e.right - T - k.top, P = e.top + (e.bottom - e.top) / 2, O = F ? -.5 * Math.PI : .5 * Math.PI;
            }
            o.save(), o.translate(A, P), o.rotate(O), o.textAlign = "center", o.textBaseline = "middle", o.fillStyle = x, o.font = y.font, o.fillText(u.labelString, 0, 0), o.restore();
        }
        if (d.drawBorder) {
            o.lineWidth = z.valueAtIndexOrDefault(d.lineWidth, 0), o.strokeStyle = z.valueAtIndexOrDefault(d.color, 0);
            var R = e.left, L = e.right + _, B = e.top, W = e.bottom + _, N = z.aliasPixel(o.lineWidth);
            c ? (B = W = "top" === a.position ? e.bottom : e.top, B += N, W += N) : (R = L = "left" === a.position ? e.right : e.left, R += N, L += N), o.beginPath(), o.moveTo(R, B), o.lineTo(L, W), o.stroke();
        }
    } } }); }, Wn = Object.freeze({ default: En, __moduleExports: En }); E._set("global", { tooltips: { enabled: !0, custom: null, mode: "nearest", position: "average", intersect: !0, backgroundColor: "rgba(0,0,0,0.8)", titleFontStyle: "bold", titleSpacing: 2, titleMarginBottom: 6, titleFontColor: "#fff", titleAlign: "left", bodySpacing: 2, bodyFontColor: "#fff", bodyAlign: "left", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor: "#fff", footerAlign: "left", yPadding: 6, xPadding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, multiKeyBackground: "#fff", displayColors: !0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, callbacks: { beforeTitle: z.noop, title: function (t, e) { var i = "", n = e.labels, a = n ? n.length : 0; if (t.length > 0) {
                var o = t[0];
                o.xLabel ? i = o.xLabel : a > 0 && o.index < a && (i = n[o.index]);
            } return i; }, afterTitle: z.noop, beforeBody: z.noop, beforeLabel: z.noop, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || ""; return i && (i += ": "), i + t.yLabel; }, labelColor: function (t, e) { var i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: i.borderColor, backgroundColor: i.backgroundColor }; }, labelTextColor: function () { return this._options.bodyFontColor; }, afterLabel: z.noop, afterBody: z.noop, beforeFooter: z.noop, footer: z.noop, afterFooter: z.noop } } }); var Nn = function (t) { function e(t, e) { var i = z.color(t); return i.alpha(e * i.alpha()).rgbaString(); } function i(t, e) { return e && (z.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t; } function n(t) { var e = E.global, i = z.valueOrDefault; return { xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, bodyFontColor: t.bodyFontColor, _bodyFontFamily: i(t.bodyFontFamily, e.defaultFontFamily), _bodyFontStyle: i(t.bodyFontStyle, e.defaultFontStyle), _bodyAlign: t.bodyAlign, bodyFontSize: i(t.bodyFontSize, e.defaultFontSize), bodySpacing: t.bodySpacing, titleFontColor: t.titleFontColor, _titleFontFamily: i(t.titleFontFamily, e.defaultFontFamily), _titleFontStyle: i(t.titleFontStyle, e.defaultFontStyle), titleFontSize: i(t.titleFontSize, e.defaultFontSize), _titleAlign: t.titleAlign, titleSpacing: t.titleSpacing, titleMarginBottom: t.titleMarginBottom, footerFontColor: t.footerFontColor, _footerFontFamily: i(t.footerFontFamily, e.defaultFontFamily), _footerFontStyle: i(t.footerFontStyle, e.defaultFontStyle), footerFontSize: i(t.footerFontSize, e.defaultFontSize), _footerAlign: t.footerAlign, footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, cornerRadius: t.cornerRadius, backgroundColor: t.backgroundColor, opacity: 0, legendColorBackground: t.multiKeyBackground, displayColors: t.displayColors, borderColor: t.borderColor, borderWidth: t.borderWidth }; } t.Tooltip = Je.extend({ initialize: function () { this._model = n(this._options), this._lastActive = []; }, getTitle: function () { var t = this._options.callbacks, e = t.beforeTitle.apply(this, arguments), n = t.title.apply(this, arguments), a = t.afterTitle.apply(this, arguments), o = []; return i(o = i(o = i(o, e), n), a); }, getBeforeBody: function () { var t = this._options.callbacks.beforeBody.apply(this, arguments); return z.isArray(t) ? t : void 0 !== t ? [t] : []; }, getBody: function (t, e) { var n = this, a = n._options.callbacks, o = []; return z.each(t, function (t) { var r = { before: [], lines: [], after: [] }; i(r.before, a.beforeLabel.call(n, t, e)), i(r.lines, a.label.call(n, t, e)), i(r.after, a.afterLabel.call(n, t, e)), o.push(r); }), o; }, getAfterBody: function () { var t = this._options.callbacks.afterBody.apply(this, arguments); return z.isArray(t) ? t : void 0 !== t ? [t] : []; }, getFooter: function () { var t = this._options.callbacks, e = t.beforeFooter.apply(this, arguments), n = t.footer.apply(this, arguments), a = t.afterFooter.apply(this, arguments), o = []; return i(o = i(o = i(o, e), n), a); }, update: function (e) { var i, a, o, r, l, s, d, u = this, h = u._options, c = u._model, f = u._model = n(h), g = u._active, p = u._data, m = { xAlign: c.xAlign, yAlign: c.yAlign }, v = { x: c.x, y: c.y }, b = { width: c.width, height: c.height }, x = { x: c.caretX, y: c.caretY }; if (g.length) {
        f.opacity = 1;
        var y = [], k = [];
        x = t.Tooltip.positioners[h.position].call(u, g, u._eventPosition);
        var w = [];
        for (i = 0, a = g.length; i < a; ++i)
            w.push((r = void 0, l = void 0, r = (o = g[i])._xScale, l = o._yScale || o._scale, s = o._index, d = o._datasetIndex, { xLabel: r ? r.getLabelForIndex(s, d) : "", yLabel: l ? l.getLabelForIndex(s, d) : "", index: s, datasetIndex: d, x: o._model.x, y: o._model.y }));
        h.filter && (w = w.filter(function (t) { return h.filter(t, p); })), h.itemSort && (w = w.sort(function (t, e) { return h.itemSort(t, e, p); })), z.each(w, function (t) { y.push(h.callbacks.labelColor.call(u, t, u._chart)), k.push(h.callbacks.labelTextColor.call(u, t, u._chart)); }), f.title = u.getTitle(w, p), f.beforeBody = u.getBeforeBody(w, p), f.body = u.getBody(w, p), f.afterBody = u.getAfterBody(w, p), f.footer = u.getFooter(w, p), f.x = Math.round(x.x), f.y = Math.round(x.y), f.caretPadding = h.caretPadding, f.labelColors = y, f.labelTextColors = k, f.dataPoints = w, v = function (t, e, i, n) { var a = t.x, o = t.y, r = t.caretSize, l = t.caretPadding, s = t.cornerRadius, d = i.xAlign, u = i.yAlign, h = r + l, c = s + l; return "right" === d ? a -= e.width : "center" === d && ((a -= e.width / 2) + e.width > n.width && (a = n.width - e.width), a < 0 && (a = 0)), "top" === u ? o += h : o -= "bottom" === u ? e.height + h : e.height / 2, "center" === u ? "left" === d ? a += h : "right" === d && (a -= h) : "left" === d ? a -= c : "right" === d && (a += c), { x: a, y: o }; }(f, b = function (t, e) { var i = t._chart.ctx, n = 2 * e.yPadding, a = 0, o = e.body, r = o.reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length; }, 0); r += e.beforeBody.length + e.afterBody.length; var l = e.title.length, s = e.footer.length, d = e.titleFontSize, u = e.bodyFontSize, h = e.footerFontSize; n += l * d, n += l ? (l - 1) * e.titleSpacing : 0, n += l ? e.titleMarginBottom : 0, n += r * u, n += r ? (r - 1) * e.bodySpacing : 0, n += s ? e.footerMarginTop : 0, n += s * h, n += s ? (s - 1) * e.footerSpacing : 0; var c = 0, f = function (t) { a = Math.max(a, i.measureText(t).width + c); }; return i.font = z.fontString(d, e._titleFontStyle, e._titleFontFamily), z.each(e.title, f), i.font = z.fontString(u, e._bodyFontStyle, e._bodyFontFamily), z.each(e.beforeBody.concat(e.afterBody), f), c = e.displayColors ? u + 2 : 0, z.each(o, function (t) { z.each(t.before, f), z.each(t.lines, f), z.each(t.after, f); }), c = 0, i.font = z.fontString(h, e._footerFontStyle, e._footerFontFamily), z.each(e.footer, f), { width: a += 2 * e.xPadding, height: n }; }(this, f), m = function (t, e) { var i, n, a, o, r, l = t._model, s = t._chart, d = t._chart.chartArea, u = "center", h = "center"; l.y < e.height ? h = "top" : l.y > s.height - e.height && (h = "bottom"); var c = (d.left + d.right) / 2, f = (d.top + d.bottom) / 2; "center" === h ? (i = function (t) { return t <= c; }, n = function (t) { return t > c; }) : (i = function (t) { return t <= e.width / 2; }, n = function (t) { return t >= s.width - e.width / 2; }), a = function (t) { return t + e.width + l.caretSize + l.caretPadding > s.width; }, o = function (t) { return t - e.width - l.caretSize - l.caretPadding < 0; }, r = function (t) { return t <= f ? "top" : "bottom"; }, i(l.x) ? (u = "left", a(l.x) && (u = "center", h = r(l.y))) : n(l.x) && (u = "right", o(l.x) && (u = "center", h = r(l.y))); var g = t._options; return { xAlign: g.xAlign ? g.xAlign : u, yAlign: g.yAlign ? g.yAlign : h }; }(this, b), u._chart);
    }
    else
        f.opacity = 0; return f.xAlign = m.xAlign, f.yAlign = m.yAlign, f.x = v.x, f.y = v.y, f.width = b.width, f.height = b.height, f.caretX = x.x, f.caretY = x.y, u._model = f, e && h.custom && h.custom.call(u, f), u; }, drawCaret: function (t, e) { var i = this._chart.ctx, n = this._view, a = this.getCaretPosition(t, e, n); i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3); }, getCaretPosition: function (t, e, i) { var n, a, o, r, l, s, d = i.caretSize, u = i.cornerRadius, h = i.xAlign, c = i.yAlign, f = t.x, g = t.y, p = e.width, m = e.height; if ("center" === c)
        l = g + m / 2, "left" === h ? (a = (n = f) - d, o = n, r = l + d, s = l - d) : (a = (n = f + p) + d, o = n, r = l - d, s = l + d);
    else if ("left" === h ? (n = (a = f + u + d) - d, o = a + d) : "right" === h ? (n = (a = f + p - u - d) - d, o = a + d) : (n = (a = i.caretX) - d, o = a + d), "top" === c)
        l = (r = g) - d, s = r;
    else {
        l = (r = g + m) + d, s = r;
        var v = o;
        o = n, n = v;
    } return { x1: n, x2: a, x3: o, y1: r, y2: l, y3: s }; }, drawTitle: function (t, i, n, a) { var o = i.title; if (o.length) {
        n.textAlign = i._titleAlign, n.textBaseline = "top";
        var r, l, s = i.titleFontSize, d = i.titleSpacing;
        for (n.fillStyle = e(i.titleFontColor, a), n.font = z.fontString(s, i._titleFontStyle, i._titleFontFamily), r = 0, l = o.length; r < l; ++r)
            n.fillText(o[r], t.x, t.y), t.y += s + d, r + 1 === o.length && (t.y += i.titleMarginBottom - d);
    } }, drawBody: function (t, i, n, a) { var o = i.bodyFontSize, r = i.bodySpacing, l = i.body; n.textAlign = i._bodyAlign, n.textBaseline = "top", n.font = z.fontString(o, i._bodyFontStyle, i._bodyFontFamily); var s = 0, d = function (e) { n.fillText(e, t.x + s, t.y), t.y += o + r; }; n.fillStyle = e(i.bodyFontColor, a), z.each(i.beforeBody, d); var u = i.displayColors; s = u ? o + 2 : 0, z.each(l, function (r, l) { var s = e(i.labelTextColors[l], a); n.fillStyle = s, z.each(r.before, d), z.each(r.lines, function (r) { u && (n.fillStyle = e(i.legendColorBackground, a), n.fillRect(t.x, t.y, o, o), n.lineWidth = 1, n.strokeStyle = e(i.labelColors[l].borderColor, a), n.strokeRect(t.x, t.y, o, o), n.fillStyle = e(i.labelColors[l].backgroundColor, a), n.fillRect(t.x + 1, t.y + 1, o - 2, o - 2), n.fillStyle = s), d(r); }), z.each(r.after, d); }), s = 0, z.each(i.afterBody, d), t.y -= r; }, drawFooter: function (t, i, n, a) { var o = i.footer; o.length && (t.y += i.footerMarginTop, n.textAlign = i._footerAlign, n.textBaseline = "top", n.fillStyle = e(i.footerFontColor, a), n.font = z.fontString(i.footerFontSize, i._footerFontStyle, i._footerFontFamily), z.each(o, function (e) { n.fillText(e, t.x, t.y), t.y += i.footerFontSize + i.footerSpacing; })); }, drawBackground: function (t, i, n, a, o) { n.fillStyle = e(i.backgroundColor, o), n.strokeStyle = e(i.borderColor, o), n.lineWidth = i.borderWidth; var r = i.xAlign, l = i.yAlign, s = t.x, d = t.y, u = a.width, h = a.height, c = i.cornerRadius; n.beginPath(), n.moveTo(s + c, d), "top" === l && this.drawCaret(t, a), n.lineTo(s + u - c, d), n.quadraticCurveTo(s + u, d, s + u, d + c), "center" === l && "right" === r && this.drawCaret(t, a), n.lineTo(s + u, d + h - c), n.quadraticCurveTo(s + u, d + h, s + u - c, d + h), "bottom" === l && this.drawCaret(t, a), n.lineTo(s + c, d + h), n.quadraticCurveTo(s, d + h, s, d + h - c), "center" === l && "left" === r && this.drawCaret(t, a), n.lineTo(s, d + c), n.quadraticCurveTo(s, d, s + c, d), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke(); }, draw: function () { var t = this._chart.ctx, e = this._view; if (0 !== e.opacity) {
        var i = { width: e.width, height: e.height }, n = { x: e.x, y: e.y }, a = Math.abs(e.opacity < .001) ? 0 : e.opacity, o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length;
        this._options.enabled && o && (this.drawBackground(n, e, t, i, a), n.x += e.xPadding, n.y += e.yPadding, this.drawTitle(n, e, t, a), this.drawBody(n, e, t, a), this.drawFooter(n, e, t, a));
    } }, handleEvent: function (t) { var e, i = this, n = i._options; return i._lastActive = i._lastActive || [], "mouseout" === t.type ? i._active = [] : i._active = i._chart.getElementsAtEventForMode(t, n.mode, n), (e = !z.arrayEquals(i._active, i._lastActive)) && (i._lastActive = i._active, (n.enabled || n.custom) && (i._eventPosition = { x: t.x, y: t.y }, i.update(!0), i.pivot())), e; } }), t.Tooltip.positioners = { average: function (t) { if (!t.length)
        return !1; var e, i, n = 0, a = 0, o = 0; for (e = 0, i = t.length; e < i; ++e) {
        var r = t[e];
        if (r && r.hasValue()) {
            var l = r.tooltipPosition();
            n += l.x, a += l.y, ++o;
        }
    } return { x: Math.round(n / o), y: Math.round(a / o) }; }, nearest: function (t, e) { var i, n, a, o = e.x, r = e.y, l = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) {
        var s = t[i];
        if (s && s.hasValue()) {
            var d = s.getCenterPoint(), u = z.distanceBetweenPoints(e, d);
            u < l && (l = u, a = s);
        }
    } if (a) {
        var h = a.tooltipPosition();
        o = h.x, r = h.y;
    } return { x: o, y: r }; } }; }, Vn = Object.freeze({ default: Nn, __moduleExports: Nn }), Hn = function (t) { var e = z.noop; t.LinearScaleBase = t.Scale.extend({ getRightValue: function (e) { return "string" == typeof e ? +e : t.Scale.prototype.getRightValue.call(this, e); }, handleTickRangeOptions: function () { var t = this, e = t.options.ticks; if (e.beginAtZero) {
        var i = z.sign(t.min), n = z.sign(t.max);
        i < 0 && n < 0 ? t.max = 0 : i > 0 && n > 0 && (t.min = 0);
    } var a = void 0 !== e.min || void 0 !== e.suggestedMin, o = void 0 !== e.max || void 0 !== e.suggestedMax; void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (null === t.min ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (null === t.max ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), a !== o && t.min >= t.max && (a ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--); }, getTickLimit: e, handleDirectionalChanges: e, buildTicks: function () { var t = this, e = t.options.ticks, i = t.getTickLimit(), n = { maxTicks: i = Math.max(2, i), min: e.min, max: e.max, stepSize: z.valueOrDefault(e.fixedStepSize, e.stepSize) }, a = t.ticks = function (t, e) { var i, n = []; if (t.stepSize && t.stepSize > 0)
        i = t.stepSize;
    else {
        var a = z.niceNum(e.max - e.min, !1);
        i = z.niceNum(a / (t.maxTicks - 1), !0);
    } var o = Math.floor(e.min / i) * i, r = Math.ceil(e.max / i) * i; t.min && t.max && t.stepSize && z.almostWhole((t.max - t.min) / t.stepSize, i / 1e3) && (o = t.min, r = t.max); var l = (r - o) / i; l = z.almostEquals(l, Math.round(l), i / 1e3) ? Math.round(l) : Math.ceil(l); var s = 1; i < 1 && (s = Math.pow(10, i.toString().length - 2), o = Math.round(o * s) / s, r = Math.round(r * s) / s), n.push(void 0 !== t.min ? t.min : o); for (var d = 1; d < l; ++d)
        n.push(Math.round((o + d * i) * s) / s); return n.push(void 0 !== t.max ? t.max : r), n; }(n, t); t.handleDirectionalChanges(), t.max = z.max(a), t.min = z.min(a), e.reverse ? (a.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max); }, convertTicksToLabels: function () { var e = this; e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e); } }); }, jn = Object.freeze({ default: Hn, __moduleExports: Hn }), qn = function (t) { var e = t.Scale.extend({ getLabels: function () { var t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels; }, determineDataLimits: function () { var t, e = this, i = e.getLabels(); e.minIndex = 0, e.maxIndex = i.length - 1, void 0 !== e.options.ticks.min && (t = i.indexOf(e.options.ticks.min), e.minIndex = -1 !== t ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = i.indexOf(e.options.ticks.max), e.maxIndex = -1 !== t ? t : e.maxIndex), e.min = i[e.minIndex], e.max = i[e.maxIndex]; }, buildTicks: function () { var t = this, e = t.getLabels(); t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1); }, getLabelForIndex: function (t, e) { var i = this, n = i.chart.data, a = i.isHorizontal(); return n.yLabels && !a ? i.getRightValue(n.datasets[e].data[t]) : i.ticks[t - i.minIndex]; }, getPixelForValue: function (t, e) { var i, n = this, a = n.options.offset, o = Math.max(n.maxIndex + 1 - n.minIndex - (a ? 0 : 1), 1); if (void 0 !== t && null !== t && (i = n.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) {
        var r = n.getLabels();
        t = i || t;
        var l = r.indexOf(t);
        e = -1 !== l ? l : e;
    } if (n.isHorizontal()) {
        var s = n.width / o, d = s * (e - n.minIndex);
        return a && (d += s / 2), n.left + Math.round(d);
    } var u = n.height / o, h = u * (e - n.minIndex); return a && (h += u / 2), n.top + Math.round(h); }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null); }, getValueForPixel: function (t) { var e = this, i = e.options.offset, n = Math.max(e._ticks.length - (i ? 0 : 1), 1), a = e.isHorizontal(), o = (a ? e.width : e.height) / n; return t -= a ? e.left : e.top, i && (t -= o / 2), (t <= 0 ? 0 : Math.round(t / o)) + e.minIndex; }, getBasePixel: function () { return this.bottom; } }); t.scaleService.registerScaleType("category", e, { position: "bottom" }); }, Yn = Object.freeze({ default: qn, __moduleExports: qn }), Un = function (t) { var e = { position: "left", ticks: { callback: Rn.formatters.linear } }, i = t.LinearScaleBase.extend({ determineDataLimits: function () { var t = this, e = t.options, i = t.chart, n = i.data.datasets, a = t.isHorizontal(); function o(e) { return a ? e.xAxisID === t.id : e.yAxisID === t.id; } t.min = null, t.max = null; var r = e.stacked; if (void 0 === r && z.each(n, function (t, e) { if (!r) {
        var n = i.getDatasetMeta(e);
        i.isDatasetVisible(e) && o(n) && void 0 !== n.stack && (r = !0);
    } }), e.stacked || r) {
        var l = {};
        z.each(n, function (n, a) { var r = i.getDatasetMeta(a), s = [r.type, void 0 === e.stacked && void 0 === r.stack ? a : "", r.stack].join("."); void 0 === l[s] && (l[s] = { positiveValues: [], negativeValues: [] }); var d = l[s].positiveValues, u = l[s].negativeValues; i.isDatasetVisible(a) && o(r) && z.each(n.data, function (i, n) { var a = +t.getRightValue(i); isNaN(a) || r.data[n].hidden || (d[n] = d[n] || 0, u[n] = u[n] || 0, e.relativePoints ? d[n] = 100 : a < 0 ? u[n] += a : d[n] += a); }); }), z.each(l, function (e) { var i = e.positiveValues.concat(e.negativeValues), n = z.min(i), a = z.max(i); t.min = null === t.min ? n : Math.min(t.min, n), t.max = null === t.max ? a : Math.max(t.max, a); });
    }
    else
        z.each(n, function (e, n) { var a = i.getDatasetMeta(n); i.isDatasetVisible(n) && o(a) && z.each(e.data, function (e, i) { var n = +t.getRightValue(e); isNaN(n) || a.data[i].hidden || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n)); }); }); t.min = isFinite(t.min) && !isNaN(t.min) ? t.min : 0, t.max = isFinite(t.max) && !isNaN(t.max) ? t.max : 1, this.handleTickRangeOptions(); }, getTickLimit: function () { var t, e = this.options.ticks; if (this.isHorizontal())
        t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.width / 50));
    else {
        var i = z.valueOrDefault(e.fontSize, E.global.defaultFontSize);
        t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.height / (2 * i)));
    } return t; }, handleDirectionalChanges: function () { this.isHorizontal() || this.ticks.reverse(); }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, getPixelForValue: function (t) { var e = this, i = e.start, n = +e.getRightValue(t), a = e.end - i; return e.isHorizontal() ? e.left + e.width / a * (n - i) : e.bottom - e.height / a * (n - i); }, getValueForPixel: function (t) { var e = this, i = e.isHorizontal(), n = i ? e.width : e.height, a = (i ? t - e.left : e.bottom - t) / n; return e.start + (e.end - e.start) * a; }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticksAsNumbers[t]); } }); t.scaleService.registerScaleType("linear", i, e); }, Xn = Object.freeze({ default: Un, __moduleExports: Un }), Kn = function (t) { var e = { position: "left", ticks: { callback: Rn.formatters.logarithmic } }, i = t.Scale.extend({ determineDataLimits: function () { var t = this, e = t.options, i = t.chart, n = i.data.datasets, a = t.isHorizontal(); function o(e) { return a ? e.xAxisID === t.id : e.yAxisID === t.id; } t.min = null, t.max = null, t.minNotZero = null; var r = e.stacked; if (void 0 === r && z.each(n, function (t, e) { if (!r) {
        var n = i.getDatasetMeta(e);
        i.isDatasetVisible(e) && o(n) && void 0 !== n.stack && (r = !0);
    } }), e.stacked || r) {
        var l = {};
        z.each(n, function (n, a) { var r = i.getDatasetMeta(a), s = [r.type, void 0 === e.stacked && void 0 === r.stack ? a : "", r.stack].join("."); i.isDatasetVisible(a) && o(r) && (void 0 === l[s] && (l[s] = []), z.each(n.data, function (e, i) { var n = l[s], a = +t.getRightValue(e); isNaN(a) || r.data[i].hidden || a < 0 || (n[i] = n[i] || 0, n[i] += a); })); }), z.each(l, function (e) { if (e.length > 0) {
            var i = z.min(e), n = z.max(e);
            t.min = null === t.min ? i : Math.min(t.min, i), t.max = null === t.max ? n : Math.max(t.max, n);
        } });
    }
    else
        z.each(n, function (e, n) { var a = i.getDatasetMeta(n); i.isDatasetVisible(n) && o(a) && z.each(e.data, function (e, i) { var n = +t.getRightValue(e); isNaN(n) || a.data[i].hidden || n < 0 || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n), 0 !== n && (null === t.minNotZero || n < t.minNotZero) && (t.minNotZero = n)); }); }); this.handleTickRangeOptions(); }, handleTickRangeOptions: function () { var t = this, e = t.options.ticks, i = z.valueOrDefault; t.min = i(e.min, t.min), t.max = i(e.max, t.max), t.min === t.max && (0 !== t.min && null !== t.min ? (t.min = Math.pow(10, Math.floor(z.log10(t.min)) - 1), t.max = Math.pow(10, Math.floor(z.log10(t.max)) + 1)) : (t.min = 1, t.max = 10)), null === t.min && (t.min = Math.pow(10, Math.floor(z.log10(t.max)) - 1)), null === t.max && (t.max = 0 !== t.min ? Math.pow(10, Math.floor(z.log10(t.min)) + 1) : 10), null === t.minNotZero && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = Math.pow(10, Math.floor(z.log10(t.max))) : t.minNotZero = 1); }, buildTicks: function () { var t = this, e = t.options.ticks, i = !t.isHorizontal(), n = { min: e.min, max: e.max }, a = t.ticks = function (t, e) { var i, n, a = [], o = z.valueOrDefault, r = o(t.min, Math.pow(10, Math.floor(z.log10(e.min)))), l = Math.floor(z.log10(e.max)), s = Math.ceil(e.max / Math.pow(10, l)); 0 === r ? (i = Math.floor(z.log10(e.minNotZero)), n = Math.floor(e.minNotZero / Math.pow(10, i)), a.push(r), r = n * Math.pow(10, i)) : (i = Math.floor(z.log10(r)), n = Math.floor(r / Math.pow(10, i))); var d = i < 0 ? Math.pow(10, Math.abs(i)) : 1; do {
        a.push(r), 10 == ++n && (n = 1, d = ++i >= 0 ? 1 : d), r = Math.round(n * Math.pow(10, i) * d) / d;
    } while (i < l || i === l && n < s); var u = o(t.max, r); return a.push(u), a; }(n, t); t.max = z.max(a), t.min = z.min(a), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && a.reverse(); }, convertTicksToLabels: function () { this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this); }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickValues[t]); }, _getFirstTickValue: function (t) { var e = Math.floor(z.log10(t)); return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e); }, getPixelForValue: function (e) { var i, n, a, o, r, l = this, s = l.options.ticks.reverse, d = z.log10, u = l._getFirstTickValue(l.minNotZero), h = 0; return e = +l.getRightValue(e), s ? (a = l.end, o = l.start, r = -1) : (a = l.start, o = l.end, r = 1), l.isHorizontal() ? (i = l.width, n = s ? l.right : l.left) : (i = l.height, r *= -1, n = s ? l.top : l.bottom), e !== a && (0 === a && (i -= h = z.getValueOrDefault(l.options.ticks.fontSize, t.defaults.global.defaultFontSize), a = u), 0 !== e && (h += i / (d(o) - d(a)) * (d(e) - d(a))), n += r * h), n; }, getValueForPixel: function (e) { var i, n, a, o, r = this, l = r.options.ticks.reverse, s = z.log10, d = r._getFirstTickValue(r.minNotZero); if (l ? (n = r.end, a = r.start) : (n = r.start, a = r.end), r.isHorizontal() ? (i = r.width, o = l ? r.right - e : e - r.left) : (i = r.height, o = l ? e - r.top : r.bottom - e), o !== n) {
        if (0 === n) {
            var u = z.getValueOrDefault(r.options.ticks.fontSize, t.defaults.global.defaultFontSize);
            o -= u, i -= u, n = d;
        }
        o *= s(a) - s(n), o /= i, o = Math.pow(10, s(n) + o);
    } return o; } }); t.scaleService.registerScaleType("logarithmic", i, e); }, Gn = Object.freeze({ default: Kn, __moduleExports: Kn }), Jn = function (t) { var e = E.global, i = { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1 }, gridLines: { circular: !1 }, ticks: { showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: Rn.formatters.linear }, pointLabels: { display: !0, fontSize: 10, callback: function (t) { return t; } } }; function n(t) { var e = t.options; return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0; } function a(t) { var i = t.options.pointLabels, n = z.valueOrDefault(i.fontSize, e.defaultFontSize), a = z.valueOrDefault(i.fontStyle, e.defaultFontStyle), o = z.valueOrDefault(i.fontFamily, e.defaultFontFamily); return { size: n, style: a, family: o, font: z.fontString(n, a, o) }; } function o(t, e, i, n, a) { return t === n || t === a ? { start: e - i / 2, end: e + i / 2 } : t < n || t > a ? { start: e - i - 5, end: e } : { start: e, end: e + i + 5 }; } function r(t) { return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right"; } function l(t, e, i, n) { if (z.isArray(e))
    for (var a = i.y, o = 1.5 * n, r = 0; r < e.length; ++r)
        t.fillText(e[r], i.x, a), a += o;
else
    t.fillText(e, i.x, i.y); } function s(t, e, i) { 90 === t || 270 === t ? i.y -= e.h / 2 : (t > 270 || t < 90) && (i.y -= e.h); } function d(t) { return z.isNumber(t) ? t : 0; } var u = t.LinearScaleBase.extend({ setDimensions: function () { var t = this, i = t.options, n = i.ticks; t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2); var a = z.min([t.height, t.width]), o = z.valueOrDefault(n.fontSize, e.defaultFontSize); t.drawingArea = i.display ? a / 2 - (o / 2 + n.backdropPaddingY) : a / 2; }, determineDataLimits: function () { var t = this, e = t.chart, i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY; z.each(e.data.datasets, function (a, o) { if (e.isDatasetVisible(o)) {
        var r = e.getDatasetMeta(o);
        z.each(a.data, function (e, a) { var o = +t.getRightValue(e); isNaN(o) || r.data[a].hidden || (i = Math.min(o, i), n = Math.max(o, n)); });
    } }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions(); }, getTickLimit: function () { var t = this.options.ticks, i = z.valueOrDefault(t.fontSize, e.defaultFontSize); return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * i))); }, convertTicksToLabels: function () { var e = this; t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e); }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); }, fit: function () { var t, e; this.options.pointLabels.display ? function (t) { var e, i, r, l = a(t), s = Math.min(t.height / 2, t.width / 2), d = { r: t.width, l: 0, t: t.height, b: 0 }, u = {}; t.ctx.font = l.font, t._pointLabelSizes = []; var h, c, f, g = n(t); for (e = 0; e < g; e++) {
        r = t.getPointPosition(e, s), h = t.ctx, c = l.size, f = t.pointLabels[e] || "", i = z.isArray(f) ? { w: z.longestText(h, h.font, f), h: f.length * c + 1.5 * (f.length - 1) * c } : { w: h.measureText(f).width, h: c }, t._pointLabelSizes[e] = i;
        var p = t.getIndexAngle(e), m = z.toDegrees(p) % 360, v = o(m, r.x, i.w, 0, 180), b = o(m, r.y, i.h, 90, 270);
        v.start < d.l && (d.l = v.start, u.l = p), v.end > d.r && (d.r = v.end, u.r = p), b.start < d.t && (d.t = b.start, u.t = p), b.end > d.b && (d.b = b.end, u.b = p);
    } t.setReductions(s, d, u); }(this) : (t = this, e = Math.min(t.height / 2, t.width / 2), t.drawingArea = Math.round(e), t.setCenterPoint(0, 0, 0, 0)); }, setReductions: function (t, e, i) { var n = e.l / Math.sin(i.l), a = Math.max(e.r - this.width, 0) / Math.sin(i.r), o = -e.t / Math.cos(i.t), r = -Math.max(e.b - this.height, 0) / Math.cos(i.b); n = d(n), a = d(a), o = d(o), r = d(r), this.drawingArea = Math.min(Math.round(t - (n + a) / 2), Math.round(t - (o + r) / 2)), this.setCenterPoint(n, a, o, r); }, setCenterPoint: function (t, e, i, n) { var a = this, o = a.width - e - a.drawingArea, r = t + a.drawingArea, l = i + a.drawingArea, s = a.height - n - a.drawingArea; a.xCenter = Math.round((r + o) / 2 + a.left), a.yCenter = Math.round((l + s) / 2 + a.top); }, getIndexAngle: function (t) { return t * (2 * Math.PI / n(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360; }, getDistanceFromCenterForValue: function (t) { var e = this; if (null === t)
        return 0; var i = e.drawingArea / (e.max - e.min); return e.options.ticks.reverse ? (e.max - t) * i : (t - e.min) * i; }, getPointPosition: function (t, e) { var i = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.round(Math.cos(i) * e) + this.xCenter, y: Math.round(Math.sin(i) * e) + this.yCenter }; }, getPointPositionForValue: function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)); }, getBasePosition: function () { var t = this.min, e = this.max; return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0); }, draw: function () { var t = this, i = t.options, o = i.gridLines, d = i.ticks, u = z.valueOrDefault; if (i.display) {
        var h = t.ctx, c = this.getIndexAngle(0), f = u(d.fontSize, e.defaultFontSize), g = u(d.fontStyle, e.defaultFontStyle), p = u(d.fontFamily, e.defaultFontFamily), m = z.fontString(f, g, p);
        z.each(t.ticks, function (i, a) { if (a > 0 || d.reverse) {
            var r = t.getDistanceFromCenterForValue(t.ticksAsNumbers[a]);
            if (o.display && 0 !== a && function (t, e, i, a) { var o = t.ctx; if (o.strokeStyle = z.valueAtIndexOrDefault(e.color, a - 1), o.lineWidth = z.valueAtIndexOrDefault(e.lineWidth, a - 1), t.options.gridLines.circular)
                o.beginPath(), o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI), o.closePath(), o.stroke();
            else {
                var r = n(t);
                if (0 === r)
                    return;
                o.beginPath();
                var l = t.getPointPosition(0, i);
                o.moveTo(l.x, l.y);
                for (var s = 1; s < r; s++)
                    l = t.getPointPosition(s, i), o.lineTo(l.x, l.y);
                o.closePath(), o.stroke();
            } }(t, o, r, a), d.display) {
                var l = u(d.fontColor, e.defaultFontColor);
                if (h.font = m, h.save(), h.translate(t.xCenter, t.yCenter), h.rotate(c), d.showLabelBackdrop) {
                    var s = h.measureText(i).width;
                    h.fillStyle = d.backdropColor, h.fillRect(-s / 2 - d.backdropPaddingX, -r - f / 2 - d.backdropPaddingY, s + 2 * d.backdropPaddingX, f + 2 * d.backdropPaddingY);
                }
                h.textAlign = "center", h.textBaseline = "middle", h.fillStyle = l, h.fillText(i, 0, -r), h.restore();
            }
        } }), (i.angleLines.display || i.pointLabels.display) && function (t) { var i = t.ctx, o = t.options, d = o.angleLines, u = o.pointLabels; i.lineWidth = d.lineWidth, i.strokeStyle = d.color; var h = t.getDistanceFromCenterForValue(o.ticks.reverse ? t.min : t.max), c = a(t); i.textBaseline = "top"; for (var f = n(t) - 1; f >= 0; f--) {
            if (d.display) {
                var g = t.getPointPosition(f, h);
                i.beginPath(), i.moveTo(t.xCenter, t.yCenter), i.lineTo(g.x, g.y), i.stroke(), i.closePath();
            }
            if (u.display) {
                var p = t.getPointPosition(f, h + 5), m = z.valueAtIndexOrDefault(u.fontColor, f, e.defaultFontColor);
                i.font = c.font, i.fillStyle = m;
                var v = t.getIndexAngle(f), b = z.toDegrees(v);
                i.textAlign = r(b), s(b, t._pointLabelSizes[f], p), l(i, t.pointLabels[f] || "", p, c.size);
            }
        } }(t);
    } } }); t.scaleService.registerScaleType("radialLinear", u, i); }, Zn = Object.freeze({ default: Jn, __moduleExports: Jn }), Qn = e.moment$1 && e.moment || e.moment$1; Qn = "function" == typeof Qn ? Qn : window.moment; var $n = Number.MIN_SAFE_INTEGER || -9007199254740991, ta = Number.MAX_SAFE_INTEGER || 9007199254740991, ea = { millisecond: { common: !0, size: 1, steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, second: { common: !0, size: 1e3, steps: [1, 2, 5, 10, 30] }, minute: { common: !0, size: 6e4, steps: [1, 2, 5, 10, 30] }, hour: { common: !0, size: 36e5, steps: [1, 2, 3, 6, 12] }, day: { common: !0, size: 864e5, steps: [1, 2, 5] }, week: { common: !1, size: 6048e5, steps: [1, 2, 3, 4] }, month: { common: !0, size: 2628e6, steps: [1, 2, 3] }, quarter: { common: !1, size: 7884e6, steps: [1, 2, 3, 4] }, year: { common: !0, size: 3154e7 } }, ia = Object.keys(ea); function na(t, e) { return t - e; } function aa(t) { var e, i, n, a = {}, o = []; for (e = 0, i = t.length; e < i; ++e)
    a[n = t[e]] || (a[n] = !0, o.push(n)); return o; } function oa(t, e, i, n) { var a = function (t, e, i) { for (var n, a, o, r = 0, l = t.length - 1; r >= 0 && r <= l;) {
    if (a = t[(n = r + l >> 1) - 1] || null, o = t[n], !a)
        return { lo: null, hi: o };
    if (o[e] < i)
        r = n + 1;
    else {
        if (!(a[e] > i))
            return { lo: a, hi: o };
        l = n - 1;
    }
} return { lo: o, hi: null }; }(t, e, i), o = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0], r = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1], l = r[e] - o[e], s = l ? (i - o[e]) / l : 0, d = (r[n] - o[n]) * s; return o[n] + d; } function ra(t, e) { var i = e.parser, n = e.parser || e.format; return "function" == typeof i ? i(t) : "string" == typeof t && "string" == typeof n ? Qn(t, n) : (t instanceof Qn || (t = Qn(t)), t.isValid() ? t : "function" == typeof n ? n(t) : t); } function la(t, e) { if (z.isNullOrUndef(t))
    return null; var i = e.options.time, n = ra(e.getRightValue(t), i); return n.isValid() ? (i.round && n.startOf(i.round), n.valueOf()) : null; } function sa(t) { for (var e = ia.indexOf(t) + 1, i = ia.length; e < i; ++e)
    if (ea[ia[e]].common)
        return ia[e]; } var da = function (t) { var e = t.Scale.extend({ initialize: function () { if (!Qn)
        throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com"); this.mergeTicksOptions(), t.Scale.prototype.initialize.call(this); }, update: function () { var e = this.options; return e.time && e.time.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), t.Scale.prototype.update.apply(this, arguments); }, getRightValue: function (e) { return e && void 0 !== e.t && (e = e.t), t.Scale.prototype.getRightValue.call(this, e); }, determineDataLimits: function () { var t, e, i, n, a, o, r = this, l = r.chart, s = r.options.time, d = s.unit || "day", u = ta, h = $n, c = [], f = [], g = []; for (t = 0, i = l.data.labels.length; t < i; ++t)
        g.push(la(l.data.labels[t], r)); for (t = 0, i = (l.data.datasets || []).length; t < i; ++t)
        if (l.isDatasetVisible(t))
            if (a = l.data.datasets[t].data, z.isObject(a[0]))
                for (f[t] = [], e = 0, n = a.length; e < n; ++e)
                    o = la(a[e], r), c.push(o), f[t][e] = o;
            else
                c.push.apply(c, g), f[t] = g.slice(0);
        else
            f[t] = []; g.length && (g = aa(g).sort(na), u = Math.min(u, g[0]), h = Math.max(h, g[g.length - 1])), c.length && (c = aa(c).sort(na), u = Math.min(u, c[0]), h = Math.max(h, c[c.length - 1])), u = la(s.min, r) || u, h = la(s.max, r) || h, u = u === ta ? +Qn().startOf(d) : u, h = h === $n ? +Qn().endOf(d) + 1 : h, r.min = Math.min(u, h), r.max = Math.max(u + 1, h), r._horizontal = r.isHorizontal(), r._table = [], r._timestamps = { data: c, datasets: f, labels: g }; }, buildTicks: function () { var t, e, i, n = this, a = n.min, o = n.max, r = n.options, l = r.time, s = [], d = []; switch (r.ticks.source) {
        case "data":
            s = n._timestamps.data;
            break;
        case "labels":
            s = n._timestamps.labels;
            break;
        case "auto":
        default: s = function (t, e, i, n) { var a, o = n.time, r = o.unit || function (t, e, i, n) { var a, o, r, l = ia.length; for (a = ia.indexOf(t); a < l - 1; ++a)
            if (r = (o = ea[ia[a]]).steps ? o.steps[o.steps.length - 1] : ta, o.common && Math.ceil((i - e) / (r * o.size)) <= n)
                return ia[a]; return ia[l - 1]; }(o.minUnit, t, e, i), l = sa(r), s = z.valueOrDefault(o.stepSize, o.unitStepSize), d = "week" === r && o.isoWeekday, u = n.ticks.major.enabled, h = ea[r], c = Qn(t), f = Qn(e), g = []; for (s || (s = function (t, e, i, n) { var a, o, l, s = e - t, d = ea[r], u = d.size, h = d.steps; if (!h)
            return Math.ceil(s / (n * u)); for (a = 0, o = h.length; a < o && (l = h[a], !(Math.ceil(s / (u * l)) <= n)); ++a)
            ; return l; }(t, e, 0, i)), d && (c = c.isoWeekday(d), f = f.isoWeekday(d)), c = c.startOf(d ? "day" : r), (f = f.startOf(d ? "day" : r)) < e && f.add(1, r), a = Qn(c), u && l && !d && !o.round && (a.startOf(l), a.add(~~((c - a) / (h.size * s)) * s, r)); a < f; a.add(s, r))
            g.push(+a); return g.push(+a), g; }(a, o, n.getLabelCapacity(a), r);
    } for ("ticks" === r.bounds && s.length && (a = s[0], o = s[s.length - 1]), a = la(l.min, n) || a, o = la(l.max, n) || o, t = 0, e = s.length; t < e; ++t)
        (i = s[t]) >= a && i <= o && d.push(i); return n.min = a, n.max = o, n._unit = l.unit || function (t, e, i, n) { var a, o, r = Qn.duration(Qn(n).diff(Qn(i))); for (a = ia.length - 1; a >= ia.indexOf(e); a--)
        if (o = ia[a], ea[o].common && r.as(o) >= t.length)
            return o; return ia[e ? ia.indexOf(e) : 0]; }(d, l.minUnit, n.min, n.max), n._majorUnit = sa(n._unit), n._table = function (t, e, i, n) { if ("linear" === r.distribution || !t.length)
        return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; var a, o, l, s, d, u = [], h = [e]; for (a = 0, o = t.length; a < o; ++a)
        (s = t[a]) > e && s < i && h.push(s); for (h.push(i), a = 0, o = h.length; a < o; ++a)
        d = h[a + 1], l = h[a - 1], s = h[a], void 0 !== l && void 0 !== d && Math.round((d + l) / 2) === s || u.push({ time: s, pos: a / (o - 1) }); return u; }(n._timestamps.data, a, o), n._offsets = function (t, e, i, n, a) { var o, r, l = 0, s = 0; return a.offset && e.length && (a.time.min || (o = e.length > 1 ? e[1] : n, r = e[0], l = (oa(t, "time", o, "pos") - oa(t, "time", r, "pos")) / 2), a.time.max || (o = e[e.length - 1], r = e.length > 1 ? e[e.length - 2] : i, s = (oa(t, "time", o, "pos") - oa(t, "time", r, "pos")) / 2)), { left: l, right: s }; }(n._table, d, a, o, r), n._labelFormat = function (t, e) { var i, n, a, o = t.length; for (i = 0; i < o; i++) {
        if (0 !== (n = ra(t[i], e)).millisecond())
            return "MMM D, YYYY h:mm:ss.SSS a";
        0 === n.second() && 0 === n.minute() && 0 === n.hour() || (a = !0);
    } return a ? "MMM D, YYYY h:mm:ss a" : "MMM D, YYYY"; }(n._timestamps.data, l), function (t, e) { var i, n, a, o, r = []; for (i = 0, n = t.length; i < n; ++i)
        a = t[i], o = !!e && a === +Qn(a).startOf(e), r.push({ value: a, major: o }); return r; }(d, n._majorUnit); }, getLabelForIndex: function (t, e) { var i = this.chart.data, n = this.options.time, a = i.labels && t < i.labels.length ? i.labels[t] : "", o = i.datasets[e].data[t]; return z.isObject(o) && (a = this.getRightValue(o)), n.tooltipFormat ? ra(a, n).format(n.tooltipFormat) : "string" == typeof a ? a : ra(a, n).format(this._labelFormat); }, tickFormatFunction: function (t, e, i, n) { var a = this.options, o = t.valueOf(), r = a.time.displayFormats, l = r[this._unit], s = this._majorUnit, d = r[s], u = t.clone().startOf(s).valueOf(), h = a.ticks.major, c = h.enabled && s && d && o === u, f = t.format(n || (c ? d : l)), g = c ? h : a.ticks.minor, p = z.valueOrDefault(g.callback, g.userCallback); return p ? p(f, e, i) : f; }, convertTicksToLabels: function (t) { var e, i, n = []; for (e = 0, i = t.length; e < i; ++e)
        n.push(this.tickFormatFunction(Qn(t[e].value), e, t)); return n; }, getPixelForOffset: function (t) { var e = this, i = e._horizontal ? e.width : e.height, n = e._horizontal ? e.left : e.top, a = oa(e._table, "time", t, "pos"); return n + i * (e._offsets.left + a) / (e._offsets.left + 1 + e._offsets.right); }, getPixelForValue: function (t, e, i) { var n = null; if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), null === n && (n = la(t, this)), null !== n)
        return this.getPixelForOffset(n); }, getPixelForTick: function (t) { var e = this.getTicks(); return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null; }, getValueForPixel: function (t) { var e = this, i = e._horizontal ? e.width : e.height, n = e._horizontal ? e.left : e.top, a = (i ? (t - n) / i : 0) * (e._offsets.left + 1 + e._offsets.left) - e._offsets.right, o = oa(e._table, "pos", a, "time"); return Qn(o); }, getLabelWidth: function (t) { var e = this.options.ticks, i = this.ctx.measureText(t).width, n = z.toRadians(e.maxRotation), a = Math.cos(n), o = Math.sin(n); return i * a + z.valueOrDefault(e.fontSize, E.global.defaultFontSize) * o; }, getLabelCapacity: function (t) { var e = this, i = e.options.time.displayFormats.millisecond, n = e.tickFormatFunction(Qn(t), 0, [], i), a = e.getLabelWidth(n), o = e.isHorizontal() ? e.width : e.height, r = Math.floor(o / a); return r > 0 ? r : 1; } }); t.scaleService.registerScaleType("time", e, { position: "bottom", distribution: "linear", bounds: "data", time: { parser: !1, format: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: { millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" } }, ticks: { autoSkip: !1, source: "auto", major: { enabled: !1 } } }); }, ua = Object.freeze({ default: da, __moduleExports: da }), ha = pi && ui || pi; E._set("bar", { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", categoryPercentage: .8, barPercentage: .9, offset: !0, gridLines: { offsetGridLines: !0 } }], yAxes: [{ type: "linear" }] } }), E._set("horizontalBar", { hover: { mode: "index", axis: "y" }, scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ position: "left", type: "category", categoryPercentage: .8, barPercentage: .9, offset: !0, gridLines: { offsetGridLines: !0 } }] }, elements: { rectangle: { borderSkipped: "left" } }, tooltips: { callbacks: { title: function (t, e) { var i = ""; return t.length > 0 && (t[0].yLabel ? i = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (i = e.labels[t[0].index])), i; }, label: function (t, e) { return (e.datasets[t.datasetIndex].label || "") + ": " + t.xLabel; } }, mode: "index", axis: "y" } }); var ca = function (t) { t.controllers.bar = t.DatasetController.extend({ dataElementType: ha.Rectangle, initialize: function () { var e; t.DatasetController.prototype.initialize.apply(this, arguments), (e = this.getMeta()).stack = this.getDataset().stack, e.bar = !0; }, update: function (t) { var e, i, n = this.getMeta().data; for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e)
        this.updateElement(n[e], e, t); }, updateElement: function (t, e, i) { var n = this, a = n.chart, o = n.getMeta(), r = n.getDataset(), l = t.custom || {}, s = a.options.elements.rectangle; t._xScale = n.getScaleForId(o.xAxisID), t._yScale = n.getScaleForId(o.yAxisID), t._datasetIndex = n.index, t._index = e, t._model = { datasetLabel: r.label, label: a.data.labels[e], borderSkipped: l.borderSkipped ? l.borderSkipped : s.borderSkipped, backgroundColor: l.backgroundColor ? l.backgroundColor : z.valueAtIndexOrDefault(r.backgroundColor, e, s.backgroundColor), borderColor: l.borderColor ? l.borderColor : z.valueAtIndexOrDefault(r.borderColor, e, s.borderColor), borderWidth: l.borderWidth ? l.borderWidth : z.valueAtIndexOrDefault(r.borderWidth, e, s.borderWidth) }, n.updateElementGeometry(t, e, i), t.pivot(); }, updateElementGeometry: function (t, e, i) { var n = this, a = t._model, o = n.getValueScale(), r = o.getBasePixel(), l = o.isHorizontal(), s = n._ruler || n.getRuler(), d = n.calculateBarValuePixels(n.index, e), u = n.calculateBarIndexPixels(n.index, e, s); a.horizontal = l, a.base = i ? r : d.base, a.x = l ? i ? r : d.head : u.center, a.y = l ? u.center : i ? r : d.head, a.height = l ? u.size : void 0, a.width = l ? void 0 : u.size; }, getValueScaleId: function () { return this.getMeta().yAxisID; }, getIndexScaleId: function () { return this.getMeta().xAxisID; }, getValueScale: function () { return this.getScaleForId(this.getValueScaleId()); }, getIndexScale: function () { return this.getScaleForId(this.getIndexScaleId()); }, _getStacks: function (t) { var e, i, n = this.chart, a = this.getIndexScale().options.stacked, o = void 0 === t ? n.data.datasets.length : t + 1, r = []; for (e = 0; e < o; ++e)
        (i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === a || !0 === a && -1 === r.indexOf(i.stack) || void 0 === a && (void 0 === i.stack || -1 === r.indexOf(i.stack))) && r.push(i.stack); return r; }, getStackCount: function () { return this._getStacks().length; }, getStackIndex: function (t, e) { var i = this._getStacks(t), n = void 0 !== e ? i.indexOf(e) : -1; return -1 === n ? i.length - 1 : n; }, getRuler: function () { var t, e, i = this.getIndexScale(), n = this.getStackCount(), a = this.index, o = i.isHorizontal(), r = o ? i.left : i.top, l = r + (o ? i.width : i.height), s = []; for (t = 0, e = this.getMeta().data.length; t < e; ++t)
        s.push(i.getPixelForValue(null, t, a)); return { min: z.isNullOrUndef(i.options.barThickness) ? function (t, e) { var i, n, a, o, r = t.isHorizontal() ? t.width : t.height, l = t.getTicks(); for (a = 1, o = e.length; a < o; ++a)
            r = Math.min(r, e[a] - e[a - 1]); for (a = 0, o = l.length; a < o; ++a)
            n = t.getPixelForTick(a), r = a > 0 ? Math.min(r, n - i) : r, i = n; return r; }(i, s) : -1, pixels: s, start: r, end: l, stackCount: n, scale: i }; }, calculateBarValuePixels: function (t, e) { var i, n, a, o, r, l, s = this.chart, d = this.getMeta(), u = this.getValueScale(), h = s.data.datasets, c = u.getRightValue(h[t].data[e]), f = u.options.stacked, g = d.stack, p = 0; if (f || void 0 === f && void 0 !== g)
        for (i = 0; i < t; ++i)
            (n = s.getDatasetMeta(i)).bar && n.stack === g && n.controller.getValueScaleId() === u.id && s.isDatasetVisible(i) && (a = u.getRightValue(h[i].data[e]), (c < 0 && a < 0 || c >= 0 && a > 0) && (p += a)); return o = u.getPixelForValue(p), { size: l = ((r = u.getPixelForValue(p + c)) - o) / 2, base: o, head: r, center: r + l / 2 }; }, calculateBarIndexPixels: function (t, e, i) { var n = i.scale.options, a = "flex" === n.barThickness ? function (t, e, i) { var n, a = e.pixels, o = a[t], r = t > 0 ? a[t - 1] : null, l = t < a.length - 1 ? a[t + 1] : null, s = i.categoryPercentage; return null === r && (r = o - (null === l ? e.end - o : l - o)), null === l && (l = o + o - r), n = o - (o - r) / 2 * s, { chunk: (l - r) / 2 * s / e.stackCount, ratio: i.barPercentage, start: n }; }(e, i, n) : function (t, e, i) { var n, a, o = i.barThickness, r = e.stackCount, l = e.pixels[t]; return z.isNullOrUndef(o) ? (n = e.min * i.categoryPercentage, a = i.barPercentage) : (n = o * r, a = 1), { chunk: n / r, ratio: a, start: l - n / 2 }; }(e, i, n), o = this.getStackIndex(t, this.getMeta().stack), r = a.start + a.chunk * o + a.chunk / 2, l = Math.min(z.valueOrDefault(n.maxBarThickness, 1 / 0), a.chunk * a.ratio); return { base: r - l / 2, head: r + l / 2, center: r, size: l }; }, draw: function () { var t = this.chart, e = this.getValueScale(), i = this.getMeta().data, n = this.getDataset(), a = i.length, o = 0; for (z.canvas.clipArea(t.ctx, t.chartArea); o < a; ++o)
        isNaN(e.getRightValue(n.data[o])) || i[o].draw(); z.canvas.unclipArea(t.ctx); }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; a.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : z.valueAtIndexOrDefault(e.hoverBackgroundColor, i, z.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor ? n.hoverBorderColor : z.valueAtIndexOrDefault(e.hoverBorderColor, i, z.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : z.valueAtIndexOrDefault(e.hoverBorderWidth, i, a.borderWidth); }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model, o = this.chart.options.elements.rectangle; a.backgroundColor = n.backgroundColor ? n.backgroundColor : z.valueAtIndexOrDefault(e.backgroundColor, i, o.backgroundColor), a.borderColor = n.borderColor ? n.borderColor : z.valueAtIndexOrDefault(e.borderColor, i, o.borderColor), a.borderWidth = n.borderWidth ? n.borderWidth : z.valueAtIndexOrDefault(e.borderWidth, i, o.borderWidth); } }), t.controllers.horizontalBar = t.controllers.bar.extend({ getValueScaleId: function () { return this.getMeta().xAxisID; }, getIndexScaleId: function () { return this.getMeta().yAxisID; } }); }, fa = Object.freeze({ default: ca, __moduleExports: ca }); E._set("bubble", { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title: function () { return ""; }, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || "", n = e.datasets[t.datasetIndex].data[t.index]; return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")"; } } } }); var ga = function (t) { t.controllers.bubble = t.DatasetController.extend({ dataElementType: ha.Point, update: function (t) { var e = this, i = e.getMeta().data; z.each(i, function (i, n) { e.updateElement(i, n, t); }); }, updateElement: function (t, e, i) { var n = this, a = n.getMeta(), o = t.custom || {}, r = n.getScaleForId(a.xAxisID), l = n.getScaleForId(a.yAxisID), s = n._resolveElementOptions(t, e), d = n.getDataset().data[e], u = n.index, h = i ? r.getPixelForDecimal(.5) : r.getPixelForValue("object" == typeof d ? d : NaN, e, u), c = i ? l.getBasePixel() : l.getPixelForValue(d, e, u); t._xScale = r, t._yScale = l, t._options = s, t._datasetIndex = u, t._index = e, t._model = { backgroundColor: s.backgroundColor, borderColor: s.borderColor, borderWidth: s.borderWidth, hitRadius: s.hitRadius, pointStyle: s.pointStyle, radius: i ? 0 : s.radius, skip: o.skip || isNaN(h) || isNaN(c), x: h, y: c }, t.pivot(); }, setHoverStyle: function (t) { var e = t._model, i = t._options; e.backgroundColor = z.valueOrDefault(i.hoverBackgroundColor, z.getHoverColor(i.backgroundColor)), e.borderColor = z.valueOrDefault(i.hoverBorderColor, z.getHoverColor(i.borderColor)), e.borderWidth = z.valueOrDefault(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius; }, removeHoverStyle: function (t) { var e = t._model, i = t._options; e.backgroundColor = i.backgroundColor, e.borderColor = i.borderColor, e.borderWidth = i.borderWidth, e.radius = i.radius; }, _resolveElementOptions: function (t, e) { var i, n, a, o = this.chart, r = o.data.datasets[this.index], l = t.custom || {}, s = o.options.elements.point, d = z.options.resolve, u = r.data[e], h = {}, c = { chart: o, dataIndex: e, dataset: r, datasetIndex: this.index }, f = ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle"]; for (i = 0, n = f.length; i < n; ++i)
        h[a = f[i]] = d([l[a], r[a], s[a]], c, e); return h.radius = d([l.radius, u ? u.r : void 0, r.radius, s.radius], c, e), h; } }); }, pa = Object.freeze({ default: ga, __moduleExports: ga }); E._set("doughnut", { animation: { animateRotate: !0, animateScale: !1 }, hover: { mode: "single" }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, a = i.labels; if (n.length)
        for (var o = 0; o < n[0].data.length; ++o)
            e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>"); return e.push("</ul>"), e.join(""); }, legend: { labels: { generateLabels: function (t) { var e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) { var a = t.getDatasetMeta(0), o = e.datasets[0], r = a.data[n], l = r && r.custom || {}, s = z.valueAtIndexOrDefault, d = t.options.elements.arc; return { text: i, fillStyle: l.backgroundColor ? l.backgroundColor : s(o.backgroundColor, n, d.backgroundColor), strokeStyle: l.borderColor ? l.borderColor : s(o.borderColor, n, d.borderColor), lineWidth: l.borderWidth ? l.borderWidth : s(o.borderWidth, n, d.borderWidth), hidden: isNaN(o.data[n]) || a.data[n].hidden, index: n }; }) : []; } }, onClick: function (t, e) { var i, n, a, o = e.index, r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)
            (a = r.getDatasetMeta(i)).data[o] && (a.data[o].hidden = !a.data[o].hidden); r.update(); } }, cutoutPercentage: 50, rotation: -.5 * Math.PI, circumference: 2 * Math.PI, tooltips: { callbacks: { title: function () { return ""; }, label: function (t, e) { var i = e.labels[t.index], n = ": " + e.datasets[t.datasetIndex].data[t.index]; return z.isArray(i) ? (i = i.slice())[0] += n : i += n, i; } } } }), E._set("pie", z.clone(E.doughnut)), E._set("pie", { cutoutPercentage: 0 }); var ma = function (t) { t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({ dataElementType: ha.Arc, linkScales: z.noop, getRingIndex: function (t) { for (var e = 0, i = 0; i < t; ++i)
        this.chart.isDatasetVisible(i) && ++e; return e; }, update: function (t) { var e = this, i = e.chart, n = i.chartArea, a = i.options, o = a.elements.arc, r = n.right - n.left - o.borderWidth, l = n.bottom - n.top - o.borderWidth, s = Math.min(r, l), d = { x: 0, y: 0 }, u = e.getMeta(), h = a.cutoutPercentage, c = a.circumference; if (c < 2 * Math.PI) {
        var f = a.rotation % (2 * Math.PI), g = (f += 2 * Math.PI * (f >= Math.PI ? -1 : f < -Math.PI ? 1 : 0)) + c, p = { x: Math.cos(f), y: Math.sin(f) }, m = { x: Math.cos(g), y: Math.sin(g) }, v = f <= 0 && g >= 0 || f <= 2 * Math.PI && 2 * Math.PI <= g, b = f <= .5 * Math.PI && .5 * Math.PI <= g || f <= 2.5 * Math.PI && 2.5 * Math.PI <= g, x = f <= -Math.PI && -Math.PI <= g || f <= Math.PI && Math.PI <= g, y = f <= .5 * -Math.PI && .5 * -Math.PI <= g || f <= 1.5 * Math.PI && 1.5 * Math.PI <= g, k = h / 100, w = { x: x ? -1 : Math.min(p.x * (p.x < 0 ? 1 : k), m.x * (m.x < 0 ? 1 : k)), y: y ? -1 : Math.min(p.y * (p.y < 0 ? 1 : k), m.y * (m.y < 0 ? 1 : k)) }, M = { x: v ? 1 : Math.max(p.x * (p.x > 0 ? 1 : k), m.x * (m.x > 0 ? 1 : k)), y: b ? 1 : Math.max(p.y * (p.y > 0 ? 1 : k), m.y * (m.y > 0 ? 1 : k)) }, _ = { width: .5 * (M.x - w.x), height: .5 * (M.y - w.y) };
        s = Math.min(r / _.width, l / _.height), d = { x: -.5 * (M.x + w.x), y: -.5 * (M.y + w.y) };
    } i.borderWidth = e.getMaxBorderWidth(u.data), i.outerRadius = Math.max((s - i.borderWidth) / 2, 0), i.innerRadius = Math.max(h ? i.outerRadius / 100 * h : 0, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), i.offsetX = d.x * i.outerRadius, i.offsetY = d.y * i.outerRadius, u.total = e.calculateTotal(), e.outerRadius = i.outerRadius - i.radiusLength * e.getRingIndex(e.index), e.innerRadius = Math.max(e.outerRadius - i.radiusLength, 0), z.each(u.data, function (i, n) { e.updateElement(i, n, t); }); }, updateElement: function (t, e, i) { var n = this, a = n.chart, o = a.chartArea, r = a.options, l = r.animation, s = (o.left + o.right) / 2, d = (o.top + o.bottom) / 2, u = r.rotation, h = r.rotation, c = n.getDataset(), f = i && l.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(c.data[e]) * (r.circumference / (2 * Math.PI)), g = i && l.animateScale ? 0 : n.innerRadius, p = i && l.animateScale ? 0 : n.outerRadius, m = z.valueAtIndexOrDefault; z.extend(t, { _datasetIndex: n.index, _index: e, _model: { x: s + a.offsetX, y: d + a.offsetY, startAngle: u, endAngle: h, circumference: f, outerRadius: p, innerRadius: g, label: m(c.label, e, a.data.labels[e]) } }); var v = t._model; this.removeHoverStyle(t), i && l.animateRotate || (v.startAngle = 0 === e ? r.rotation : n.getMeta().data[e - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot(); }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc); }, calculateTotal: function () { var t, e = this.getDataset(), i = this.getMeta(), n = 0; return z.each(i.data, function (i, a) { t = e.data[a], isNaN(t) || i.hidden || (n += Math.abs(t)); }), n; }, calculateCircumference: function (t) { var e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0; }, getMaxBorderWidth: function (t) { for (var e, i, n = 0, a = this.index, o = t.length, r = 0; r < o; r++)
        e = t[r]._model ? t[r]._model.borderWidth : 0, n = (i = t[r]._chart ? t[r]._chart.config.data.datasets[a].hoverBorderWidth : 0) > (n = e > n ? e : n) ? i : n; return n; } }); }, va = Object.freeze({ default: ma, __moduleExports: ma }); E._set("line", { showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } }); var ba = function (t) { function e(t, e) { return z.valueOrDefault(t.showLine, e.showLines); } t.controllers.line = t.DatasetController.extend({ datasetElementType: ha.Line, dataElementType: ha.Point, update: function (t) { var i, n, a, o = this, r = o.getMeta(), l = r.dataset, s = r.data || [], d = o.chart.options, u = d.elements.line, h = o.getScaleForId(r.yAxisID), c = o.getDataset(), f = e(c, d); for (f && (a = l.custom || {}, void 0 !== c.tension && void 0 === c.lineTension && (c.lineTension = c.tension), l._scale = h, l._datasetIndex = o.index, l._children = s, l._model = { spanGaps: c.spanGaps ? c.spanGaps : d.spanGaps, tension: a.tension ? a.tension : z.valueOrDefault(c.lineTension, u.tension), backgroundColor: a.backgroundColor ? a.backgroundColor : c.backgroundColor || u.backgroundColor, borderWidth: a.borderWidth ? a.borderWidth : c.borderWidth || u.borderWidth, borderColor: a.borderColor ? a.borderColor : c.borderColor || u.borderColor, borderCapStyle: a.borderCapStyle ? a.borderCapStyle : c.borderCapStyle || u.borderCapStyle, borderDash: a.borderDash ? a.borderDash : c.borderDash || u.borderDash, borderDashOffset: a.borderDashOffset ? a.borderDashOffset : c.borderDashOffset || u.borderDashOffset, borderJoinStyle: a.borderJoinStyle ? a.borderJoinStyle : c.borderJoinStyle || u.borderJoinStyle, fill: a.fill ? a.fill : void 0 !== c.fill ? c.fill : u.fill, steppedLine: a.steppedLine ? a.steppedLine : z.valueOrDefault(c.steppedLine, u.stepped), cubicInterpolationMode: a.cubicInterpolationMode ? a.cubicInterpolationMode : z.valueOrDefault(c.cubicInterpolationMode, u.cubicInterpolationMode) }, l.pivot()), i = 0, n = s.length; i < n; ++i)
        o.updateElement(s[i], i, t); for (f && 0 !== l._model.tension && o.updateBezierControlPoints(), i = 0, n = s.length; i < n; ++i)
        s[i].pivot(); }, getPointBackgroundColor: function (t, e) { var i = this.chart.options.elements.point.backgroundColor, n = this.getDataset(), a = t.custom || {}; return a.backgroundColor ? i = a.backgroundColor : n.pointBackgroundColor ? i = z.valueAtIndexOrDefault(n.pointBackgroundColor, e, i) : n.backgroundColor && (i = n.backgroundColor), i; }, getPointBorderColor: function (t, e) { var i = this.chart.options.elements.point.borderColor, n = this.getDataset(), a = t.custom || {}; return a.borderColor ? i = a.borderColor : n.pointBorderColor ? i = z.valueAtIndexOrDefault(n.pointBorderColor, e, i) : n.borderColor && (i = n.borderColor), i; }, getPointBorderWidth: function (t, e) { var i = this.chart.options.elements.point.borderWidth, n = this.getDataset(), a = t.custom || {}; return isNaN(a.borderWidth) ? !isNaN(n.pointBorderWidth) || z.isArray(n.pointBorderWidth) ? i = z.valueAtIndexOrDefault(n.pointBorderWidth, e, i) : isNaN(n.borderWidth) || (i = n.borderWidth) : i = a.borderWidth, i; }, updateElement: function (t, e, i) { var n, a, o = this, r = o.getMeta(), l = t.custom || {}, s = o.getDataset(), d = o.index, u = s.data[e], h = o.getScaleForId(r.yAxisID), c = o.getScaleForId(r.xAxisID), f = o.chart.options.elements.point; void 0 !== s.radius && void 0 === s.pointRadius && (s.pointRadius = s.radius), void 0 !== s.hitRadius && void 0 === s.pointHitRadius && (s.pointHitRadius = s.hitRadius), n = c.getPixelForValue("object" == typeof u ? u : NaN, e, d), a = i ? h.getBasePixel() : o.calculatePointY(u, e, d), t._xScale = c, t._yScale = h, t._datasetIndex = d, t._index = e, t._model = { x: n, y: a, skip: l.skip || isNaN(n) || isNaN(a), radius: l.radius || z.valueAtIndexOrDefault(s.pointRadius, e, f.radius), pointStyle: l.pointStyle || z.valueAtIndexOrDefault(s.pointStyle, e, f.pointStyle), backgroundColor: o.getPointBackgroundColor(t, e), borderColor: o.getPointBorderColor(t, e), borderWidth: o.getPointBorderWidth(t, e), tension: r.dataset._model ? r.dataset._model.tension : 0, steppedLine: !!r.dataset._model && r.dataset._model.steppedLine, hitRadius: l.hitRadius || z.valueAtIndexOrDefault(s.pointHitRadius, e, f.hitRadius) }; }, calculatePointY: function (t, e, i) { var n, a, o, r = this.chart, l = this.getMeta(), s = this.getScaleForId(l.yAxisID), d = 0, u = 0; if (s.options.stacked) {
        for (n = 0; n < i; n++)
            if (a = r.data.datasets[n], "line" === (o = r.getDatasetMeta(n)).type && o.yAxisID === s.id && r.isDatasetVisible(n)) {
                var h = Number(s.getRightValue(a.data[e]));
                h < 0 ? u += h || 0 : d += h || 0;
            }
        var c = Number(s.getRightValue(t));
        return c < 0 ? s.getPixelForValue(u + c) : s.getPixelForValue(d + c);
    } return s.getPixelForValue(t); }, updateBezierControlPoints: function () { var t, e, i, n, a = this.getMeta(), o = this.chart.chartArea, r = a.data || []; function l(t, e, i) { return Math.max(Math.min(t, i), e); } if (a.dataset._model.spanGaps && (r = r.filter(function (t) { return !t._model.skip; })), "monotone" === a.dataset._model.cubicInterpolationMode)
        z.splineCurveMonotone(r);
    else
        for (t = 0, e = r.length; t < e; ++t)
            i = r[t]._model, n = z.splineCurve(z.previousItem(r, t)._model, i, z.nextItem(r, t)._model, a.dataset._model.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y; if (this.chart.options.elements.line.capBezierPoints)
        for (t = 0, e = r.length; t < e; ++t)
            (i = r[t]._model).controlPointPreviousX = l(i.controlPointPreviousX, o.left, o.right), i.controlPointPreviousY = l(i.controlPointPreviousY, o.top, o.bottom), i.controlPointNextX = l(i.controlPointNextX, o.left, o.right), i.controlPointNextY = l(i.controlPointNextY, o.top, o.bottom); }, draw: function () { var t = this.chart, i = this.getMeta(), n = i.data || [], a = t.chartArea, o = n.length, r = 0; for (z.canvas.clipArea(t.ctx, a), e(this.getDataset(), t.options) && i.dataset.draw(), z.canvas.unclipArea(t.ctx); r < o; ++r)
        n[r].draw(a); }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; a.radius = n.hoverRadius || z.valueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), a.backgroundColor = n.hoverBackgroundColor || z.valueAtIndexOrDefault(e.pointHoverBackgroundColor, i, z.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor || z.valueAtIndexOrDefault(e.pointHoverBorderColor, i, z.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth || z.valueAtIndexOrDefault(e.pointHoverBorderWidth, i, a.borderWidth); }, removeHoverStyle: function (t) { var e = this, i = e.chart.data.datasets[t._datasetIndex], n = t._index, a = t.custom || {}, o = t._model; void 0 !== i.radius && void 0 === i.pointRadius && (i.pointRadius = i.radius), o.radius = a.radius || z.valueAtIndexOrDefault(i.pointRadius, n, e.chart.options.elements.point.radius), o.backgroundColor = e.getPointBackgroundColor(t, n), o.borderColor = e.getPointBorderColor(t, n), o.borderWidth = e.getPointBorderWidth(t, n); } }); }, xa = Object.freeze({ default: ba, __moduleExports: ba }); E._set("polarArea", { scale: { type: "radialLinear", angleLines: { display: !1 }, gridLines: { circular: !0 }, pointLabels: { display: !1 }, ticks: { beginAtZero: !0 } }, animation: { animateRotate: !0, animateScale: !0 }, startAngle: -.5 * Math.PI, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, a = i.labels; if (n.length)
        for (var o = 0; o < n[0].data.length; ++o)
            e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>"); return e.push("</ul>"), e.join(""); }, legend: { labels: { generateLabels: function (t) { var e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) { var a = t.getDatasetMeta(0), o = e.datasets[0], r = a.data[n].custom || {}, l = z.valueAtIndexOrDefault, s = t.options.elements.arc; return { text: i, fillStyle: r.backgroundColor ? r.backgroundColor : l(o.backgroundColor, n, s.backgroundColor), strokeStyle: r.borderColor ? r.borderColor : l(o.borderColor, n, s.borderColor), lineWidth: r.borderWidth ? r.borderWidth : l(o.borderWidth, n, s.borderWidth), hidden: isNaN(o.data[n]) || a.data[n].hidden, index: n }; }) : []; } }, onClick: function (t, e) { var i, n, a, o = e.index, r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)
            (a = r.getDatasetMeta(i)).data[o].hidden = !a.data[o].hidden; r.update(); } }, tooltips: { callbacks: { title: function () { return ""; }, label: function (t, e) { return e.labels[t.index] + ": " + t.yLabel; } } } }); var ya = function (t) { t.controllers.polarArea = t.DatasetController.extend({ dataElementType: ha.Arc, linkScales: z.noop, update: function (t) { var e = this, i = e.chart, n = i.chartArea, a = e.getMeta(), o = i.options, r = o.elements.arc, l = Math.min(n.right - n.left, n.bottom - n.top); i.outerRadius = Math.max((l - r.borderWidth / 2) / 2, 0), i.innerRadius = Math.max(o.cutoutPercentage ? i.outerRadius / 100 * o.cutoutPercentage : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), e.outerRadius = i.outerRadius - i.radiusLength * e.index, e.innerRadius = e.outerRadius - i.radiusLength, a.count = e.countVisibleElements(), z.each(a.data, function (i, n) { e.updateElement(i, n, t); }); }, updateElement: function (t, e, i) { for (var n = this, a = n.chart, o = n.getDataset(), r = a.options, l = r.animation, s = a.scale, d = a.data.labels, u = n.calculateCircumference(o.data[e]), h = s.xCenter, c = s.yCenter, f = 0, g = n.getMeta(), p = 0; p < e; ++p)
        isNaN(o.data[p]) || g.data[p].hidden || ++f; var m = r.startAngle, v = t.hidden ? 0 : s.getDistanceFromCenterForValue(o.data[e]), b = m + u * f, x = b + (t.hidden ? 0 : u), y = l.animateScale ? 0 : s.getDistanceFromCenterForValue(o.data[e]); z.extend(t, { _datasetIndex: n.index, _index: e, _scale: s, _model: { x: h, y: c, innerRadius: 0, outerRadius: i ? y : v, startAngle: i && l.animateRotate ? m : b, endAngle: i && l.animateRotate ? m : x, label: z.valueAtIndexOrDefault(d, e, d[e]) } }), n.removeHoverStyle(t), t.pivot(); }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc); }, countVisibleElements: function () { var t = this.getDataset(), e = this.getMeta(), i = 0; return z.each(e.data, function (e, n) { isNaN(t.data[n]) || e.hidden || i++; }), i; }, calculateCircumference: function (t) { var e = this.getMeta().count; return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0; } }); }, ka = Object.freeze({ default: ya, __moduleExports: ya }); E._set("radar", { scale: { type: "radialLinear" }, elements: { line: { tension: 0 } } }); var wa = function (t) { t.controllers.radar = t.DatasetController.extend({ datasetElementType: ha.Line, dataElementType: ha.Point, linkScales: z.noop, update: function (t) { var e = this, i = e.getMeta(), n = i.dataset, a = i.data, o = n.custom || {}, r = e.getDataset(), l = e.chart.options.elements.line, s = e.chart.scale; void 0 !== r.tension && void 0 === r.lineTension && (r.lineTension = r.tension), z.extend(i.dataset, { _datasetIndex: e.index, _scale: s, _children: a, _loop: !0, _model: { tension: o.tension ? o.tension : z.valueOrDefault(r.lineTension, l.tension), backgroundColor: o.backgroundColor ? o.backgroundColor : r.backgroundColor || l.backgroundColor, borderWidth: o.borderWidth ? o.borderWidth : r.borderWidth || l.borderWidth, borderColor: o.borderColor ? o.borderColor : r.borderColor || l.borderColor, fill: o.fill ? o.fill : void 0 !== r.fill ? r.fill : l.fill, borderCapStyle: o.borderCapStyle ? o.borderCapStyle : r.borderCapStyle || l.borderCapStyle, borderDash: o.borderDash ? o.borderDash : r.borderDash || l.borderDash, borderDashOffset: o.borderDashOffset ? o.borderDashOffset : r.borderDashOffset || l.borderDashOffset, borderJoinStyle: o.borderJoinStyle ? o.borderJoinStyle : r.borderJoinStyle || l.borderJoinStyle } }), i.dataset.pivot(), z.each(a, function (i, n) { e.updateElement(i, n, t); }, e), e.updateBezierControlPoints(); }, updateElement: function (t, e, i) { var n = this, a = t.custom || {}, o = n.getDataset(), r = n.chart.scale, l = n.chart.options.elements.point, s = r.getPointPositionForValue(e, o.data[e]); void 0 !== o.radius && void 0 === o.pointRadius && (o.pointRadius = o.radius), void 0 !== o.hitRadius && void 0 === o.pointHitRadius && (o.pointHitRadius = o.hitRadius), z.extend(t, { _datasetIndex: n.index, _index: e, _scale: r, _model: { x: i ? r.xCenter : s.x, y: i ? r.yCenter : s.y, tension: a.tension ? a.tension : z.valueOrDefault(o.lineTension, n.chart.options.elements.line.tension), radius: a.radius ? a.radius : z.valueAtIndexOrDefault(o.pointRadius, e, l.radius), backgroundColor: a.backgroundColor ? a.backgroundColor : z.valueAtIndexOrDefault(o.pointBackgroundColor, e, l.backgroundColor), borderColor: a.borderColor ? a.borderColor : z.valueAtIndexOrDefault(o.pointBorderColor, e, l.borderColor), borderWidth: a.borderWidth ? a.borderWidth : z.valueAtIndexOrDefault(o.pointBorderWidth, e, l.borderWidth), pointStyle: a.pointStyle ? a.pointStyle : z.valueAtIndexOrDefault(o.pointStyle, e, l.pointStyle), hitRadius: a.hitRadius ? a.hitRadius : z.valueAtIndexOrDefault(o.pointHitRadius, e, l.hitRadius) } }), t._model.skip = a.skip ? a.skip : isNaN(t._model.x) || isNaN(t._model.y); }, updateBezierControlPoints: function () { var t = this.chart.chartArea, e = this.getMeta(); z.each(e.data, function (i, n) { var a = i._model, o = z.splineCurve(z.previousItem(e.data, n, !0)._model, a, z.nextItem(e.data, n, !0)._model, a.tension); a.controlPointPreviousX = Math.max(Math.min(o.previous.x, t.right), t.left), a.controlPointPreviousY = Math.max(Math.min(o.previous.y, t.bottom), t.top), a.controlPointNextX = Math.max(Math.min(o.next.x, t.right), t.left), a.controlPointNextY = Math.max(Math.min(o.next.y, t.bottom), t.top), i.pivot(); }); }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, a = t._model; a.radius = i.hoverRadius ? i.hoverRadius : z.valueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), a.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : z.valueAtIndexOrDefault(e.pointHoverBackgroundColor, n, z.getHoverColor(a.backgroundColor)), a.borderColor = i.hoverBorderColor ? i.hoverBorderColor : z.valueAtIndexOrDefault(e.pointHoverBorderColor, n, z.getHoverColor(a.borderColor)), a.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : z.valueAtIndexOrDefault(e.pointHoverBorderWidth, n, a.borderWidth); }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, a = t._model, o = this.chart.options.elements.point; a.radius = i.radius ? i.radius : z.valueAtIndexOrDefault(e.pointRadius, n, o.radius), a.backgroundColor = i.backgroundColor ? i.backgroundColor : z.valueAtIndexOrDefault(e.pointBackgroundColor, n, o.backgroundColor), a.borderColor = i.borderColor ? i.borderColor : z.valueAtIndexOrDefault(e.pointBorderColor, n, o.borderColor), a.borderWidth = i.borderWidth ? i.borderWidth : z.valueAtIndexOrDefault(e.pointBorderWidth, n, o.borderWidth); } }); }, Ma = Object.freeze({ default: wa, __moduleExports: wa }); E._set("scatter", { hover: { mode: "single" }, scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] }, showLines: !1, tooltips: { callbacks: { title: function () { return ""; }, label: function (t) { return "(" + t.xLabel + ", " + t.yLabel + ")"; } } } }); var _a = function (t) { t.controllers.scatter = t.controllers.line; }, Sa = Object.freeze({ default: _a, __moduleExports: _a }), Ca = function (t) { t.Bar = function (e, i) { return i.type = "bar", new t(e, i); }; }, Da = Object.freeze({ default: Ca, __moduleExports: Ca }), Ia = function (t) { t.Bubble = function (e, i) { return i.type = "bubble", new t(e, i); }; }, Aa = Object.freeze({ default: Ia, __moduleExports: Ia }), Pa = function (t) { t.Doughnut = function (e, i) { return i.type = "doughnut", new t(e, i); }; }, Oa = Object.freeze({ default: Pa, __moduleExports: Pa }), Ta = function (t) { t.Line = function (e, i) { return i.type = "line", new t(e, i); }; }, Fa = Object.freeze({ default: Ta, __moduleExports: Ta }), za = function (t) { t.PolarArea = function (e, i) { return i.type = "polarArea", new t(e, i); }; }, Ra = Object.freeze({ default: za, __moduleExports: za }), La = function (t) { t.Radar = function (e, i) { return i.type = "radar", new t(e, i); }; }, Ba = Object.freeze({ default: La, __moduleExports: La }), Ea = function (t) { t.Scatter = function (e, i) { return i.type = "scatter", new t(e, i); }; }, Wa = Object.freeze({ default: Ea, __moduleExports: Ea }); E._set("global", { plugins: { filler: { propagate: !0 } } }); var Na = { dataset: function (t) { var e = t.fill, i = t.chart, n = i.getDatasetMeta(e), a = n && i.isDatasetVisible(e) && n.dataset._children || [], o = a.length || 0; return o ? function (t, e) { return e < o && a[e]._view || null; } : null; }, boundary: function (t) { var e = t.boundary, i = e ? e.x : null, n = e ? e.y : null; return function (t) { return { x: null === i ? t.x : i, y: null === n ? t.y : n }; }; } }; function Va(t, e, i) { var n, a = t._model || {}, o = a.fill; if (void 0 === o && (o = !!a.backgroundColor), !1 === o || null === o)
    return !1; if (!0 === o)
    return "origin"; if (n = parseFloat(o, 10), isFinite(n) && Math.floor(n) === n)
    return "-" !== o[0] && "+" !== o[0] || (n = e + n), !(n === e || n < 0 || n >= i) && n; switch (o) {
    case "bottom": return "start";
    case "top": return "end";
    case "zero": return "origin";
    case "origin":
    case "start":
    case "end": return o;
    default: return !1;
} } function Ha(t) { var e, i = t.el._model || {}, n = t.el._scale || {}, a = t.fill, o = null; if (isFinite(a))
    return null; if ("start" === a ? o = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : "end" === a ? o = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? o = i.scaleZero : n.getBasePosition ? o = n.getBasePosition() : n.getBasePixel && (o = n.getBasePixel()), void 0 !== o && null !== o) {
    if (void 0 !== o.x && void 0 !== o.y)
        return o;
    if ("number" == typeof o && isFinite(o))
        return { x: (e = n.isHorizontal()) ? o : null, y: e ? null : o };
} return null; } function ja(t, e, i) { var n, a = t[e].fill, o = [e]; if (!i)
    return a; for (; !1 !== a && -1 === o.indexOf(a);) {
    if (!isFinite(a))
        return a;
    if (!(n = t[a]))
        return !1;
    if (n.visible)
        return a;
    o.push(a), a = n.fill;
} return !1; } function qa(t) { var e = t.fill, i = "dataset"; return !1 === e ? null : (isFinite(e) || (i = "boundary"), Na[i](t)); } function Ya(t) { return t && !t.skip; } function Ua(t, e, i, n, a) { var o; if (n && a) {
    for (t.moveTo(e[0].x, e[0].y), o = 1; o < n; ++o)
        z.canvas.lineTo(t, e[o - 1], e[o]);
    for (t.lineTo(i[a - 1].x, i[a - 1].y), o = a - 1; o > 0; --o)
        z.canvas.lineTo(t, i[o], i[o - 1], !0);
} } var Xa = { id: "filler", afterDatasetsUpdate: function (t, e) { var i, n, a, o, r = (t.data.datasets || []).length, l = e.propagate, s = []; for (n = 0; n < r; ++n)
        o = null, (a = (i = t.getDatasetMeta(n)).dataset) && a._model && a instanceof ha.Line && (o = { visible: t.isDatasetVisible(n), fill: Va(a, n, r), chart: t, el: a }), i.$filler = o, s.push(o); for (n = 0; n < r; ++n)
        (o = s[n]) && (o.fill = ja(s, n, l), o.boundary = Ha(o), o.mapper = qa(o)); }, beforeDatasetDraw: function (t, e) { var i = e.meta.$filler; if (i) {
        var n = t.ctx, a = i.el, o = a._view, r = a._children || [], l = i.mapper, s = o.backgroundColor || E.global.defaultColor;
        l && s && r.length && (z.canvas.clipArea(n, t.chartArea), function (t, e, i, n, a, o) { var r, l, s, d, u, h, c, f = e.length, g = n.spanGaps, p = [], m = [], v = 0, b = 0; for (t.beginPath(), r = 0, l = f + !!o; r < l; ++r)
            u = i(d = e[s = r % f]._view, s, n), h = Ya(d), c = Ya(u), h && c ? (v = p.push(d), b = m.push(u)) : v && b && (g ? (h && p.push(d), c && m.push(u)) : (Ua(t, p, m, v, b), v = b = 0, p = [], m = [])); Ua(t, p, m, v, b), t.closePath(), t.fillStyle = a, t.fill(); }(n, r, l, o, s, a._loop), z.canvas.unclipArea(n));
    } } }, Ka = Xa.id, Ga = Xa.afterDatasetsUpdate, Ja = Xa.beforeDatasetDraw, Za = Object.freeze({ default: Xa, __moduleExports: Xa, id: Ka, afterDatasetsUpdate: Ga, beforeDatasetDraw: Ja }), Qa = z.noop; function $a(t, e) { return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth; } E._set("global", { legend: { display: !0, position: "top", fullWidth: !0, reverse: !1, weight: 1e3, onClick: function (t, e) { var i = e.datasetIndex, n = this.chart, a = n.getDatasetMeta(i); a.hidden = null === a.hidden ? !n.data.datasets[i].hidden : null, n.update(); }, onHover: null, labels: { boxWidth: 40, padding: 10, generateLabels: function (t) { var e = t.data; return z.isArray(e.datasets) ? e.datasets.map(function (e, i) { return { text: e.label, fillStyle: z.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: e.borderCapStyle, lineDash: e.borderDash, lineDashOffset: e.borderDashOffset, lineJoin: e.borderJoinStyle, lineWidth: e.borderWidth, strokeStyle: e.borderColor, pointStyle: e.pointStyle, datasetIndex: i }; }, this) : []; } } }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); for (var i = 0; i < t.data.datasets.length; i++)
        e.push('<li><span style="background-color:' + t.data.datasets[i].backgroundColor + '"></span>'), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>"); return e.push("</ul>"), e.join(""); } }); var to = Je.extend({ initialize: function (t) { z.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1; }, beforeUpdate: Qa, update: function (t, e, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize; }, afterUpdate: Qa, beforeSetDimensions: Qa, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; }, afterSetDimensions: Qa, beforeBuildLabels: Qa, buildLabels: function () { var t = this, e = t.options.labels || {}, i = z.callback(e.generateLabels, [t.chart], t) || []; e.filter && (i = i.filter(function (i) { return e.filter(i, t.chart.data); })), t.options.reverse && i.reverse(), t.legendItems = i; }, afterBuildLabels: Qa, beforeFit: Qa, fit: function () { var t = this, e = t.options, i = e.labels, n = e.display, a = t.ctx, o = E.global, r = z.valueOrDefault, l = r(i.fontSize, o.defaultFontSize), s = r(i.fontStyle, o.defaultFontStyle), d = r(i.fontFamily, o.defaultFontFamily), u = z.fontString(l, s, d), h = t.legendHitBoxes = [], c = t.minSize, f = t.isHorizontal(); if (f ? (c.width = t.maxWidth, c.height = n ? 10 : 0) : (c.width = n ? 10 : 0, c.height = t.maxHeight), n)
        if (a.font = u, f) {
            var g = t.lineWidths = [0], p = t.legendItems.length ? l + i.padding : 0;
            a.textAlign = "left", a.textBaseline = "top", z.each(t.legendItems, function (e, n) { var o = $a(i, l) + l / 2 + a.measureText(e.text).width; g[g.length - 1] + o + i.padding >= t.width && (p += l + i.padding, g[g.length] = t.left), h[n] = { left: 0, top: 0, width: o, height: l }, g[g.length - 1] += o + i.padding; }), c.height += p;
        }
        else {
            var m = i.padding, v = t.columnWidths = [], b = i.padding, x = 0, y = 0, k = l + m;
            z.each(t.legendItems, function (t, e) { var n = $a(i, l) + l / 2 + a.measureText(t.text).width; y + k > c.height && (b += x + i.padding, v.push(x), x = 0, y = 0), x = Math.max(x, n), y += k, h[e] = { left: 0, top: 0, width: n, height: l }; }), b += x, v.push(x), c.width += b;
        } t.width = c.width, t.height = c.height; }, afterFit: Qa, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position; }, draw: function () { var t = this, e = t.options, i = e.labels, n = E.global, a = n.elements.line, o = t.width, r = t.lineWidths; if (e.display) {
        var l, s = t.ctx, d = z.valueOrDefault, u = d(i.fontColor, n.defaultFontColor), h = d(i.fontSize, n.defaultFontSize), c = d(i.fontStyle, n.defaultFontStyle), f = d(i.fontFamily, n.defaultFontFamily), g = z.fontString(h, c, f);
        s.textAlign = "left", s.textBaseline = "middle", s.lineWidth = .5, s.strokeStyle = u, s.fillStyle = u, s.font = g;
        var p = $a(i, h), m = t.legendHitBoxes, v = t.isHorizontal();
        l = v ? { x: t.left + (o - r[0]) / 2, y: t.top + i.padding, line: 0 } : { x: t.left + i.padding, y: t.top + i.padding, line: 0 };
        var b = h + i.padding;
        z.each(t.legendItems, function (u, c) { var f = s.measureText(u.text).width, g = p + h / 2 + f, x = l.x, y = l.y; v ? x + g >= o && (y = l.y += b, l.line++, x = l.x = t.left + (o - r[l.line]) / 2) : y + b > t.bottom && (x = l.x = x + t.columnWidths[l.line] + i.padding, y = l.y = t.top + i.padding, l.line++), function (t, i, o) { if (!(isNaN(p) || p <= 0)) {
            s.save(), s.fillStyle = d(o.fillStyle, n.defaultColor), s.lineCap = d(o.lineCap, a.borderCapStyle), s.lineDashOffset = d(o.lineDashOffset, a.borderDashOffset), s.lineJoin = d(o.lineJoin, a.borderJoinStyle), s.lineWidth = d(o.lineWidth, a.borderWidth), s.strokeStyle = d(o.strokeStyle, n.defaultColor);
            var r = 0 === d(o.lineWidth, a.borderWidth);
            if (s.setLineDash && s.setLineDash(d(o.lineDash, a.borderDash)), e.labels && e.labels.usePointStyle) {
                var l = h * Math.SQRT2 / 2, u = l / Math.SQRT2, c = t + u, f = i + u;
                z.canvas.drawPoint(s, o.pointStyle, l, c, f);
            }
            else
                r || s.strokeRect(t, i, p, h), s.fillRect(t, i, p, h);
            s.restore();
        } }(x, y, u), m[c].left = x, m[c].top = y, function (t, e, i, n) { var a = h / 2, o = p + a + t, r = e + a; s.fillText(i.text, o, r), i.hidden && (s.beginPath(), s.lineWidth = 2, s.moveTo(o, r), s.lineTo(o + n, r), s.stroke()); }(x, y, u, f), v ? l.x += g + i.padding : l.y += b; });
    } }, handleEvent: function (t) { var e = this, i = e.options, n = "mouseup" === t.type ? "click" : t.type, a = !1; if ("mousemove" === n) {
        if (!i.onHover)
            return;
    }
    else {
        if ("click" !== n)
            return;
        if (!i.onClick)
            return;
    } var o = t.x, r = t.y; if (o >= e.left && o <= e.right && r >= e.top && r <= e.bottom)
        for (var l = e.legendHitBoxes, s = 0; s < l.length; ++s) {
            var d = l[s];
            if (o >= d.left && o <= d.left + d.width && r >= d.top && r <= d.top + d.height) {
                if ("click" === n) {
                    i.onClick.call(e, t.native, e.legendItems[s]), a = !0;
                    break;
                }
                if ("mousemove" === n) {
                    i.onHover.call(e, t.native, e.legendItems[s]), a = !0;
                    break;
                }
            }
        } return a; } }); function eo(t, e) { var i = new to({ ctx: t.ctx, options: e, chart: t }); Cn.configure(t, i, e), Cn.addBox(t, i), t.legend = i; } var io = { id: "legend", _element: to, beforeInit: function (t) { var e = t.options.legend; e && eo(t, e); }, beforeUpdate: function (t) { var e = t.options.legend, i = t.legend; e ? (z.mergeIf(e, E.global.legend), i ? (Cn.configure(t, i, e), i.options = e) : eo(t, e)) : i && (Cn.removeBox(t, i), delete t.legend); }, afterEvent: function (t, e) { var i = t.legend; i && i.handleEvent(e); } }, no = io.id, ao = io._element, oo = io.beforeInit, ro = io.beforeUpdate, lo = io.afterEvent, so = Object.freeze({ default: io, __moduleExports: io, id: no, _element: ao, beforeInit: oo, beforeUpdate: ro, afterEvent: lo }), uo = z.noop; E._set("global", { title: { display: !1, fontStyle: "bold", fullWidth: !0, lineHeight: 1.2, padding: 10, position: "top", text: "", weight: 2e3 } }); var ho = Je.extend({ initialize: function (t) { z.extend(this, t), this.legendHitBoxes = []; }, beforeUpdate: uo, update: function (t, e, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize; }, afterUpdate: uo, beforeSetDimensions: uo, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; }, afterSetDimensions: uo, beforeBuildLabels: uo, buildLabels: uo, afterBuildLabels: uo, beforeFit: uo, fit: function () { var t = this, e = z.valueOrDefault, i = t.options, n = i.display, a = e(i.fontSize, E.global.defaultFontSize), o = t.minSize, r = z.isArray(i.text) ? i.text.length : 1, l = z.options.toLineHeight(i.lineHeight, a), s = n ? r * l + 2 * i.padding : 0; t.isHorizontal() ? (o.width = t.maxWidth, o.height = s) : (o.width = s, o.height = t.maxHeight), t.width = o.width, t.height = o.height; }, afterFit: uo, isHorizontal: function () { var t = this.options.position; return "top" === t || "bottom" === t; }, draw: function () { var t = this, e = t.ctx, i = z.valueOrDefault, n = t.options, a = E.global; if (n.display) {
        var o, r, l, s = i(n.fontSize, a.defaultFontSize), d = i(n.fontStyle, a.defaultFontStyle), u = i(n.fontFamily, a.defaultFontFamily), h = z.fontString(s, d, u), c = z.options.toLineHeight(n.lineHeight, s), f = c / 2 + n.padding, g = 0, p = t.top, m = t.left, v = t.bottom, b = t.right;
        e.fillStyle = i(n.fontColor, a.defaultFontColor), e.font = h, t.isHorizontal() ? (r = m + (b - m) / 2, l = p + f, o = b - m) : (r = "left" === n.position ? m + f : b - f, l = p + (v - p) / 2, o = v - p, g = Math.PI * ("left" === n.position ? -.5 : .5)), e.save(), e.translate(r, l), e.rotate(g), e.textAlign = "center", e.textBaseline = "middle";
        var x = n.text;
        if (z.isArray(x))
            for (var y = 0, k = 0; k < x.length; ++k)
                e.fillText(x[k], 0, y, o), y += c;
        else
            e.fillText(x, 0, 0, o);
        e.restore();
    } } }); function co(t, e) { var i = new ho({ ctx: t.ctx, options: e, chart: t }); Cn.configure(t, i, e), Cn.addBox(t, i), t.titleBlock = i; } var fo = { id: "title", _element: ho, beforeInit: function (t) { var e = t.options.title; e && co(t, e); }, beforeUpdate: function (t) { var e = t.options.title, i = t.titleBlock; e ? (z.mergeIf(e, E.global.title), i ? (Cn.configure(t, i, e), i.options = e) : co(t, e)) : i && (Cn.removeBox(t, i), delete t.titleBlock); } }, go = fo.id, po = fo._element, mo = fo.beforeInit, vo = fo.beforeUpdate, bo = Object.freeze({ default: fo, __moduleExports: fo, id: go, _element: po, beforeInit: mo, beforeUpdate: vo }), xo = {}, yo = Za && Xa || Za, ko = so && io || so, wo = bo && fo || bo; xo.filler = yo, xo.legend = ko, xo.title = wo; var Mo = Object.freeze({ default: xo, __moduleExports: xo, filler: yo, legend: ko, title: wo }), _o = Ue && Ye || Ue, So = _n && Mn || _n, Co = Pn && An || Pn, Do = Tn && On || Tn, Io = zn && Fn || zn, Ao = Wn && En || Wn, Po = Vn && Nn || Vn, Oo = jn && Hn || jn, To = Yn && qn || Yn, Fo = Xn && Un || Xn, zo = Gn && Kn || Gn, Ro = Zn && Jn || Zn, Lo = ua && da || ua, Bo = fa && ca || fa, Eo = pa && ga || pa, Wo = va && ma || va, No = xa && ba || xa, Vo = ka && ya || ka, Ho = Ma && wa || Ma, jo = Sa && _a || Sa, qo = Da && Ca || Da, Yo = Aa && Ia || Aa, Uo = Oa && Pa || Oa, Xo = Fa && Ta || Fa, Ko = Ra && za || Ra, Go = Ba && La || Ba, Jo = Wa && Ea || Wa, Zo = Mo && xo || Mo, Qo = (N && W || N)(); for (var $o in Qo.helpers = z, _o(Qo), Qo.defaults = E, Qo.Element = Je, Qo.elements = ha, Qo.Interaction = Sn, Qo.layouts = Cn, Qo.platform = Dn, Qo.plugins = In, Qo.Ticks = Rn, So(Qo), Co(Qo), Do(Qo), Io(Qo), Ao(Qo), Po(Qo), Oo(Qo), To(Qo), Fo(Qo), zo(Qo), Ro(Qo), Lo(Qo), Bo(Qo), Eo(Qo), Wo(Qo), No(Qo), Vo(Qo), Ho(Qo), jo(Qo), qo(Qo), Yo(Qo), Uo(Qo), Xo(Qo), Ko(Qo), Go(Qo), Jo(Qo), Zo)
    Zo.hasOwnProperty($o) && Qo.plugins.register(Zo[$o]); Qo.platform.initialize(); var tr = Qo; "undefined" != typeof window && (window.Chart = Qo), Qo.Legend = Zo.legend._element, Qo.Title = Zo.title._element, Qo.pluginService = Qo.plugins, Qo.PluginBase = Qo.Element.extend({}), Qo.canvasHelpers = Qo.helpers.canvas, Qo.layoutService = Qo.layouts, t.Chart = tr, t.commonjsGlobal = c, t.createCommonjsModule = f; });
