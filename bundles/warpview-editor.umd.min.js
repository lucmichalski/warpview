!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("monaco-editor"),require("@angular/core"),require("@angular/common/http"),require("rxjs/operators"),require("rxjs"),require("bignumber.js"),require("@angular/common"),require("@angular/forms"),require("@angular/platform-browser")):"function"==typeof define&&define.amd?define("warpview-editor",["exports","monaco-editor","@angular/core","@angular/common/http","rxjs/operators","rxjs","bignumber.js","@angular/common","@angular/forms","@angular/platform-browser"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["warpview-editor"]={},e["monaco-editor"],e.ng.core,e.ng.common.http,e.rxjs.operators,e.rxjs,e.bignumber.js,e.ng.common,e.ng.forms,e.ng.platformBrowser)}(this,(function(e,t,n,a,i,o,s,r,l,c){"use strict";function p(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var u=p(s),h=function(){function e(){}return e.mergeDeep=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];for(var a={},i=!0,o=0;o<t.length;o++){var s=t[o];e.merge(s,a,i)}return a},e.merge=function(t,n,a){for(var i in t)t.hasOwnProperty(i)&&(a&&"[object Object]"===Object.prototype.toString.call(t[i])?n[i]=e.mergeDeep(n[i],t[i]):n[i]=t[i])},e.toArray=function(e){var t=[];return Object.keys(e).forEach((function(n){return t.push(e[n])})),t},e}(),m=function(){this.buttons={class:""},this.execButton={class:"",label:"Execute"},this.datavizButton={class:"",label:"Visualize"},this.hover=!0,this.readOnly=!1,this.messageClass="",this.errorClass="",this.editor={quickSuggestionsDelay:10,quickSuggestions:!0,tabSize:2,minLineNumber:10,enableDebug:!1,rawResultsReadOnly:!0}},d=function(e,t){return(d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function T(e,t){function n(){this.constructor=e}d(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}Object.create;function f(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var a,i,o=n.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(a=o.next()).done;)s.push(a.value)}catch(e){i={error:e}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(i)throw i.error}}return s}function g(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(f(arguments[t]));return e}Object.create;var S,E=function(){function e(e,t){void 0===t&&(t=!1),this.isDebug=!1,this.className=e.name,this.isDebug=t}return e.prototype.setDebug=function(e){this.isDebug=e},e.prototype.log=function(e,t,n){var a=[];switch(a.push("["+this.className+"] "+t.join(" - ")),a=a.concat(n),e){case S.DEBUG:this.isDebug&&console.debug.apply(console,g(a));break;case S.ERROR:console.error.apply(console,g(a));break;case S.INFO:console.log.apply(console,g(a));break;case S.WARN:console.warn.apply(console,g(a));break;default:this.isDebug&&console.log.apply(console,g(a))}},e.prototype.debug=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];this.log(S.DEBUG,e,t)},e.prototype.error=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];this.log(S.ERROR,e,t)},e.prototype.warn=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];this.log(S.WARN,e,t)},e.prototype.info=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];this.log(S.INFO,e,t)},e}();!function(e){e[e.DEBUG=0]="DEBUG",e[e.ERROR=1]="ERROR",e[e.WARN=2]="WARN",e[e.INFO=3]="INFO"}(S||(S={}));var O=function(){function e(){}return e.emitBubblingEvent=function(e,t,n){e.nativeElement.dispatchEvent(new CustomEvent(t,{bubbles:!0,detail:n,composed:!0}))},e}(),G=function(){function e(){}return e.parseWarpScriptStatements=function(e){for(var t=0,n=[];t<e.length-1;){if("<"===e.charAt(t)&&"'"===e.charAt(t+1)){for(var a=e.substring(t,e.length).split("\n"),i=0;i<a.length&&"'>"!==a[i].trim();)t+=a[i].length+1,i++;t+=a[i].length+1}if("/"===e.charAt(t)&&"*"===e.charAt(t+1)){for(t++;t<e.length-1&&("*"!==e.charAt(t)||"/"!==e.charAt(t+1));)t++;t+=2}if("/"===e.charAt(t)&&"/"===e.charAt(t+1))for(t++;t<e.length-1&&"\n"!==e.charAt(t);)t++;if("'"===e.charAt(t)){var o=t;for(t++;t<e.length&&"'"!==e.charAt(t)&&"\n"!==e.charAt(t);)t++;t++,n.push(e.substring(o,t))}if('"'===e.charAt(t)){o=t;for(t++;t<e.length&&'"'!==e.charAt(t)&&"\n"!==e.charAt(t);)t++;t++,n.push(e.substring(o,t))}if("<"===e.charAt(t)&&"%"===e.charAt(t+1)&&(n.push("<%"),t+=2),"%"===e.charAt(t)&&">"===e.charAt(t+1)&&(n.push("%>"),t+=2)," "!==e.charAt(t)&&"\n"!==e.charAt(t)){for(o=t;t<e.length&&" "!==e.charAt(t)&&"\n"!==e.charAt(t);)t++;n.push(e.substring(o,t))}t++}return n},e.extractSpecialComments=function(e){for(var t={},n=e.split("\n"),a=0;a<n.length;a++){var i=n[a];if(i.startsWith("//"))for(var o=void 0,s=RegExp(/\/\/\s*@(\w*)\s*(.*)$/g);o=s.exec(i.replace("\r",""));){var r=o[1],l=o[2];switch(r){case"endpoint":t.endpoint=l;break;case"localmacrosubstitution":t.localMacroSubstitution="true"===l.toLowerCase();break;case"timeunit":["us","ms","ns"].indexOf(l.trim())>-1&&(t.timeUnit=l.trim());break;case"preview":switch(l.toLowerCase().substr(0,4)){case"none":t.displayPreviewOpt="X";break;case"gts":t.displayPreviewOpt="G";break;case"imag":t.displayPreviewOpt="I";break;default:t.displayPreviewOpt=""}}}else if(a>0)break}return t},e}(),b=function(){};b.reference=[{name:"!",detail:"input<BOOLEAN>  !  result<BOOLEAN>\ngtsinput<GTS>  !  gtsresult<GTS>",documentation:"Negates a boolean.\n\nThe `!` function is synonymous for [`NOT`](/doc/NOT). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nSince Warp 10™ 2.1, `!` can be applied on a boolean GTS to flip all values.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gtsinput` Since 2.1, a GTS with boolean value.\n\n@param `gtsresult` Since 2.1, a GTS with negated boolean value. GTS is not sorted by the operation. Metadata are kept.\n\n",tags:["logic","operators"],since:"1.0.0",OPB64name:"7F"},{name:"!=",detail:"p1<ANY> p2<ANY>  !=  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  !=  outgts<GTS>\nconstant<ANY> inputgts<GTS>  !=  outgts<GTS>\ngts1<GTS> gts2<GTS>  !=  outputgts<GTS>",documentation:"Tests if both parameters are different.\n\nThe `!=` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are different, false otherwise.\n\nThe two parameters must be homogeneous of numeric, boolean or string types.\n\nSince Warp 10™ 2.1, as every other comparison operators, `!=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 !=` is strictly equivalent of a `42 mapper.ne` MAP operation, with a simplified syntax.\n\n@param `p1` First parameter to compare, anything except a GTS.\n\n@param `p2` Second parameter to compare, anything except a GTS.\n\n@param `result` True if p1 and p2 are different, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values different from constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is different from gts2 value.\n\n",tags:["operators"],since:"1.0.0",OPB64name:"7Io"},{name:"%",detail:"divisor<LONG> dividend<LONG>  %  modulo<LONG>\ndivisor<DOUBLE> dividend<LONG>  %  modulo<DOUBLE>\ndivisor<LONG> dividend<DOUBLE>  %  modulo<DOUBLE>\ndivisor<DOUBLE> dividend<DOUBLE>  %  modulo<DOUBLE>\ndivisor<COUNTER> dividend<COUNTER>  %  modulo<LONG>\ndivisor<DOUBLE> dividend<COUNTER>  %  modulo<DOUBLE>\ndivisor<COUNTER> dividend<DOUBLE>  %  modulo<DOUBLE>\ndivisor<LONG> dividend<COUNTER>  %  modulo<LONG>\ndivisor<COUNTER> dividend<LONG>  %  modulo<LONG>",documentation:"The `%` operator consumes two parameters from the top of the stack and pushes back the remainder of the Euclidean division of the first one by the second one.\n\nThe two parameters must be of numeric types.\n\n@param `dividend` Number divided by divisor\n\n@param `divisor` Number used to divide dividend\n\n@param `modulo` Modulo of the two given parameters\n\n",tags:["operators"],since:"1.0.0",OPB64name:"8F"},{name:"&",detail:"p1<LONG> p2<LONG>  &  result<LONG>\ninputgts<GTS> mask<LONG>  &  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  &  outputgts<GTS>",documentation:"Performs a bitwise **AND** operation.\n\nThe `&` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **AND**.\n\nSince Warp 10™ 2.1, `&` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be AND to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with AND between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts AND with mask\n\n",tags:["binary","operators"],since:"1.0.0",OPB64name:"8V"},{name:"&&",detail:"p1<BOOLEAN> p2<BOOLEAN>  &&  result<BOOLEAN>\nl<LIST>  &&  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  &&  gtsresult<GTS>",documentation:"The `&&` operator is a synonymous for [`AND`](/doc/AND).\n\nIt performs a logical **&&** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `&&` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical && applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with && between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"8XN"},{name:"(",detail:" (  mark<MARK>",documentation:"Starts a set creation.\n\nThe `(` function creates a set by pushing a mark onto the stack. This is a syntactic help to better present set constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",tags:["sets"],since:"1.2.13",OPB64name:"9."},{name:"()",detail:"content<ANY>  ()  newset<SET>",documentation:"The `()` function creates an empty SET on the top of the stack.\nA Set is a collection that cannot contain duplicate elements.\n\nThis is an implementation of java [HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html). NULL object is permitted. It makes no guarantees as to the iteration order of the set.\n\nThe SET object could not be represented on the stack.\nIt has to be converted in a list to be displayed.\n\nStoring GTS into sets do not guarantee uniqueness. each GTS has a hidden id. see example.\n\n\n@param `content` 0 to n elements.\n\n@param `newset` set instance, initialized with content.\n\n",tags:["sets"],since:"1.2.13",OPB64name:"91Z"},{name:")",detail:"mark<MARK> v1<ANY> vN<ANY>  )  set<SET>",documentation:"Closes a currently open set and pushes it onto the stack.\n\nThe `)` function pops from the stack the elements of the set up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `set` The built set\n\n@param `mark` The mark indicating the deepest level to consider when building the set\n\n",tags:["sets"],since:"1.2.13",OPB64name:"9F"},{name:"*",detail:"p1<NUMBER> p2<NUMBER>  *  result<NUMBER>\np1<VECTOR> p2<NUMBER>  *  result<VECTOR>\np1<NUMBER> p2<VECTOR>  *  result<VECTOR>\np1<MATRIX> p2<NUMBER>  *  result<MATRIX>\np1<NUMBER> p2<MATRIX>  *  result<MATRIX>\np1<MATRIX> p2<VECTOR>  *  result<VECTOR>\np1<VECTOR> p2<MATRIX>  *  result<VECTOR>\np1<MATRIX> p2<MATRIX>  *  result<VECTOR>\np2<GTS> p1<GTS>  *  result<GTS>\np2<GTS> p1<NUMBER>  *  result<GTS>\np2<NUMBER> p1<GTS>  *  result<GTS>",documentation:"The `*` operator consumes two parameters from the top of the stack and pushes back the result of multiplying both of them.\n\nIf you want to multiply two matrices together, they have to be of the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Multiplication result\n\n",tags:["operators"],since:"1.0.0",OPB64name:"9V"},{name:"**",detail:"b<LONG> n<LONG>  **  result<LONG>\nb<DOUBLE> n<LONG>  **  result<DOUBLE>\nb<LONG> n<DOUBLE>  **  result<DOUBLE>\nb<DOUBLE> n<DOUBLE>  **  result<DOUBLE>\nb<COUNTER> n<COUNTER>  **  result<LONG>\nb<DOUBLE> n<COUNTER>  **  result<DOUBLE>\nb<COUNTER> n<DOUBLE>  **  result<DOUBLE>\nb<COUNTER> n<LONG>  **  result<LONG>\nb<LONG> n<COUNTER>  **  result<LONG>",documentation:'Returns the value of the first argument raised to the power of the second argument.\n\nThe `**` operator consumes two parameters from the top of the stack (a base **b** and an exponent **n**) and pushes back the result raising b to the power of n,\ni.e. b<sup>n</sup>. For special cases see [pow()](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#pow-double-double- "javadoc").\n\nThe two parameters must be of numeric types.\n\n@param `b` First parameter, the base\n\n@param `n` Second parameter, the exponent\n\n@param `result` The result of b<sup>n</sup>\n\n',tags:["math","operators"],since:"1.0.0",OPB64name:"9Xc"},{name:"+",detail:"param1<STRING> param2<STRING>  +  result<STRING>\nparam1<LONG> param2<LONG>  +  result<LONG>\nparam1<DOUBLE> param2<LONG>  +  result<DOUBLE>\nparam1<COUNTER> param2<LONG>  +  result<LONG>\nparam1<LONG> param2<DOUBLE>  +  result<DOUBLE>\nparam1<DOUBLE> param2<DOUBLE>  +  result<DOUBLE>\nparam1<COUNTER> param2<DOUBLE>  +  result<DOUBLE>\nparam1<COUNTER> param2<COUNTER>  +  result<LONG>\nparam1<DOUBLE> param2<COUNTER>  +  result<DOUBLE>\nparam1<LONG> param2<COUNTER>  +  result<LONG>\nparam1<LIST> param2<ANY>  +  result<LIST>\nparam1<SET> param2<ANY>  +  result<SET>\nparam1<VECTOR> param2<NUMBER>  +  result<VECTOR>\nparam1<NUMBER> param2<VECTOR>  +  result<VECTOR>\nparam1<VECTOR> param2<VECTOR>  +  result<VECTOR>\nparam1<MACRO> param2<MACRO>  +  result<MACRO>\nparam1<MATRIX> param2<NUMBER>  +  result<MATRIX>\nparam1<NUMBER> param2<MATRIX>  +  result<MATRIX>\nparam1<MATRIX> param2<MATRIX>  +  result<MATRIX>\nparam2<GTS> param1<GTS>  +  result<GTS>\nparam2<GTS> param1<DOUBLE>  +  result<GTS>\nparam2<GTS> param1<LONG>  +  result<GTS>\nparam2<GTS> param1<STRING>  +  result<GTS>\nparam2<DOUBLE> param1<GTS>  +  result<GTS>\nparam2<LONG> param1<GTS>  +  result<GTS>\nparam2<STRING> param1<GTS>  +  result<GTS>\nparam1<BYTES> param2<BYTES>  +  result<BYTES>",documentation:"The `+` operator consumes two parameters from the top of the stack and pushes back the result of adding them.\n\nThe meaning of adding depends on the type of parameter:\n\n- If both parameters are numbers, the result is the sum of both numbers.\n\n- If both parameters are strings, the result is the concatenation of both strings.\n- If both parameters are byte arrays, the result is the concatenation of both byte arrays (version 2.1+).\n\n- If the first parameter is a list, the + operator clones the list and appends the second parameter to the cloned list.\n\n- If the first parameter is a set, the + operator clones the set and appends the second parameter to the cloned set.\n\n- If both parameters are macros, the result is a macro concatenating the two others in any other case + with throw an exception.\n\n- If the first parameter is a vector, the + operator adds the second numeric parameter to each element of the vector.\n- If the second parameter is a vector, the + operator adds the first numeric parameter to each element of the vector.\n- If both parameters are vectors, the + operator adds each element of vectors which are on the same index. Vectors must be the same size.\n\n- If the first parameter is a matrix, the + operator adds the second numeric parameter to each element of the matrix.\n- If the second parameter is a matrix, the + operator adds the first numeric parameter to each element of the matrix.\n- If both parameters are matrices, the + operator adds each element of matrices which are on the same index. Matrices must be the same size.\n- If one of the parameters is a Geo Time Series™, the result will be a Geo Time Series™ of type DOUBLE.\n\n@param `param1` First parameter\n\n@param `param2` Second parameter\n\n@param `result` Result of the addition\n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"9k"},{name:"+!",detail:"input<LIST> item<ANY>  +!  output<LIST>\ninput<SET> item<ANY>  +!  output<SET>",documentation:"The +! operator adds the element on top of the stack to the set or list below it. \nThe element is added to the existing collection. \n\n\n@param `input` reference to the list or set to be modified\n\n@param `output` copy of input list or set reference.\n\n@param `item` the item to append to inputlist. Depending on list content, could be any type.\n\n",tags:["lists","operators"],since:"1.2.0",OPB64name:"9m3"},{name:"-",detail:"p1<LONG> p2<LONG>  -  result<LONG>\np1<LONG> p2<DOUBLE>  -  result<DOUBLE>\np1<DOUBLE> p2<LONG>  -  result<DOUBLE>\np1<DOUBLE> p2<DOUBLE>  -  result<DOUBLE>\np1<COUNTER> p2<COUNTER>  -  result<LONG>\np1<COUNTER> p2<DOUBLE>  -  result<DOUBLE>\np1<DOUBLE> p2<COUNTER>  -  result<DOUBLE>\np1<LONG> p2<COUNTER>  -  result<LONG>\np1<COUNTER> p2<LONG>  -  result<LONG>\np1<MATRIX> p2<MATRIX>  -  result<MATRIX>\np1<VECTOR> p2<VECTOR>  -  result<VECTOR>\np2<GTS> p1<GTS>  -  result<GTS>\np2<GTS> p1<NUMBER>  -  result<GTS>\np2<NUMBER> p1<GTS>  -  result<GTS>",documentation:"Subtracts two parameters.\n\nThe `-` operator consumes two parameters from the top of the stack and pushes back the result of subtracting the second one from the first one.\n\n- If both parameters are numbers, the result is the subtraction of both numbers.\n\n- If both parameters are vectors, the - operator subtracts each element of vectors which are on the same index. Vectors must be the same size.\n\n- If both parameters are matrices, the - operator subtracts each element of matrices which are on the same index. Matrices must be the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Subtraction result\n\n",tags:["operators"],since:"1.0.0",OPB64name:"AF"},{name:"->B64",detail:"input<STRING>  ->B64  result<STRING>\ninput<BYTES>  ->B64  result<STRING>",documentation:"Encodes the string on top of the stack in [base64](https://en.wikipedia.org/wiki/Base64).\n\n@param `input` String or byte array to encode\n\n@param `result` Base64 encoded string\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYF"},{name:"->B64URL",detail:"input<STRING>  ->B64URL  result<STRING>\nbytes<BYTES>  ->B64URL  result<STRING>",documentation:"Encodes the string on top of the stack in [base64url](https://en.wikipedia.org/wiki/Base64#Variants_summary_table).\n\n@param `input` String to encode\n\n@param `bytes` Byte array to encode\n\n@param `result` Base64url encoded string\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYGKJZk"},{name:"->BIN",detail:"input<STRING>  ->BIN  output<STRING>\ninput<BYTES>  ->BIN  output<STRING>",documentation:"The ->BIN function converts the byte array or the string on top of the stack \nto its binary representation.\n\nApplied on a string, `->BIN` replaces ` 'utf-8' ->BYTES ->BIN `\n\nIf the encoded content is not a \nvalid UTF-8 representation, the resulting string will reflect that. \n\n@param `input` Any string or byte array.\n\n@param `output` Binary representation of the input.\n\n",tags:["conversion","binary"],since:"1.0.6",OPB64name:"AIt1HJs"},{name:"->BYTES",detail:"input<STRING> charset<STRING>  ->BYTES  output<BYTES>",documentation:"->BYTES function converts a string into a bytes array given a charset\nand put the result on top of the stack.\n\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\nBytes array cannot be represented on the stack.\n\n\n@param `input` String input.\n\n@param `charset` Charset to use.\n\n@param `output` Byte array representation of input.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"AIt1LKG4Jk"},{name:"->DOUBLEBITS",detail:"number<NUMBER>  ->DOUBLEBITS  bits<LONG>\ngts<GTS>  ->DOUBLEBITS  longgts<GTS>",documentation:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",tags:["math","gts","binary"],since:"1.2.3",OPB64name:"AIt3IpK1I3K1HKGI"},{name:"->ENCODER",detail:"elements<LIST>  ->ENCODER  output<GTSENCODER>\nlgts<LIST<GTS>>  ->ENCODER  output<GTSENCODER>\nlwrappedgts<LIST<STRING>>  ->ENCODER  output<GTSENCODER>\nlrawwrappedgts<LIST<BYTES>>  ->ENCODER  output<GTSENCODER>",documentation:"The `->ENCODER` function takes a list of points and encode them in a single encoder. Each point is a list of ( timestamp, latitude, longitude, elevation, value ). Since 2.1.1, a point can also be a Geo Time Series™ or a wrapped one. In that case all the points of the Geo Time Series™ are added to the encoder.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `elements` List of list of ( timestamp, latitude, longitude, elevation, value ). See example to see which element(s) can be omitted.\n\n@param `lgts` A list of Geo Time Series™ instances.\n\n@param `lwrappedgts` A list of wrapped Geo Time Series™ instances, such as produced by [`WRAP`](/doc/WRAP).\n\n@param `lrawwrappedgts` A list of raw wrapped Geo Time Series™ instances, such as produced by [`WRAPRAW`](/doc/WRAPRAW).\n\n@param `output` Encoder\n\n",tags:["encoder","conversion"],since:"1.2.9",OPB64name:"AIt4IZCEG3KH"},{name:"->ENCODERS",detail:"encoder<GTSENCODER>  ->ENCODERS  output<MAP>\nwrappedencoder<STRING>  ->ENCODERS  output<MAP>\nrawwrappedencoder<BYTES>  ->ENCODERS  output<MAP>",documentation:"The `->ENCODERS` function converts an encoder into one encoder per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content, when a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder.\n\n",tags:["gts","encoder","conversion"],since:"2.1.0",OPB64name:"AIt4IZCEG3KHJk"},{name:"->FLOATBITS",detail:"input<NUMBER>  ->FLOATBITS  result<LONG>",documentation:"Converts a numeric value to a **FLOAT** then to a **LONG** value of the raw bits of its representation.\n\nOnly the lower 32 bits of the **LONG** value are significant.\n\n@param `input` Double to convert\n\n@param `result` Raw bits representation\n\n",tags:["math","binary"],since:"1.2.3",OPB64name:"AIt5I3x0K388K4B"},{name:"->GEOCELL",detail:"hhPrefixS<STRING>  ->GEOCELL  geocell<LONG>\nhhPrefixB<BYTES>  ->GEOCELL  geocell<LONG>",documentation:"The `->GEOCELL` function converts a **STRING** or a **BYTES** HHCode prefix to a **LONG** geocell. The length of the input implicitly specifies the resolution of the cell.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `hhPrefixS` A HHCode prefix representing a cell. Resolution is twice the length of the **STRING**.\n\n@param `hhPrefixB` A HHCode prefix representing a cell. Resolution is four times the length of the **BYTES**.\n\n@param `geocell` The geocell representation.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJx2GJlB"},{name:"->GEOHASH",detail:"lat<DOUBLE> lon<DOUBLE>  ->GEOHASH  geohash<STRING>\nhhcode<LONG>  ->GEOHASH  geohash<STRING>\nshape<GEOSHAPE>  ->GEOHASH  geohashes<LIST<STRING>>",documentation:"The `->GEOHASH` function packs a latitude and a longitude into a STRING [Geohash](https://en.wikipedia.org/wiki/Geohash), converts a [HHCode](https://en.wikipedia.org/wiki/HHCode) into its Geohash counterpart, or converts a `GEOSHAPE` into a list of Geohashes covering the same geographical area.\n\n@param `lat` Latitude to pack.\n\n@param `lon` Longitude to pack.\n\n@param `geohash` Geohash string packing the specified latitude and longitude.\n\n@param `hhcode` HHCode to transform.\n\n@param `shape` `GEOSHAPE` to convert.\n\n@param `geohashes` List of Geohashes covering the same area as `shape`.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"AIt6GJx7FKC7"},{name:"->GEOJSON",detail:"shape<GEOSHAPE>  ->GEOJSON  geojson<STRING>\nshape<GEOSHAPE> allCells<BOOLEAN>  ->GEOJSON  geojson<STRING>\nwkt<STRING>  ->GEOJSON  geojson<STRING>\nwkb<BYTES>  ->GEOJSON  geojson<STRING>",documentation:"The `->GEOJSON` function translate the given GeoShape into a GeoJSON.\n\nThe resulting GeoJSON is a string representing a MultiPolygon geometry. By default, it defines the boundaries of the covered areas and any holes it these areas, if any.\n\nIt is also possible for this function to return a GeoJSON representing all the cells in the GeoShape.\n\n GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` The resulting GeoJSON.\n\n@param `wkt` A WKT string\n\n@param `wkb` WKB bytes\n\n",tags:["geo"],since:"2.4.1",OPB64name:"AIt6GJx9JoxD"},{name:"->GEOSHAPE",detail:"geocells<LIST<LONG>>  ->GEOSHAPE  geoshape<GEOSHAPE>\nhhPrefixesS<LIST<STRING>>  ->GEOSHAPE  geoshape<GEOSHAPE>\nhhPrefixesB<LIST<BYTES>>  ->GEOSHAPE  geoshape<GEOSHAPE>",documentation:"The `->GEOSHAPE` function converts a list of **LONG** geocells or HHCode prefixes (**STRING** or **BYTES**) to a **GEOSHAPE**.\n\n@param `geocells` List of geocells, as **LONGs**.\n\n@param `hhPrefixesS` List of HHCode prefixes, as **STRINGs**.\n\n@param `hhPrefixesB` List of HHCode prefixes, as **BYTESs**.\n\n@param `geoshape` The resulting **GEOSHAPE**.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJxIH34FGF"},{name:"->GTS",detail:"encoder<GTSENCODER>  ->GTS  output<MAP>\nwrappedencoder<STRING>  ->GTS  output<MAP>\nrawwrappedencoder<BYTES>  ->GTS  output<MAP>\nlencoder<LIST<GTSENCODER>>  ->GTS  loutput<MAP>\nlwrappedencoder<LIST<STRING>>  ->GTS  loutput<MAP>\nlrawwrappedencoder<LIST<BYTES>>  ->GTS  loutput<MAP>\nencoder<GTSENCODER> conversionmap<MAP>  ->GTS  conversionoutput<GTS>\nwrappedencoder<STRING> conversionmap<MAP>  ->GTS  conversionoutput<GTS>\nrawwrappedencoder<BYTES> conversionmap<MAP>  ->GTS  conversionoutput<GTS>\nlencoder<LIST<GTSENCODER>> conversionmap<MAP>  ->GTS  conversionoutput<LIST<GTS>>\nlwrappedencoder<LIST<STRING>> conversionmap<MAP>  ->GTS  conversionoutput<LIST<GTS>>\nlrawwrappedencoder<LIST<BYTES>> conversionmap<MAP>  ->GTS  conversionoutput<LIST<GTS>>",documentation:"The `->GTS` function converts an encoder into one GTS per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\n###### Since 2.4.0:\n- `->GTS` function can also take a conversion MAP input. Using this conversion MAP, the output is always a list of GTS.\n- The conversion map can also take a list of selectors for each output type.\n- The conversion map can be empty: In this case, the GTS type is enforced by the type of the first element in the encoder input.\n- The first selector match stops the research. It means key order matters. See Examples.\n- A new '.type' label is added to each output GTS. This could be overriden with the 'label.type' parameter of the conversion MAP.\n- `->GTS` function can handle encoders, or list of encoders.\n\n###### What is an encoder ?\nA Geo Time Series™ is limited to the type of the first value stored.\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content.\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder. Values are GTS.\n\n@param `lencoder` List of encoders input (supported since 2.4.0).\n\n@param `lwrappedencoder` List of encoders after WRAP (supported since 2.4.0).\n\n@param `lrawwrappedencoder` List of encoders after WRAPRAW (supported since 2.4.0).\n\n@param `loutput` Map with a key/value per type encountered in the input encoder. Values are a list of GTS.\n\n@param `conversionmap` Map with type as keys, selectors or list of selectors as values. The special key `label` allow to change the default `.type` label. Set label to NULL to avoid any new label. The conversion map could be empty.\n\n@param `conversionoutput` A GTS, or a list of GTS.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"1.2.9",OPB64name:"AIt6K4B"},{name:"->GTSHHCODE",detail:"lat<NUMBER> lon<NUMBER>  ->GTSHHCODE  hhcode<STRING>",documentation:"The `->GTSHHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3J"},{name:"->GTSHHCODELONG",detail:"lat<NUMBER> lon<NUMBER>  ->GTSHHCODELONG  hhcode<STRING>",documentation:"The `->GTSHHCODE` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3KBIot6"},{name:"->HEX",detail:"input<STRING>  ->HEX  output<STRING>\ninput<BYTES>  ->HEX  output<STRING>",documentation:"Decodes an hex encoded string or a byte array.\nFor different encodings, use bytes array conversion [`BYTES->`](/doc/F__JGKBhEV).\n\n\nApplied on a string, `->HEX` replaces ` 'utf-8' ->BYTES ->HEX `\n\nIf the encoded content is not a\nvalid UTF-8 representation, the resulting string will reflect that.\n\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Decoded string of input, assuming utf-8 encoding of input.\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"AIt7GKV"},{name:"->HHCODE",detail:"lat<NUMBER> lon<NUMBER>  ->HHCODE  hhcode<STRING>",documentation:"The `->HHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"AIt7H3CEG3J"},{name:"->HHCODELONG",detail:"lat<NUMBER> lon<NUMBER>  ->HHCODELONG  hhcode<LONG>",documentation:"The `->HHCODELONG` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",tags:["geo"],since:"1.2.5",OPB64name:"AIt7H3CEG3KBIot6"},{name:"->JSON",detail:"object<ANY>  ->JSON  output<STRING>",documentation:"The `->JSON` functions serialize structures containing numbers, strings, booleans, lists, vlists and maps which do not reference the same list/map multiple times.\n\n@param `object` Object to serialize\n\n@param `output` JSON formatted string\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"AIt9JoxD"},{name:"->LIST",detail:"content<ANY*> N<LONG>  ->LIST  newlist<LIST>",documentation:"The `->LIST` function create a list from N elements on the stack.\nN and the N next elements on the stack are consumed.\n\nIf N is greater than current stack depth, the function raises an error.\n\n@param `N` The number of elements to take on the top of the stack to build the list.\n\n@param `newlist` The list of N elements. [deepest in stack ... TOP-1 ]\n\n@param `content` 0 to n elements\n\n",tags:["lists","conversion"],since:"1.0.0",OPB64name:"AItBHKCJ"},{name:"->LONGBYTES",detail:"number<LONG> nbbytes<LONG>  ->LONGBYTES  output<BYTES>\nnumberList<LIST<LONG>> nbbytes<LONG>  ->LONGBYTES  output<BYTES>",documentation:"`->LONGBYTES` converts a LONG to a byte array. It expects a number of bytes on the top of the stack.\n\nSince Warp 10™ 2.1, `->LONGBYTES` can also convert a list of LONG.\n\n@param `nbbytes` Number of bytes for number conversion: nbbytes could be 1 to 8. If less than 8, most significant bytes will be truncated.\n\n@param `number` must be a LONG\n\n@param `output` byte array, from 1 to 8 bytes per number\n\n@param `numberList` Since Warp 10 2.1, a list of LONG\n\n",tags:["binary","conversion"],since:"2.1.0",OPB64name:"AItBIot6F__JGKB"},{name:"->MAP",detail:"N<LONG> content<ANY*> content<ANY*>  ->MAP  newmap<MAP>",documentation:"The ->MAP function creates a MAP from an even number N of elements on the stack. \nN is consumed off the top of the stack. For each pair, the deepest element is the key, the shallowest is the value.\n\n\n@param `content` 0 to n pairs of key-value elements. Keys must be different.\n\n@param `N` Number of content elements to consume on the stack. It must be even.\n\n@param `newmap` map instance, initialized with content.\n\n",tags:["maps","conversion"],since:"1.0.0",OPB64name:"AItCFK."},{name:"->MAT",detail:"[ input<LIST> ]  ->MAT  result<MATRIX>",documentation:"The `->MAT` function converts nested lists of numbers (2D array with same number of columns) into a Matrix.\n\nMATRIX objects cannot be represented on the stack. \n\nMatrix entries must be numbers.\n\n\n@param `input` List of lists of values\n\n@param `result` A MATRIX object\n\n",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItCFKF"},{name:"->MVSTRING",detail:"input<STRING>  ->MVSTRING  mvstring<STRING>\ninput<BYTES>  ->MVSTRING  mvstring<STRING>\ninput<GTS>  ->MVSTRING  mvstring<STRING>\ninput<GTSENCODER>  ->MVSTRING  mvstring<STRING>",documentation:"The `->MVSTRING` function generates a STRING representation of an ENCODER in the format expected by the `/update` endpoint for multi values.\n\nWhen encountering a binary element, the function attempts to interpret it as a wrapped encoder, if that fails then it will output the element as a binary (`b64:...`) value.\n\n@param `input` Wrapped or unwrapped Geo Time Series™ or ENCODER.\n\n@param `mvstring` MultiValue format representation of the wrapped encoder/GTS.\n\n",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"AItCK_CJJZ_DGk"},{name:"->OPB64",detail:"input<STRING>  ->OPB64  output<STRING>\ninput<BYTES>  ->OPB64  output<STRING>",documentation:"Encode a String in order preserving base64. OPB64 is a Base64 like encoding which preserves the lexicographic order of\nthe original byte arrays in the encoded ones. This is useful to compare encoded byte arrays without having to first decode them.\n\n@param `input` Could be a string or a byte array.\n\n@param `output` OPB64 of input.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"AItEJ37qC."},{name:"->PICKLE",detail:"input<ANY>  ->PICKLE  output<BYTES>",documentation:"The `->PICKLE` function converts the object on top of the stack to a Python object and serializes it using Pickle protocol version 2.\nThe conversion table used is as follow:\n\n| WarpScript | Python |\n|------------|--------|\n| NULL | None |\n| BOOLEAN | bool |\n| BYTES | bytearray |\n| STRING | str/unicode |\n| DOUBLE | float |\n| LONG | int |\n| LIST | list |\n| MAP | dict |\n| SET | set |\n| GTS | dict |\n| ENCODER | dict |\n\nOther types are unsupported.\n\nPython example with `->PICKLE ->HEX` output:\n```python\n>>> s=\"80025d71002858060000005049434b4c4571015806000000535452494e4771025d7103284b0547400921fb54442d1865652e\"\n>>> import pickle\n>>> pickle.loads(s.decode(\"hex\"))\n[u'PICKLE', u'STRING', [5, 3.141592653589793]]\n```\n\n@param `input` A serializable object\n\n@param `output` Pickle encoded content\n\n",tags:["platform"],since:"1.0.7",OPB64name:"AItFHJCAI3J"},{name:"->Q",detail:"w<DOUBLE> x<DOUBLE> y<DOUBLE> z<DOUBLE>  ->Q  result<LONG>",documentation:"The `->Q` function consumes on the stack 4 doubles (w, x, y, z, with z being on top) representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion)\nand push back quaternion representation into a **LONG**.\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `result` Quaternion representation\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"AItG"},{name:"->SET",detail:"input<LIST>  ->SET  newset<SET>",documentation:"The -`>SET` function converts a **LIST** on top of the stack into a **SET**.\n\nSETs are not viewable, null will be return if it remains on the stack.\n\nThe order in the SET is not garanteed, see [`()`](/doc/91Z).\n\n\n@param `input` The input list\n\n@param `newset` The new set reference. SETs are not viewable, null remains on the stack.\n\n",tags:["sets"],since:"1.0.0",OPB64name:"AItIGKF"},{name:"->TSELEMENTS",detail:"timestamp<LONG>  ->TSELEMENTS  dateAndTimeElements<LIST<LONG>>\ntimestamp<LONG> timezone<STRING>  ->TSELEMENTS  dateAndTimeElements<LIST<LONG>>",documentation:"The `->TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",tags:["date","time"],since:"1.2.0",OPB64name:"AItJJoKBGJp4I_GI"},{name:"->V",detail:"list<LIST>  ->V  result<VLIST>\nset<SET>  ->V  result<VLIST>",documentation:"The `->V` function converts a list of objects into a Pig Vector (VLIST).\n\nVLIST are represented as lists on the stack.\n\n@param `list` Input list\n\n@param `set` Input set\n\n@param `result` Result list\n\n",tags:["conversion","pig"],since:"1.0.11",OPB64name:"AItL"},{name:"->VARINT",detail:"number<LONG>  ->VARINT  encoded<BYTES>\nnumbers<LIST<LONG>>  ->VARINT  encoded<BYTES>",documentation:"The `->VARINT` function encodes a `LONG` or a list of `LONG`s using [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoding. The result is a byte array containing the concatenation of the encoded numbers.\n\nThe `->VARINT` function is optimized for encoding unsigned `LONG`s, this means that negative numbers (with the most significant bit set to 1) will be encoded on 10 bytes. In order to reduce this footprint you can pre-process the numbers to encode so they are encoded unsing [ZigZag VarInt](https://developers.google.com/protocol-buffers/docs/encoding#types) encoding. The simple trick is to compute\n\n```\n$value 1 << $value 63 >> ^\n```\n\nthis will have the effect of alternatively encoding positive and negative numbers thus leading to a more efficient footprint for negative numbers.\n\nAt decoding time using `VARINT->`, simply undo the *Zig-Zag* trick:\n\n```\n$unsigned 63 << 63 >> $unsigned ^ 1 >>\n// Flip the top bit\n$unsigned 1 63 << & ^\n```\n\n@param `number` Single number to encode.\n\n@param `numbers` List of numbers to encode.\n\n@param `encoded` Byte array containing the encoded number(s).\n\n",tags:["conversion","binary"],since:"2.6.0",OPB64name:"AItLFK88I_F"},{name:"->VEC",detail:"list<LIST>  ->VEC  result<VECTOR>\nmatrix<MATRIX>  ->VEC  result<VECTOR>",documentation:"The `->VEC` function converts a list of numbers into a Vector.\n\nVectors objects cannot be represented on the stack. \n\nVectors entries must be numbers.\n\n@param `list` List to convert\n\n@param `matrix` Matrix with a single column\n\n@param `result` Vector\n\n",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItLGJB"},{name:"->WKB",detail:"shape<GEOSHAPE>  ->WKB  wkb<BYTES>\nshape<GEOSHAPE> allCells<BOOLEAN>  ->WKB  wkb<BYTES>\nwkt<STRING>  ->WKB  wkb<BYTES>\ngeojson<STRING>  ->WKB  wkb<BYTES>",documentation:"The `->WKB` function converts a GeoJSON **STRING**, a WKT **STRING** or a **SHAPE** to WKB **BYTES**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` A WKT string\n\n@param `wkb` The resulting WKB.\n\n",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHo7"},{name:"->WKT",detail:"shape<GEOSHAPE>  ->WKT  wkt<STRING>\nshape<GEOSHAPE> allCells<BOOLEAN>  ->WKT  wkt<STRING>\ngeojson<STRING>  ->WKT  wkt<STRING>\nwkb<BYTES>  ->WKT  wkt<STRING>",documentation:"The `->WKT` function converts a GeoJSON **STRING**, a WKB **BYTES** or a **SHAPE** to WKT **STRING**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` The resulting  WKT.\n\n@param `wkb` WKB bytes.\n\n",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHpF"},{name:"->Z",detail:"longs<LIST<LONG>> bitwidth<LONG>  ->Z  z<BYTES>",documentation:"The `->Z` function packs multiple **LONG** arguments into a byte array by interleaving the bits of the arguments. This produces a \n[Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) value encoding the original arguments. The value might be right padded with bits set to 0 to reach a multiple of 8 bits.\n\n@param `bitwidth` Number of bits to consider for each LONG in 'longs', from 1 to 63.\n\n@param `longs` List of LONGs to pack. Each LONG *MUST* be positive, i.e. with bit 63 set to 0.\n\n@param `z` Byte array containing the packed values.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"AItP"},{name:"/",detail:"long<LONG> long<LONG>  /  long-result<LONG>\ndouble<DOUBLE> long<LONG>  /  double-result<DOUBLE>\nlong<LONG> double<DOUBLE>  /  double-result<DOUBLE>\ndouble<DOUBLE> double<DOUBLE>  /  double-result<DOUBLE>\ncounter<COUNTER> counter<COUNTER>  /  long-result<LONG>\ndouble<DOUBLE> counter<COUNTER>  /  long-result<DOUBLE>\ncounter<COUNTER> double<DOUBLE>  /  long-result<DOUBLE>\ncounter<COUNTER> long<LONG>  /  long-result<LONG>\nlong<LONG> counter<COUNTER>  /  long-result<LONG>\ndouble<VECTOR> double<NUMBER>  /  double-result<VECTOR>\nparam2<GTS> param1<GTS>  /  result<GTS>\nparam2<GTS> param1<NUMBER>  /  result<GTS>\nparam2<NUMBER> param1<GTS>  /  result<GTS>",documentation:"The `/` operator consumes two parameters from the top of the stack and pushes back the result of dividing the first one by the second one.\n\nYou can't devide by zero.\n\nThe two parameters must be of numeric types, or Geo Time Series™, or a mix of the two.\n\n@param `long` Numeric integer\n\n@param `long-result` Numeric floor-rounded integer\n\n@param `double` Numeric floating point number\n\n@param `double-result` Numeric floating point number\n\n@param `counter` Numeric counter\n\n@param `param1` First parameter of the division.\n\n@param `param2` Second parameter of the division.\n\n@param `result` Resulting GTS, of type DOUBLE.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"Ak"},{name:"<",detail:"p1<NUMBER> p2<NUMBER>  <  result<BOOLEAN>\np1<STRING> p2<STRING>  <  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  <  outgts<GTS>\nconstant<ANY> inputgts<GTS>  <  outgts<GTS>\ngts1<GTS> gts2<GTS>  <  outputgts<GTS>",documentation:"The `<` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 < p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <` is strictly equivalent of a `42 mapper.lt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 < p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"E."},{name:"<<",detail:"number<LONG> shift<LONG>  <<  result<LONG>\ninputgts<GTS> number<LONG>  <<  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  <<  outputgts<GTS>",documentation:"Shifts the bits of a long by a number of positions to the left. The least significant bit is filled with 0 after each shift.\n\nSince Warp 10™ 2.1, `<<` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",tags:["operators"],since:"1.0.0",OPB64name:"E2k"},{name:"<=",detail:"p1<NUMBER> p2<NUMBER>  <=  result<BOOLEAN>\np1<STRING> p2<STRING>  <=  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  <=  outgts<GTS>\nconstant<ANY> inputgts<GTS>  <=  outgts<GTS>\ngts1<GTS> gts2<GTS>  <=  outputgts<GTS>",documentation:"The `<=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 <= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <=` is strictly equivalent of a `42 mapper.le` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 <= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less or equal than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"E2o"},{name:"==",detail:"p1<ANY> p2<ANY>  ==  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  ==  outgts<GTS>\nconstant<ANY> inputgts<GTS>  ==  outgts<GTS>\ngts1<GTS> gts2<GTS>  ==  outputgts<GTS>",documentation:"Tests if both parameters are equal.\n\nThe `==` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are equal, false otherwise.\n\nThe two parameters must be of numeric, boolean, vector, matrix or string types.\nFor vector or matrix, the parameters must be the same size.\n\nSince 2.1.0, as every other comparison operators, `==` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 ==` is strictly equivalent of a `42 mapper.eq` MAP operation, with a simplified syntax.\n\nSince 2.1.1, `==` can be use to check equality between Lists, Maps and Sets. For for details about how this is defined, check the [java documentation](https://docs.oracle.com/en/java/javase/index.html).\n\n@param `p1` First parameter to compare\n\n@param `p2` Second parameter to compare\n\n@param `result` True if p1 and p2 are equal, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values equal to constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value equals gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"EIo"},{name:">",detail:"p1<NUMBER> p2<NUMBER>  >  result<BOOLEAN>\np1<STRING> p2<STRING>  >  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  >  outgts<GTS>\nconstant<ANY> inputgts<GTS>  >  outgts<GTS>\ngts1<GTS> gts2<GTS>  >  outputgts<GTS>",documentation:"The `>` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 > p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >` is strictly equivalent of a `42 mapper.gt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 > p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"EV"},{name:">=",detail:"p1<NUMBER> p2<NUMBER>  >=  result<BOOLEAN>\np1<STRING> p2<STRING>  >=  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  >=  outgts<GTS>\nconstant<ANY> inputgts<GTS>  >=  outgts<GTS>\ngts1<GTS> gts2<GTS>  >=  outputgts<GTS>",documentation:"The `>=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 >= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >=` is strictly equivalent of a `42 mapper.ge` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 >= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater or equal than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"EYo"},{name:">>",detail:"number<LONG> shift<LONG>  >>  result<LONG>\ninputgts<GTS> number<LONG>  >>  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  >>  outputgts<GTS>",documentation:"Shifts the bits of a long by a number of positions to the right. The most significant bit after shifting depends on the sign of the unshifted long.\n\nSince Warp 10™ 2.1, `>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",tags:["operators"],since:"1.0.0",OPB64name:"EYs"},{name:">>>",detail:"number<LONG> shift<LONG>  >>>  result<LONG>\ninputgts<GTS> number<LONG>  >>>  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  >>>  outputgts<GTS>",documentation:"Shifts the bits of a long by a number of positions to the right. The most significant bit after each shift is set to 0, regardless of the sign of \nthe unshifted long.\n\nSince Warp 10™ 2.1, `>>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",tags:["operators"],since:"1.0.0",OPB64name:"EYsy"},{name:"ABS",detail:"value<LONG>  ABS  result<LONG>\nvalue<COUNTER>  ABS  result<LONG>\nvalue<DOUBLE>  ABS  result<DOUBLE>\nlvalue<LIST<LONG>>  ABS  lresult<LIST<LONG>>\nlvalue<LIST<COUNTER>>  ABS  lresult<LIST<LONG>>\nlvalue<LIST<DOUBLE>>  ABS  lresult<LIST<DOUBLE>>",documentation:"Computes the absolute value of a number value.\n\nThe `ABS` function consumes a numeric value from the top of the stack and pushes back its absolute value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` A numeric value\n\n@param `result` The absolute value of the given numeric value.\n\n@param `lvalue` A list of numeric values\n\n@param `lresult` A list of the absolute values of the given values.\n\n",tags:["math"],since:"1.0.0",OPB64name:"ABS"},{name:"ACCEL.CACHE",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.CACHE` function will enable accessing the in-memory data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.CACHE"},{name:"ACCEL.NOCACHE",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOCACHE` function will disable accessing the in-memory data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOCACHE"},{name:"ACCEL.NOPERSIST",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOPERSIST` function will disable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOPERSIST"},{name:"ACCEL.PERSIST",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.PERSIST` function will enable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.PERSIST"},{name:"ACCEL.REPORT",detail:" ACCEL.REPORT  report<MAP>",documentation:"The `ACCEL.REPORT` function will produce a map containing informations related to the Warp 10 Accelerator. The following table describes the various keys present in this map:\n\n| Key | Description |\n|-----|-------------|\n| `accelerated` | Boolean indicating whether or not the last [`FETCH`](/doc/FETCH) accessed the in-memory data managed by the Warp 10 Accelerator. |\n| `status` | Boolean indicating whether or not the Warp 10 Accelerator is enabled. |\n| `cache` | Boolean indicating if the in-memory data will be considered for update, fetch and delete operations. |\n| `persist` | Boolean indicating if the persistent data will be considered for update, fetch and delete operations. |\n| `chunkcount` | Number of chunks managed by the accelerator for its in-memory data. |\n| `chunkspan` | Length of each chunk expressed in platform time units. |\n\n@param `report` Map containing informations related to the Warp 10 Accelerator\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.REPORT"},{name:"ACOS",detail:"value<NUMBER>  ACOS  result<DOUBLE>\nlvalue<LIST<NUMBER>>  ACOS  lresult<LIST<DOUBLE>>",documentation:"The `ACOS` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arccosine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arccosine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arccosine in radians of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ACOS"},{name:"ADDDAYS",detail:"timestamp<LONG> timezone<STRING> days<LONG>  ADDDAYS  result<LONG>\ntimestamp<LONG> days<LONG>  ADDDAYS  result<LONG>\ntselements<LIST<LONG>> days<LONG>  ADDDAYS  tselementsresult<LIST<LONG>>",documentation:'Adds days to a timestamp or a tselements.\n\nThe `ADDDAYS` function consumes from the top of the stack a number (positive or negative) of days, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the days and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `days` The number of days to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',tags:["date"],since:"1.2.0",OPB64name:"ADDDAYS"},{name:"ADDDURATION",detail:"timestamp<LONG> timezone<STRING> duration<STRING>  ADDDURATION  result<LONG>\ntimestamp<LONG> timezone<STRING> duration<STRING> factor<LONG>  ADDDURATION  result<LONG>\ntimestamp<LONG> duration<STRING>  ADDDURATION  result<LONG>\ntimestamp<LONG> duration<STRING> factor<LONG>  ADDDURATION  result<LONG>\ntselements<LIST<LONG>> duration<STRING>  ADDDURATION  tselementsresult<LIST<LONG>>\ntselements<LIST<LONG>> duration<STRING> factor<LONG>  ADDDURATION  tselementsresult<LIST<LONG>>",documentation:"Adds an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) to a timestamp or a tselements.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `duration` The duration\n\n@param `factor` The number of durations to add. Can be negative. Default to 1 if not set.\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n",tags:["date"],since:"2.4.0",OPB64name:"ADDDURATION"},{name:"ADDEXACT",detail:"x<NUMBER> y<NUMBER>  ADDEXACT  sum<LONG>\nlist<LIST<NUMBER>>  ADDEXACT  ssum<LONG>\nlx<LIST<NUMBER>> y<NUMBER>  ADDEXACT  lsum<LIST<LONG>>",documentation:"The `ADDEXACT` function consumes two LONGs from the top of the stack and puts back the sum. If the sum overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `sum` The sum of x and y\n\n@param `list` List of numeric values\n\n@param `ssum` The sum of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lsum` List of **LONG** where each value is the sum of y and an element in lx\n\n",tags:["math"],since:"1.2.23",OPB64name:"ADDEXACT"},{name:"ADDMONTHS",detail:"timestamp<LONG> timezone<STRING> months<LONG>  ADDMONTHS  result<LONG>\ntimestamp<LONG> months<LONG>  ADDMONTHS  result<LONG>\ntselements<LIST<LONG>> months<LONG>  ADDMONTHS  tselementsresult<LIST<LONG>>",documentation:'Adds months to a timestamp or a tselements.\n\nThe `ADDMONTHS` function consumes from the top of the stack a number (positive or negative) of months, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the months and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `months` The number of months to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',tags:["date"],since:"1.2.0",OPB64name:"ADDMONTHS"},{name:"ADDVALUE",detail:"gts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<STRING>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<BYTES>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<BOOLEAN>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<DOUBLE>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<LONG>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<GTSENCODER>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<GTS>  ADDVALUE  result<GTS>",documentation:"The `ADDVALUE` function adds a value to a GTS, without checking for tick duplicates. The added data point is appended to the GTS.\nThe [`SETVALUE`](/doc/SETVALUE) overrides an existing value.\n\nThe `ADDVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `ADDVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, for example by using [`GET`](/doc/GET)\nwith value 0 as parameter.\n\nIf latitude or longitude are NaN (not a number), value has only timestamp, elevation, value.\nIf elevation is NaN (not a number), value has only timestamp, latitude, longitude, value.\nIf elevation is NaN and longitude or latitude are NaN, value has only timestamp, value.\n\nWhen adding a Geo Time Series™ or GTS Encoder value, the value will be wrapped (as when using `WRAPRAW`) and added as a binary value.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Series™\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `result` The Geo Time Series™ with the new datapoint added\n\n@param `elevation` Elevation or NaN\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ADDVALUE"},{name:"ADDYEARS",detail:"timestamp<LONG> timezone<STRING> years<LONG>  ADDYEARS  result<LONG>\ntimestamp<LONG> years<LONG>  ADDYEARS  result<LONG>\ntselements<LIST<LONG>> years<LONG>  ADDYEARS  tselementsresult<LIST<LONG>>",documentation:'Adds years to a timestamp or a tselements.\n\nThe `ADDYEARS` function consumes from the top of the stack a number (positive or negative) of years, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the years and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `years` The number of years to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',tags:["date"],since:"1.2.0",OPB64name:"ADDYEARS"},{name:"AESUNWRAP",detail:"key<BYTES> data<BYTES>  AESUNWRAP  decoded<BYTES>",documentation:'Unwraps a byte array with the [AES WRAP](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") and pushes back the decrypted data into an bytes array.\n\n`AESUNWRAP` removes the a 64bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) added by [`AESWRAP`](/doc/AESWRAP) WarpScript function\n\n@param `data` Encoded Byte array.\n\n@param `key` Byte array, 128, 192 or 256 bits key.\n\n@param `decoded` Decoded Byte array.\n\n',tags:["crypto"],since:"1.0.11",OPB64name:"AESUNWRAP"},{name:"AESWRAP",detail:"string<STRING> key<BYTES>  AESWRAP  encrypted<BYTES>\nbytes<BYTES> key<BYTES>  AESWRAP  encrypted<BYTES>",documentation:'Wraps a byte array or String with the [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt) algorithm and pushes a byte array containing the encrypted data onto the stack.\n\n`AESWRAP` adds a 64 bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) prefix to the input in order to protect the encrypted data against AES block determinism as [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") uses a fixed Initialization Vector.\n\n@param `key` 128, 192 or 256 bits key to use for encryption.\n\n@param `string` String data to encrypt.\n\n@param `bytes` Byte array to encrypt.\n\n@param `encrypted` Encrypted result.\n\n',tags:["crypto"],since:"1.0.11",OPB64name:"AESWRAP"},{name:"AGO",detail:"offset<NUMBER>  AGO  timestamp<LONG>",documentation:"The `AGO` function is a shortcut which enables you to compute timestamps by specifying an offset from the current time.\n\n@param `offset` The numbers of ticks in platform time unit to subtract, truncated if floating-point.\n\n@param `timestamp` The computed timestamp\n\n",tags:["date"],since:"1.2.0",OPB64name:"AGO"},{name:"AND",detail:"p1<BOOLEAN> p2<BOOLEAN>  AND  result<BOOLEAN>\nl<LIST>  AND  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  AND  gtsresult<GTS>",documentation:"The `AND` operator is a synonymous for [`&&`](/doc/8XN).\n\nIt performs a logical **AND** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `AND` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical AND applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with AND between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"AND"},{name:"APPEND",detail:"inputlist<LIST> newitems<LIST>  APPEND  outputlist<LIST>\ninputmap<MAP> newitems<MAP>  APPEND  outputmap<MAP>\ninputGTS<GTS> newitems<GTS>  APPEND  outputGTS<MAP>",documentation:"The `APPEND` function consumes two paramters from the top of the stack and appends the LIST, MAP or GTS on top of the stack to the one just below.\nThe augmented LIST, MAP or GTS is then pushed back on the stack.\n\n@param `newitems` items to append to input.\n\n@param `inputlist` LIST to be modified.\n\n@param `outputlist` The LIST that has been modified\n\n@param `inputmap` MAP to be modified.\n\n@param `outputmap` The AP that has been modified \n\n@param `inputGTS` GTS to be modified.\n\n@param `outputGTS` The GTS that has been modified\n\n",tags:["lists","maps"],since:"1.0.0",OPB64name:"APPEND"},{name:"APPLY",detail:"[ gts<LIST<GTS>+> labels<LIST> op<OPERATOR> ]  APPLY  result<LIST<GTS>>",documentation:"The `APPLY` framework provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can do. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` List of resulting GTS, one per equivalence class.\n\n@param `op` Operation to perform.\n\n",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"APPLY"},{name:"ASENCODERS",detail:"gts<GTS>  ASENCODERS  encoder<GTSENCODER>\nlgts<LIST<GTS>>  ASENCODERS  lencoder<LIST<GTSENCODER>>\nwrappedgts<STRING>  ASENCODERS  encoder<GTSENCODER>\nlwrappedgts<LIST<STRING>>  ASENCODERS  lencoder<LIST<GTSENCODER>>\nrawwrappedgts<BYTES>  ASENCODERS  encoder<GTSENCODER>\nlrawwrappedgts<LIST<BYTES>>  ASENCODERS  lencoder<LIST<GTSENCODER>>\nencoder<GTSENCODER>  ASENCODERS  encoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>>  ASENCODERS  lencoder<LIST<GTSENCODER>>",documentation:"The `ASENCODERS` function consumes a Geo Time Series™, a wrap or a raw wrap, or a list thereof and convert each one into an encoder.\n\n@param `gts` Geo Time Series™ to be converted.\n\n@param `lgts` List of Geo Time Series™ to be converted.\n\n@param `wrappedgts` Wrapped Geo Time Series™ to be converted.\n\n@param `lwrappedgts` List of wrapped Geo Time Series™ to be converted.\n\n@param `rawwrappedgts` Raw wrapped Geo Time Series™ to be converted.\n\n@param `lrawwrappedgts` List of raw wrapped Geo Time Series™ to be converted.\n\n@param `encoder` Encoder of the given Geo Time Series™.\n\n@param `lencoder` List of encoder, one for each given Geo Time Series™.\n\n",tags:["encoder","conversion"],since:"2.2.0",OPB64name:"ASENCODERS"},{name:"ASIN",detail:"value<NUMBER>  ASIN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  ASIN  lresult<LIST<DOUBLE>>",documentation:"The `ASIN` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arcsine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arcsine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arcsine in radians of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ASIN"},{name:"ASREGS",detail:"macro<MACRO> vars<LIST<STRING>>  ASREGS  macro<MACRO>\nmacro<MACRO>  ASREGS  macro<MACRO>",documentation:"Replaces in a macro the uses of the given symbols by the use of registers.\n\nIf there are not enough registers available, replace each of the symbols from the start of the list until all registers are used.\n\nSince 2.6.0, the list of symbols is optional. In that case, `ASREGS` first recursively extracts all the symbols from given the macro and uses that list to do the replacement.\n\n@param `macro` Macro to transform.\n\n@param `vars` List of symbols.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"ASREGS"},{name:"ASSERT",detail:"condition<BOOLEAN>  ASSERT ",documentation:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise.\n\nThe `ASSERT` function consumes a **BOOLEAN** parameter from the top of the stack. If the boolean is **true** the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception.\n\n`ASSERT` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n",tags:["debug"],since:"1.0.0",OPB64name:"ASSERT"},{name:"ASSERTMSG",detail:"condition<BOOLEAN> message<STRING>  ASSERTMSG ",documentation:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise and displays a message.\n\nThe `ASSERTMSG` function consumes a **BOOLEAN** parameter and a **STRING** parameter from the top of the stack. If the boolean is **true**, the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception with a message displaying the **STRING** parameter.\n\n`ASSERTMSG` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n@param `message` The exception message to display if the test fails\n\n",tags:["debug"],since:"1.2.13",OPB64name:"ASSERTMSG"},{name:"ATAN",detail:"value<NUMBER>  ATAN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  ATAN  lresult<LIST<DOUBLE>>",documentation:"The `ATAN` function consumes a floating point number between -1 et 1 from the top of the stack and pushes back its arctangent in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arctangent in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arctangent in radians of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ATAN"},{name:"ATAN2",detail:"y<NUMBER> x<NUMBER>  ATAN2  result<DOUBLE>\ny<NUMBER> lx<LIST<NUMBER>>  ATAN2  lresult<LIST<DOUBLE>>\nly<LIST<NUMBER>> x<NUMBER>  ATAN2  lresult<LIST<DOUBLE>>",documentation:"ATAN2 function returns the polar angle theta (azimut) from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta). This method computes the phase theta by computing an arc tangent of y/x in the range of `] -pi  pi ]`.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `result` theta in polar coordinates\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `lresult` List of thetas in polar coordinates\n\n",tags:["math","trigonometry"],since:"1.2.13",OPB64name:"ATAN2"},{name:"ATBUCKET",detail:"gts<GTS> index<LONG>  ATBUCKET  result<LIST>",documentation:"The `ATBUCKET` function consumes a bucketized GTS from the stack, looks at its `index`-th bucket and puts on the stack a\nlist with the timestamp, latitude, longitude, elevation and value for this bucket.\n\n@param `gts` Bucketized Geo Time Series™\n\n@param `index` Index of the bucket\n\n@param `result` List with the timestamp, latitude, longitude, elevation and value for the index-th bucket of the GTS\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"ATBUCKET"},{name:"ATINDEX",detail:"gts<GTS> index<NUMBER>  ATINDEX  data<LIST>\nlgts<LIST<GTS>> index<NUMBER>  ATINDEX  ldata<LIST<LIST>>",documentation:"The `ATINDEX` function consumes a Geo Time Series™ or a list thereof from the stack, looks at its index-th point and put on the stack a list with the timestamp, longitude, \nlatitude, elevation and value for the `index`-th point of the GTS.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the GTS.\n\n@param `index` Index of the tick, truncated if floating-point.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ATINDEX"},{name:"ATTICK",detail:"gts<GTS> timestamp<LONG>  ATTICK  data<LIST>\nlgts<LIST<GTS>> timestamp<LONG>  ATTICK  ldata<LIST<LIST>>\ngts<GTS> timestamp<COUNTER>  ATTICK  data<LIST>\nlgts<LIST<GTS>> timestamp<COUNTER>  ATTICK  ldata<LIST<LIST>>\ngts<GTS> timestamp<DOUBLE>  ATTICK  data<LIST>\nlgts<LIST<GTS>> timestamp<DOUBLE>  ATTICK  ldata<LIST<LIST>>",documentation:"The `ATTICK` function consumes a Geo Time Series™ from the stack, looks at its tick-th tick (the data point with a timestamp tick) and put on the \nstack a list with the timestamp, latitude, longitude, elevation and value for that data point.\n\nIf there is no data point with tick timestamp, it return a list with timestamp, latitude, longitude and elevation at **NaN** and value at **null**.\n\n@param `timestamp` Timestamp at which to take the data, if it is a floating-point value, it is truncated.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ATTICK"},{name:"ATTRIBUTES",detail:"gts<GTS>  ATTRIBUTES  return<MAP>\nencoder<GTSENCODER>  ATTRIBUTES  return<MAP>",documentation:"Retrieves the attributes of a Geo Time Series™.\n\nThe `ATTRIBUTES` function takes a **GTS** on top of the stack and push back a **MAP** including all its attributes.\n\nAn attribute corresponds to a tag for a specific series.\nThe attribute system allows the user to add some information that can change in a series.\n\n@param `gts` The input Geo Time Series™\n\n@param `encoder` The input Geo Time Series™ Encoder\n\n@param `return` The attributes MAP of the input Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ATTRIBUTES"},{name:"AUTHENTICATE",detail:"token<STRING>  AUTHENTICATE ",documentation:"The `AUTHENTICATE` function authenticates the current stack with the **read token** on top of the stack. This function removes the token from the stack.\n\nInside a WarpScript, the stack could be authenticated only once. An exception is thrown when the stack is already authenticated.\n\n@param `token` Read token\n\n",tags:["stack"],since:"1.0.0",OPB64name:"AUTHENTICATE"},{name:"B64->",detail:"content<STRING>  B64->  result<BYTES>",documentation:"Decodes the [base64](http://tools.ietf.org/html/rfc4648#section-4) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoAIs"},{name:"B64TOHEX",detail:"content<STRING>  B64TOHEX  result<STRING>",documentation:"Decodes the  [base64](http://tools.ietf.org/html/rfc4648#section-4) content on top of the stack and immediately re-encode it in hexadecimal.\nThis enables you to convert encoded content which would not be valid UTF-8 encoding from base64 to hexadecimal. \nAs the string are URL encoded, the symbol `+` have to be replaced by `%2B`, otherwise a space will replace the `+` in the string.\n\n@param `content` String to convert\n\n@param `result` Hexadecimal converted string\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"B64TOHEX"},{name:"B64URL->",detail:"content<STRING>  B64URL->  result<BYTES>",documentation:"Decodes the [base64url](http://tools.ietf.org/html/rfc4648#section-5) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoKK8BAIs"},{name:"BBOX",detail:"gts<GTS>  BBOX  [  minlat<DOUBLE>  minlon<DOUBLE>  maxlat<DOUBLE>  maxlon<DOUBLE>  ]\nlgts<LIST<GTS>>  BBOX  extremas<LIST<LIST<DOUBLE>>>",documentation:"The `BBOX` function computes the bounding box of a Geo Time Series™ or a list thereof. It returns a list with extremas, or a list of list of extremas.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `minlat` Latitude of lower left of bounding box.\n\n@param `minlon` Longitude of lower left of bounding box.\n\n@param `maxlat` Latitude of upper right of bounding box.\n\n@param `maxlon` Longitude of upper right of bounding box.\n\n@param `extremas` List of list containing minlat, minlon, maxlat, maxlon, for every GTS in lgts.\n\n",tags:["geo","gts"],since:"1.0.0",OPB64name:"BBOX"},{name:"BIN->",detail:"binary<STRING>  BIN->  result<BYTES>",documentation:"The `->BIN` function decodes a binary string representation into a bytes array.\n\n@param `binary` The binary string representation\n\n@param `result` The bytes array\n\n",tags:["strings","conversion","binary"],since:"1.0.6",OPB64name:"FZ_DAIs"},{name:"BINTOHEX",detail:"content<STRING>  BINTOHEX  result<STRING>",documentation:"Converts a string representing a binary number into a string representing a hexadecimal number.\n\nThe `BINTOHEX` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from binary to hexadecimal.\n\n@param `content` The string representing a binary number\n\n@param `result` The string representing a hexadecimal number\n\n",tags:["strings","conversion","binary"],since:"1.0.0",OPB64name:"BINTOHEX"},{name:"BITCOUNT",detail:"bitset<BITSET>  BITCOUNT  cardinality<LONG> length<LONG>",documentation:"Returns the logical size and the cardinality of a [BitSet](https://docs.oracle.com/javase/8/docs/api/java/util/BitSet.html).\n\nThe `BITCOUNT` function consumes a bitset on the top of the stack and push back its logical size and its cardinality.\n  * The logical size is the index of the highest bit set to true plus one.\n  * The cardinality is the number of bit set to true.\n\n@param `bitset` The BitSet to count\n\n@param `length` The logical size of the BitSet\n\n@param `cardinality` The number of bits set to true\n\n",tags:["bitset","binary"],since:"1.0.6",OPB64name:"BITCOUNT"},{name:"BITGET",detail:"bitset<BITSET> index<LONG>  BITGET  return<BOOLEAN>",documentation:"Returns the value of the bit with the specified index.\n\nThe `BITGET` function consumes a bitset and a long on the top of the stack. It returns the value of the bit with the specified index. The bit index starts at 0 from the right.\n\n@param `index` The bit index\n\n@param `bitset` The bitset\n\n@param `return` The value of the bit with the specified index\n\n",tags:["bitset","binary"],since:"1.0.5",OPB64name:"BITGET"},{name:"BITSTOBYTES",detail:"bitset<BITSET>  BITSTOBYTES  result<BYTES>",documentation:"Converts a bitset into a bytes array.\n\n@param `bitset` Bitset\n\n@param `result` Bytes array\n\n",tags:["bitset","binary","conversion"],since:"1.0.6",OPB64name:"BITSTOBYTES"},{name:"BOOTSTRAP",detail:"",documentation:"This function is executed systematically before the WarpScript stack is available for anything else. By default this function does nothing, it is equivalent \nto [`NOOP`](/doc/NOOP).\n\nIf bootstrap code was specified in the Warp 10 platform configuration, for either or all of `egress`, `mobius` or `runner`, the `BOOTSTRAP` function might\nhave been redefined and actual code could be executed.\n\nThis function is not meant to be used in user provided scripts.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"BOOTSTRAP"},{name:"BREAK",detail:"",documentation:"The `BREAK` function breaks out of the current loop. It takes no argument.\n\n> If used outside a loop, an error is thown\n\n",tags:["logic","control"],since:"1.0.0",OPB64name:"BREAK"},{name:"BUCKETCOUNT",detail:"gts<GTS>  BUCKETCOUNT  result<LONG>",documentation:"The function `BUCKETCOUNT` consumes a GTS off the stack and pushes its bucketcount onto the stack.\n\n> Note: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Number of buckets\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETCOUNT"},{name:"BUCKETIZE",detail:"[ gts<GTS+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>\n[ gts<GTS+> macro<MACRO> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> macro<MACRO> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>",documentation:"The Geo Time Series™ kept in the Warp 10 platform grow over time as more measurements are added. Some series have very regular measurements,\nothers more sporadic ones. But when it comes to manipulating the data, it might be handy to be able to impose some kind of regularity to measurements.\nThis is exactly what the [`BUCKETIZE`](/doc/BUCKETIZE) framework does, it provides the tooling for putting the data of a Geo Time Series™ into regularly spaced\n**buckets**.\n\nA **bucket** is a time interval which spans a certain number of time units called the **bucketspan**, ending at a tick called the **lastbucket**.\n\nAs an example, the bucket spanning 10 time units and ending at time units 20 will contain all measurements taken at the following times:\n\n20, 19, 18, 17, 16, 15, 14, 13, 12, 11\n\nthe previous bucket with the same bucketspan ends at 10 and covers ticks 10 down to 1. The next bucket ends at 30 and covers ticks 21 to 30.\n\nA bucketized Geo Time Series™ is characterized by its **bucketspan**, its **bucketcount** and the **lastbucket**.\nA bucketized Geo Time Series™ has at most one measurement per bucket, there might be buckets with no measurements.\n\nThe `BUCKETIZE` framework is used to convert a non bucketized Geo Time Series™ into a bucketized one. The bucketization process collects\nthe measurements of the original geo time series which fall in each bucket and apply a bucketizer function on those data, thus leading to at most a\nsingle measurement for each bucket.\n\nThe `BUCKETIZE` framework comes with a number of bucketizer which implement very common aggregation functions such as SUM, MIN, MAX, MEAN, etc.\n\nA macro can be used instead of the bucketizer argument. In that case, in each bucket the measurements are collected as a sub Geo Time Series™ which is taken as parameter by the macro.\nThis macro must then push onto the stack its result (see description in signature description below).\n\nIf the bucketizer argument is NULL, then BUCKETIZE do not create any new Geo Time Series™ but instead sets the lastbucket, bucketspan and bucketcount of its inputs without processing their data.\n\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so the first value of the geo time series is at the beginning of the first bucket.\n\n@param `bucketspan` Width in time units of each bucket. If `bucketspan` is 0 but `bucketcount` is set, WarpScript will compute `bucketspan` so `bucketcount` buckets cover the complete set of values from firsttick to lasttick. If this value is set to -1, the number of buckets is computed so the first tick is towards the end of the first bucket.\n\n@param `lastbucket` Specifies the timestamp in time units since the Unix Epoch of the end of the most recent bucket. If you set this value to 0, this timestamp will be computed automatically so it covers the most recent value of the geo time series and falls on a `bucketspan` boundary.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS\n\n",tags:["framework","bucketize","gts","bucketizer"],since:"1.0.0",OPB64name:"BUCKETIZE"},{name:"BUCKETIZE.CALENDAR",detail:"[ gts<GTS+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>\n[ gts<GTS+> macro<MACRO> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>\n[ gts<GTS+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> timezone<STRING> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>\n[ gts<GTS+> macro<MACRO> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> timezone<STRING> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>",documentation:"Creates bucketized Geo Time Series with buckets that span a calendar duration that can be irregular (e.g. taking into account leap years and daylight saving time).\n\nInstead of using a bucketspan like the BUCKETIZE framework, it uses a bucketduration: a STRING in [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) format, as `PyYmMwWdDThHmMsS` similarly to that of ADDDURATION function. However, complex bucketdurations that can be non-positive from some ticks are not allowed.\n\nIn the result, the tick of each bucket is its index, which is equal to the number of buckets that are ended since Unix Epoch. In particular, the tick of the bucket that contains Unix Epoch is always 0. The resulting GTS is considered bucketized for further operations. Then, the function UNBUCKETIZE.CALENDAR can be used to replace bucket indices with their timestamp end boundaries.\n\nThis function answers the limitation of BUCKETIZE to regular buckets. For instance, BUCKETIZE.CALENDAR can be used with a duration of one month (`P1M`) or one year (`P1Y`).\n\nThe delta between Unix Epoch and the first timestamp of bucket 0th is called the bucketoffset. The bucketoffset, bucketduration and buckettimezone are stored in the attributes.\n\n@param `timezone` The timezone to consider. Default to UTC\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so every value of the GTS falls in a bucket.\n\n@param `bucketduration` Width in ISO 8601 duration format of each bucket.\n\n@param `lastbucket` Specifies the timestamp in platform time units of the end boundary of the most recent bucket. For coherency with BUCKETIZE, this value can not be set to 0.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS in the new time referential\n\n",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"BUCKETIZE.CALENDAR"},{name:"BUCKETSPAN",detail:"gts<GTS>  BUCKETSPAN  result<LONG>",documentation:"The function `BUCKETSPAN` consumes a GTS off the stack and pushes its bucketspan onto the stack.\n\n> when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Bucketspan\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETSPAN"},{name:"BYTES->",detail:"bytes<BYTES> charset<STRING>  BYTES->  result<STRING>",documentation:"Converts a bytes array into a string with given a charset and put the string on top of the stack.\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\n\n@param `charset` Charset to use\n\n@param `bytes` Bytes array to convert\n\n@param `result` String converted byte array\n\n",tags:["strings","conversion"],since:"1.0.6",OPB64name:"F__JGKBhEV"},{name:"BYTESTOBITS",detail:"bytesarray<BYTES>  BYTESTOBITS  result<BITSET>",documentation:"Converts a byte array into a bitset.\n\n@param `bytesarray` Bytes array\n\n@param `result` Bitset\n\n",tags:["bitset","conversion","binary"],since:"1.0.6",OPB64name:"BYTESTOBITS"},{name:"CALL",detail:"params<STRING> program<STRING>  CALL  result<STRING>",documentation:'The `CALL` function invokes the external program whose path (relative to the `warpscript.call.directory` directory) is on top of the stack. The calling convention will pass to the external\nprogram the **STRING** object below the path on a line by itself on standard input after having URL encoded the **STRING**. The invoked\nprogram is expected to return a URL encoded **STRING** object if invocation was successful, or a string starting with a space and followed by a URL encoded error message if an error was encoutered.\n\nIf you need to pass complex structures to the invoked program, you can use functions such as [`->JSON`](/doc/AIt9JoxD), [`->PICKLE`](/doc/AItFHJCAI3J)\nand [`->B64`](/doc/AIt1CYF) to encode the input prior to the invocation.\n\nExamples of callable programs are provided in [shell](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/sh/callable.sh)\nand [python](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/python/callable.py).\n\nThe program must be stored in the directory described by the `warpscript.call.directory` configuration parameter.\n\nThe program must first output on the stdout the number of concurrent thread allowed.\n\nExample:\n\n```bash\n#!/bin/bash\necho 5 # 5 threads allowed\nurldecode() {\n  # urldecode <string>\n  local url_encoded="${1//+/ }"\n  printf \'%b\' "${url_encoded//%/\\\\x}"\n}\nwhile true\n\ndo\n  read line\n  line=`urldecode "${line}"` # read the params given by the WarpScript\n  echo $line # Will be pushed on the stack\ndone\n```\n\n@param `program` Program path\n\n@param `params` URL encoded input\n\n@param `result` URL encoded output\n\n',tags:["platform"],since:"1.0.7",OPB64name:"CALL"},{name:"CBRT",detail:"value<NUMBER>  CBRT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  CBRT  lresult<LIST<DOUBLE>>",documentation:"The `CBRT` function consumes a numeric parameter from the top of the stack and pushes back its cubic root.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Cubic root of the given value.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of cubic root of each given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"CBRT"},{name:"CEIL",detail:"value<NUMBER>  CEIL  result<DOUBLE>\nlvalue<LIST<NUMBER>>  CEIL  lresult<LIST<DOUBLE>>",documentation:"The `CEIL` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number bigger than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-up value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-up values, for each given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"CEIL"},{name:"CEVAL",detail:"macros<LIST> poolSize<LONG>  CEVAL  result<LIST>",documentation:"The `CEVAL` function allows you to execute macros in a concurrent way on a pool of threads.\n\nAll macros will be executed with the maximum parallelism level specified. Each macro is executed on its own stack. The context of the global stack is\nreplicated to each of those stacks so each macro will have access to the existing symbols and the redefined functions. Any modification to the symbol\ntable or redifined functions done in a concurrent macro will not be reflected in the global stack afterwards.\n\nEach macro is invoked with its index in the list on top of the stack.\n\nUpon termination of each macro, the content of their respective stacks is put into a list, with the top of the stack at index 0, and those lists are\nmerged into a global list which is then pushed onto the stack. The resulting list for each macro appears at the index of the macro in the original macro list.\n\nBeware that no synchronization is implicitely performed between the concurrent macros. If you require synchronization between macros, for example because\nyou are modifying a list accessible by all macros via a symbol, you must use the [`SYNC`](/doc/SYNC) function.\n\nIf one of the macros fail, an attempt to interrupt the other running macros will be done and the failure will be propagated to the other macros. For the\ntime being, a call to [`STOP`](/doc/STOP) or [`RETURN`](/doc/RETURN) in one of the macros will stop all of them.\n\nUse of `CEVAL` is not available from within a macro currently executing in a `CEVAL` call.\n\nThe `CEVAL` function is part of the `io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```properties\n// Enable CEVAL and SYNC functions\nwarpscript.extension.concurrent = io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension\n```\n\n@param `poolSize` Parallelism level\n\n@param `macros` List of macros\n\n@param `result` Result list\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"CEVAL"},{name:"CHECKMACRO",detail:"name<STRING>  CHECKMACRO ",documentation:"The `CHECKMACRO` function checks if a macro is defined and aborts the execution when it encounters an undefined macro.\n\n@param `name` The macro name\n\n",tags:["logic","control"],since:"2.1.0",OPB64name:"CHECKMACRO"},{name:"CHECKSHAPE",detail:"list<LIST>  CHECKSHAPE  result<LIST>\n{ list<LIST>  } CHECKSHAPE  result<LIST>",documentation:"Return a BOOLEAN indicating whether an input list and its nested lists sizes are coherent together to form a tensor (or multidimensional array).\n\n@param `list` The input list.\n\n@param `result` true or false.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"CHECKSHAPE"},{name:"CHRONOEND",detail:"name<STRING>  CHRONOEND ",documentation:"The `CHRONOEND` function ends a stopwatch with the given name previously started with [`CHRONOSTART`](/doc/CHRONOSTART). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\nIt is a good practice to put `CHRONOEND` in the finally clause of a [`TRY`](/doc/TRY) for the timing to work even if exceptions are thrown.\n\n@param `name` A name identifying the stopwatch.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOEND"},{name:"CHRONOSTART",detail:"name<STRING>  CHRONOSTART ",documentation:"The `CHRONOSTART` function starts a stopwatch with the given name. To stop the stopwatch, call [`CHRONOEND`](/doc/CHRONOEND). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\n@param `name` A name identifying the stopwatch.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTART"},{name:"CHRONOSTATS",detail:" CHRONOSTATS  stats<MAP>",documentation:"The `CHRONOSTATS` function \n\n@param `stats` A map with stopwatches names as keys and maps as values. These maps have two keys, `total_calls` and `total_time`. The former gives the number of calls to [`CHRONOSTART`](/doc/CHRONOSTART) and the latter gives the cumulative time between [`CHRONOSTART`](/doc/CHRONOSTART) and [`CHRONOEND`](/doc/CHRONOEND) in **nanoseconds**.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTATS"},{name:"CHUNK",detail:"gts<GTS> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  result<LIST<GTS>>\ngtsList<LIST<GTS>> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  result<LIST<GTS>>\nencoder<GTSENCODER> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  resultEncoders<LIST<GTSENCODER>>\nlEncoder<LIST<GTSENCODER>> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  resultEncoders<LIST<GTSENCODER>>",documentation:"The `CHUNK` is used to split a Geo Time Series™ into partial GTS. The split operation is controlled by multiple parameters.\nThe series will be splitted in chunks, each chunks will form a new GTS, with a label value corresponding to its first tick.\n\n@param `keepempty` If true empty chunks are kept\n\n@param `chunklabel` The label name of the label added by the split operation (with a value corresponding to the first tick of the chunk).\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` An overlap duration (in time units) between chunks, this is useful when chunking a GTS to apply an algorithm which operates on a sliding window.\n\n@param `chunkwidth` The width in time units of each chunk.\n\n@param `lastchunkend` The end timestamp of the most recent split to consider.\n\n@param `gts` A single GTS instance.\n\n@param `gtsList` A GTS list to split, each GTS will be splitted individually.\n\n@param `encoder` A single GTS Encoder instance.\n\n@param `lEncoder` A GTS Encoder list to split, each GTS Encoder will be splitted individually.\n\n@param `result` GTS Chunks, a list formed with its partial GTS.\n\n@param `resultEncoders` GTS Encoders Chunks, a list formed with its partial GTS Encoders.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"CHUNK"},{name:"CHUNKENCODER",detail:"GTSEncoder<GTSENCODER> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNKENCODER  result<LIST<GTSENCODER>>\nGTSEncoderList<LIST<GTSENCODER>> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNKENCODER  result<LIST<LIST<GTSENCODER>>>",documentation:"The `CHUNKENCODER` function is used to split a [GTSEncoder](/doc/NEWENCODER) into partial GTSEncoder. The user defines some parameters that will \nbe applied to the split operation. The series will be splitted in chunks, each chunks will form a new GTSEncoder, with a label value \ncorresponding to its first tick.\n\nDeprecated since 2.1, use CHUNK instead which behaves the same.\n\n@param `keepempty` If true empty chunk are kept\n\n@param `chunklabel` The label name of the label added by this split operation (add a value corresponding to the first tick of the chunk). Could be a regular expression.\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` A time overlap for each chunks in time units.\n\n@param `chunkwidth` The width in time unit of each chunks in time units.\n\n@param `lastchunkend` The split operation end when it encounters this timestamp.\n\n@param `GTSEncoder` A single GTSEncoder \n\n@param `GTSEncoderList` A GTSEncoder list to split, each GTSEncoder will be splitted individually.\n\n@param `result` GTSEncoder Chunks, a list formed with its partial GTSEncoder\n\n",tags:["encoder"],since:"1.2.9",OPB64name:"CHUNKENCODER"},{name:"CLEAR",detail:"input<ANY*>  CLEAR ",documentation:"The `CLEAR` function empties the stack.\n\n@param `input` all the input on the stack will be erased from the stack.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEAR"},{name:"CLEARDEFS",detail:"",documentation:"The `CLEARDEFS` function allows you to clear all [redefined WarpScript functions](/doc/DEF).\n\nBy default, all redefined WarpScript function, will not be available anymore. Set the `warpscript.def.unshadow` \nconfiguration property to change this behaviour.\n\nThis configuration parameter determines if undefining a function (via NULL 'XXX' DEF) will unshadow the original statement \nthus making it available again or if it will replace it with a function that will fail with a message saying the function is undefined.\nThe safest behavior is to leave this undefined or set to **false**.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEARDEFS"},{name:"CLEARREGS",detail:" CLEARREGS  value<ANY>",documentation:"Clears all registers, setting their current value to `NULL`.\n\n@param `value` Value from the designated register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"CLEARREGS"},{name:"CLEARSYMBOLS",detail:"",documentation:"The `CLEARSYMBOLS` function clears all symbols defined with the function [`STORE`](/doc/STORE).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEARSYMBOLS"},{name:"CLEARTOMARK",detail:"mark<MARK> inputs<ANY*>  CLEARTOMARK ",documentation:"Removes elements from the stack up to and including the first mark encountered.\n\n@param `inputs` all the inputs references on the stack will be erased\n\n@param `mark` the mark will also be erased\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEARTOMARK"},{name:"CLIP",detail:"gts<GTS> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<GTS>>\nlgts<LIST<GTS>> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<LIST<GTS>>>\nencoder<GTSENCODER> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<GTSENCODER>>\nlencoder<LIST<GTSENCODER>> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<LIST<GTS>>>",documentation:"The `CLIP` function clips a Geo Time Series™, encoders or list thereof according to a series of limits. The limits are lists of pair containing the lower and upper \ntimestamps used to clip. Each pair will generate a clipped GTS or encoder for each instance.\n\n@param `bounds` List of timestamp pairs. Each pair is a list of LONG.\n\n@param `gts` GTS to clip\n\n@param `lgts` List of GTSs to clip\n\n@param `encoder` Emcoder to clip\n\n@param `lencoder` List of encoders to clip\n\n@param `result` List of clipped GTS\n\n",tags:["gts"],since:"1.2.0",OPB64name:"CLIP"},{name:"CLONE",detail:"gts<GTS>  CLONE  original<GTS> clone<GTS>\nlist<LIST>  CLONE  original<LIST> clone<LIST>\nmap<MAP>  CLONE  original<MAP> clone<MAP>\nset<SET>  CLONE  original<SET> clone<SET>\nvector<VECTOR>  CLONE  original<VECTOR> clone<VECTOR>\nencoder<GTSENCODER>  CLONE  original<GTSENCODER> clone<GTSENCODER>",documentation:"The `CLONE` function does a shallow copy of a given Geo Time Series™, List, Map or Vector. Since 2.1.1 it can also clone Encoders.\n\nAs it makes a shallow copy, be careful when using CLONE on a List of Geo Time Series™ like those generated by the use of [`FETCH`](/doc/FETCH). Modifying a Geo Time Series™ in any of those list will alter the matching Geo Time Series™ in the other List.\nIf you want to use `CLONE` after a [`FETCH`](/doc/FETCH), you will need to extract the Geo Time Series™ from the list, for example by using [`LIST->`](/doc/I3_IK1oy), [`GET`](/doc/GET) or [`LMAP`](/doc/LMAP).\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `list` The List to clone\n\n@param `map` The Map to clone\n\n@param `set` The Set to clone\n\n@param `vector` The Vector to clone\n\n@param `encoder` The Encoder to clone\n\n@param `clone` The cloned Geo Time Series™, List, Map, Vector or Encoder\n\n@param `original` The original Geo Time Series™, List, Map, Vector or Encoder\n\n",tags:["gts","lists","maps"],since:"1.0.0",OPB64name:"CLONE"},{name:"CLONEEMPTY",detail:"gts<GTS>  CLONEEMPTY  result<GTS>\ngtsList<LIST<GTS>>  CLONEEMPTY  resultList<LIST<GTS>>\nencoder<GTSENCODER>  CLONEEMPTY  encoderResult<GTSENCODER>\nencoderList<LIST<GTSENCODER>>  CLONEEMPTY  encoderResultList<LIST<GTSENCODER>>",documentation:"Clones a Geo Time Series™, an Encoder or all the instances in a list of Geo Time Series™ or an Encoder, keeping only the metadata and not the values.\n\nThe `CLONEEMPTY` function takes as parameter a Geo Time Series™, an Encoder or a list thereof. It creates an empty clone of the input with only his metadata. The cloned metadata are:\n * Classname\n * Labels\n * Attributes\n * Lastbucket, for Geo Time Series™ only\n * Bucketspan, for Geo Time Series™ only\n * Bucketcount, for Geo Time Series™ only\n * Base timestamp, for Encoders only\n * Wrapping key, for Encoders only\n\nThe input parameter is consumed and the clone or list of clones is left on the stack.\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `gtsList` The list of Geo Time Series™ to clone\n\n@param `result` The cloned Geo Time Series™\n\n@param `resultList` The cloned list of Geo Time Series™\n\n@param `encoder` The encoder to clone\n\n@param `encoderList` The list of encoder to clone\n\n@param `encoderResult` The cloned encoder\n\n@param `encoderResultList` The cloned list of encoders\n\n",tags:["gts"],since:"1.0.0",OPB64name:"CLONEEMPTY"},{name:"CLONEREVERSE",detail:"input<LIST>  CLONEREVERSE  output<LIST>\ninput<STRING>  CLONEREVERSE  output<STRING>\ninput<BYTES>  CLONEREVERSE  output<BYTES>",documentation:"The function CLONEREVERSE clone the input and reverses the order of the elements. \nOutput is a reference to a new object.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n@param `input` reference of the list or string to reverse.\n\n@param `output` reference to a new reversed list or string or byte array.\n\n",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"CLONEREVERSE"},{name:"COMMONTICKS",detail:"gtsList<LIST<GTS>>  COMMONTICKS  result<LIST<GTS>>",documentation:"Take a list of Geo Time Series™ and output A GTS list with only the set of ticks they have in common compared by timestamp.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with common ticks\n\n",tags:["gts"],since:"1.0.0",OPB64name:"COMMONTICKS"},{name:"COMPACT",detail:"gts<GTS>  COMPACT  result<GTS>\ngtsList<LIST<GTS>>  COMPACT  resultList<LIST<GTS>>",documentation:"The `COMPACT` function expects a Geo Time Series™ or a **LIST** of GTS on top of the stack. For each GTS instance it reads, it will \nproduce a GTS whith fewer values, by removing measurements which have the same value, location and elevation as the previous one. The first tick will be the kept, then ticks with value or position change will be kept. The last tick from the original gts will be copied, in order to keep the same LASTTICK.\n\n@param `gts` A GTS to compact\n\n@param `gtsList` A GTS list to compact\n\n@param `result` A compacted GTS\n\n@param `resultList` A compacted GTS list\n\n",tags:["gts"],since:"1.0.0",OPB64name:"COMPACT"},{name:"CONTAINS",detail:"list<LIST> item<ANY>  CONTAINS  list<LIST> presence<BOOLEAN>\nset<SET> item<ANY>  CONTAINS  set<LIST> presence<BOOLEAN>\nstr<STRING> substr<STRING>  CONTAINS  presence<BOOLEAN>",documentation:"The `CONTAINS` function checks if the element on top of the stack is contained by the list on second position. A boolean is pushed on the stack.\n\nIf the parameters are two STRINGs, `CONTAINS` checks if the second STRING is contained in the first one, leaving a boolean on the stack. This latter usage is available since revision 2.1.0.\n\n@param `item` Depending on list construction, could be a number, a string, a boolean, NULL, a GTS...\n\n@param `presence` true if inputlist contains the item. false otherwise or if inputlist is empty.\n\n@param `list` reference to the LIST to search.\n\n@param `set` reference to the SET to search.\n\n@param `str` STRING in which to find `substr`.\n\n@param `substr` STRING to find in `str`.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"CONTAINS"},{name:"CONTAINSKEY",detail:"inputmap<MAP> key<ANY>  CONTAINSKEY  outputmap<MAP> presence<BOOLEAN>",documentation:"The `CONTAINSKEY` function checks if the key element on top of the stack is a key \nof the map on second position. \n\nThe key is consumed, and a boolean is pushed on the stack.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this key. Do not trust presence if key is NULL.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSKEY"},{name:"CONTAINSVALUE",detail:"inputmap<MAP> value<ANY>  CONTAINSVALUE  outputmap<MAP> presence<BOOLEAN>",documentation:"The `CONTAINSVALUE` function checks if the value element on top of the stack is a value \nof the map on second position. \n\nThe value is consumed, and a boolean is pushed on the stack.\n\n@param `value` Depending on map construction, could be a number, a string, a boolean, NULL.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this value in at least one pair of its key-value.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSVALUE"},{name:"CONTINUE",detail:"",documentation:"Immediately stop executing the current iteration of an ongoing loop and start the next one.\n\n",tags:["logic","control"],since:"1.0.0",OPB64name:"CONTINUE"},{name:"COPYGEO",detail:"gts<GTS> geogts<GTS>  COPYGEO  result<GTS>\ngtsList<LIST<GTS>> geogts<GTS>  COPYGEO  resultList<LIST<GTS>>",documentation:"The `COPYGEO` function forces the location elements of a GTS onto others. `COPYGEO` expects two parameters on the stack.\nFirst input is GTS or a gts list: those series(s) will have their location overwritten by the one of the second GTS parameter. Geo information will be copied only if they are present in the second paramaters on the same tick otherwise it keep the existing location. See [`COMMONTICKS`](/doc/COMMONTICKS) to keep only commonticks before calling `COPYGEO`.\n\n@param `gts` A GTS\n\n@param `gtsList` A list of GTS\n\n@param `geogts` A GTS with the geo information you want to copy to other (list of) gts.\n\n@param `result` A GTS with the geo information of the geogts input\n\n@param `resultList` A list of GTS with the geo information of the geogts input\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"COPYGEO"},{name:"COPYSIGN",detail:"p1<NUMBER> p2<NUMBER>  COPYSIGN  result<DOUBLE>\np1<NUMBER> list2<LIST<NUMBER>>  COPYSIGN  lresult<LIST<DOUBLE>>\nlist1<LIST<NUMBER>> p2<NUMBER>  COPYSIGN  lresult<LIST<DOUBLE>>",documentation:"The `COPYSIGN` function copies the sign of a number on another one and pushes back the value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` Numeric parameter on which sign is applied\n\n@param `p2` Numeric parameter on which sign is extracted\n\n@param `list1` List of numeric parameter on wich sign is applied\n\n@param `list2` List of numeric parameter on wich sign is extracted\n\n@param `result` Value of p1 with the sign of p2 s a DOUBLE\n\n@param `lresult` List of results\n\n",tags:["math"],since:"1.0.0",OPB64name:"COPYSIGN"},{name:"CORRELATE",detail:"baseGTS<GTS> gtsList<LIST> timeOffsets<LIST>  CORRELATE  result<LIST<GTS>>",documentation:"The `CORRELATE` function allows you to compute correlation between one base Geo Time Series™ and a set of others. \nBy putting the base GTS in the set of others, cross correlation can be computed.\n\n@param `baseGTS` The base Geo Time Series\n\n@param `gtsList` A list of Geo Time Series against which to compute the correlation\n\n@param `timeOffsets` A list of time offsets for which the correlation will be computed (expressed in time units of the Warp instance)\n\n@param `result` A list of synthetic Geo Time Series™ whose timestamps are the offsets from the initial offset list and the values are the computed correlations. There is one GTS per GTS in the list at TOP-1.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"CORRELATE"},{name:"COS",detail:"value<NUMBER>  COS  result<DOUBLE>\nlvalue<LIST<NUMBER>>  COS  lresult<LIST<DOUBLE>>",documentation:"The `COS` function consumes a floating point number from the top of the stack and pushes back its cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Cosine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of cosine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COS"},{name:"COSH",detail:"value<NUMBER>  COSH  result<DOUBLE>\nlvalue<LIST<NUMBER>>  COSH  lresult<LIST<DOUBLE>>",documentation:"The `COSH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic cosine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic cosine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COSH"},{name:"COUNTER",detail:" COUNTER  counter<COUNTER>",documentation:"The `COUNTER` function pushes a counter (AtomicLong) initialized with the value 0 onto the stack.\n\nThis atomic counter can be safely shared in multiple concurrent macros (see [`CEVAL`](/doc/CEVAL)).\n\n@param `counter` Counter instance.\n\n",tags:["counters"],since:"1.0.0",OPB64name:"COUNTER"},{name:"COUNTERDELTA",detail:"counter<COUNTER> increment<LONG>  COUNTERDELTA  counter<COUNTER>",documentation:"The `COUNTERDELTA` function increments a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `increment` Counter increment.\n\n",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERDELTA"},{name:"COUNTERSET",detail:"counter<COUNTER> value<LONG>  COUNTERSET  counter<COUNTER>",documentation:"The `COUNTERSET` function set the value of a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `value` Counter value.\n\n",tags:["counters"],since:"1.2.22",OPB64name:"COUNTERSET"},{name:"COUNTERVALUE",detail:"counter<COUNTER>  COUNTERVALUE  value<LONG>",documentation:"The `COUNTERVALUE` function pushes the counter value onto the stack.\n\n@param `counter` The counter instance.\n\n@param `value` The value of the counter.\n\n",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERVALUE"},{name:"COUNTTOMARK",detail:" COUNTTOMARK  result<LONG>",documentation:"Counts the number of elements on the stack up to but excluding the first mark encountered. Neither the mark nor the\nelements on top of it are removed from the stack.\n\n@param `result` Stack depth until `MARK`\n\n",tags:["stack"],since:"1.0.0",OPB64name:"COUNTTOMARK"},{name:"CPOPR",detail:"value<ANY>  CPOPR ",documentation:"Pops a value from the top of the stack and stores it into the designated register if the register is empty (*i.e.* has `NULL` as its current value).\n\nThe `CPOPR` function is really a family of functions named `CPOPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"CPOPR"},{name:"CPROB",detail:"gts<GTS> separator<STRING>  CPROB  result<GTS>\nlgts<LIST<GTS>> separator<STRING>  CPROB  lresult<LIST<GTS>>",documentation:"The function `CPROB` generates a new Geo Time Series™ from an input Geo Time Series™ by computing a conditional probability.\n\nThe function expects a **STRING** separator on top of the stack and expects the input Geo Time Series™ to have \nvalues of the form given1< SEP >given2< SEP >....< SEP >event. It will then emit P(event|given1,given2,...).\n\nIf the separator is **NULL**, `CPROB` behaves like [`PROB`](/doc/PROB).\n\n@param `separator` Value separator\n\n@param `gts` Geo Time Series™\n\n@param `lgts` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `lresult` List of Geo Time Series™\n\n",tags:["gts"],since:"1.0.6",OPB64name:"CPROB"},{name:"CROP",detail:"gts<GTS>  CROP  result<GTS>\ngtsList<LIST<GTS>>  CROP  resultList<LIST<GTS>>",documentation:"The `CROP` function works on bucketized Geo Time Series™ instances, if transforms a GTS into another one whose bucketcount, last bucket parameters span the smallest interval with actual values. Bucket span remains the same.\n\nWhen called on a non bucketized GTS instance, `CROP` simply clones it.\n\nThis function expects a list of GTS instances on the top of the stack.\n\n@param `gts` Bucketized GTS\n\n@param `result` ropped version of GTS or a clone thereof if GTS was not bucketized.\n\n@param `gtsList` List of bucketized GTS\n\n@param `resultList` A list of cropped version of GTS or a clone thereof if GTS was not bucketized.\n\n",tags:["bucketize"],since:"1.0.0",OPB64name:"CROP"},{name:"CSTORE",detail:"value<ANY> symbol<STRING>  CSTORE \nvalue<ANY> register<LONG>  CSTORE ",documentation:"The `CSTORE` function stores a value in a symbol or a register only if that symbol or register is not yet defined. The name of this function stands for Conditional STORE.\n\n@param `symbol` Name of symbol under which to store `value`.\n\n@param `register` Number of the register under which to store `value`.\n\n@param `value` Value to store unde `symbol`.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CSTORE"},{name:"CUDF",detail:"class<STRING>  CUDF ",documentation:"The `CUDF` function invokes a User Defined Function from a Jar as [`UDF`](/doc/UDF) but reuses a cached instance of the function.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",tags:["control"],since:"1.0.0",OPB64name:"CUDF"},{name:"DEBUGOFF",detail:"",documentation:"Turns off stack debugging which was turned on by [`DEBUGON`](/doc/DEBUGON) or [`NDEBUGON`](/doc/NDEBUGON).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGOFF"},{name:"DEBUGON",detail:"",documentation:"Turns on stack debugging which returns the stack content in case of error. Stack debugging is off by default.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGON"},{name:"DECREMENTEXACT",detail:"value<NUMBER>  DECREMENTEXACT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  DECREMENTEXACT  lresult<LIST<DOUBLE>>",documentation:"The `DECREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value decremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be decremented by one\n\n@param `result` The decremented value\n\n@param `lvalue` List of values to be decremented by one\n\n@param `lresult` List of decremented values\n\n",tags:["math"],since:"1.2.23",OPB64name:"DECREMENTEXACT"},{name:"DEDUP",detail:"gts<GTS>  DEDUP  result<GTS>\ngts<GTS> mapper<AGGREGATOR>  DEDUP  lresult<GTS>\ngts<GTS> macro<MACRO>  DEDUP  lresult<GTS>\nlgts<LIST<GTS>>  DEDUP  lresult<LIST<GTS>>\nlgts<LIST<GTS>> mapper<AGGREGATOR>  DEDUP  lresult<LIST<GTS>>\nlgts<LIST<GTS>> macro<MACRO>  DEDUP  lresult<LIST<GTS>>",documentation:"Removes duplicate ticks.\n\nThe `DEDUP` function consumes a Geo Time Series™ or a **LIST** thereof from the top of the stack and pushes back the Geo Time Series™ with deduplicated ticks.\n\nSince the 2.7.0 version, this function can be given an optional mapper or macro to combine the duplicate data points.\n\n@param `gts` The Geo Time Series™ to deduplicate\n\n@param `result` The Geo Time Series™ with deduplicated ticks\n\n@param `lgts` The list of Geo Time Series™ to deduplicate\n\n@param `lresult` The list of Geo Time Series™ with deduplicated ticks\n\n@param `mapper` Mapper used to aggregate duplicate values\n\n@param `macro` Macro used to aggregate duplicate values given as a GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"DEDUP"},{name:"DEF",detail:"newDef<MACRO> name<STRING>  DEF ",documentation:"The `DEF` function allows you to define new WarpScript functions or redefine existing ones for the duration of your script execution.\n\nThe function expects on the stack a macro which will be used as the content of the newly defined function, and a name under which to define the new function.\n\nWhen redefining a function, if the function being redefined is used within the macro, the code which will be executed is the current one, \nas the binding of function to code is done at the time when the macro is defined and not when it is executed.\n\nYou may therefore add limits to the use of an existing function by rewrapping it in a macro which will be associated with the original function name.\n\nTo remove redefined functions see [`CLEARDEFS`](/doc/CLEARDEFS).\n\n@param `name` New function name\n\n@param `newDef` Macro which will be used as the content of the newly defined function\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEF"},{name:"DEFINED",detail:"name<STRING>  DEFINED  result<BOOLEAN>",documentation:"The `DEFINED` function checks whether or not a symbol is defined.\n\n@param `name` Symbol name\n\n@param `result` Whether or not the symbol is defined\n\n",tags:["logic","control"],since:"1.0.0",OPB64name:"DEFINED"},{name:"DEFINEDMACRO",detail:"name<STRING>  DEFINEDMACRO  result<BOOLEAN>",documentation:"The `DEFINEDMACRO` function checks if a macro is defined and pushes true or false on the stack accordingly.\n\n@param `name` The macro name\n\n@param `result` True if the macro is defined, false otherwise\n\n",tags:["logic","control"],since:"1.0.16",OPB64name:"DEFINEDMACRO"},{name:"DEFLATE",detail:"string<STRING>  DEFLATE  compressed<BYTES>\nbytes<BYTES>  DEFLATE  compressed<BYTES>",documentation:"The `DEFLATE` function compresses a STRING or a byte array using the [Zlib](https://en.wikipedia.org/wiki/Zlib) library. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",tags:["conversion"],since:"2.1.0",OPB64name:"DEFLATE"},{name:"DELETE",detail:"writeToken<STRING> gts_selector<STRING> start_timestamp<LONG> end_timestamp<LONG> count<LONG>  DELETE  result<LONG>",documentation:"The `DELETE` function is used to delete a set of GTS from a Warp 10 platform. A delete endpoint must be set on the Warp 10 configuration.\n\nDelete expects 5 parameters on top of the stack: the write token of the Warp 10 application, a string corresponding to a gts selector, a start \nand a end timestamp and finally the number of GTS expected to be deleted.\n\nFor safety reasons `DELETE` will first perform a dryrun call to the /delete endpoint to retrieve the number of GTS which would be deleted by the call. \nIf this number is above the expected number provided by the user the actual delete will not be performed and instead an error will be raised.\n\nDelete will push as a result the number of GTS really deleted.\n\nIf both end_timestamp and start_timestamp are NULL, Warp 10 will perform a delete all. FETCH won't find anything after a delete all.\n\n```flow\n// Write token\n'TOKEN'\n\n// Gts selector\n'gts.to.delete{}'\n\n// Start Timestamp\n1479372838011043\n\n// End timestamp\nNOW\n\n// DELETE expects a count number (if nb GTS > count, DELETE is stopped)\n1\n\nDELETE \n```\n\n@param `count` Number of GTS expected to be deleted\n\n@param `end_timestamp` End timestamp or NULL\n\n@param `start_timestamp` Start timestamp or NULL\n\n@param `gts_selector` GTS selector\n\n@param `writeToken` Write token\n\n@param `result` Actual deleted GTS count\n\n",tags:["gts"],since:"1.0.5",OPB64name:"DELETE"},{name:"DELETEOFF",detail:"message<STRING> secret<STRING>  DELETEOFF ",documentation:"Disables delete operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a delete operation is attempted.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"DELETEOFF"},{name:"DELETEON",detail:"secret<STRING>  DELETEON ",documentation:"Enables delete operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"DELETEON"},{name:"DEPTH",detail:" DEPTH  result<LONG>",documentation:"The `DEPTH` function pushes on top of the stack the depth (i.e. number of levels) of the stack prior to the call.\n\n@param `result` Stack depth\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEPTH"},{name:"DEREF",detail:"macro<MACRO> values<MAP>  DEREF  macro<MACRO>",documentation:"Replaces in a Macro the occurrences of symbol dereferencing (`$x`) or calls to `LOAD` with a `STRING` argument or calls to `PUSHRx` by the values associated with either the symbol name or register number in a parameter map.\n\nValues are used verbatim except for Macros which are inserted as functions, *i.e.* they are inserted followed by a call to `EVAL` so they are executed in the target macro instead of ending up on the stack. If you wish to replace a symbol dereference by a Macro, you need to write the macro inside of another Macro.\n\n\n@param `macro` Macro to transform.\n\n@param `values` Map of symbol name or register number to replacement value.\n\n",tags:["stack"],since:"2.3.0",OPB64name:"DEREF"},{name:"DET",detail:"matrix<MATRIX>  DET  det<DOUBLE>",documentation:"Computes the [determinant](https://en.wikipedia.org/wiki/Determinant) of a matrix.\n\n@param `matrix` The matrix for which to compute the determinant.\n\n@param `det` The computed determinant.\n\n",tags:["math"],since:"1.0.6",OPB64name:"DET"},{name:"DIFFERENCE",detail:"setA<SET> setB<SET>  DIFFERENCE  output<SET>",documentation:"Computes the difference between two sets.\n\nThe `DIFFERENCE` function consumes two sets from the top of the stack and pushes back its mathematical difference (ie: the elements in *A* but not in *B*).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* - *B*, the set of elements in *A* but not in *B*\n\n",tags:["sets"],since:"1.0.0",OPB64name:"DIFFERENCE"},{name:"DISCORDS",detail:"lgts<LIST<GTS>> wsize<LONG> length<LONG> scale<LONG> maximum<LONG> overlapping<BOOLEAN> distance<DOUBLE>  DISCORDS  lresult<LIST<GTS>>\ngts<GTS> wsize<LONG> length<LONG> scale<LONG> maximum<LONG> overlapping<BOOLEAN> distance<DOUBLE>  DISCORDS  result<GTS>",documentation:"The `DISCORDS` function detects discords in a Geo Time Series™. The discord detection algorithm is based on identifying outlier patterns in\nthe Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `DISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0\n\n@param `overlapping` Flag indicating whether or not the `DISCORDS` function should report overlapping discords\n\n@param `maximum` The maximum number of discords to identify\n\n@param `lresult` The list of Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `result` The Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"DISCORDS"},{name:"DOC",detail:"string<STRING>  DOC  string<STRING>",documentation:"Consumes the String on the stack or leave it there and stop the script if the stack is currently in documentation mode ([`DOCMODE`](/doc/DOCMODE)) \n\nYou can use it to document macros.\n\n@param `string` Text to display in [`DOCMODE`](/doc/DOCMODE)\n\n",tags:["help"],since:"1.0.0",OPB64name:"DOC"},{name:"DOCMODE",detail:"",documentation:"Toggle the 'documentation mode' of the stack\n\n",tags:["help"],since:"1.0.0",OPB64name:"DOCMODE"},{name:"DOUBLEBITS->",detail:"input<LONG>  DOUBLEBITS->  result<DOUBLE>",documentation:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the **LONG** value as the raw bits of the **DOUBLE**\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",tags:["conversion","binary"],since:"1.2.3",OPB64name:"G3xKFZl4FZ_JJmoy"},{name:"DOUBLEEXPONENTIALSMOOTHING",detail:"gts<GTS> alpha<DOUBLE> beta<DOUBLE>  DOUBLEEXPONENTIALSMOOTHING  result<LIST<GTS>>",documentation:"The `DOUBLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Double Exponential Smoothing aka Holt's linear trend method](https://www.otexts.org/fpp/7/2) formula.\n\nIt consumes three parameters from the top of the stack:\n * A trend smoothing factor beta (a numeric parameter between 0 < beta < 1)\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** and levels are pushed onto the stack (in this order in the **LIST**).\n\n@param `beta` The trend smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The list within the smoothed Geo Time Series™ and its levels\n\n",tags:["gts","statistics"],since:"1.0.0",OPB64name:"DOUBLEEXPONENTIALSMOOTHING"},{name:"DROP",detail:"input<ANY>  DROP ",documentation:"The `DROP` function removes the element at the top of the stack.\n\n@param `input` object reference to drop from the top of the stack.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DROP"},{name:"DROPN",detail:"number<NUMBER>  DROPN ",documentation:"The `DROPN` function removes the top N elements of the stack after having consumed N which was on the top of the stack prior to calling `DROPN`.\n\n@param `number` The number of elements to drop\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DROPN"},{name:"DTW",detail:"gts1<GTS> gts2<GTS> threshold<DOUBLE>  DTW  dtw<DOUBLE>",documentation:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) or -1 if the threshold was reached.\n\n",tags:["gts","distance"],since:"1.0.0",OPB64name:"DTW"},{name:"DUP",detail:"input<ANY>  DUP  input<ANY> out<ANY>",documentation:"The `DUP` function duplicates the element on the top of the stack, it doesn’t copy the content. If you apply DUP to a GTS you will\nhave two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `input` any parameter on top of the stack\n\n@param `out` a reference copy of input on top of the stack\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DUP"},{name:"DUPN",detail:"number<NUMBER>  DUPN ",documentation:"The `DUPN` function duplicates the top N elements of the stack after having consumed N which is on the top of the stack when calling `DUPN`.\n\nAs the [`DUP`](/doc/DUP) function, `DUPN` duplicates the references of the N elements on the top of the stack, it doesn’t copy the elements.\nIf you apply `DUPN` to a GTS you will have two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `number` The number of elements to duplicate\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DUPN"},{name:"DURATION",detail:"isoDuration<STRING>  DURATION  duration<LONG>",documentation:"The `DURATION` function consumes a **STRING** representing an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) and pushes back a **LONG** duration in platform time unit.\n\nThe ISO 8601 duration can be expessed as `PwWdDThHmMsS` with:\n- `w` weeks\n- `d` days\n- `h` hours\n- `m` minutes\n- `s` or `s.ssssss...` seconds\nEach of these values can be either positive or negative. Each value/unit couple can be omitted if the value is zero but at least one value/couple should be defined.\n\nIf the consumed ISO 8601 duration has precision under platform time unit, superfluous digits will be ignored. Prior to revision 2.4, precision below milliseconds were always ignored, independently of platform time unit.\n\n@param `isoDuration` A representation of a ISO 8601 duration with some limitations, see the description.\n\n@param `duration` Number of platform time unit corresponding to the duration.\n\n",tags:["time"],since:"1.0.0",OPB64name:"DURATION"},{name:"DWTSPLIT",detail:"gts<GTS> label-name<STRING>  DWTSPLIT  result<GTS>\nlgts<LIST<GTS>> label-name<STRING>  DWTSPLIT  lresult<LIST<GTS>>",documentation:"The `DWTSPLIT` function splits a Geo Time Series™ produced by [`FDWT`](/doc/FDWT) into multiple series, one per resolution level of the Wavelet transform.\n\n\n@param `label-name` Label name used in the generated series to indicate the level of each Geo Time Series™\n\n@param `gts` GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `lgts` List of GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `result` Splited GTS\n\n@param `lresult` List of splited GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"DWTSPLIT"},{name:"E",detail:" E  eValue<DOUBLE>",documentation:"Alias of [e](/doc/OF).\n\nThe `E` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"GF"},{name:"ECGEN",detail:"curve<STRING>  ECGEN  private<MAP> public<MAP>",documentation:"The `ECGEN` function generates a public/private key pair parameters suitable for performing [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n\nThe resulting parameters can serve as input to [`ECPRIVATE`](/doc/ECPRIVATE) and [`ECPUBLIC`](/doc/ECPUBLIC) to generate the actual private and public keys.\n\nThe following curves are supported:\n\n`c2pnb272w1`, `c2tnb191v3`, `c2pnb208w1`, `c2tnb191v2`, `c2tnb191v1`, `prime192v3`, `c2tnb359v1`, `prime192v2`, `prime192v1`, `c2tnb239v3`, `c2pnb163v3`, `c2tnb239v2`, `c2pnb163v2`, `c2tnb239v1`, `c2pnb163v1`, `c2pnb176w1`, `prime256v1`, `c2pnb304w1`, `c2pnb368w1`, `c2tnb431r1`, `prime239v3`, `prime239v2`, `prime239v1`, `sect233r1`, `secp112r2`, `secp112r1`, `secp256k1`, `sect113r2`, `secp521r1`, `sect113r1`, `sect409r1`, `secp192r1`, `sect193r2`, `sect131r2`, `sect193r1`, `sect131r1`, `secp160k1`, `sect571r1`, `sect283k1`, `secp384r1`, `sect163k1`, `secp256r1`, `secp128r2`, `secp128r1`, `secp224k1`, `sect233k1`, `secp160r2`, `secp160r1`, `sect409k1`, `sect283r1`, `sect163r2`, `sect163r1`, `secp192k1`, `secp224r1`, `sect239k1`, `sect571k1`, `B-163`, `P-521`, `P-256`, `B-233`, `P-224`, `B-409`, `P-384`, `B-283`, `B-571`, `P-192`, `brainpoolp512r1`, `brainpoolp384t1`, `brainpoolp256r1`, `brainpoolp192r1`, `brainpoolp512t1`, `brainpoolp256t1`, `brainpoolp224r1`, `brainpoolp320r1`, `brainpoolp192t1`, `brainpoolp160r1`, `brainpoolp224t1`, `brainpoolp384r1`, `brainpoolp320t1`, `brainpoolp160t1`\n\n@param `curve` Name of the elliptic curve to use.\n\n@param `public` Map containing the public key parameters.\n\n@param `private` Map containing the private key parameters.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECGEN"},{name:"ECHOOFF",detail:" ECHOOFF ",documentation:"Turns off the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"ECHOOFF"},{name:"ECHOON",detail:"levels<NUMBER>  ECHOON ",documentation:"Turns on the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of topmost stack levels to display after each WarpScript™ line, truncated if floating-point.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"ECHOON"},{name:"ECPRIVATE",detail:"private<MAP>  ECPRIVATE  key<KEY>",documentation:"The `ECPRIVATE` function generates a private key from private key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `private` Map containing ECC private key parameters.\n\n@param `key` ECC private key.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECPRIVATE"},{name:"ECPUBLIC",detail:"public<MAP>  ECPUBLIC  key<KEY>",documentation:"The `ECPUBLIC` function generates a public key from public key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `public` Map containing ECC public key parameters.\n\n@param `key` ECC public key.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECPUBLIC"},{name:"ECSIGN",detail:"data<BYTES> alg<STRING> private<KEY>  ECSIGN  signature<BYTES>",documentation:"The `ECSIGN` function generates a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) private key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Content to sign.\n\n@param `alg` Signing algorithm to use.\n\n@param `private` Private key to use for signining.\n\n@param `signature` Resulting signature.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECSIGN"},{name:"ECVERIFY",detail:"data<BYTES> signature<BYTES> alg<STRING> public<KEY>  ECVERIFY  result<BOOLEAN>",documentation:"The `ECVERIFY` function verifies a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) public key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Signed data.\n\n@param `alg` Signing algorithm to use.\n\n@param `public` Public key to use for verification.\n\n@param `signature` Signature to verify.\n\n@param `result` Validity of the signature.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECVERIFY"},{name:"ELAPSED",detail:" ELAPSED  result<LIST<LONG>>",documentation:"The `ELAPSED` function pushes onto the stack a list containing timing informations. The first element of the list is the timestamp at which \nthe script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution \nof the associated script line.\n\nTiming informations are only collected after a call to [`TIMINGS`](/doc/TIMINGS) (its line included) and before a call to [`NOTIMINGS`](/doc/NOTIMINGS)\n (its line excluded).\n\n@param `result` The first element of the list is the timestamp at which the script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution of the associated script line.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ELAPSED"},{name:"ELEVATIONS",detail:"gts<GTS>  ELEVATIONS  elevations<LIST<LONG>>\nlgts<LIST<GTS>>  ELEVATIONS  lelevations<LIST<LIST<LONG>>>",documentation:"The `ELEVATIONS` function consumes a Geo Time Series™ or a list thereof from the stack, extracts its elevations, puts them in a list and pushes the list onto the stack.      \n\n@param `gts` The Geo Time Series™ from which to extract the elevations\n\n@param `lgts` The list of Geo Time Series™ from which to extract the elevations\n\n@param `elevations` The elevations of the given Geo Time Series™\n\n@param `lelevations` The list of elevations of the given Geo Time Series™\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"ELEVATIONS"},{name:"EMPTY",detail:"gtsList<LIST<GTS>>  EMPTY  result<LIST<GTS>>",documentation:"Reject GTS instances with values.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with empty values\n\n",tags:["gts"],since:"1.2.5",OPB64name:"EMPTY"},{name:"ENCODER->",detail:"encoder<GTSENCODER>  ENCODER->  name<STRING> attributes<MAP> labels<MAP> output<LIST>\nwrappedinput<STRING>  ENCODER->  name<STRING> attributes<MAP> labels<MAP> output<LIST>\nrawwrappedinput<BYTES>  ENCODER->  name<STRING> attributes<MAP> labels<MAP> output<LIST>",documentation:"The `ENCODER->` functions convert an encoder into a list of ( timestamp, latitude, longitude, elevation, value ) list. It also pushes attributes, labels and name on the stack.\nFunction also accepts wrapped or raw-wrapped encoders or gts.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedinput` Encoder or GTS after WRAP. \n\n@param `rawwrappedinput` Encoder or GTS after WRAPRAW.\n\n@param `output` List of list of ( timestamp, latitude, longitude, elevation, value ). Missing values in the encoder or GTS are replaced by NaN.\n\n@param `name` Name of encoder or GTS. If no name was defined, will be NULL.\n\n@param `attributes` Attributes of encoder or GTS input. If none defined, will be an empty map.\n\n@param `labels` Labels of encoder or GTS input. If none defined, will be an empty map.\n\n",tags:["encoder","conversion","gts"],since:"1.2.9",OPB64name:"GJt2IoG4JXoy"},{name:"ERROR",detail:" ERROR  error<LIST<MAP>>",documentation:"Pushes onto the stack a list containing the current error (as caught by a [`TRY`](/doc/TRY)) and its causes. Each error is a map with the following fields:\n\n| Field | Description |\n| --- | --- |\n| type | Type of the error, the Java class of the underlying exception |\n| message | The message associated with the error |\n| stacktrace | A list of lists, each containing `filename`, `line number`, `class name`, `method name` |      \n\nThe current error is the first element of the list.\n\nIf there is no current error, the returned list will be empty.\n\n@param `error` List of maps describing the current error and its causes.\n\n",tags:["stack"],since:"1.2.11",OPB64name:"ERROR"},{name:"ESDTEST",detail:"gts<GTS> k<LONG> mad<BOOLEAN> alpha<DOUBLE>  ESDTEST  result<LIST<LONG>>\ngts<GTS> k<LONG> mad<BOOLEAN>  ESDTEST  result<LIST<LONG>>\ngtsList<LIST<GTS>> k<LONG> mad<BOOLEAN> alpha<DOUBLE>  ESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> k<LONG> mad<BOOLEAN>  ESDTEST  resultList<LIST<LIST<LONG>>>",documentation:"The `ESDTEST` function detects outliers in a GTS (or a **LIST** of GTS), by applying a [generalized extreme studentized deviate test](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm).\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nA [Grubbs’](/doc/GRUBBSTEST)test is done for one candidate at a time. Then, the candidate is removed from the set and another [Grubbs’](/doc/GRUBBSTEST)test\nis performed. This process is iterated a given number of times. The detected outliers are the removed values and the current candidate of the last successful\ntest.\n\nA **LIST** of ticks (or a **LIST** of **LIST** of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ESDTEST"},{name:"EVAL",detail:"macro<MACRO>  EVAL \nstring<STRING>  EVAL ",documentation:"The `EVAL` function evaluates the statements contained in the string at the top of the stack as if they had been entered individually or runs the macro at the top os the stack.\n\n@param `string` String to evaluate\n\n@param `macro` Macro to run\n\n",tags:["control"],since:"1.0.0",OPB64name:"EVAL"},{name:"EVALSECURE",detail:"secure<STRING>  EVALSECURE  return<ANY>",documentation:"The `EVALSECURE` function executes a secure script. The script must have been created on a platform with the same secure script cryptographic key as the current platform (note that this is not the *secret* set using [`SECUREKEY`](doc/SECUREKEY)).\n\n@param `secure` String containing the secure script to execute.\n\n@param `return` The return values depend on the actual code of the secure script.\n\n",tags:["crypto","stack"],since:"1.0.0",OPB64name:"EVALSECURE"},{name:"EVERY",detail:"macro<MACRO> repeat<LONG>  EVERY ",documentation:"When called via the `/mobius` endpoint, the `EVERY` function sets the repeat interval for the preceding macro.\n\nWhen called outside of `/mobius`, the `EVERY` function simply executes the macro.\n\n@param `repeat` The repeat interval to enforce, in milliseconds.\n\n@param `macro` The macro to execute.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"EVERY"},{name:"EXP",detail:"value<NUMBER>  EXP  result<DOUBLE>\nlvalue<LIST<NUMBER>>  EXP  lresult<LIST<DOUBLE>>",documentation:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a floating point value x consumed from the top of the stack,\n i.e. e<sup>x</sup>.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List where each value is e<sup>x</sup>\n\n",tags:["math"],since:"1.0.0",OPB64name:"EXP"},{name:"EXPM1",detail:"value<NUMBER>  EXPM1  result<DOUBLE>\nlvalue<LIST<NUMBER>>  EXPM1  lresult<LIST<DOUBLE>>",documentation:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a DOUBLE value x consumed from the top of the stack then subtracts one, i.e. e<sup>x</sup>-1.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>-1\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List of e<sup>x</sup>-1\n\n",tags:["math"],since:"1.0.0",OPB64name:"EXPM1"},{name:"EXPORT",detail:"symbol<STRING>  EXPORT \nsymbols<LIST>  EXPORT ",documentation:"The `EXPORT` function allows you to set or update a list of symbols which will be dumped upon script termination. This proves handy when \ndebugging a script as you can visualize, even in the case of errors, the value of specific symbols.\n\nThe function expects either a symbol name (a **STRING**) which will be added to the current list of exported symbols, a list of symbol \nname which will replace the current list of exported symbols, an empty list to disable symbol export altogether, or a list with a single\n**NULL** element to instruct the WarpScript engine to export all existing symbols.\n\nWhen symbols should be exported, the debug mode is implied (see [`DEBUGON`](/doc/DEBUGON)).\n\n@param `symbol` Symbol name\n\n@param `symbols` List of symbols\n\n",tags:["stack","debug"],since:"1.0.2",OPB64name:"EXPORT"},{name:"EXTLOADED",detail:"ext<STRING>  EXTLOADED  loaded<BOOLEAN>",documentation:"Checks if a WarpScript extension is loaded or not and therefore available.      \n\n@param `ext` Name of extension to check.\n\n@param `loaded` Boolean indicating whether or not the specified extension is loaded in the WarpScript environment.\n\n",tags:["stack"],since:"1.2.13",OPB64name:"EXTLOADED"},{name:"F",detail:" F  b<BOOLEAN>",documentation:"`F` stand for `false`. It is a boolean constant.\n\n\n@param `b` false\n\n",tags:["logic","constants"],since:"1.0.0",OPB64name:"F"},{name:"FAIL",detail:"",documentation:"The `FAIL` function stops the execution of the WarpScript scripts by throwing an exception.\n\n",tags:["control"],since:"1.0.0",OPB64name:"FAIL"},{name:"FDWT",detail:"gts<GTS> wavelet<STRING>  FDWT  fdwt<GTS>\nlgts<LIST<GTS>> wavelet<STRING>  FDWT  lfdwt<LIST<GTS>>",documentation:"The `FDWT` function performs a [Forward Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Fast_wavelet_transform#Forward_DWT) on a Geo Time Series™.\n\nA number of different [Wavelets](https://en.wikipedia.org/wiki/Wavelet) are available, the list is inspired by that available on \nthe [Wavelet Browser](http://wavelets.pybytes.com/).\n\nThe list of Wavelets which can be used is the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\nThe FDWT can only be applied to Geo Time Series™ with a number of values which is a power of 2.\n\nAssuming the input GTS has 2<sup>n</sup> values, the result of the FDWT transformation is a GTS with 2<sup>n</sup> values (the wavelet coefficients) with timestamps from 0 to 2<sup>n</sup>-1.\n\nThe ticks of the `n` levels are contiguous, with the first tick being for level `n`, the next 2 for level `n-1`, the next 4 for level `n-2`, up to the last 2<sup>n-1</sup> for level 1.\n\nLevel 1 has the finest time resolution but the coarsest frequency resolution. Each level has half (coarser) the time resolution and double (finer) the frequency resolution as the previous level.\n\n@param `wavelet` Name of wavelet to use for the transformation.\n\n@param `gts` Geo Time Series™ instance on which to perform the FDWT.\n\n@param `lgts` List of Geo Time Series™ on which to apply the FDWT.\n\n@param `fdwt` Transformed Geo Time Series™.\n\n@param `lfdwt` List of transformed Geo Time Series™.\n\n",tags:["math","gts"],since:"1.0.0",OPB64name:"FDWT"},{name:"FETCH",detail:"[ token<STRING> class<STRING> labels<MAP> end<LONG> timespan<LONG> ]  FETCH  data<LIST<GTS>>\n[ token<STRING> class<STRING> labels<MAP> start<STRING> end<STRING> ]  FETCH  data<LIST<GTS>>\n{ token<STRING> class<STRING> labels<MAP> end<LONG> start<STRING> timespan<LONG> count<LONG> selector<STRING> selectors<LIST<STRING>> metaset<STRING> type<STRING> typeattr<STRING> extra<LIST<STRING>> active.after<LONG> quiet.after<LONG> gts<LIST<GTS>> boundary.post<LONG> boundary.pre<LONG> boundary<LONG> skip.count<LONG> sampling.ratio<DOUBLE>  } FETCH  data<LIST<GTS>>",documentation:"The `FETCH` function interacts with the Warp 10 Storage Engine to retrieve data according to given criteria.\n\n`FETCH` either accepts a list of 5 parameters or a map with the parameters. Those are defining the **read access rights**, the **concerned Geo Time Series** and the **time window**. Other parameters in the map input are optional. \n\nThe list input is here to keep backward compatibility with old WarpScripts. The map input allows a great flexibility, as described below.\n\n### Access rights\nA valid read token is needed to read data with fetch. If you use a [metaset](/doc/METASET) and also specify a token, the token included in the metaset will be ignored.\n\n### Concerned Geo Time Series\n`FETCH` selects Geo Time Series according to:\n+ The `selectors` parameter, which is a list of selector.\n+ If `selectors` is not found, `FETCH` uses the `selector` parameter which is a single selector.\n+ If `selector` is not found, `FETCH`  uses both `class` and `labels` parameters.  \n\n### Time window\n`FETCH`  begins from the newest value and stop when the oldest value is collected. Thus, `end` must be defined in your request and defines the newest included value in your time window. If `end` is anterior to your oldest value, the result will be empty (no Geo Time Series). The span of the time window ending at `end` is then defined according to:\n+ The `timespan` parameter.\n+ If `timespan` is not defined, `FETCH` collects a maximum of `count` point.\n+ If `count` is not defined, `FETCH` determines `timespan` with `start`. If `start` is more recent than `end`, `end` and `start` are permuted internally. Be careful, this means `end` is included but  **`start` is excluded from the time window**.\n\n### Boundaries\nSince version 2.3.0, you can define *boundaries* around the requested data. When fetching data based on a time range, both a *pre* and *post* boundaries can be specified. When fetching by count, only a *pre* boundary can be requested.\nBoundaries are a number of datapoints which are either before (*pre* boundary) or after (*post* boundary) the fetched data. Fetching boundaries is very useful when storing only the changes of values as they enable you to always fetch datapoints even if the requested time range does not contain any. They can also be used to fetch the first `N` datapoints after a given timestamp.\nNote that fetching *post* boundaries is less efficient than fetching the requested range or a *pre* boundary as the data has to be scanned in reverse order which has an impact on I/Os and ultimately on performance.\n\n### Sampling options\n+ Since version 2.3.0, you can randomly sample points with the `sample` parameter. If `sample` equals 0.1, `FETCH` will randomly return one point out of ten. This implementation is the fastest way to resample data.\n+ Since version 2.3.0, you can `skip` the N newest datapoints in the time window specified.\n\n### Query without looking into directory\nThe fetch time to read one gts among millions of gts recorded with the same classname, the same application and the same owner can take time. Use the `gts` parameter to select if you exactly know the classname and all the labels.\n\nIf you want to read only Geo Time Series attributes or labels, using [FIND](/doc/FIND) is more efficient than fetching the last value.\n\n@param `token` Read token to use to fetch the data.\n\n@param `class` Selector for the GTS classes. Can either be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `labels` Map of labels selectors. The key is the label name, the value a selector which can be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `start` Oldest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `end` Newest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `data` List of fetched Geo Time Series™.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n@param `metaset` A set of Geo Time Series™ produced by the [`METASET`](/doc/METASET) function.\n\n@param `type` Name of type to force for the GTS, either LONG, DOUBLE, BOOLEAN or STRING.\n\n@param `typeattr` Name of label to use for storing the GTS type. This option is incompatible with 'type', when set values of different types are ventilated in separate GTS with the same set of class and labels and an additional *type* label of the given name.\n\n@param `timespan` Depth to consider when fetching the datapoints. If the value is positive then it is interpreted as a duration in time units, if it is negative then as the maximum number of datapoints to fetch. If negative, incompatible with 'count'.\n\n@param `count` Maximum number of datapoints to fetch for each GTS. Incompatible with negative 'timespan'.\n\n@param `extra` List of extraneous classes to fetch. For each GTS matching the selection criteria, GTS with those extra class names will be fetched too (with the *exact* same set of labels).\n\n@param `active.after` Timestamp after which a GTS must have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `quiet.after` Timestamp after which a GTS must not have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `gts` Explicit list of Geo Time Series™ to fetch. The class and labels will be used as is and not serve as selectors.\n\n@param `boundary` Number of datapoints to include in both *pre* and *post* boundaries.\n\n@param `boundary.pre` Number of datapoints in the *pre* boundary.\n\n@param `boundary.post` Number of datapoints in the *post* boundary.\n\n@param `sampling.ratio` A probability between 0 (excluded, no datapoints returned) and 1.0 (all datapoints returned). The random sampling is done by the storage layer, which is the most efficient.\n\n@param `skip.count` Set fetch to ignore the N newest points in the time window you specified.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCH"},{name:"FETCHBOOLEAN",detail:"linput<LIST>  FETCHBOOLEAN  data<LIST<GTS>>\nminput<MAP>  FETCHBOOLEAN  data<LIST<GTS>>",documentation:"The `FETCHBOOLEAN` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type BOOLEAN.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHBOOLEAN"},{name:"FETCHDOUBLE",detail:"linput<LIST>  FETCHDOUBLE  data<LIST<GTS>>\nminput<MAP>  FETCHDOUBLE  data<LIST<GTS>>",documentation:"The `FETCHDOUBLE` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type DOUBLE.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHDOUBLE"},{name:"FETCHLONG",detail:"linput<LIST>  FETCHLONG  data<LIST<GTS>>\nminput<MAP>  FETCHLONG  data<LIST<GTS>>",documentation:"The `FETCHLONG` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type LONG.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHLONG"},{name:"FETCHSTRING",detail:"linput<LIST>  FETCHSTRING  data<LIST<GTS>>\nminput<MAP>  FETCHSTRING  data<LIST<GTS>>",documentation:"The `FETCHSTRING` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type STRING.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHSTRING"},{name:"FFT",detail:"gts<GTS>  FFT  result<LIST<GTS>>\ngtsList<LIST<GTS>>  FFT  result<LIST<LIST<GTS>>>",documentation:"The `FFT` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFT` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe real parts of the `FFT` coefficients, the second the imaginary parts. The scale factor is equal to X/(n * bucketspan) where n is the number\nof elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the number\nof values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFT` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the real parts of the `FFT` coefficients, the second the imaginary parts.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FFT"},{name:"FFTAP",detail:"gts<GTS>  FFTAP  result<LIST<GTS>>\ngtsList<LIST<GTS>>  FFTAP  result<LIST<LIST<GTS>>>",documentation:"The `FFTAP` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFTAP` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe amplitude of the coefficient at that frequency and the second the associated phase. The scale factor is equal to X/(n * bucketspan) where n is\nthe number of elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the\nnumber of values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFTAP` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the amplitude of the coefficient at that frequency and the second the associated phase.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FFTAP"},{name:"FFTWINDOW",detail:"gts<GTS> window<STRING>  FFTWINDOW  windowed<GTS>\nlgts<LIST<GTS>> window<STRING>  FFTWINDOW  lwindowed<LIST<GTS>>",documentation:"The `FFTWINDOW` transforms Geo Time Series™ by applying a [window function](https://en.wikipedia.org/wiki/Window_function) to its values. The function supports the following windows:\n\n| Name | Window |\n| --- | --- |\n| `triangular` | [Triangular](https://en.wikipedia.org/wiki/Window_function#Triangular_window) |\n| `parzen` | [Parzen](https://en.wikipedia.org/wiki/Window_function#Parzen_window) |\n| `welch` | [Welch](https://en.wikipedia.org/wiki/Window_function#Welch_window) |\n| `sine` | [Sine](https://en.wikipedia.org/wiki/Window_function#Sine_window) |\n| `hann` | [Hann](https://en.wikipedia.org/wiki/Window_function#Hann_window) |\n| `hamming` | [Hamming](https://en.wikipedia.org/wiki/Window_function#Hamming_window) |\n| `blackman` | [Blackman](https://en.wikipedia.org/wiki/Window_function#Blackman_window) |\n| `nuttall` | [Nuttall](https://en.wikipedia.org/wiki/Window_function#Nuttall_window,_continuous_first_derivative) | \n| `blackman-nuttall` | [Blackman-Nuttall](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Nuttall_window) |\n| `blackman-harris` | [Blackman-Harris](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Harris_window) |\n| `flattop` | [Flat top](https://en.wikipedia.org/wiki/Window_function#Flat_top_window) |\n| `rectangular` | [Rectangular](https://en.wikipedia.org/wiki/Window_function#Rectangular_window) |\n\n@param `window` Name of the window function to apply.\n\n@param `gts` Single Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `windowed` Tranformed Geo Time Series™.\n\n@param `lwindowed` List of transformed Geo Time Series™.\n\n",tags:["gts"],since:"1.2.13",OPB64name:"FFTWINDOW"},{name:"FILL",detail:"gtsa<GTS> gtsb<GTS> filler<FILLER>  FILL  gtsa<GTS> gtsb<GTS>",documentation:"The `FILL` function fills missing values in two Geo Time Series™ so they end up with identical ticks.\n\nThe filling is done using a *filler* function which applies a given strategy. Filler functions can be created using macros via the [`MACROFILLER`](/doc/MACROFILLER) function.\n\n@param `gtsa` First Geo Time Series™ to fill.\n\n@param `gtsb` Second Geo Time Series™ to fill.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"FILL"},{name:"FILLNEXT",detail:"gts<GTS>  FILLNEXT  result<GTS>\ngtsList<LIST<GTS>>  FILLNEXT  resultList<LIST<GTS>>",documentation:"The `FILLNEXT` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation of the \nnext non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLNEXT"},{name:"FILLPREVIOUS",detail:"gts<GTS>  FILLPREVIOUS  result<GTS>\ngtsList<LIST<GTS>>  FILLPREVIOUS  resultList<LIST<GTS>>",documentation:"The `FILLPREVIOUS` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation \nof the previous non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLPREVIOUS"},{name:"FILLTICKS",detail:"gts<GTS> data<LIST>  FILLTICKS  result<GTS>\ngtsList<LIST<GTS>> data<LIST>  FILLTICKS  resultList<LIST<GTS>>",documentation:"The `FILLTICKS` function add values to a Geo Time Series™ instance or a list thereof for ticks in the given **LIST**.\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n@param `data` List of (latitude, longitude, elevation, ticks) where ticks is a list of ticks.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FILLTICKS"},{name:"FILLVALUE",detail:"gts<GTS> data<LIST>  FILLVALUE  result<GTS>\ngtsList<LIST<GTS>> data<LIST>  FILLVALUE  resultList<LIST<GTS>>",documentation:"The `FILLVALUE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with a fixed value/location/elevation.\n\nIt expects a GTS or a list thereof on the top of the stack after having consumed a list of parameters (latitude, longitude, elevation, value)\nsitting on top of the stack prior to the call.\n\nLocation must be floating point numbers (e.g. 0.0 not 0). Elevation must be an integer. If no location or elevation should be set, **NaN** can\nbe used instead of specific value.\n\nThis function has no effect on non bucketized GTS instances.\n\n\n\nThe value is cast to the type of the GTS value\n\n@param `gts` The Geo Time Series™ to fill\n\n@param `gtsList` The list of Geo Time Series™ to fill\n\n@param `result` The filled Geo Time Series™\n\n@param `resultList` The list of filled Geo Time Series™\n\n@param `data` The list of parameters (latitude, longitude, elevation, value)\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLVALUE"},{name:"FILTER",detail:"[ gtsList<LIST<GTS>> labels<LIST<STRING>> filter<FILTER> ]  FILTER  result<LIST<GTS>>",documentation:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `FILTER` framework allows for advanced filtering using N-ary functions\n(functions which accept N parameters).\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A single list containing only the selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `FILTER`.\n\n",tags:["framework","filter"],since:"1.0.0",OPB64name:"FILTER"},{name:"FILTERBY",detail:"list<LIST> macro<MACRO>  FILTERBY  sublist<LIST>",documentation:"The `FILTERBY` function selects elements of a list based on the boolean return value of a macro evaluated for each element.\n\n@param `macro` Macro used for filtering. This macro should consume the element of the list pushed on top of the stack and leave a boolean on the stack. If this boolean is `true`, the element will be retained.\n\n@param `list` List of elements to filter.\n\n@param `sublist` List with the selected elements from `list`.\n\n",tags:["lists"],since:"1.2.22",OPB64name:"FILTERBY"},{name:"FIND",detail:"[ token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FIND  data<LIST<GTS>>\n[ uuidattribute<BOOLEAN> token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FIND  data<LIST<GTS>>\n{ token<STRING> classSelector<STRING> labelsSelector<MAP>  } FIND  data<LIST<GTS>>\n{ token<STRING> selector<STRING>  } FIND  data<LIST<GTS>>\n{ token<STRING> selectors<LIST<STRING>>  } FIND  data<LIST<GTS>>",documentation:"The `FIND` function finds Geo Time Series™ labels and attributes of GTS, not their values. It is the fastest way to read attributes of GTS. `FIND` ask only `directory` component of Warp&nbsp;10™, while [FETCH](/doc/FETCH) first ask `directory`, then ask `store` to read GTS values. \n\nSyntax is close to [FETCH](/doc/FETCH), without time boundaries or data point count.\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `data` List of fetched Geo Time Series™. These GTS does not contain any value.\n\n@param `uuidattribute` Setting this to true add `.uuid` attribute in the output data. This UUID is a hash of class and label.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FIND"},{name:"FINDSETS",detail:"[ token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FINDSETS  classes<LIST<STRING>> labels<MAP> attributes<MAP>",documentation:"The `FINDSETS` function returns sets of values for the classes, labels and attributes of the Geo Time Series™ which matched the selection criteria.\n\nThose results can be used for example to update a UI with lists of possible values for labels when exploring a corpus of GTS.\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label names to exact match or regular expression (if the value starts with a *~*) for matching labels and attributes.\n\n@param `attributes` Map of attribute names to value list.\n\n@param `labels` Map of label names to value list.\n\n@param `classes` List of class names.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FINDSETS"},{name:"FINDSTATS",detail:"[ token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FINDSTATS  result<MAP>",documentation:"The `FINDSTATS` function computes statistics on matching Geo Time Series™. The estimations are based on the use of [HyperLogLogPlus](https://en.wikipedia.org/wiki/HyperLogLog) estimators.\n\nThe function returns a map containing information about the matching Geo Time Series. The fields of the map are the following:\n\n| Key | Value |\n|-----|-------|\n| `gts.estimate` | Estimation of the number of matching Geo Time Series™ |\n| `classes.estimate` | Estimation of the number of distinct class names |\n| `labelnames.estimate` | Estimation of the number of distinct label names |\n| `labelvalues.estimate` | Estimation of the number of distinct label values |\n| `per.class.estimate` | If the number of matching classes is below the `directory.stats.class.maxcardinality`, this key will be associated with a map containing per class estimate of number of GTS |\n| `per.label.value.estimate` | If the number of label names in the matching GTS is below `directory.stats.labels.maxcardinality`, this key will be associated with a map containing an estimation of distinct label values per label name |\n| `error.rate` | This is the error rate of the estimators used for computing the estimations |\n| `partial.results` | When accessing a sharded Directory, this will be set to `true` if only partial results were collected |\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `result` Map containing stats such as error rate or whether estimates on classes, gts, or labels.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FINDSTATS"},{name:"FIRSTTICK",detail:"gts<GTS>  FIRSTTICK  result<LONG>\nlgts<LIST<GTS>>  FIRSTTICK  result<LONG>",documentation:"The `FIRSTTICK` function pushes on the stack the timestamp of the first tick of the Geo Time Series™ on top of the stack.\n\nWhen applied to a list of GTS, `FIRSTTICK` will return the lowest first tick found across all Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™\n\n@param `gts` Geo Time Series™\n\n@param `result` Timestamp. If the GTS does not have values, **Long.MAX_VALUE** is pushed.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FIRSTTICK"},{name:"FLATTEN",detail:"input<LIST>  FLATTEN  output<LIST>\nnotAList<ANY>  FLATTEN  notAList<ANY>",documentation:"The function `FLATTEN` inspects the top of the stack.\n\nIf it is a LIST of values,\nit inspects each value and replaces each value which was a LIST with its content.\n`FLATTEN` proceed recursively until all LISTs have been flattened.\n\nIf it is not a LIST, the function exits and let the stack in the same state.\n\n@param `input` Input is a list who may contains lists\n\n@param `notAList` An object which is not a list\n\n@param `output` Output list do not contains anymore nested lists\n\n",tags:["lists"],since:"1.0.0",OPB64name:"FLATTEN"},{name:"FLOATBITS->",detail:"input<LONG>  FLOATBITS->  result<DOUBLE>",documentation:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the 32 lower bits of the **LONG** value as the raw bits of a **FLOAT**.\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",tags:["conversion","binary"],since:"1.2.3",OPB64name:"GZlEFKG1HKGIAIs"},{name:"FLOOR",detail:"value<NUMBER>  FLOOR  result<DOUBLE>\nlvalue<LIST<NUMBER>>  FLOOR  lresult<LIST<DOUBLE>>",documentation:"The `FLOOR` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number smaller than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-down value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-down values, for each given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"FLOOR"},{name:"FLOORDIV",detail:"dividend<NUMBER> divisor<NUMBER>  FLOORDIV  fDiv<LONG>\ndividend<NUMBER> ldivisor<LIST<NUMBER>>  FLOORDIV  lfDiv<LIST<LONG>>\nldividend<LIST<NUMBER>> divisor<NUMBER>  FLOORDIV  lfDiv<LIST<LONG>>",documentation:"The `FLOORDIV` function consumes two NUMBER values, convert them to LONGs and pushes back largest LONG value that is less than or equal to the algebraic quotient.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fDiv` The largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfDiv` List of largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n",tags:["math"],since:"1.2.23",OPB64name:"FLOORDIV"},{name:"FLOORMOD",detail:"dividend<NUMBER> divisor<NUMBER>  FLOORMOD  fMod<LONG>\ndividend<NUMBER> ldivisor<LIST<NUMBER>>  FLOORMOD  lfMod<LIST<LONG>>\nldividend<LIST<NUMBER>> divisor<NUMBER>  FLOORMOD  lfMod<LIST<LONG>>",documentation:"The `FLOORMOD` function consumes two NUMBER values, convert them to LONGs and pushes back the floor modulus which is x - (floorDiv(x, y) * y).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fMod` The floor modulus x - (floorDiv(x, y) * y)\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfMod` List of floor modulus x - (floorDiv(x, y) * y)\n\n",tags:["math"],since:"1.2.23",OPB64name:"FLOORMOD"},{name:"FOR",detail:"initial<NUMBER> final<NUMBER> macro<MACRO>  FOR \ninitial<NUMBER> final<NUMBER> macro<MACRO> index<BOOLEAN>  FOR ",documentation:"The `FOR` function implements a for loop. It takes three arguments from the stack: the initial and the final values of the loop index and a macro to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",tags:["control"],since:"1.0.0",OPB64name:"FOR"},{name:"FOREACH",detail:"list<LIST> exec<MACRO>  FOREACH \nmap<MAP> exec<MACRO>  FOREACH \nset<SET> exec<MACRO>  FOREACH \nvector<VLIST> exec<MACRO>  FOREACH \nstring<STRING> exec<MACRO>  FOREACH \ngts<GTS> exec<MACRO>  FOREACH \nencoder<GTSENCODER> exec<MACRO>  FOREACH \nlist<LIST> exec<MACRO> index<BOOLEAN>  FOREACH \nmap<MAP> exec<MACRO> index<BOOLEAN>  FOREACH \nset<SET> exec<MACRO> index<BOOLEAN>  FOREACH \nvector<VLIST> exec<MACRO> index<BOOLEAN>  FOREACH \nstring<STRING> exec<MACRO> index<BOOLEAN>  FOREACH \ngts<GTS> exec<MACRO> index<BOOLEAN>  FOREACH \nencoder<GTSENCODER> exec<MACRO> index<BOOLEAN>  FOREACH ",documentation:"The `FOREACH` function implements a for loop on a list or map.\n\nFor each iteration i on a list, the i-th element on the list is put on top of the stack, and the exec macro is then called.\n\nFor each iteration i on a map, the exec macro is called with the i-th value on top of the stack, and the i-th key just below on the stack.\nYou can start your macro with `'value' STORE 'key' STORE`.\n\nSince release 2.1, `FOREACH` has the ability to iterate over Geo Time Series™ and GTS Encoders. When iterating over a GTS or Encoder, the macro is fed with a list of the form `[ tick lat lon elev value ]` where `lat`, `lon` and `elev` may be `NaN` if unset. In the case of an Encoder, `value` can be a byte array or a `BigDecimal` on top of `LONG`, `DOUBLE`, `STRING` or `BOOLEAN`.\n\nSince release 2.4.0, you can force FOREACH to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `exec` Macro to apply\n\n@param `list` List to iterate on\n\n@param `map` Map to iterate on\n\n@param `set` Set to iterate on\n\n@param `vector` Vector to iterate on\n\n@param `gts` GTS to iterate on\n\n@param `string` String to iterate on\n\n@param `encoder` GTSEncoder to iterate on\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",tags:["control"],since:"1.0.0",OPB64name:"FOREACH"},{name:"FORGET",detail:"symbol<STRING>  FORGET ",documentation:"Removes a symbol from the symbol table.      \n\n@param `symbol` Name of the symbol to remove.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"FORGET"},{name:"FORSTEP",detail:"initial<NUMBER> final<NUMBER> step<MACRO> macro<MACRO>  FORSTEP \ninitial<NUMBER> final<NUMBER> step<MACRO> macro<MACRO> index<BOOLEAN>  FORSTEP ",documentation:"The `FORSTEP` function implements for loop with an index step. It takes four arguments from the stack: the initial and the final values of the loop index,\na macro step to evaluate after each iteration and an other one to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `step` Macro step to evaluate after each iteration, typically to compute index\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",tags:["control"],since:"1.0.0",OPB64name:"FORSTEP"},{name:"FROMBIN",detail:"input<STRING>  FROMBIN  output<LONG>",documentation:"Converts the binary representation on top of the stack into the corresponding long.\n\n@param `input` Binary representation of a signed long, 64 characters max.\n\n@param `output` Signed long of input.\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBIN"},{name:"FROMBITS",detail:"input<LONG>  FROMBITS  result<DOUBLE>",documentation:"**This function is deprecated. Replace it in your code by the [`DOUBLEBITS->`](/doc/G3xKFZl4FZ_JJmoy) function.**\n\nConverts the **LONG** on top of the stack into a **DOUBLE** by considering it a raw bit representation.\n\n@param `input` Raw bit representation to convert\n\n@param `result` Converted value\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBITS"},{name:"FROMHEX",detail:"input<STRING>  FROMHEX  output<LONG>",documentation:"Converts an hexadecimal representation into a signed long. 64bits max.\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Signed long\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"FROMHEX"},{name:"FUNCTIONS",detail:" FUNCTIONS  functions<LIST<STRING>>",documentation:"FUNCTIONS returns a list of every functions available in your Warp 10 environnment, including native and extension functions.\n\nIt could be useful when coding your own extension to check your new functions are correctly registered.\n\n\nFUNCTIONS allow anyone to discover new extensions you created on the platform, so it is deactivated by default.\n\nYou must add `warpscript.extension.inventory=io.warp10.script.ext.inventory.InventoryWarpScriptExtension` in your configuration file for this function to be available.\n\n@param `functions` List of Warp 10 functions available on this instance\n\n",tags:["platform","extensions"],since:"1.2.16",OPB64name:"FUNCTIONS"},{name:"FUSE",detail:"chunks<LIST<GTS>>  FUSE  gts<GTS>",documentation:"Fuses Geo Time Series™ chunks. The fusion process attempts to keep the bucketization parameters if all chunks are bucketized with compatible `bucketspan` and `lastbucket` values.\n\nAll chunks must be of the same type.\n\nThe fused GTS will have the common class name of the chunks or no class name if some chunks have a different class name. The labels will be those common to all chunks, so when fusing chunks created with [`CHUNK`](/doc/CHUNK), the chunk id will be dropped.\n\n@param `chunks` List of Geo Time Series™ to fuse.\n\n@param `gts` Geo Time Series™ resulting from the fusion of `chunk`.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FUSE"},{name:"GEO.BUFFER",detail:"params<MAP>  GEO.BUFFER  wkb<BYTES>\nparams<MAP>  GEO.BUFFER  area<STRING>\nparams<MAP>  GEO.BUFFER ",documentation:"The `GEO.BUFFER` function allows to create [*buffer*](https://en.wikipedia.org/wiki/Buffer_(GIS)) **GEOSHAPE** objects. The function takes a `MAP` instance as input. This map can contain the following entries:\n\n| Key | Description |\n|-----|-------------|\n| `dist` | Distance of the buffer, as a central angle expressed in degrees. |\n| `mdist` | Distance of the buffer expressed in meters. This key is only taken into account if `dist` is not specified. |\n| `cap` | The end cap style to consider, use `SQUARE`, `FLAT` or `ROUND` (default). |\n| `join` | The join style to use, use `BEVEL`, `MITRE` or `ROUND` (default). |\n| `limit` | The mitre limit to use. Defaults to 5.0. |\n| `segments` | Number of segments to use per quadrant, defaults to 8. |\n| `singlesided` | Set to `true` to compute a single sided buffer. If `true`, positive distance will indicate left-hand side and negative distance right-hand side. End cap is ignored for single sided buffers. |\n| `wkb` | Byte array containing a [WKB](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary) definition of a geographic area. |\n| `wkt` | String containing a [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) definition of a geographic area. |\n| `geojson` | String containing a [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) definition of a geographic area. |\n\nIf a geographic area is defined, only one of `wkb`, `wkt` or `geojson` may be specified. The output of the function is a new definition of a geographic area with the buffer added to the original definition.\n\nIf no geographic area is defined, `GEO.BUFFER` will define a buffer which will be used by the next call to either [`GEO.WKT`](/doc/GEO.WKT), [`GEO.WKB`](/doc/GEO.WKB) or [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `params` Parameter map containing keys as defined above.\n\n@param `wkb` Area definition with the buffer added, if `params` had a value for key `wkb`.\n\n@param `area` Area definition with the buffer added, in WKT or GeoJSON depending on the presence of key `wkt` or `geojson` in `params`.\n\n",tags:["geo"],since:"2.7.0",OPB64name:"GEO.BUFFER"},{name:"GEO.COVER",detail:"gts<GTS> resolution<LONG>  GEO.COVER  geoshape<GEOSHAPE>\nencoder<GTSENCODER> resolution<LONG>  GEO.COVER  geoshape<GEOSHAPE>\nlist<LIST> resolution<LONG>  GEO.COVER  geoshapes<LIST<GEOSHAPE>>",documentation:"The `GEO.COVER` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* in which the input Geo Time Series™ or GTS Encoder had datapoints.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER"},{name:"GEO.COVER.RL",detail:"gts<GTS> resolution<LONG>  GEO.COVER.RL  geoshape<GEOSHAPE>\nencoder<GTSENCODER> resolution<LONG>  GEO.COVER.RL  geoshape<GEOSHAPE>\nlist<LIST> resolution<LONG>  GEO.COVER.RL  geoshapes<LIST<GEOSHAPE>>",documentation:"The `GEO.COVER.RL` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* which cover the path of an input Geo Time Series™ or GTS Encoder. The path is considered to follow [rhumb lines](https://en.wikipedia.org/wiki/Rhumb_line), hence the function suffix `.RL`.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER.RL"},{name:"GEO.DIFFERENCE",detail:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.DIFFERENCE  shape<GEOSHAPE>",documentation:"The `GEO.DIFFERENCE` function computes the difference between two GEOSHAPE. The resulting GEOSHAPE instance contains cells which cover the part of the first GEOSHAPE which is not in the second. If you need to have cells up to a certain resolution, you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the result.\n\n@param `shapeA` GEOSHAPE instance from which to subtract the second shape.\n\n@param `shapeB` GEOSHAPE to subtract from 'shapeA'.\n\n@param `shape` GEOSHAPE containing 'shapeA' minus 'shapeB'.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.DIFFERENCE"},{name:"GEO.INTERSECTION",detail:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.INTERSECTION  shape<GEOSHAPE>\nshapes<LIST<GEOSHAPE>>  GEO.INTERSECTION  shape<GEOSHAPE>",documentation:"The `GEO.INTERSECTION` function computes the intersection of two GEOSHAPE instances. The intersection process will produce a GEOSHAPE whose cells are common to the two initial shapes. The common cells will be of various resolutions, depending on the resolutions of the cells from the initial shapes. If you need the resulting shape to contain cells up to a specific resolution, you can call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) either on the result or on the initial shapes.\n\n@param `shapeA` First GEOSHAPE instance.\n\n@param `shapeB` Second GEOSHAPE instance.\n\n@param `shapes` GEOSHAPE instances.\n\n@param `shape` Geographical area (GEOSHAPE) resulting from the intersection of the given shapes.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.INTERSECTION"},{name:"GEO.INTERSECTS",detail:"gts<GTS> shape<GEOSHAPE>  GEO.INTERSECTS  result<BOOLEAN>\nlgts<LIST<GTS>> shape<GEOSHAPE>  GEO.INTERSECTS  results<LIST<BOOLEAN>>\nshapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.INTERSECTS  result<BOOLEAN>",documentation:"The `GEO.INTERSECTS` function checks if a Geo Time Series or each GTS from a list has at least one data point with a position inside a given geographical area. Since `2.7.1`, the function can also check if two `GEOSHAPE` instances intersect.\n\n@param `shapeA` First `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shapeB` Second `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shape` Instance of GEOSHAPE containing the area which the Geo Time Series must intersect.\n\n@param `gts` Single instance of Geo Time Series.\n\n@param `lgts` List of Geo Time Series.\n\n@param `result` Boolean indicating whether or not the Geo Time Series had at least one datapoint in 'shape' or if the two shapes intersect.\n\n@param `results` List of boolean results indicating whether or not each GTS had at least one datapoint in 'shape'.\n\n",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.INTERSECTS"},{name:"GEO.JSON",detail:"GeoJSON<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.JSON  geoshape<GEOSHAPE>\nGeoJSON<STRING> resolution<LONG> inside<BOOLEAN>  GEO.JSON  geoshape<GEOSHAPE>",documentation:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"1.2.9",OPB64name:"GEO.JSON"},{name:"GEO.JSON.UNIFORM",detail:"GeoJSON<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.JSON.UNIFORM  geoshape<GEOSHAPE>\nGeoJSON<STRING> resolution<LONG> inside<BOOLEAN>  GEO.JSON.UNIFORM  geoshape<GEOSHAPE>",documentation:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.JSON`](doc/GEO.JSON), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"1.2.13",OPB64name:"GEO.JSON.UNIFORM"},{name:"GEO.NORMALIZE",detail:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.NORMALIZE  normalizedA<GEOSHAPE> normalizedB<GEOSHAPE>",documentation:"The `GEO.NORMALIZE` function ensures that the intersection of two **GEOSHAPE**s is present in both as an identical set of cells.\n\n@param `shapeA` The first GEOSHAPE to normalize.\n\n@param `shapeB` The second GEOSHAPE to normalize.\n\n@param `normalizedA` A normalized copy of the first GEOSHAPE.\n\n@param `normalizedB` A normalized copy of the second GEOSHAPE.\n\n",tags:["geo"],since:"2.5.0",OPB64name:"GEO.NORMALIZE"},{name:"GEO.OPTIMIZE",detail:"shape<GEOSHAPE> resolution<LONG>  GEO.OPTIMIZE  optimized<GEOSHAPE>",documentation:"The `GEO.OPTIMIZE` function optimizes a GEOSHAPE instance by modifying its cells to either limit the finest resolution present in the shape or reduce the number of cells by merging cells which cover a whole cell at the coarser resolution.\n\n@param `shape` GEOSHAPE instance to optimize.\n\n@param `resolution` Finest resolution acceptable (even number from 2 to 32) or 0 to reduce the number of cells.\n\n@param `optimized` Optimized GEOSHAPE instance\n\n",tags:["geo"],since:"1.2.13",OPB64name:"GEO.OPTIMIZE"},{name:"GEO.REGEXP",detail:"shape<GEOSHAPE>  GEO.REGEXP  regexp<STRING>",documentation:"The `GEO.REGEXP` function converts a GEOSHAPE into a regular expression to select hexadecimal [HHCode](https://en.wikipedia.org/wiki/HHCode) STRINGs which are included in the GEOSHAPE.\n\n@param `shape` An instance of GEOSHAPE.\n\n@param `regexp` A regular expression for matching HHCodes covered by 'shape'.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"GEO.REGEXP"},{name:"GEO.UNION",detail:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.UNION  shape<GEOSHAPE>\nshapes<LIST<GEOSHAPE>>  GEO.UNION  shape<GEOSHAPE>",documentation:"The `GEO.UNION` function computes a GEOSHAPE which is the union of two other shapes. The resulting shape will have cells covering the two original shapes. If you need to have cells up to a certain resolution you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the resulting shape.\n\n@param `shapeA` First GEOSHAPE instance to merge.\n\n@param `shapeB` Second GEOSHAPE instance to merge.\n\n@param `shapes` GEOSHAPE instances to merge.\n\n@param `shape` Resulting GEOSHAPE which is the union of the given shapes.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.UNION"},{name:"GEO.WITHIN",detail:"gts<GTS> shape<GEOSHAPE>  GEO.WITHIN  result<BOOLEAN>\nlgts<LIST<GTS>> shape<GEOSHAPE>  GEO.WITHIN  results<LIST<BOOLEAN>>",documentation:"The `GEO.WITHIN` function checks whether a Geo Time Series™ or each GTS from a list have all its datapoints with a location inside a given geographical area.\n\n@param `shape` Instance of GEOSHAPE containing the area inside which the Geo Time Series™ must be contained.\n\n@param `gts` Single instance of Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `result` Boolean indicating whether or not the Geo Time Series™ had all its datapoints with a location inside 'shape'.\n\n@param `results` List of boolean results indicating whether or not each GTS had all its datapoints with a location inside 'shape'.\n\n",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.WITHIN"},{name:"GEO.WKB",detail:"WKB<BYTES> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKB  geoshape<GEOSHAPE>\nWKB<BYTES> resolution<LONG> inside<BOOLEAN>  GEO.WKB  geoshape<GEOSHAPE>",documentation:"The `GEO.WKB` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB"},{name:"GEO.WKB.UNIFORM",detail:"WKB<BYTES> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKB.UNIFORM  geoshape<GEOSHAPE>\nWKB<BYTES> resolution<LONG> inside<BOOLEAN>  GEO.WKB.UNIFORM  geoshape<GEOSHAPE>",documentation:"The `GEO.WKB.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKB`](doc/GEO.WKB), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geographical area output.\n\n",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB.UNIFORM"},{name:"GEO.WKT",detail:"WKT<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKT  geoshape<GEOSHAPE>\nWKT<STRING> resolution<LONG> inside<BOOLEAN>  GEO.WKT  geoshape<GEOSHAPE>",documentation:"The `GEO.WKT` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.WKT"},{name:"GEO.WKT.UNIFORM",detail:"WKT<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKT.UNIFORM  geoshape<GEOSHAPE>\nWKT<STRING> resolution<LONG> inside<BOOLEAN>  GEO.WKT.UNIFORM  geoshape<GEOSHAPE>",documentation:"The `GEO.WKT.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKT`](doc/GEO.WKT), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geographical area output.\n\n",tags:["geo"],since:"1.2.11",OPB64name:"GEO.WKT.UNIFORM"},{name:"GEOCELL->",detail:"geocell<LONG>  GEOCELL->  hhPrefix<STRING>",documentation:"The `GEOCELL->` function converts a **LONG** geocell to a **STRING** HHCode prefix. The resulting string length is half the resolution of the geocell.\n\nThis function cannot convert to **BYTES** because this representation is limited to resolutions multiple of 4.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `geocell` A geocell.\n\n@param `hhPrefix` A HHCode prefix representing the given cell.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"GoKEFoKBI1oy"},{name:"GEOHASH->",detail:"geohash<STRING>  GEOHASH->  lat<DOUBLE> lon<DOUBLE>\ngeohash<STRING> toHHCodeString<BOOLEAN>  GEOHASH->  hhcode<ANY>\ngeohashes<LIST<STRING>>  GEOHASH->  shape<GEOSHAPE>",documentation:"The `GEOHASH->` converts a [Geohash](https://en.wikipedia.org/wiki/Geohash), exposing the latitude and longitude it contains, or transforms a list of Geohashes into a `GEOSHAPE`.\n\n@param `geohash` Geohash to unpack.\n\n@param `geohashes` List of Geohashes defining a geographical area.\n\n@param `lat` Unpacked latitude.\n\n@param `lon` Unpacked longitude.\n\n@param `toHHCodeString` Set to `true` to convert the GeoHash to a HHCode STRING or to `false` to convert it to a LONG HHCode instead of extracting its latitude and longitude.\n\n@param `hhcode` The HHCode for `geohash`, as a LONG or STRING.\n\n@param `shape` Warp 10 `GEOSHAPE` covering the same geographic area as the Geohashes in `geohashes`.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"GoKEH34IH1oy"},{name:"GEOPACK",detail:"shape<GEOSHAPE>  GEOPACK  packed<STRING>",documentation:"The `GEOPACK` function takes a **GEOSHAPE** and packs it into a String.\n\n@param `shape` The GEOSHAPE instance to pack.\n\n@param `packed` The packed string representation of the GEOSHAPE.\n\n",tags:["geo"],since:"1.0.7",OPB64name:"GEOPACK"},{name:"GEOSHAPE->",detail:"geoshape<GEOSHAPE>  GEOSHAPE->  geocells<LIST<LONG>>\ngeoshape<GEOSHAPE> toString<BOOLEAN>  GEOSHAPE->  geocellsOrHHPrefixes<LIST<ANY>>",documentation:"The `GEOSHAPE->` function converts **GEOSHAPE** to a list of **LONG** geocells or **STRING** HHCode prefixes. Conversion to list of **BYTES** is not supported, because this representation only supports resolution multiple of 4.\n\n@param `geoshape` The geoshape to get the cells from.\n\n@param `toString` Whether to convert the cells to **STRING** HHCode prefix (true) or geocells (false).\n\n@param `geocells` List of geocells.\n\n@param `geocellsOrHHPrefixes` List of **LONG** geocells or **STRING** HHCode prefixes.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"GoKEJoW0J3JhEV"},{name:"GEOSHIFT",detail:"shape<GEOSHAPE> lat<DOUBLE> lon<DOUBLE> precision<LONG>  GEOSHIFT  output<GEOSHAPE>\nshape<GEOSHAPE> meridian<DOUBLE> lat<DOUBLE> lon<DOUBLE> precision<LONG>  GEOSHIFT  output<GEOSHAPE>",documentation:"`GEOSHIFT` functions shifts a geoshape on the earth. It is able to safely overlap the poles or the 180th meridian.\n- Longitude shift keeps distances.\n- Latitude shift keeps angles, not distances.\n- When doing latitude shift, you can specify a meridian to shift along this meridian. It means a positive shift became a negative shift behind this meridian +/- 90°.\n\nSet precision parameter to zero for safe shifting operation. See [`GEO.WKT`](/doc/GEO.WKT) for precision encoding.\n\nUse [`->GEOJSON`](/doc/AIt6GJx9JoxD) to visualize shapes and the results. GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `lon` degrees of longitude to shift (-360 to 360).\n\n@param `lat` degrees of latitude to shift (-180 to 180).\n\n@param `precision` even number from 0 to 30. Set to 0 for automatic resolution. Force to another value if you know the input resolution to be finer and you want a coarser resolution.\n\n@param `shape` The input geoshape.\n\n@param `output` The shifted geoshape.\n\n@param `meridian` When doing latitude shift, you can specify a meridian to shift along this meridian. (-180 to 180)\n\n",tags:["geo"],since:"2.5.0",OPB64name:"GEOSHIFT"},{name:"GEOSPLIT",detail:"shape<GEOSHAPE>  GEOSPLIT  subshapes<LIST<GEOSHAPE>>",documentation:"The `GEOSPLIT` function splits a **GEOSHAPE** into a set of **GEOSHAPE**s which have no adjacent cells (each shape is a connected space).\n\nAdjacent cells share part of their side. Adjacency is not provided by corners and cells on each side of the international date line are not considered adjacent either.\n\n@param `shape` The GEOSHAPE instance to split.\n\n@param `subshapes` The shapes whose union form `shape` and which each form a connected space.\n\n",tags:["geo"],since:"2.5.0",OPB64name:"GEOSPLIT"},{name:"GEOUNPACK",detail:"packed<STRING>  GEOUNPACK  shape<GEOSHAPE>\npackedbytes<BYTES>  GEOUNPACK  shape<GEOSHAPE>",documentation:"The `GEOUNPACK` function unpacks a GEOSHAPE previously packed using [`GEOPACK`](/doc/GEOPACK).\n\n@param `packed` A packed string representation of a GEOSHAPE.\n\n@param `packedbytes` A byte array representation of a GEOSHAPE.\n\n@param `shape` The decoded instance of GEOSHAPE.\n\n",tags:["geo"],since:"1.0.7",OPB64name:"GEOUNPACK"},{name:"GET",detail:"map<MAP> key<ANY>  GET  mapvalue<ANY>\nlist<LIST> index<LONG>  GET  value<ANY>\nlist<LIST> index<LIST>  GET  value<ANY>\narray<BYTES> index<LONG>  GET  bytevalue<LONG>",documentation:"Retreive a value in a **MAP** or a **list**.\n\nThe `GET` function consumes on the top of the stack a list, a byte array, or a map, and the index (or the key), \nthen put the result on the stack. \n\nIf key is not found, it returns NULL on the stack.\n\nIf index is out of bound, `GET` raises an error.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, GET can operate recursively on nested lists. In this case, the index is a list.\n\n@param `map` The input MAP.\n\n@param `key` Depending on map construction, could be a number, a string, a list, another map, a GTS, a boolean.\n\n@param `mapvalue` The value for the requested key. If key do not exists in map, returns NULL\n\n@param `index` The index number in the list. Valid values in [-size; size-1]\n\n@param `list` The input LIST.\n\n@param `value` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `array` Byte array from which to read a byte.\n\n@param `bytevalue` The value of the byte, always unsigned (from 0 to 255).\n\n",tags:["lists","maps","binary"],since:"1.0.0",OPB64name:"GET"},{name:"GETEXPONENT",detail:"n<NUMBER>  GETEXPONENT  exponent<LONG>",documentation:"The `GETEXPONENT` function consumes a DOUBLE, a LONG casted as a DOUBLE or a COUNTER caster as DOUBLE and pushes back the unbiased exponent used in the representation of this DOUBLE.\n\n@param `n` The decimal value to get the exponent from, will be converted to DOUBLE if not already the case.\n\n@param `exponent` the unbiased exponent of the argument\n\n",tags:["math"],since:"1.2.23",OPB64name:"GETEXPONENT"},{name:"GETHOOK",detail:"token<STRING> hook<STRING>  GETHOOK  secure<STRING>",documentation:"Extracts the macro associated with a token hook and pushes it onto the stack wrapped as a secure script.\n\nIf the token does not contain the given hook, an empty macro will be wrapped.\n\n@param `hook` Name of the hook to extract from the token.\n\n@param `token` Read token from which to extract the hook.\n\n@param `secure` Hook macro wrapped in a secure script.\n\n",tags:["platform"],since:"1.0.8",OPB64name:"GETHOOK"},{name:"GETSECTION",detail:" GETSECTION  section<STRING>",documentation:"The `GETSECTION` function pushes onto the stack the name of the current section.\n\n@param `section` Name of the current section.\n\n",tags:["stack","debug"],since:"1.2.7",OPB64name:"GETSECTION"},{name:"GOLDWRAP",detail:"encoder<GTSENCODER>  GOLDWRAP  wrapped<BYTES>\ngts<GTS>  GOLDWRAP  wrapped<BYTES>\nwrap<BYTES>  GOLDWRAP  wrapped<BYTES>\nlist<LIST<GTS>>  GOLDWRAP  lwrapped<LIST<BYTES>>\nlist<LIST<GTSENCODER>>  GOLDWRAP  lwrapped<LIST<BYTES>>\nlist<LIST<BYTES>>  GOLDWRAP  lwrapped<LIST<BYTES>>",documentation:"The `GOLDWRAP` function wraps a Geo Time Series™ or a GTS Encoder in a deterministic way, by sorting on timestamps but also on values, locations and elevations.\n\nThis version of a `WRAP` like function is meant to create a *gold standard* blob from its input. In order to ensure reproducibility of the processs, attributes should be dropped prior to calling `GOLDWRAP`.\n\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `wrap` Wrapped Geo Time Series™ instance to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n@param `list` List of Geo Time Series™ or GTS Encoders to wrap.\n\n",tags:["gts"],since:"2.2.0",OPB64name:"GOLDWRAP"},{name:"GROUPBY",detail:"list<LIST> macro<MACRO>  GROUPBY  grouped<LIST>",documentation:"The `GROUPBY` function groups the elements of a list according to the value returned by a macro.\n\n@param `macro` Macro used for grouping, consumes an element off the stack and produces a value on the stack.\n\n@param `list` List of elements to group.\n\n@param `grouped` List of groups, each group is a list whose first element is the group key and whose second element is the sublist of `list` for which `macro` produced the same value.\n\n",tags:["lists"],since:"1.2.22",OPB64name:"GROUPBY"},{name:"GRUBBSTEST",detail:"gts<GTS> mad<BOOLEAN> alpha<DOUBLE>  GRUBBSTEST  result<LIST<LONG>>\ngts<GTS> mad<BOOLEAN>  GRUBBSTEST  result<LIST<LONG>>\ngtsList<LIST<GTS>> mad<BOOLEAN> alpha<DOUBLE>  GRUBBSTEST  resultList<LIST>\ngtsList<LIST<GTS>> mad<BOOLEAN>  GRUBBSTEST  resultList<LIST<LIST<LONG>>>",documentation:"The `GRUBBSTEST` function detects an outlier in a GTS (or a LIST of GTS), by applying a \n[Grubbs’](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm) test.\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nIt tests whether there is exactly a single outlier in a GTS or not. For an iterative version which can detect multiple outliers, use instead\n[`ESDTEST`](/doc/ESDTEST).\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> ### Reference \n> Grubbs, Frank (February 1969). “Procedures for Detecting Outlying Observations in Samples”. Technometrics (Technometrics, Vol. 11, No. 1).\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"GRUBBSTEST"},{name:"GTSHHCODE->",detail:"hhcode<LONG>  GTSHHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<STRING>  GTSHHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<BYTES>  GTSHHCODE->  lat<DOUBLE> lon<DOUBLE>",documentation:"The `GTSHHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude. This function is very similar to [`HHCODE->`](/doc/H3W2IoG4AIs) except that when given the internal value used by Geo Time Series™ for a missing location it pushes back `NaN NaN`.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",tags:["geo"],since:"2.2.0",OPB64name:"GpGIH3W2IoG4AIs"},{name:"GZIP",detail:"string<STRING>  GZIP  compressed<BYTES>\nbytes<BYTES>  GZIP  compressed<BYTES>",documentation:"The `GZIP` function compresses a STRING or a byte array using the [gzip](https://en.wikipedia.org/wiki/Gzip) algorithm. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",tags:["conversion"],since:"1.0.11",OPB64name:"GZIP"},{name:"HASH",detail:"str<STRING>  HASH  result<LONG>\nbytes<BYTES>  HASH  result<LONG>",documentation:"Computes a 64 bits hash of the string or byte array on top of the stack.\n\n@param `str` String to hash\n\n@param `bytes` Bytes to hash\n\n@param `result` 64bit hash\n\n",tags:["strings"],since:"1.0.0",OPB64name:"HASH"},{name:"HAVERSINE",detail:"p1_latitude<NUMBER> p1_longitude<NUMBER> p2_latitude<NUMBER> p2_longitude<NUMBER>  HAVERSINE  haversineDistance<DOUBLE>",documentation:"The `HAVERSINE` function consumes two coordinates and pushes back a **DOUBLE** [great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance) in meters.\n\n@param `p2_longitude` Point 2 longitude.\n\n@param `p2_latitude` Point 2 latitude.\n\n@param `p1_longitude` Point 1 longitude.\n\n@param `p1_latitude` Point 1 latitude.\n\n@param `haversineDistance` Great circle distance using the haversine fonction.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"HAVERSINE"},{name:"HEADER",detail:"name<STRING> value<STRING>  HEADER ",documentation:"The `HEADER` function allows you to set custom headers which should be returned in the HTTP response. This obviously works only for the `/exec` Warp 10 endpoint.\n\n@param `name` Name of HTTP header to return, MUST start with `X-`, *i.e.* be a custom header.\n\n@param `value` Value to return for the `name` header. If `NULL`, the specified header is removed from the list of headers to return.\n\n",tags:["stack"],since:"1.0.14",OPB64name:"HEADER"},{name:"HEX->",detail:"input<STRING>  HEX->  output<BYTES>",documentation:"Converts a hexadecimal string representation into a bytes array.\nBytes array cannot be represented on the stack.\n\n@param `input` A valid hexadecimal string.\n\n@param `output` Bytes Array from input. Seen as null on the stack.\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"H3KNAIs"},{name:"HEXTOB64",detail:"input<STRING>  HEXTOB64  output<STRING>",documentation:"Decodes the hex encoded content on top of the stack and \nimmediately re-encode it in base64. This enables you to \nconvert encoded content which would not be valid UTF-8 encoding \nfrom hexadecimal to base64.      \n\n@param `input` A valid hexadecimal string\n\n@param `output` Base64 representation of input\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"HEXTOB64"},{name:"HEXTOBIN",detail:"input<STRING>  HEXTOBIN  output<STRING>",documentation:"Converts a string representing a hexadecimal number into a string representing a binary number.\n\nThe `HEXTOBIN` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from hexadecimal to binary.\n\n@param `input` The string representing a hexadecimal number\n\n@param `output` The string representing a binary number\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"HEXTOBIN"},{name:"HHCODE->",detail:"hhcode<LONG>  HHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<STRING>  HHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<BYTES>  HHCODE->  lat<DOUBLE> lon<DOUBLE>",documentation:"The `HHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",tags:["geo"],since:"1.0.11",OPB64name:"H3W2IoG4AIs"},{name:"HHCODE.BBOX",detail:"hhCode<STRING> resolution<LONG>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<LONG> resolution<LONG>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<BYTES> resolution<LONG>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<STRING>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<BYTES>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>",documentation:"The `HHCODE.BBOX` function returns the bounding box of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the bounding box representing the lat/lon of North-Easth and South-West corners of the bbox.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `latSW` Latitude of the south west corner of the bounding box\n\n@param `lonSW` Longitude of the south west corner of the bounding box\n\n@param `latNE` Latitude of the north east corner of the bounding box\n\n@param `lonNE` Longitude of the north east corner of the bounding box\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.BBOX"},{name:"HHCODE.CENTER",detail:"hhCode<STRING> resolution<LONG>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<LONG> resolution<LONG>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<BYTES> resolution<LONG>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<STRING>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<BYTES>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>",documentation:"The `HHCODE.CENTER` function returns the center of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the center and returns its lat/lon.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `lat` Latitude of the center of the given HHCode\n\n@param `lon` Longitude of the center of the given HHCode\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.CENTER"},{name:"HHCODE.EAST",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.EAST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.EAST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.EAST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.EAST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.EAST  outputHHCode<BYTES>",documentation:"The `HHCODE.EAST` function returns the cell east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.EAST"},{name:"HHCODE.NORTH",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.NORTH  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.NORTH  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.NORTH  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.NORTH  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.NORTH  outputHHCode<BYTES>",documentation:"The `HHCODE.NORTH` function returns the cell north of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH"},{name:"HHCODE.NORTH.EAST",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.NORTH.EAST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.NORTH.EAST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.NORTH.EAST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.NORTH.EAST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.NORTH.EAST  outputHHCode<BYTES>",documentation:"The `HHCODE.NORTH.EAST` function returns the cell north east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.EAST"},{name:"HHCODE.NORTH.WEST",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.NORTH.WEST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.NORTH.WEST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.NORTH.WEST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.NORTH.WEST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.NORTH.WEST  outputHHCode<BYTES>",documentation:"The `HHCODE.NORTH.WEST` function returns the cell north west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.WEST"},{name:"HHCODE.SOUTH",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.SOUTH  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.SOUTH  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.SOUTH  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.SOUTH  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.SOUTH  outputHHCode<BYTES>",documentation:"The `HHCODE.SOUTH` function returns the cell south of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH"},{name:"HHCODE.SOUTH.EAST",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.SOUTH.EAST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.SOUTH.EAST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.SOUTH.EAST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.SOUTH.EAST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.SOUTH.EAST  outputHHCode<BYTES>",documentation:"The `HHCODE.SOUTH.EAST.EAST` function returns the cell south east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.EAST"},{name:"HHCODE.SOUTH.WEST",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.SOUTH.WEST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.SOUTH.WEST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.SOUTH.WEST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.SOUTH.WEST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.SOUTH.WEST  outputHHCode<BYTES>",documentation:"The `HHCODE.SOUTH.WEST` function returns the cell south west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.WEST"},{name:"HHCODE.WEST",detail:"inputHHCode<STRING> resolution<LONG>  HHCODE.WEST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.WEST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.WEST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.WEST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.WEST  outputHHCode<BYTES>",documentation:"The `HHCODE.WEST` function returns the cell west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.WEST"},{name:"HIDE",detail:"levels<LONG>  HIDE  hidden<LONG>",documentation:"The `HIDE` function hides some levels of the stack to the rest of the executing code. This allows a kind of protection for levels which should not be accessed by a macro call for example. Note that this is not a real protection since a call to [`SHOW`](/doc/SHOW) could reveal the hidden levels.\n\nThe hidden levels are always the deepest. Depending on the `levels` parameter to the call to `HIDE`, the hidden levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there remains at most a certain number ((*abs(`levels`)*) with `levels` < 0).\n\nWhen called with `NULL` as parameter, `HIDE` will hide all the visible levels.\n\nThe number of newly hidden levels is returned.\n\n@param `levels` Number of levels to hide or to remain visible, or `NULL` to hide them all.\n\n@param `hidden` Number of levels actually hidden.\n\n",tags:["stack"],since:"2.7.1",OPB64name:"HIDE"},{name:"HLOCATE",detail:"gts<LIST<GTS>>  HLOCATE  result<LIST>",documentation:"The `HLOCATE` function locates the HBase regions containing a list of Geo Time Series™.\n\nThis function only works with the distributed version of Warp 10™.\n\nIt outputs a list of lists containing a GTS selector, the host and port of the RegionServer currently serving the region and the region id of a region containing data for this GTS.\n\n@param `gts` List of Geo Time Series™ to locate.\n\n@param `result` List of GTS, RegionServer, region tuples.\n\n",tags:["extensions"],since:"1.2.13",OPB64name:"HLOCATE"},{name:"HULLSHAPE",detail:"list<LIST>  HULLSHAPE  shape<LIST>\n{ list<LIST>  } HULLSHAPE  shape<LIST>",documentation:"Return the shape of a tensor (or multidimensional array) that would be able to contain all the values of an input nested list. The size of the returned shape is equal to the deepest level of nesting plus one. Its i-th value is equal to the size of the largest list that is nested i levels deep.\n\n@param `list` The input list.\n\n@param `shape` The hull shape of the input list.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"HULLSHAPE"},{name:"HUMANDURATION",detail:"duration<LONG>  HUMANDURATION  humanReadableDuration<STRING>",documentation:"The `HUMANDURATION` function consumes a **LONG** duration and push back an easily readable **STRING** representation of this duration.\n\nThe format of the pushed back **STRING** is **[Dd][Hh][Mm]S.XXXXXXs** with D as days, H as hours, M as minutes, S as seconds and XXXXXX the number of ms (3 digits), us (6 digits) or ns (9 digits) depending on the platform configuration. If the duration is less than a day, Dd is omitted, sames goes with Hh and Mm.\n\n@param `duration` Duration expressed in the platform time unit.\n\n@param `humanReadableDuration`  A representation of the duration, easily readable for a human.\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"HUMANDURATION"},{name:"HYBRIDTEST",detail:"gts<GTS> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE> parameters<MAP>  HYBRIDTEST  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG> parameters<MAP>  HYBRIDTEST  result<LIST<LONG>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE> parameters<MAP>  HYBRIDTEST  result<LIST<LIST<LONG>>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST  result<LIST<LIST<LONG>>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST  result<LIST<LIST<LONG>>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG> parameters<MAP>  HYBRIDTEST  result<LIST<LIST<LONG>>>",documentation:"The `HYBRIDTEST` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\nLike [`STLESDTEST`](/doc/STLESDTEST), `HYBRIDTEST` performs an [`ESDTEST`](/doc/ESDTEST) onto a GTS that have been relieved of its seasonal and trend part. \nBut unlike the mentioned test, [`STL`](/doc/STL) and [`ESDTEST`](/doc/ESDTEST) are performed piecewise. Plus, the trend is approximated with the piecewise \nmedian instead of the trend part of the [`STL`](/doc/STL) decomposition.\n\nA LIST of ticks (or a LIST of LIST of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis technique was first developped at [Twitter](https://blog.twitter.com/2015/introducing-practical-and-robust-anomaly-detection-in-a-time-series).\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ## References\n> - Owen Vallis, Jordan Hochenbaum, Arun Kejariwal. “A Novel Technique for Long-Term Anomaly Detection in the Cloud”, Twitter Inc (2014).\n> - Cleveland, Robert B., et al. “STL: A seasonal-trend decomposition procedure based on loess.” Journal of Official Statistics 6.1 (1990): 3-73.\n> - Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n\n@param `parameters` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `lgts` List of [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST"},{name:"HYBRIDTEST2",detail:"gts<GTS> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST2  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST2  result<LIST<LONG>>\ngtsList<LIST<GTS>> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST2  result<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST2  result<LIST<LIST<LONG>>>",documentation:"The `HYBRIDTEST2` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\n`HYBRIDTEST2` is almost the same procedure than [`HYBRIDTEST`](/doc/HYBRIDTEST) except that it does not use [`STL`](/doc/STL) decomposition for the \nseasonal extract.\n\nThe seasonal part is approximated by pondering each value with the [entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29) of the \n[modified Z-score](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm) of its seasonal subseries (series with only the values of the \nsame season).\n\nThis test is usually preferred when it is meaningful to think in term of entropy, for example when the GTS represents counters of events. Also as it \ndoes not use [`STL`](/doc/STL) decomposition, it is not prone to border effects, but at the cost of not detecting slight outliers.\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n@param `gtsList` List of GTS\n\n",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST2"},{name:"HYPOT",detail:"x<NUMBER> y<NUMBER>  HYPOT  result<DOUBLE>\nx<NUMBER> ly<LIST<NUMBER>>  HYPOT  lresult<LIST<DOUBLE>>\nlx<LIST<NUMBER>> y<NUMBER>  HYPOT  lresult<LIST<DOUBLE>>",documentation:"HYPOT function returns the radius r from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta), r = sqrt(x²+y²).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `result` radius r in polar coordinates\n\n@param `lresult` List of radiuses r in polar coordinates\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"HYPOT"},{name:"IDENT",detail:" IDENT  ident<STRING>",documentation:"The `IDENT` function pushes onto the stack the value of the system property `warp.ident`.\n\n@param `ident` The value of the `warp.ident` property.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"IDENT"},{name:"IDWT",detail:"gts<GTS> wavelet<STRING>  IDWT  result<GTS>",documentation:"The `IDWT` function computes an Inverse [Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Discrete_wavelet_transform) on a Geo Time Series™.\n\nThe names of the available Wavelet are the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\n\n@param `wavelet` Wavelet to consider\n\n@param `gts` Geo Time Series™ which contains the wavelet coefficients as is returned by [`FDWT`](/doc/FDWT).\n\n@param `result` Reconstructed Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"IDWT"},{name:"IEEEREMAINDER",detail:"dividend<NUMBER> divisor<NUMBER>  IEEEREMAINDER  result<LONG>\ndividend<NUMBER> ldivisor<LIST<NUMBER>>  IEEEREMAINDER  lresult<LIST<LONG>>\nldividend<LIST<NUMBER>> divisor<NUMBER>  IEEEREMAINDER  lresult<LIST<LONG>>",documentation:"The `IEEEREMAINDER` function consumes two parameters, a dividend f1 and a divisor f2. This function push the remainder onto the stack as\nprescribed by the [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_754-1985).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` Dividend, converted as DOUBLE if not already the case.\n\n@param `divisor` Divisor, converted as DOUBLE if not already the case.\n\n@param `result` Remainder\n\n@param `ldividend` List of dividends, converted as DOUBLE if not already the case.\n\n@param `ldivisor` List of divisors, converted as DOUBLE if not already the case.\n\n@param `lresult` List of remainders\n\n",tags:["operators"],since:"1.0.0",OPB64name:"IEEEREMAINDER"},{name:"IFFT",detail:"real<GTS> im<GTS>  IFFT  result<GTS>",documentation:"The `IFFT` function computes an Inverse [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) of two Geo Time Series™ \nrepresenting real and imaginary parts of FFT coefficients.\n\nThe result is the reconstructed Geo Time Series™. The ticks of this reconstructed GTS are the coefficient indices. They must be multipled by the original \nbucketspan to space the ticks according to the decomposed Geo Time Series™. The bucketspan is equal to `X / (n * factor)` where `X` is the number of time \nunits in a second, `n` is the number of coefficients and `factor` is the scale factor returned by `FFT`.\n\n@param `im` GTS containing the imaginary part\n\n@param `real` GTS containing the real parts of the `FFT` coefficients\n\n@param `result` Reconstructed Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"IFFT"},{name:"IFT",detail:"if<MACRO> then<MACRO>  IFT  result<ANY*>\ncheck<BOOLEAN> then<MACRO>  IFT  result<ANY*>",documentation:"The `IFT` function is a conditional construct which will run a macro only if a boolean condition is true. The condition can either be a boolean on the stack or the result of a macro run.\n\n@param `check` Boolean which will be checked as the conditional test.\n\n@param `if` Macro which will be executed to determine the conditional test. This macro must leave a boolean on the stack.\n\n@param `then` Macro which is executed if the conditional test is `true`.\n\n@param `result` State of the stack after the `then` macro is executed.\n\n",tags:["control"],since:"1.0.0",OPB64name:"IFT"},{name:"IFTE",detail:"if<MACRO> then<MACRO> else<MACRO>  IFTE  result<ANY*>\ncondition<BOOLEAN> then<MACRO> else<MACRO>  IFTE  result<ANY*>",documentation:"The `IFTE` function is a conditional construct which evaluates a condition and executes one of two macros depending on the condition (`true` or `false`). The condition can either be a BOOLEAN value on the stack or a macro which will be executed and must leave a BOOLEAN on the stack.\n\n@param `else` Macro executed if the condition is `false`.\n\n@param `then` Macro executed if the condition is `true`.\n\n@param `if` Macro executed to evaluate the condition. Must leave a BOOLEAN on top of the stack.\n\n@param `condition` Boolean value used as the condition.\n\n@param `result` Result of the execution of either the `then` or `else` macro.\n\n",tags:["control"],since:"1.0.0",OPB64name:"IFTE"},{name:"IMMUTABLE",detail:"list<LIST>  IMMUTABLE  immutableList<LIST>\nmap<MAP>  IMMUTABLE  immutableMap<MAP>\nset<SET>  IMMUTABLE  immutableSet<SET>\nvector<VLIST>  IMMUTABLE  immutableVector<VLIST>",documentation:"Transforms a collection (**LIST**, **MAP**, **VLIST**, **SET**) into an immutable one. Any attempt to modify the immutable collection will fail. The original collection is not modified.\n\n@param `list` List to wrap into an immutable wrapper.\n\n@param `map` Map to wrap into an immutable wrapper.\n\n@param `set` Set to wrap into an immutable wrapper.\n\n@param `vector` Vector to wrap into an immutable wrapper.\n\n@param `immutableList` Immutable version of 'list'.\n\n@param `immutableMap` Immutable version of 'map'.\n\n@param `immutableSet` Immutable version of 'set'.\n\n@param `immutableVector` Immutable version of 'vector'.\n\n",tags:["lists","maps","sets"],since:"1.0.0",OPB64name:"IMMUTABLE"},{name:"IMPORT",detail:"prefix<STRING> as<STRING>  IMPORT ",documentation:"The `IMPORT` function allows to create aliases for macro name prefixes. This is handy when accessing macros from WarpFleet™ repositories which might have multiple versions and/or long group and artifact ids. When fetching a macro, the *imported* prefixes will be scanned and the longest matching one will be replaced by the associated alias.\n\n@param `prefix` Original prefix to *import*.\n\n@param `as` Name under which `prefix` will be imported.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"IMPORT"},{name:"INCREMENTEXACT",detail:"value<NUMBER>  INCREMENTEXACT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  INCREMENTEXACT  lresult<LIST<DOUBLE>>",documentation:"The `INCREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value incremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be incremented by one\n\n@param `result` The incremented value\n\n@param `lvalue` List of values to be incremented by one\n\n@param `lresult` List of incremented values\n\n",tags:["math"],since:"1.2.23",OPB64name:"INCREMENTEXACT"},{name:"INFLATE",detail:"compressed<BYTES>  INFLATE  uncompressed<BYTES>",documentation:"Decompresses a byte array containing data compressed by [`DEFLATE`](doc/DEFLATE).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",tags:["conversion"],since:"2.1.0",OPB64name:"INFLATE"},{name:"INFO",detail:"{ plugin<STRING> ext<STRING> name<STRING> since<STRING> deprecated<STRING> deleted<STRING> version<STRING> tags<LIST> desc<STRING> sig<LIST> params<MAP> related<LIST> examples<LIST> conf<LIST>  } INFO ",documentation:"Generate documentation of a function or a macro.\n\n@param `conf` String list of related configuration keys existing in the Warp 10 configuration.\n\n@param `examples` String list of WarpScript examples.\n\n@param `related` String list of related functions.\n\n@param `params` Map describing the parameters defined in `sig`.\n\n@param `sig` List of signatures. Each signature is a **LIST** with 2 lists (input and output) which contain parameter definitions: *eg* `param1:STRING` in stack order (top first)\n\n@param `desc` Description of the function or macro.\n\n@param `tags` String list tags (*eg* categories).\n\n@param `version` Version of the Warp 10 distribution on which this funcion is available (`standalone` | `distributed` | `all` | `pkg` | `ext` | `plugin`)\n\n@param `deleted` Version's number of Warp 10 where this function (or macro) was deleted.\n\n@param `deprecated` Version's number of Warp 10 where this function (or macro) was deprecated.\n\n@param `since` Version's number of Warp 10 where this function (or macro) was included.\n\n@param `name` Name of the function or macro.\n\n@param `ext` Fully qualified class name of the WarpScript Extension defining the function.\n\n@param `plugin` Fully qualified class name of the WarpScript Plugin defining the function.\n\n",tags:["platform","help"],since:"1.2.14",OPB64name:"INFO"},{name:"INFOMODE",detail:" INFOMODE ",documentation:"Toggles the info mode ON or OFF depending on its current state. Default is OFF when the stack is created.\n\nWhen info mode is ON, the [`INFO`](/doc/INFO) function pushes its map parameter on the stack and stops the current execution as [`STOP`](/doc/STOP) would do.\n\n",tags:["platform","help"],since:"1.2.14",OPB64name:"INFOMODE"},{name:"INTEGRATE",detail:"gts<GTS> initial<NUMBER>  INTEGRATE  result<GTS>\nlgts<LIST<GTS>> initial<NUMBER>  INTEGRATE  lresult<LIST<GTS>>",documentation:"The `INTEGRATE` function takes a GTS or a list thereof and integrates it/them, considering the value at each tick is a rate of change per second.\n\n@param `initial` Initial value\n\n@param `gts` GTS to integrate\n\n@param `lgts` List of GTS to integrate\n\n@param `result` Integrated GTS\n\n@param `lresult` List of integrated GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"INTEGRATE"},{name:"INTERPOLATE",detail:"gts<GTS>  INTERPOLATE  result<GTS>\ngtsList<LIST<GTS>>  INTERPOLATE  resultList<LIST<GTS>>",documentation:"The `INTERPOLATE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with by interpolating linearly. \n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled bucketized GTS\n\n@param `resultList` list of filled bucketized GTS\n\n",tags:["bucketize"],since:"1.0.0",OPB64name:"INTERPOLATE"},{name:"INTERSECTION",detail:"setA<SET> setB<SET>  INTERSECTION  output<SET>",documentation:"Computes the intersection &#x2229; of two sets.\n\nThe `INTERSECTION` function consumes two sets from the top of the stack and pushes back its mathematical intersection (ie: the elements in common).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x2229; *B*\n\n",tags:["sets"],since:"1.0.0",OPB64name:"INTERSECTION"},{name:"INV",detail:"matrix<MATRIX>  INV  inverse<MATRIX>",documentation:"Inverts a matrix. The inversion is attempted using the [LU Decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.\n\nIf the matrix is singular or not square an error will be raised.\n\n@param `matrix` Matrix to invert.\n\n@param `inverse` Inverse of the original matrix.\n\n",tags:["math"],since:"1.0.6",OPB64name:"INV"},{name:"ISAUTHENTICATED",detail:" ISAUTHENTICATED  result<BOOLEAN>",documentation:"Returns true or false whether or not the stack is authenticated\n\n@param `result` True if the stack is authenticated, false otherwise\n\n",tags:["stack"],since:"1.2.11",OPB64name:"ISAUTHENTICATED"},{name:"ISNULL",detail:"p<ANY>  ISNULL  result<BOOLEAN>",documentation:"The `ISNULL` function consumes a parameter p from the top of the stack and pushes onto the stack true if p is null, else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p is null\n\n",tags:["math","logic"],since:"1.0.0",OPB64name:"ISNULL"},{name:"ISNaN",detail:"p<ANY>  ISNaN  result<BOOLEAN>",documentation:"The `ISNaN` function consumes a numeric parameter p from the top of the stack and pushes onto the stack true if p is Not a Number (NaN), else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p a Double and is NaN, false  otherwise\n\n",tags:["math"],since:"1.0.0",OPB64name:"ISNaN"},{name:"ISO8601",detail:"timestamp<LONG>  ISO8601  iso8601dateAndTime<STRING>\ntimestamp<LONG> timezone<STRING>  ISO8601  iso8601dateAndTime<STRING>",documentation:"The `ISO8601` function consumes an optional **STRING** timezone and a **LONG** UTC timestamp and pushes back a **STRING** representing the date and time according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\n\nDepending on the platform time unit, the part representing seconds can have 3, 6 or 9 significant figures respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time representation.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `iso8601dateAndTime` Representation of the date and time of the given timestamp for the givent timezone according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"ISO8601"},{name:"ISODURATION",detail:"duration<LONG>  ISODURATION  iso8601duration<STRING>",documentation:"The `ISODURATION` function consumes a **LONG** duration in platform unit and pushes back a **STRING** reresenting an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). Whatever the platform time unit is, the representation maximum resolution is milliseconds.\n\nThe format of the ISO 8601 representation is `PThHmMs.xS` with `h` as hours, `m` as minutes, `s` as seconds and `x` as milliseconds. If any of these value is zero, the value and unit are omitted. The only exception is for a duration of 0 which is represented as `PT0S`. If the duration is negative, `h`, `m` and `s`, if displayed, are negative numbers. \n\n@param `duration` A duration expressed in platform time unit.\n\n@param `iso8601duration` A representation of the consumed duration according to ISO 8601.\n\n",tags:["time"],since:"1.0.0",OPB64name:"ISODURATION"},{name:"ISONORMALIZE",detail:"gts<GTS>  ISONORMALIZE  result<GTS>\ngtsList<LIST<GTS>>  ISONORMALIZE  resultList<LIST<GTS>>",documentation:"The `ISONORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between -1 and 1 (i.e. it replaces X by \n(X - mean)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ISONORMALIZE"},{name:"JOIN",detail:"string<STRING*> sep<STRING> n<LONG>  JOIN  result<STRING>\nobjects<LIST> sep<STRING>  JOIN  result<STRING>",documentation:"Join N strings with the given separator.\n\n@param `n` Number of elements to join that it needs to take from the top of the stack.\n\n@param `sep` Separator used to join the strings.\n\n@param `string` One or more string on the stack.\n\n@param `objects` List of objects whose string representations are to be joined.\n\n@param `result` Joined string.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"JOIN"},{name:"JSON->",detail:"json<STRING>  JSON->  resultMap<MAP>\njson<STRING>  JSON->  resultList<LIST>",documentation:"The `JSON->` function parses a string as [JSON](http://json.org/) from the top of the stack and pushes the result onto the stack.\n\n@param `json` String JSON representation\n\n@param `resultMap` Map JSON representation if it is a JSON object\n\n@param `resultList` List JSON representation if it is a JSON array\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"H_CEIXoy"},{name:"JSONLOOSE",detail:"",documentation:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONLOOSE` function configures the stack to send results in a loose [JSON](http://json.org/) format where `NaN` and `Infinite` are valid values.\n\nIf the [JSON](http://json.org/) parser you’re using is strict, you should either configurate the [`JSONSTRICT`](/doc/JSONSTRICT) mode or dealing with \n`NaN` and `Infinite` values outside the parser.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"JSONLOOSE"},{name:"JSONSTACK",detail:" JSONSTACK ",documentation:"Select the JSON format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"JSONSTACK"},{name:"JSONSTRICT",detail:"",documentation:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONSTRICT` function configures the stack to send results in strict [JSON](http://json.org/) format.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"JSONSTRICT"},{name:"KEYLIST",detail:"map<MAP>  KEYLIST  result<LIST>",documentation:"Gets keys from a **MAP**.\n\nThe function `KEYLIST` extracts the keys of a map on the top of the stack and pushes on the stack a list with those keys. The map is consumed.      \n\n@param `map` Map from which you want to extract keys\n\n@param `result` List of keys\n\n",tags:["maps"],since:"1.0.0",OPB64name:"KEYLIST"},{name:"KURTOSIS",detail:"gts<GTS> bessel<BOOLEAN>  KURTOSIS  kurtosis<DOUBLE>\nlgts<LIST<GTS>> bessel<BOOLEAN>  KURTOSIS  lkurtosis<LIST<DOUBLE>>",documentation:"The `KURTOSIS` function computes the [kurtosis](https://en.wikipedia.org/wiki/Kurtosis) of a Geo Time Series™ or a list thereof.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the kurtosis.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `kurtosis` Computed kurtosis of the Geo Time Series™ instance.\n\n@param `lkurtosis` List of computed kurtosis of the Geo Time Series™ instances.\n\n",tags:["gts","statistics"],since:"1.2.13",OPB64name:"KURTOSIS"},{name:"LABELS",detail:"gts<GTS>  LABELS  return<MAP>\nencoder<GTSENCODER>  LABELS  return<MAP>",documentation:"The `LABELS` function consumes a GTS from the stack, extracts its labels, puts them in a map and pushes the map onto the stack.\n\n@param `gts` The Geo Time Series™ to get the labels from.\n\n@param `encoder` The Geo Time Series™ Encoder to get the labels from.\n\n@param `return` Labels MAP\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LABELS"},{name:"LASTACTIVITY",detail:"gts<GTS>  LASTACTIVITY  lastactivity<LONG>\nencoder<GTSENCODER>  LASTACTIVITY  lastactivity<LONG>\nlgts<LIST<GTS>>  LASTACTIVITY  llastactivity<LONG>\nlencoder<LIST<GTSENCODER>>  LASTACTIVITY  llastactivity<LONG>",documentation:"Extracts the timestamp of last activity recorded in the Geo Time Series™ metadata.\n\nThe timestamp is expressed as platform time units elapsed since the Unix Epoch.\n\n@param `gts` Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `encoder` Geo Time Series™ encoder from which to extract the last activity timestamp.\n\n@param `lgts` List of Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `lencoder` List of Geo Time Series™ encoders from which to extract the last activity timestamp.\n\n@param `lastactivity` Timestamp of last activity.\n\n@param `llastactivity` List of timestamps of last activity.\n\n",tags:["gts"],since:"2.0.0",OPB64name:"LASTACTIVITY"},{name:"LASTBUCKET",detail:"gts<GTS>  LASTBUCKET  result<LONG>",documentation:"The function `LASTBUCKET` consumes a GTS off the stack and pushes its lastbucket onto the stack.\n\nNote: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Last bucket timestamp\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"LASTBUCKET"},{name:"LASTSORT",detail:"gtsList<LIST<GTS>>  LASTSORT  result<LIST<GTS>>",documentation:"Sorts a list of Geo Time Series™ according to their most recent value. If most recent values are identical, ticks will be compared, the most recent \nappearing first. If the ticks are also identical, then metadata (class and labels) will be compared.\n\nUse this function to compute Top N queries.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Sorted list of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LASTSORT"},{name:"LASTTICK",detail:"gts<GTS>  LASTTICK  result<LONG>\nlgts<LIST<GTS>>  LASTTICK  result<LONG>",documentation:"The `LASTTICK` function pushes on the stack the newest tick of the Geo Time Series™ on top of the stack or, if the GTS is bucketized, its last bucket.\n\nWhen applied to a list of GTS, `LASTTICK` will return the greatest last tick found across all Geo Time Series™.\n\nIf the GTS does not have values, `Long.MIN_VALUE` is pushed.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `gts` Geo Time Series™.\n\n@param `result` Last tick value.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LASTTICK"},{name:"LBOUNDS",detail:"lower<DOUBLE> upper<DOUBLE> n<LONG>  LBOUNDS  bounds<LIST<DOUBLE>>",documentation:"The `LBOUNDS` function computes bounds which divide a specified interval into `n` intervals of equal length.\n\nThe result of `LBOUNDS` is a list of `n+1` bounds, defining `n` intervals inside the specified range plus the two bounds of this range which define the intervals before and after the range.\n\n@param `n` Number of intervals to generate.\n\n@param `upper` Upper bound of the range to subdivide.\n\n@param `lower` Lower bound of the range to subdivide.\n\n@param `bounds` List of computed bounds.\n\n",tags:["math"],since:"1.0.0",OPB64name:"LBOUNDS"},{name:"LFLATMAP",detail:"inputlist<LIST> macro<MACRO>  LFLATMAP  results<LIST>\ninputlist<LIST> macro<MACRO> index<BOOLEAN>  LFLATMAP  results<LIST>",documentation:"The `LFLATMAP` function applies a macro on each element of a list, producing a list \nwith the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the list index on top and the element \nat that particular index below it. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\nDifference with `LMAP`: if the macro returns a list, then LFLATMAP will produce a \nlist with the elements of the macro output list (_i.e._ it will _flatten_ the list). \n\nDifference with `LMAP FLATTEN`: flatten will do the list flattening recursively. \n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count -1) will be on the top of the stack. By default, true.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"LFLATMAP"},{name:"LIMIT",detail:"maxDataPoints<LONG>  LIMIT ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and \na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `LIMIT` function modifies the maximum number of datapoints which can be fetched during a script execution by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call `AUTHENTICATE` with a valid token.\n\n@param `maxDataPoints` Maximal data points retrieved from database in a single FETCH\n\n",tags:["platform"],since:"1.0.0",OPB64name:"LIMIT"},{name:"LINEOFF",detail:"",documentation:"The `LINEOFF` function disables the automatic labelling of WarpScript code as enabled by `LINEON`.      \n\n",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEOFF"},{name:"LINEON",detail:"",documentation:"The `LINEON` function enables the automatic section labelling at the beginning of each line of the input WarpScript code. This handy feature greatly simplifies the debug process as the exact line number where an error happens will appear in the error message embedded as a section name of the form `[Line #xx]`.\n\nThis automatic labelling only works with the `/exec` endpoint of Warp 10.\n\n",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEON"},{name:"LIST->",detail:"input<LIST>  LIST->  elements<ANY*> listlength<LONG>",documentation:"The `LIST->` function extracts the elements of the **LIST** at the top of the stack\nand pushes them onto the stack one by one. The function then pushes\nonto the stack the number of elements that were in the **LIST**.\n\n@param `input` The input list, will be consumbed\n\n@param `listlength` The length N of input\n\n@param `elements` N elements pushed on the stack\n\n",tags:["lists","conversion"],since:"1.0.0",OPB64name:"I3_IK1oy"},{name:"LMAP",detail:"inputlist<LIST> macro<MACRO>  LMAP  results<LIST>\ninputlist<LIST> macro<MACRO> index<BOOLEAN>  LMAP  results<LIST>",documentation:"The `LMAP` function applies a macro on each element of a **LIST**, producing a **LIST** with the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **LIST** index on top and the element at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"LMAP"},{name:"LOAD",detail:"name<STRING>  LOAD  value<ANY>\nregister<LONG>  LOAD  value<ANY>",documentation:"The `LOAD` function pushes onto the stack the value currently associated with a symbol name.      \n\nIf the symbol is not defined, an error will be raised.\n\n@param `name` Name of symbol whose value should be retrieved.\n\n@param `register` Register number whose value should be retrieved.\n\n@param `value` Retrieved value.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"LOAD"},{name:"LOCATIONOFFSET",detail:"gts<GTS> distance<NUMBER>  LOCATIONOFFSET  result<GTS>\ngtsList<LIST<GTS>> distance<NUMBER>  LOCATIONOFFSET  resultList<LIST<GTS>>",documentation:"The `LOCATIONOFFSET` function downsamples a Geo Time Series™ by retaining the first and last datapoints and only those datapoints which are \nmore than a given distance away.\n\n@param `distance` Distance in meters\n\n@param `gts` Geo Time Series™ to downsample\n\n@param `gtsList` List of Geo Time Series™ to downsample\n\n@param `result` Downsampled Geo Time Series™\n\n@param `resultList` List of downsampled Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LOCATIONOFFSET"},{name:"LOCATIONS",detail:"gts<GTS>  LOCATIONS  latitudes<LIST<DOUBLE>> longitudes<LIST<DOUBLE>>",documentation:"The `LOCATIONS` function consumes a Geo Time Series™ from the stack, extracts the locations of a Geo Time Series™, puts them in two lists \n(a list of latitudes and a list of longitudes) and pushes the two lists onto the stack.\n\n@param `gts` GTS\n\n@param `longitudes` List of longitudes\n\n@param `latitudes` List of latitudes\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCATIONS"},{name:"LOCSTRINGS",detail:"gts<GTS>  LOCSTRINGS  result<LIST<STRING>>",documentation:"The `LOCSTRINGS` function extract the locations from a Geo Time Series™ and builds a list of the 64 bits hexadecimal representation of their \n[HHCode](https://en.wikipedia.org/wiki/HHCode).\n\n@param `gts` Geo Time Series™\n\n@param `result` List of [HHCode](https://en.wikipedia.org/wiki/HHCode)\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCSTRINGS"},{name:"LOG",detail:"value<NUMBER>  LOG  result<DOUBLE>\nlvalue<LIST<NUMBER>>  LOG  lresult<LIST<DOUBLE>>",documentation:"The `LOG` function consumes a floating point number x from the top of the stack and pushes back its natural logarithm, log<sub>e</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Natural logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of natural logarithms of the given values\n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG"},{name:"LOG10",detail:"value<NUMBER>  LOG10  result<DOUBLE>\nlvalue<LIST<NUMBER>>  LOG10  lresult<LIST<DOUBLE>>",documentation:"The `LOG10` function consumes a floating point number x from the top of the stack and pushes back its common logarithm, log<sub>10</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Common logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of common logarithms of the given values\n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG10"},{name:"LOG1P",detail:"value<NUMBER>  LOG1P  result<DOUBLE>\nlvalue<LIST<NUMBER>>  LOG1P  lresult<LIST<DOUBLE>>",documentation:"Returns the natural logarithm of the sum of the argument and 1.\n\nThe `LOG1P` function consumes a number from the top of the stack and pushes back the natural logarithm for (arg + 1).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Logarithm of (value + 1)\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of logarithm of (value + 1)\n\n",tags:["math"],since:"1.0.0",OPB64name:"LOG1P"},{name:"LOGEVENT->",detail:"logline<STRING>  LOGEVENT->  decodedlog<STRING>",documentation:"Warp&nbsp;10™ runner execution logs are encrypted. See [this documentation](/content/03_Documentation/06_Operations/05_Logs/).\n\nThe easiest way to read logs is to copy the log output and use this function.\n\n\n@param `logline` The opb64 representation of the aes encrypted log line\n\n@param `decodedlog` The decoded logs.\n\n",tags:["debug"],since:"1.2.7",OPB64name:"I3x6GKO4I_FhEV"},{name:"LOGMSG",detail:"msg<STRING>  LOGMSG ",documentation:"`LOGMSG` function prints millisecond timestamp and input text on the standard output.\n\nThe `LOGMSG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"LOGMSG"},{name:"LOWESS",detail:"gts<GTS> bandwidth<LONG>  LOWESS  result<GTS>\ngtsList<LIST<GTS>> bandwidth<LONG>  LOWESS  lresult<LIST<GTS>>",documentation:"The `LOWESS` function consumes a bandwidth (a **LONG**) from the top of the stack, then smooths a GTS or a **LIST** of GTS that are below by using \nlocal regression.\n\nTo obtain a good smoothing, it is advised to choose an odd number of at least 5 as the bandwidth parameter.\n\n@param `bandwidth` The bandwitdth parameter is the number of nearest neighbours to consider when applying the local regression.\n\n@param `gts` Geo Time Series™.\n\n@param `gtsList` List of Geo Time Series™.\n\n@param `lresult` List of Geo Time Series™ result.\n\n@param `result` Geo Time Series™ result.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LOWESS"},{name:"LR",detail:"gts<GTS>  LR  alpha<DOUBLE> beta<DOUBLE>",documentation:"Compute the [simple linear regression](https://en.wikipedia.org/wiki/Linear_regression) parameters `alpha` (y-intercept) and `beta` (line slope) for the given numerical Geo Time Series™.\n\n@param `gts` Geo Time Series™ on which to compute linear regression.\n\n@param `beta` The slope of the line fitted on the GTS values.\n\n@param `alpha` The y-intercept of the lined fitted on the GTS values.\n\n",tags:["gts","statistics"],since:"1.0.13",OPB64name:"LR"},{name:"LSORT",detail:"inputlist<LIST>  LSORT  sortedlist<LIST>",documentation:"The `LSORT` function sorts the list on the top of the stack.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `inputlist` The reference of the list to sort\n\n@param `sortedlist` The original list sorted, this is not a new list object\n\n",tags:["lists"],since:"1.0.0",OPB64name:"LSORT"},{name:"LTTB",detail:"gts<GTS> samples<LONG>  LTTB  downsampled<GTS>\nlgts<LIST<GTS>> samples<LONG>  LTTB  ldownsampled<LIST<GTS>>",documentation:"The `LTTB` function downsamples a Geo Time Series™ or list thereof using the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",tags:["gts"],since:"1.0.11",OPB64name:"LTTB"},{name:"MACROBUCKETIZER",detail:"macro<MACRO>  MACROBUCKETIZER  result<AGGREGATOR>",documentation:"`MACROBUCKETIZER` converts a macro into a bucketizer which can be used with the [`BUCKETIZE`](/doc/BUCKETIZE) framework.\n\nFor each tick in the mapped GTS, the macro will be called with a list containing the following elements on the stack:\n\n```js\n[tick_of_computation,[gts_classes],[label_bucketize],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n@param `macro` Macro used as a bucketizer\n\n@param `result` Bucketizer to apply\n\n",tags:["bucketize","bucketizer"],since:"1.0.0",OPB64name:"MACROBUCKETIZER"},{name:"MACROCONFIG",detail:"key<STRING>  MACROCONFIG ",documentation:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration keys looked up are those built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIG`.\n\n`MACROCONFIG` will check if the keys exists, if not it will remove the part of the macro name after the last `/` and will try that new key. It will successively try all names up to the last part of the macro name.\n\nIf none of those keys existed, the call will end in error.\n\nSo for example, if `MACROCONFIG` is called from a macro `my/test/macro` to retrieve the value associated with `mykey`, it will look up the following keys in the configuration:\n\n```\nmykey@my/test/macro\nmykey@my/test\nmykey@my\n```\n\n@param `key` Configuration key to look up.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIG"},{name:"MACROCONFIGDEFAULT",detail:"key<STRING> default<STRING>  MACROCONFIGDEFAULT ",documentation:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration key looked is built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIGDEFAULT`.\n\n`MACROCONFIGDEFAULT` will check if the keys exists, if not it will push the provided default value onto the stack, or fail with an error if the default was `NULL`. If the key is found, the associated value is pushed on the stack.\n\n@param `key` Configuration key to look up.\n\n@param `default` Default value to use if the key was not found, or `NULL` to fail if the key is absent.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGDEFAULT"},{name:"MACROCONFIGSECRET",detail:"oldSecret<STRING> newSecret<STRING>  MACROCONFIGSECRET ",documentation:"The `MACROCONFIGSECRET` macro consumes 2 elements on the stack, the current and new secret to be set. If no secret has been set, the function will throw an error.\n\nThe secret set by this function is the secret used by [`SETMACROCONFIG`](/doc/SETMACROCONFIG).\n\n@param `newSecret` New secret to override the current one.\n\n@param `oldSecret` Currently set secret.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGSECRET"},{name:"MACROFILLER",detail:"macro<MACRO> prewindow<LONG> postwindow<LONG>  MACROFILLER  filler<FILLER>",documentation:"`MACROFILLER` converts a macro into a *filler* which can be used with the [`FILL`](/doc/FILL) function.\n\nThe macro will find the following elements on the stack when it is called:\n\n```\n6: Geo Time Series™ to fill. Both this GTS and the one above are only meant to expose the metadata\n5: Geo Time Series™ of the *other* GTS with a value at the current tick\n4: list of [ tick latitude longitude elevation value ] for the pre window\n3: [ tick latitude longitude elevation value ] of the *other* Geo Time Series™\n2: list of [ tick latitude longitude elevation value ] for the post window\nTOP: tick which is being filled\n```\n\nIt must leave on the stack a list containing the following elements, in this order:\n\n*tick*, *latitude* or `NaN`, *longitude* or `NaN`, *elevation* or `NaN`, *value*\n\n\n@param `macro` Macro to wrap.\n\n@param `prewindow` Number of datapoints needed ahead of the missing datapoint.\n\n@param `postwindow` Number of datapoints needed after the missing datapoint.\n\n@param `filler` Filler instance.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"MACROFILLER"},{name:"MACROFILTER",detail:"macro<MACRO>  MACROFILTER  result<FILTER>",documentation:"`MACROFILTER` converts a macro into a filter which can be used with the [`FILTER`](/doc/FILTER) framework\n\nFor each equivalence classes in the filter set of Geo Time Series™, the macro will be called with the following elements on the stack:\n\n```\n[gts], {labels_equivalence_class}\n```\n\nAfter each call the macro is expected to leave a list on the stack.\n\n@param `macro` Macro to apply\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"MACROFILTER"},{name:"MACROMAPPER",detail:"macro<MACRO>  MACROMAPPER  result<AGGREGATOR>",documentation:"`MACROMAPPER` converts a macro into a mapper which can be used with the [`MAP`](/doc/MAP) framework.\n\nFor each tick in the mapped Geo Time Series™, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROMAPPER` can also create a multivariate mapper, that is, a mapper that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate mapper with MAP, each input GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n\n@param `macro` Macro to convert\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"MACROMAPPER"},{name:"MACROREDUCER",detail:"macro<MACRO>  MACROREDUCER  result<AGGREGATOR>",documentation:"`MACROREDUCER` converts a macro into a reducer which can be used with the [`REDUCE`](/doc/REDUCE) framework\n\nFor each tick in the Geo Time Series™ to reduce, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nEach list have a length of the number of GTSs in the partition. Each missing value are replaced by `null`, each missing tick by the minimum value of long and each missing latitude, longitude or elevation by NaN. The `label_maps` list as one more element at the end compared to the other lists: the common labels for the GTSs of the partition.\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROREDUCER` can also create a multivariate reducer, that is, a reducer that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate reducer with REDUCE, each input List of GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n@param `macro` Macro to apply\n\n@param `result` Reducer to apply\n\n",tags:["reducer"],since:"1.0.0",OPB64name:"MACROREDUCER"},{name:"MACROTTL",detail:"ttl<LONG>  MACROTTL ",documentation:"In a file defining a server side macro, the `MACROTTL` function defines the time to live of the macro code. If the macro is accessed after this delay has expired and ondemand loading of macros is enabled, it will unconditionnaly be reloaded from disk.\n\nThis feature is very useful when you have macros generated dynamically on the server side which change frequently. Using `MACROTTL` you can ensure the newest code is loaded regardless of the rescan interval of the macro directory.\n\nIn a the file defining a server side macro, the call to `MACROTTL` should appear before or after the actual macro definition but not within.\n\nThe time after which the macro will no longer be valid is the time of the call to `MACROTTL` plus its parameter.\n\n@param `ttl` The time to live to apply to the macro, in ms.\n\n",tags:["platform"],since:"1.2.13",OPB64name:"MACROTTL"},{name:"MAKEGTS",detail:"timestamps<LIST> latitudes<LIST> longitudes<LIST> elevations<LIST> values<LIST>  MAKEGTS  result<GTS>",documentation:"The `MAKEGTS` function builds a Geo Time Series™ from **LIST**s.\n\nThe timestamp and values lists must be of the exact same size.\nHowever, as latitudes, longitudes and elevations are optional in a Geo Time Series™, these lists can be shorter than the timestamps lists or even empty. If there are missing latitudes, longitudes and elevations, use [`NaN`](/doc/NaN).\n\n@param `values` Values of the GTS\n\n@param `elevations` Elevations of the GTS\n\n@param `longitudes` Longitudes of the GTS\n\n@param `latitudes` Latitudes of the GTS\n\n@param `timestamps` Timestamps of the GTS\n\n@param `result` Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MAKEGTS"},{name:"MAN",detail:"function<STRING>  MAN  url<STRING>\nany<ANY>  MAN  url<STRING>\n MAN  url<STRING>",documentation:"The `MAN` function returns the help link for a function name.\n\nIf the function does not exists, it returns http://www.warp10.io/\n\n\n@param `function` The function name\n\n@param `any` Anything except a function name\n\n@param `url` URL of the online help\n\n",tags:["misc","help"],since:"1.2.18",OPB64name:"MAN"},{name:"MAP",detail:"[ gts<GTS+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> ]  MAP  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> ]  MAP  result<LIST<GTS>>\n[ gts<GTS+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> ]  MAP  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> ]  MAP  result<LIST<GTS>>\n[ gts<GTS+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> ]  MAP  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> ]  MAP  result<LIST<GTS>>\ngts<GTS+> { mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> outputTicks<LIST<LONG>>  } MAP  result<LIST<GTS>>\ngtsList<LIST<GTS>+> { mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> outputTicks<LIST<LONG>>  } MAP  result<LIST<GTS>>",documentation:"The `MAP` framework applies a function on values of a Geo Time Series™ that fall into a sliding window.\n\nThe `MAP` framework is designed to use an existing MAPPER or a custom MACROMAPPER. It could also accept a macro: the current window is passed as a GTS to the macro. See examples below.\n\n@param `result` List of Geo Time Series™, one for each input, whose values are the results of the function application on each sliding window. If the input series is bucketized, the result series will be too unless outputTicks is non null.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `mapper` Mapper function to apply\n\n@param `pre` Width of the sliding window before the current tick. This parameter is interpreted as a number of ticks if its value is positive, and as a number of time units if its value is negative. A value of 0 means the sliding window does not cover the past. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the past. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `post` Width of the sliding window after the current tick. Values have the same semantics as for the `pre` parameter. A value of 0 means the sliding window does not cover the future. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the future. Defaults to 0.\n\n@param `occurrences` Limit the number of computations to that number. If the value is 0, compute a value for each tick of the input Geo Time Series™. If it is non-negative, compute that many values starting from the oldest to the most recent tick. In the other case, do that many computations in the reverse order. This is useful when you are interested in a single result, like the max or sum of all values. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `step` The step size in number of ticks. The mapper beggins at the oldest tick and goes to the tick `step` after the current one and so on. Defaults to 1.\n\n@param `overrideTick` If set to true, the tick value returned by the mapper is used to update the current tick, else it is ignored and the original tick is kept. Defaults to false.\n\n@param `outputTicks` If non null, it sets the list of ticks that is traversed to anchor the sliding windows (instead of the ticks of the input Geo Time Series™). In that case, a tick of the input Geo Time Series™ that would be equal to one of these anchor points is counted by a positive `post` if `occurences` is non-negative, or by a positive `pre` if `occurences` is negative.\n\n",tags:["mapper","framework"],since:"1.0.0",OPB64name:"MAP"},{name:"MAP->",detail:"map<MAP>  MAP->  key<ANY*> value<ANY*> mapsize<LONG>",documentation:"The `MAP->` function expands the **MAP** on top of the stack into pairs of elements followed by the number of elements extracted. If the **MAP** was \ncreated by a call to `->MAP`, the order of the elements will be the same as prior to calling `->MAP`.\n\n@param `map` Map to expand\n\n@param `key` Key of the pair\n\n@param `value` Value of the pair\n\n@param `mapsize` The number of key value pushed on the stack.\n\n",tags:["maps","conversion"],since:"1.0.0",OPB64name:"IJ4FAIs"},{name:"MAPID",detail:"input<MAP>  MAPID  result<STRING>",documentation:"Generates a fingerprint of a map.\n\n@param `input` Input map\n\n@param `result` Fingerprint of the map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"MAPID"},{name:"MARK",detail:" MARK  mark<MARK>",documentation:"Pushes a mark onto the stack.\n\n@param `mark` A MARK instance.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"MARK"},{name:"MAT->",detail:"input<MATRIX>  MAT->  [  result<LIST<LIST<DOUBLE>>>  ]",documentation:"The `MAT->` function converts a Matrix into nested lists.\n\n\n@param `input` Matrix to convert\n\n@param `result` Nested list of values\n\n",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"IJ4JAIs"},{name:"MATCH",detail:"string<STRING> regexp<STRING>  MATCH  result<LIST<STRING>>\nstring<STRING> regexp<MATCHER>  MATCH  result<LIST<STRING>>",documentation:"The `MATCH` function applies a regular expression (regexp) to a string.\n\nIt consumes two parameters from the top of the stack: the regexp pattern and the string to test matching with.\n\nIf the string doesn’t match the regexp, the function return an empty list. If it matches, the function will return a list of every matching group.\n\nInstead of using a regular expression **STRING**, you can also use the result of [`MATCHER`](/doc/MATCHER) for improved performance.\n\n@param `regexp` Regular expression to apply\n\n@param `string` String to evaluate\n\n@param `result` List of every matching group.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"MATCH"},{name:"MATCHER",detail:"regexp<STRING>  MATCHER  result<MATCHER>",documentation:"The `MATCHER` function will compile a regular expression into an efficient object which can be used by [`MATCH`](/doc/MATCH).\n\n@param `regexp` Regular expression to compile\n\n@param `result` Compiled regula expression\n\n",tags:["strings"],since:"1.0.0",OPB64name:"MATCHER"},{name:"MAX",detail:"p1<LONG> p2<LONG>  MAX  result<LONG>\np1<LONG> p2<DOUBLE>  MAX  result<DOUBLE>\np1<DOUBLE> p2<LONG>  MAX  result<DOUBLE>\np1<DOUBLE> p2<DOUBLE>  MAX  result<DOUBLE>\np1<COUNTER> p2<COUNTER>  MAX  result<LONG>\np1<COUNTER> p2<DOUBLE>  MAX  result<DOUBLE>\np1<DOUBLE> p2<COUNTER>  MAX  result<DOUBLE>\np1<COUNTER> p2<LONG>  MAX  result<DOUBLE>\np1<LONG> p2<COUNTER>  MAX  result<DOUBLE>\nllist<LIST<LONG>>  MAX  sresult<LONG>\ndlist<LIST<DOUBLE>>  MAX  sresult<DOUBLE>\nclist<LIST<COUNTER>>  MAX  sresult<LONG>\nllist<LIST<LONG>> value<LONG>  MAX  lresult<LIST<LONG>>\nclist<LIST<COUNTER>> value<COUNTER>  MAX  lresult<LIST<LONG>>\ndlist<LIST<DOUBLE>> value<DOUBLE>  MAX  lresult<LIST<DOUBLE>>",documentation:"Returns the greater of two numeric values.\n\nThe `MAX` function consumes two numeric parameters from the top of the stack and pushes back the greatest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The larger of p1 and p2.\n\n@param `sresult` The larger of the elements in the given list.\n\n@param `lresult` A list where each value is the max between the element in the list and the given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"MAX"},{name:"MAXBUCKETS",detail:"limit<LONG>  MAXBUCKETS ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXBUCKETS` function modifies the maximum number of buckets which can be created by a call to [`BUCKETIZE`](/doc/BUCKETIZE) by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform","bucketize"],since:"1.0.0",OPB64name:"MAXBUCKETS"},{name:"MAXDEPTH",detail:"limit<LONG>  MAXDEPTH ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXDEPTH` function modifies the maximum depth (number of levels) of the execution stack by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform","stack"],since:"1.0.0",OPB64name:"MAXDEPTH"},{name:"MAXGEOCELLS",detail:"maxcells<LONG>  MAXGEOCELLS ",documentation:"Modifies the maximum number of cells a **GEOSHAPE** created by [`GEO.WKT`](/doc/GEO.WKT) or [`GEO.JSON`](/doc/GEO.JSON) can have. The limit can be modified up to the configured value for `warpscript.maxgeocells.hard`.\n\n@param `maxcells` New limit to set.\n\n",tags:["platform"],since:"1.2.11",OPB64name:"MAXGEOCELLS"},{name:"MAXGTS",detail:"limit<LONG>  MAXGTS ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard limit \nwhich can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXGTS` function modifies the maximum number of Geo Time Series™ which can be fetched by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform","gts"],since:"1.0.0",OPB64name:"MAXGTS"},{name:"MAXJSON",detail:"limit<LONG>  MAXJSON ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to\nthe hard limit value.\n\nThe `MAXJSON` function modifies the maximum number of characters in a json produced by [`->JSON`](/doc/AIt9JoxD).\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"2.5.0",OPB64name:"MAXJSON"},{name:"MAXLONG",detail:" MAXLONG  result<LONG>",documentation:"Pushes [Long.MAX_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MAX_VALUE) onto the stack.\n\n@param `result` Long.MAX_LONG\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"MAXLONG"},{name:"MAXLOOP",detail:"limit<LONG>  MAXLOOP ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard\nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe MAXLOOP function modifies the maximum number of milliseconds which can be spent in a loop setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXLOOP"},{name:"MAXOPS",detail:"limit<LONG>  MAXOPS ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXOPS` function modifies the maximum number of operations which can be performed during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXOPS"},{name:"MAXPIXELS",detail:"pixels<LONG>  MAXPIXELS ",documentation:"Modifies the maximum size (in pixels) of images which can be created by [`PGraphics`](/doc/PGraphics). The limit can be modified up to the value configured in `warpscript.maxpixels.hard`.\n\n@param `pixels` Maximum size (in pixels).\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXPIXELS"},{name:"MAXRECURSION",detail:"depth<LONG>  MAXRECURSION ",documentation:"Modifies the maximum nesting depth of macro calls. The limit can be modified up to the value configured in `warpscript.maxrecursion.hard`.\n\n@param `depth` Maximum nesting depth.\n\n",tags:["platform"],since:"1.2.13",OPB64name:"MAXRECURSION"},{name:"MAXSYMBOLS",detail:"limit<LONG>  MAXSYMBOLS ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a \nhard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXSYMBOLS` function modifies the maximum number of simultaneous symbols which can be defined on the stack during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXSYMBOLS"},{name:"MAXURLFETCHCOUNT",detail:"limit<LONG>  MAXURLFETCHCOUNT ",documentation:"The `MAXURLFETCHCOUNT` function modifies the maximum number of URLs which can be fetched with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.MAXURLFETCHCOUNT.limit.hard`.\n\n@param `limit` The maximum number of URLs which can be fetched.\n\n",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHCOUNT"},{name:"MAXURLFETCHSIZE",detail:"limit<LONG>  MAXURLFETCHSIZE ",documentation:"The `MAXURLFETCHSIZE` function modifies the maximum cumulative size of fetched payloads with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.urlfetch.maxsize.hard` and is expressed as a number of bytes.\n\n@param `limit` The maximum cumulative size of fetched payloads.\n\n",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHSIZE"},{name:"MD5",detail:"input<BYTES>  MD5  result<BYTES>",documentation:"The `MD5` function digests a byte array on the stack with the cryptographic hash function [`MD5`](https://en.wikipedia.org/wiki/MD5).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"MD5"},{name:"MERGE",detail:"gtsList<LIST<GTS>>  MERGE  result<GTS>",documentation:"Merge several Geo Time Series™ together.\n\nThe `MERGE` function expects a **LIST** of Geo Time Series™ on the top of the stack. It will consume these GTS and push onto the stack a single GTS instance\nwith all measurements found in the GTS instances present in the **LIST**. The name and labels of the resulting GTS instance are those of the first one of the\n**LIST**.\n\n`MERGE` do not override values on the same timestamp, they are appenned.\n\n@param `gtsList` The list of Geo Time Series™\n\n@param `result` The merged Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MERGE"},{name:"META",detail:"gtsList<LIST<GTS>> writeToken<STRING>  META ",documentation:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `META` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",tags:["gts"],since:"1.0.0",OPB64name:"META"},{name:"METADIFF",detail:"gtsList<LIST<GTS>> writeToken<STRING>  METADIFF ",documentation:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend in an incremental manner. New attributes are added and already existing attributes are updated or removed if their value is an empty string.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `METADIFF` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",tags:["gts"],since:"2.3.0",OPB64name:"METADIFF"},{name:"METAOFF",detail:"message<STRING> secret<STRING>  METAOFF ",documentation:"Disables meta operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a meta operation is attempted.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"METAOFF"},{name:"METAON",detail:"secret<STRING>  METAON ",documentation:"Enables meta operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"METAON"},{name:"METASET",detail:"[ token<STRING> class<STRING> labels<MAP> notbefore<LONG> notafter<LONG> maxduration<LONG> ttl<LONG> ]  METASET  metaset<STRING>",documentation:"Performs a [`FIND`](/doc/FIND), retrieving a list of Geo Time Series™ and builds a *metaset* which can be distributed to allow access to those GTS without having to give away credentials.\n\nMetaset support is only available if a key has been set for `warp.aes.metasets`.\n\n@param `ttl` Time to live of the produces metaset. It will not be usable after that much time has elapsed since the current time. The ttl is specified in time units.\n\n@param `maxduration` The maximum span of data which can be retrieved using this metaset, in time units.\n\n@param `notafter` Most recent timestamp of the data this metaset can retrieve.\n\n@param `notbefore` Most ancient timestamp of the data this meataset can retrieve.\n\n@param `labels` Map of label selectors.\n\n@param `class` Geo Time Series™ class selector.\n\n@param `token` Read token to use for retrieving the GTS.\n\n@param `metaset` Encrypted metaset which can be used with a [`FETCH`](/doc/FETCH).\n\n",tags:["gts"],since:"1.2.5",OPB64name:"METASET"},{name:"METASORT",detail:"gts<LIST<GTS>> elements<LIST>  METASORT  sorted<LIST<GTS>>",documentation:"Sorts a list of Geo Time Series™ according to elements of their metadata. The list of elements to consider for sorting can contain label names or NULL to consider the classname. Elements will be considered in the order in which they appear in the list.\n\n@param `gts` List of Geo Time Series™ to sort.\n\n@param `elements` Metadata elements to consider for sorting.\n\n@param `sorted` Sorted list of GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"METASORT"},{name:"MIN",detail:"p1<LONG> p2<LONG>  MIN  result<LONG>\np1<LONG> p2<DOUBLE>  MIN  result<DOUBLE>\np1<DOUBLE> p2<LONG>  MIN  result<DOUBLE>\np1<DOUBLE> p2<DOUBLE>  MIN  result<DOUBLE>\np1<COUNTER> p2<COUNTER>  MIN  result<LONG>\np1<COUNTER> p2<DOUBLE>  MIN  result<DOUBLE>\np1<DOUBLE> p2<COUNTER>  MIN  result<DOUBLE>\np1<COUNTER> p2<LONG>  MIN  result<DOUBLE>\np1<LONG> p2<COUNTER>  MIN  result<DOUBLE>\nllist<LIST<LONG>>  MIN  sresult<LONG>\ndlist<LIST<DOUBLE>>  MIN  sresult<DOUBLE>\nclist<LIST<COUNTER>>  MIN  sresult<LONG>\nllist<LIST<LONG>> value<LONG>  MIN  lresult<LIST<LONG>>\nclist<LIST<COUNTER>> value<COUNTER>  MIN  lresult<LIST<LONG>>\ndlist<LIST<DOUBLE>> value<DOUBLE>  MIN  lresult<LIST<DOUBLE>>",documentation:"Returns the smaller of two numeric values.\n\nThe `MIN` function consumes two numeric parameters from the top of the stack and pushes back the smallest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The smaller of p1 and p2.\n\n@param `sresult` The smaller of the elements in the given list.\n\n@param `lresult` A list where each value is the min between the element in the list and the given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"MIN"},{name:"MINLONG",detail:" MINLONG  result<LONG>",documentation:"Pushes [Long.MIN_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MIN_VALUE) onto the stack.\n\n@param `result` Long.MIN_VALUE\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"MINLONG"},{name:"MINREV",detail:"revision<STRING>  MINREV  newer<BOOLEAN>",documentation:"The `MINREV` function consumes a string representing a revision on the stack and puts back a boolean indicating if the revision of the current Warp 10™ platform is newer or equal.\n\n@param `revision` A string representing a revision (semantic versioning). Given a version number MAJOR.MINOR.PATCH, .MINOR or .MINOR.PATCH can be omitted.\n\n@param `newer` A boolean indicating wether the revision of the current Warp 10™ platform is newer or equal to the given revision.\n\n",tags:["platform"],since:"1.2.23",OPB64name:"MINREV"},{name:"MMAP",detail:"inputmap<MAP> macro<MACRO>  MMAP  results<MAP>\ninputmap<MAP> macro<MACRO> index<BOOLEAN>  MMAP  results<MAP>",documentation:"The `MMAP` function applies a macro on each key/value pair of a **MAP**, producing a **MAP** with the two elements on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **MAP** index on top and the key/value pair at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each entry in inputmap.\n\n@param `inputmap` Map to iterate on.\n\n@param `results` Map of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",tags:["maps"],since:"2.7.0",OPB64name:"MMAP"},{name:"MODE",detail:"gts<GTS>  MODE  result<LIST>\ngtsList<LIST<GTS>>  MODE  [  result<LIST<LIST>>  ]",documentation:"The `MODE` function computes the mode(s) for a given Geo Time Series™ or a GTS **LIST**. Foreach Geo Time Series™ pushes back on the stack a list containing \ntheir mode(s).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Mode of the list (the items that occurs most often)\n\n",tags:["gts"],since:"1.0.11",OPB64name:"MODE"},{name:"MONOTONIC",detail:"gts<GTS> trend<BOOLEAN>  MONOTONIC  result<GTS>\ngtsList<LIST<GTS>> trend<BOOLEAN>  MONOTONIC  resultList<LIST<GTS>>",documentation:"Produces a new Geo Time Series™ from an input by modifying the value so the result is monotonous. This is technically applying a ratchet effect on values.\n\nThe `MONOTONIC` function expects a boolean on top of the stack and a Geo Time Series™ or list thereof below the boolean. The boolean indicates whether the\nresult should be monotonically increasing (false) or decreasing (true).\n\n@param `trend` Whether the result should be monotonically increasing (false) or decreasing (true)\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` New Geo Time Series™\n\n@param `resultList` List of new Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MONOTONIC"},{name:"MOTIONSPLIT",detail:"gts<GTS> parameters<MAP>  MOTIONSPLIT  splits<LIST<GTS>>\nlgts<LIST<GTS>> parameters<MAP>  MOTIONSPLIT  lsplits<LIST<LIST<GTS>>>",documentation:'The `MOTIONSPLIT` function splits Geo Time Series™ instances based on several possible motion criteria. Split parameters can be combined to split on multiple criteria.\n\n`MOTIONSPLIT` can split on:\n- stopped state detection\n- moving to stopped transition\n- time difference between two ticks (just as [`TIMESPLIT`](/doc/TIMESPLIT) does).\n- maximal distance between two consecutive positions.\n\n`MOTIONSPLIT` parameters:\n- **timesplit**: LONG value, time in platform time unit. Splits if the time difference between two consecutive ticks is strictly greater than this parameter. If defined, the split type label will be "timesplit".\n- **distance.split**: DOUBLE value, distance in meter. Splits if the orthodromic distance between two consecutive locations is strictly greater than this parameter. If defined, the split type label will be "distancesplit".\n- **stopped.min.time**: LONG value, time in platform time unit. This is the minimum time the consecutive locations should stay in the stopped zone radius to consider a stop state. If defined, the split type label will be "stopped".\n- **stopped.max.radius**: DOUBLE value, distance in meter. As long as consecutive positions remains in the radius during stopped.min.time, `MOTIONSPLIT` detect a stopped state.\n- **stopped.max.speed**: DOUBLE value, speed in m/s. If the speed is greater than this value while in stopped state, `MOTIONSPLIT` exits the stopped state.\n- **stopped.max.mean.speed**: DOUBLE value, speed in m/s. Maximum mean speed in the proximity zone that prevent the split. `MOTIONSPLIT` will split only if there is a full stop during the given time and radius, and if the mean speed in the proximity zone is less than this parameter.\n- **stopped.split**: BOOLEAN value. If true, `MOTIONSPLIT` also splits between stopped and moving sequences. If defined, the split type label will be "stopped" or "moving".\n- **label.stopped.time**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the time in stopped state. If the split source is not a stop detection, this label won\'t be set.\n- **label.split.number**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the split number, starting from 1.\n- **label.split.type**: STRING value. If defined, `MOTIONSPLIT` will add an extra label that contains the split reason. It could be "timesplit", "distancesplit", "end", "stopped" or "moving".\n\n`MOTIONSPLIT` split type priorities:\n- If stopped.min.time and stopped.max.radius are set, the stop detection has the first priority.\n- If `MOTIONSPLIT` does not detect a stopped state, it looks for a distance split.\n- If `MOTIONSPLIT` does not detect a stopped state or a distance split, it looks for a time split.\n\n\n@param `parameters` List of splitting parameters. See the function description.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n',tags:["gts"],since:"2.3.0",OPB64name:"MOTIONSPLIT"},{name:"MSGFAIL",detail:"message<STRING>  MSGFAIL ",documentation:"The `MSGFAIL` function stops the execution of WarpScript code by throwing an exception. \n\n@param `message` The exception message\n\n",tags:["control"],since:"1.0.0",OPB64name:"MSGFAIL"},{name:"MSORT",detail:"map<MAP>  MSORT  result<MAP>",documentation:"The function `MSORT` inspects the top of the stack. If it is a **MAP**, it sorts the **MAP** according to its keys. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\n@param `map` Map to sort\n\n@param `result` Sorted map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"MSORT"},{name:"MSTU",detail:" MSTU  numberTimeUnits<LONG>",documentation:"The `MSTU` function pushes onto the stack the number of platform time units in one millisecond. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one millisecond.\n\n",tags:["date","time","platform"],since:"1.0.0",OPB64name:"MSTU"},{name:"MULTIPLYEXACT",detail:"x<NUMBER> y<NUMBER>  MULTIPLYEXACT  prod<LONG>\nlist<LIST<NUMBER>>  MULTIPLYEXACT  sprod<LONG>\nlx<LIST<NUMBER>> y<NUMBER>  MULTIPLYEXACT  lprod<LIST<LONG>>",documentation:"The `MULTIPLYEXACT` function consumes two LONGs from the top of the stack and puts back the product. If the product overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `prod` The product of x and y\n\n@param `list` List of numeric values\n\n@param `sprod` The product of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lprod` List of **LONG** where each value is the product of y and an element in lx\n\n",tags:["math"],since:"1.2.23",OPB64name:"MULTIPLYEXACT"},{name:"MUSIGMA",detail:"gts<GTS> bessel<BOOLEAN>  MUSIGMA  mu<DOUBLE> sigma<DOUBLE>",documentation:"The `MUSIGMA` function calculates the mean and the standard deviation of a Geo Time Series. It consumes two parameters from the top of the stack: a boolean \n(to choose if [Bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction) should be applied on the standard deviation) and a numeric GTS, and \nit pushes onto the stack its mean (mu) and its standard deviation (sigma).\n\n@param `bessel` True if apply a [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `sigma` Standard deviation\n\n@param `mu` Mean\n\n@param `gts` A single Geo Time Series\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MUSIGMA"},{name:"MUTEX",detail:"macro<MACRO> mutex<STRING>  MUTEX ",documentation:"Attempts to hold a named lock, creating it if needed, and execute a macro while holding the lock. When the macro execution terminates, either normally or with an error, the lock is released.\n\n@param `mutex` Name of lock to hold.\n\n@param `macro` Macro to execute while holding the lock.\n\n",tags:["extensions","stack"],since:"2.0.0",OPB64name:"MUTEX"},{name:"MVELEVATIONS",detail:"input<GTSENCODER>  MVELEVATIONS  output<LIST>\ninput<GTS>  MVELEVATIONS  output<LIST>\nlinput<LIST>  MVELEVATIONS  output<LIST>",documentation:"The `MVELEVATIONS` function extracts elevations from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVELEVATIONS` function will emit a list with two elements (a pair), the first element will be the elevation associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the elevations of the Multivariate value itself.\n\nIf a tick has no associated elevation, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted elevations.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVELEVATIONS"},{name:"MVHHCODES",detail:"input<GTSENCODER>  MVHHCODES  output<LIST>\ninput<GTS>  MVHHCODES  output<LIST>\nlinput<LIST>  MVHHCODES  output<LIST>",documentation:"The `MVHHCODES` function extracts [`HHCodes`](https://en.wikipedia.org/wiki/HHCode) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVHHCODES` function will emit a list with two elements (a pair), the first element will be the HHCode associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the HHCodes of the Multivariate value itself.\n\nIf a tick has no associated location, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted HHCodes.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVHHCODES"},{name:"MVINDEXSPLIT",detail:"input<GTSENCODER>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> indices<LIST>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> indices<LIST> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> indices<LIST>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> indices<LIST> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTSENCODER>> indices<LIST>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTSENCODER>> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTSENCODER>> indices<LIST> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>> indices<LIST>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>> indices<LIST> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>",documentation:"The `MVINDEXSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVINDEXSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element index (first element being at index 0).\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:INDEX` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of indices or indices ranges can be specified to only produce encoders for the indices which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `indices` List of indices or indices ranges (list of two indices), used to restrict which indices to consider.\n\n@param `renaming` Map of index (LONG) to parameter to `RENAME`. If no entry is present for an index, `+:INDEX` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVINDEXSPLIT"},{name:"MVLOCATIONS",detail:"input<GTSENCODER>  MVLOCATIONS  output<LIST>\ninput<GTS>  MVLOCATIONS  output<LIST>\nlinput<LIST>  MVLOCATIONS  output<LIST>",documentation:"The `MVLOCATIONS` function extracts location (latitude, longitude) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVLOCATIONS` function will emit a list with two elements (a pair), the first element will be the latitude and longitude (a list) associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the latitudes and longitudes of the Multivariate value itself.\n\nIf a tick has no associated location, `[ NaN NaN ]` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted locations.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVLOCATIONS"},{name:"MVTICKS",detail:"input<GTSENCODER>  MVTICKS  output<LIST>\ninput<GTS>  MVTICKS  output<LIST>\nlinput<LIST>  MVTICKS  output<LIST>",documentation:"The `MVTICKS` function extracts ticks from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVTICKS` function will emit a list with two elements (a pair), the first element will be the tick at which the Multivariate value was encountered, the second element will be a list containing the ticks of the Multivariate value itself.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted ticks.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKS"},{name:"MVTICKSPLIT",detail:"input<GTSENCODER>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> timestamps<LIST>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> timestamps<LIST>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>> timestamps<LIST>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>> timestamps<LIST>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>",documentation:"The `MVTICKSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVTICKSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element timestamp.\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:TIMESTAMP` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of timestamps or timestamp ranges can be specified to only produce encoders for the timestamps which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `timestamps` List of timestamps or timestamps ranges (list of two timestamps), used to restrict which timestamps to consider.\n\n@param `renaming` Map of timestamp (LONG) to parameter to `RENAME`. If no entry is present for a timestamp, `+:TIMESTAMP` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKSPLIT"},{name:"MVVALUES",detail:"input<GTSENCODER>  MVVALUES  output<LIST>\ninput<GTS>  MVVALUES  output<LIST>\nlinput<LIST>  MVVALUES  output<LIST>",documentation:"The `MVVALUES` function extracts values from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted values.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVVALUES"},{name:"NAME",detail:"gts<GTS>  NAME  result<STRING>\nencoder<GTSENCODER>  NAME  result<STRING>",documentation:"The `NAME` function consumes a Geo Time Series™ from the stack, extracts its class name, and pushes it onto the stack.\n\n@param `gts` Geo Time Series™\n\n@param `encoder` Geo Time Series™ Encoder\n\n@param `result` Class name\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NAME"},{name:"NBOUNDS",detail:"mu<NUMBER> sigma<NUMBER> n<LONG>  NBOUNDS  bounds<LIST<DOUBLE>>",documentation:"The `NBOUNDS` function computes bounds defining a specified number of intervals which have the same area under the curve of a normal distribution with a given mean and standard deviation.\n\n@param `n` Number of desired intervals.\n\n@param `sigma` Positive standard deviation to use for the normal distribution.\n\n@param `mu` Mean to use for the normal distribution.\n\n@param `bounds` List of `n`-1 bounds defining the `n` intervals.\n\n",tags:["math"],since:"1.0.0",OPB64name:"NBOUNDS"},{name:"NDEBUGON",detail:"n<NUMBER>  NDEBUGON ",documentation:"Turns on stack debugging so up to the given number of stack levels will be returned in case of error. Stack debugging is off by default.\n\n@param `n` Maximum number of stack levels to return in case of error.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"NDEBUGON"},{name:"NEGATEEXACT",detail:"value<NUMBER>  NEGATEEXACT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  NEGATEEXACT  lresult<LIST<DOUBLE>>",documentation:"The `NEGATEEXACT` function consumes one LONG from the top of the stack and puts back the negated value. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be negated\n\n@param `result` The negated value\n\n@param `lvalue` List of values to be negated\n\n@param `lresult` List of negated values\n\n",tags:["math"],since:"1.2.23",OPB64name:"NEGATEEXACT"},{name:"NEWENCODER",detail:" NEWENCODER  encoder<GTSENCODER>",documentation:"The `NEWENCODER` function creates an empty encoder and pushes it onto the stack. An encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` A newly created empty encoder instance.\n\n",tags:["encoder","multivariate"],since:"1.2.9",OPB64name:"NEWENCODER"},{name:"NEWGTS",detail:" NEWGTS  gts<GTS>",documentation:"The `NEWGTS` function pushes onto the stack an empty Geo Time Series™ instance.\n\n@param `gts` A newly created empty GTS instance.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NEWGTS"},{name:"NEXTAFTER",detail:"from<NUMBER> to<NUMBER>  NEXTAFTER  result<DOUBLE>\nfrom<NUMBER> lto<LIST<NUMBER>>  NEXTAFTER  lresult<LIST<DOUBLE>>\nlfrom<LIST<NUMBER>> to<NUMBER>  NEXTAFTER  lresult<LIST<DOUBLE>>",documentation:"The `NEXTAFTER` function consumes two numeric parameter from the top of the stack and pushes back the **DOUBLE** adjacent to the first argument in the direction of the second argument. In other words, the result is between *from* and *to* and adjacent to *from*.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `from` Starting value\n\n@param `to` Direction used to calculate the adjacent value\n\n@param `result` Next **DOUBLE** from *from* to *to*\n\n@param `lfrom` List of starting values\n\n@param `lto` List of directions used to calculate the adjacent value\n\n@param `lresult` List of next **DOUBLE** from *from* to *to*\n\n",tags:["math"],since:"1.0.0",OPB64name:"NEXTAFTER"},{name:"NEXTDOWN",detail:"value<NUMBER>  NEXTDOWN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  NEXTDOWN  lresult<LIST<DOUBLE>>",documentation:"The `NEXTDOWN` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of negative infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of negative infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of negative infinity\n\n",tags:["math"],since:"1.2.23",OPB64name:"NEXTDOWN"},{name:"NEXTUP",detail:"value<NUMBER>  NEXTUP  result<DOUBLE>\nlvalue<LIST<NUMBER>>  NEXTUP  lresult<LIST<DOUBLE>>",documentation:"The `NEXTUP` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of positive infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of positive infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of positive infinity\n\n",tags:["math"],since:"1.0.0",OPB64name:"NEXTUP"},{name:"NOLOG",detail:" NOLOG ",documentation:"The `NOLOG` function resets java.util.logging.LogManager.\n\nIt can be useful to do this during developments and tests of an extension.\n\nThe `NOLOG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n",tags:["extensions"],since:"1.2.19",OPB64name:"NOLOG"},{name:"NONEMPTY",detail:"gtsList<LIST<GTS>>  NONEMPTY  results<LIST<GTS>>",documentation:"Filter a list of Geo Time Series™ in order to retain only those that have at least one value.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `results` Filtered list of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NONEMPTY"},{name:"NONNULL",detail:"list<LIST>  NONNULL  nonnulls<LIST>",documentation:"The `NONNULL` function consumes a list and produces a list containing only the non NULL elements of the argument list.\n\n@param `list` The argument list to filter\n\n@param `nonnulls` A new list with only those elements from `list` which are not NULL\n\n",tags:["math","logic"],since:"1.2.7",OPB64name:"NONNULL"},{name:"NOOP",detail:"",documentation:"It does nothing.\n\nWhile it does not have a usefulness of its own, it can be used when generating code from within WarpScript code prior to executing it with [`EVAL`](/doc/EVAL).\n\n",tags:["platform"],since:"1.0.0",OPB64name:"NOOP"},{name:"NORMALIZE",detail:"gts<GTS>  NORMALIZE  result<GTS>\ngtsList<LIST<GTS>>  NORMALIZE  resultList<LIST<GTS>>",documentation:"The `NORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between 0 and 1 (i.e. it replaces X by \n(X - min)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NORMALIZE"},{name:"NOT",detail:"input<BOOLEAN>  NOT  result<BOOLEAN>\ngts<GTS>  NOT  negatedgts<GTS>",documentation:"Negates a boolean.\n\nThe `NOT` function is synonymous for [`!`](/doc/7F). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gts` A boolean Geo Time Series™\n\n@param `negatedgts` A boolean Geo Time Series™\n\n",tags:["logic"],since:"1.0.0",OPB64name:"NOT"},{name:"NOTAFTER",detail:"timestamp<LONG>  NOTAFTER \ndate<STRING>  NOTAFTER ",documentation:"Checks that the current time is not after the provided timestamp.\n\nThe `NOTAFTER` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not after the provided timestamp.\nIf it is not after the WarpScript execution continues, otherwise it throws an exception.\n\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",tags:["date"],since:"1.0.0",OPB64name:"NOTAFTER"},{name:"NOTBEFORE",detail:"timestamp<LONG>  NOTBEFORE \ndate<STRING>  NOTBEFORE ",documentation:"Checks that the current time is not before the provided timestamp.\n\nThe `NOTBEFORE` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not before the provided timestamp.\nIf it is not before the WarpScript execution continues, otherwise it throws an exception.\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",tags:["date"],since:"1.0.0",OPB64name:"NOTBEFORE"},{name:"NOTIMINGS",detail:"",documentation:"Use of the `NOTIMINGS` function disables the collection of timing information for each line of the input script. Use [`TIMINGS`](/doc/TIMINGS) to enable it again.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"NOTIMINGS"},{name:"NOW",detail:" NOW  timestamp<LONG>",documentation:"The `NOW` function pushes onto the stack the current **LONG** timestamp expressed in the platform time unit. This timestamp is the number of platform time unit elapsed since 00:00:00 on 1 January 1970 UTC minus the number of leap seconds, see [Unix time](https://en.wikipedia.org/wiki/Unix_time).\n\nThis function is mostly linear with time but this property is violated when the OS resynchronises its clock (ie consecutive calls to `NOW` may 'jump' or 'go backward').\n\n@param `timestamp` The current timestamp in platform time unit.\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"NOW"},{name:"NPDF",detail:"mu<NUMBER> sigma<NUMBER>  NPDF  npdf<FUNCTION>",documentation:"The `NPDF` function builds a function which outputs the probability of occurrence of a given value under a specified normal distribution.\n\nThe normal distribution is defined by its mean and standard deviation. The result of the `NPDF` function is itself a function which can be invoked via [`EVAL`](doc/EVAL).\n\n*NPDF* stands for Normal (Gaussian) distribution Probability Density Function.\n\n@param `sigma` Standard deviation of the normal distribution to consider.\n\n@param `mu` Mean of the normal distribution to consider.\n\n@param `npdf` Function which given an input number outputs the probability of its occurence under the given normal distribution.\n\n",tags:["math"],since:"1.0.0",OPB64name:"NPDF"},{name:"NPEEK",detail:"levels<NUMBER>  NPEEK ",documentation:"Displays a given number of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of stack levels to display.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"NPEEK"},{name:"NRETURN",detail:"levelnumber<LONG>  NRETURN ",documentation:"Immediately exit a certain number of macros being executed. The `NRETURN` function expects a number of levels on top of the stack.\n\n@param `levelnumber` Number of levels of macro to exit.\n\n",tags:["control"],since:"1.0.0",OPB64name:"NRETURN"},{name:"NSUMSUMSQ",detail:"gts<GTS>  NSUMSUMSQ  cardinality<LONG> sum<DOUBLE> square<DOUBLE>",documentation:"Computes the cardinality, sum of values and sum of squared values of a Geo Time Series™. Pushes those results on the stack in the order they were mentioned.\n\nOnly numeric series are allowed.\n\n@param `square` Sum of squared values\n\n@param `sum` Sum of values\n\n@param `cardinality` Values count\n\n@param `gts` Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NSUMSUMSQ"},{name:"NULL",detail:" NULL  result<NULL>",documentation:"The `NULL` function pushes the symbolic value *null* onto the stack.\n\n@param `result` Symbolic value *null*\n\n",tags:["constants"],since:"1.0.0",OPB64name:"NULL"},{name:"NaN",detail:" NaN  result<DOUBLE>",documentation:"Pushes the double value *NaN* (Not a Number) onto the stack.\n\n@param `result` Value *NaN*\n\n",tags:["constants"],since:"1.0.0",OPB64name:"NaN"},{name:"ONLYBUCKETS",detail:"gts<GTS>  ONLYBUCKETS  result<GTS>\nlgts<LIST<GTS>>  ONLYBUCKETS  lresult<LIST<GTS>>",documentation:"Only retains ticks from Geo Time Series™ with timestamps which are bucket ends. If an input GTS is not bucketized, a clone of the GTS will be returned.\n\nThe `ONLYBUCKETS` function does not remove duplicate ticks, please consider using [`DEDUP`](/doc/DEDUP) for that purpose.\n\n@param `gts` Single instance of Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `result` Transformed GTS.\n\n@param `lresult` List of transformed GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ONLYBUCKETS"},{name:"OPB64->",detail:"input<STRING>  OPB64->  output<BYTES>",documentation:"Decode a String in order preserving base64 into a byte array.\n\nBytes array cannot be represented on the stack.\n\n@param `input` Any valid opbbase64 string.\n\n@param `output` Byte array of the input decoded input.\n\n",tags:["conversion"],since:"1.0.7",OPB64name:"Ip01CYFhEV"},{name:"OPB64TOHEX",detail:"input<STRING>  OPB64TOHEX  output<STRING>",documentation:"The OPB64TOHEX function decodes the order preserving base64 string on top of the stack and immediately re-encode it in hex string.\n\n\n@param `input` OPBase64 encoded string\n\n@param `output` hexadecimal representation\n\n",tags:["conversion"],since:"1.0.2",OPB64name:"OPB64TOHEX"},{name:"OPS",detail:" OPS  ops<LONG>",documentation:"Pushes onto the stack the current number of operations which were performed by the WarpScript code execution.\n\n@param `ops` number of operations\n\n",tags:["platform"],since:"1.0.0",OPB64name:"OPS"},{name:"OPTDTW",detail:"data<LIST> query<LIST> match<LONG>  OPTDTW  result<LIST>",documentation:"The `OPTDTW` function finds the top subsequence matches in a sequence for a given query sequence. The function uses [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping)\nto assess the subsequence similarity with the query.\n\n@param `match` Number of top matches. Use 0 as the number of matches to return to return them all.\n\n@param `query` Query numerical sequence, thr shortest\n\n@param `data` Data sequence in which to find matches\n\n@param `result` List of matches, each match being a pair of (index, distance).\n\n",tags:["math","distance"],since:"1.0.0",OPB64name:"OPTDTW"},{name:"OPTIMIZE",detail:"gts<GTS> ratio<NUMBER>  OPTIMIZE  gts<GTS>\nencoder<GTSENCODER> ratio<NUMBER>  OPTIMIZE  optencoder<GTSENCODER>\nlgts<LIST<GTS>> ratio<NUMBER>  OPTIMIZE  lgts<LIST<GTS>>\nlencoder<LIST<GTSENCODER>> ratio<NUMBER>  OPTIMIZE  loptencoder<LIST<GTSENCODER>>",documentation:"Optimizes the memory footprint of Geo Time Series™ and GTS Encoder instances.\n\n@param `ratio` Ratio of memory footprint to number of values, if this ratio is not exceeded, no optimization will take place. As a result, optimization is always done when ratio <= 1 or ratio is NaN.\n\n@param `gts` Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `encoder` Instance of GTS Encoder to optimize.\n\n@param `optencoder` Optimized version of the encoder, or the original instance if no optimization occurred.\n\n@param `lgts` List of Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `lencoder` List of instances of GTS Encoder to optimize.\n\n@param `loptencoder` List of optimized version of the encoders or the original instances if no optimization occurred.\n\n",tags:["gts"],since:"1.2.9",OPB64name:"OPTIMIZE"},{name:"OR",detail:"p1<BOOLEAN> p2<BOOLEAN>  OR  result<BOOLEAN>\nl<LIST>  OR  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  OR  gtsresult<GTS>",documentation:"The `OR` operator is a synonymous for [`||`](/doc/U6k).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `OR` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"OR"},{name:"PACK",detail:"input<LIST> format<STRING>  PACK  result<BYTES>",documentation:"The `PACK` function packs a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n@param `input` List to pack\n\n@param `format` Format used to pack\n\n@param `result` Bytes array\n\n",tags:["lists"],since:"1.0.7",OPB64name:"PACK"},{name:"PAPPLY",detail:"[ op<OPERATOR> labels<LIST> gts<LIST<GTS>+> ]  PAPPLY  result<MAP>",documentation:"The `PAPPLY` function performs operations in a way identical to the [`APPLY`](/doc/APPLY) framework but produces a map of results keyed by the label map of each equivalence class.\n\nAs [`APPLY`](/doc/APPLY), `PAPPLY` provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can due. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` Map of resulting GTS, one per equivalence class, keyed with the equivalence class labels.\n\n@param `op` Operation to perform.\n\n",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"PAPPLY"},{name:"PARSE",detail:"data<STRING>  PARSE  result<LIST<GTS>>",documentation:"The `PARSE` function parses an input **STRING** containing datapoints in the [Geo Time Series™ input format](/content/03_Documentation/03_Interacting_with_Warp_10/03_Ingesting_data/02_GTS_input_format) and pushes onto the stack the parsed Geo Time Series™.\n\n@param `data` Datapoints in the Geo Time Series™ input format\n\n@param `result` List of parsed Geo Time Series™\n\n",tags:["gts","strings"],since:"1.0.11",OPB64name:"PARSE"},{name:"PARSESELECTOR",detail:"selector<STRING>  PARSESELECTOR  classselector<STRING> labelselector<MAP>",documentation:"The `PARSESELECTOR` function parses a GTS Selector (STRING) returnss the class selector and labels selectors.\n\nIn order for `PARSESELECTOR` to parse correctly a selector, the following characters MUST appear percent-encoded in the `STRING` to parse, the equal sign (`=`, `%3D`), the comma (`,` `%2C`) and closing curly brace (`}` `%7D`). Due to the way WarpScript parses `STRING` constants, the `%` sign MUST be percent-encoded (`%25`) in the `STRING` if it appears in WarpScript code:\n\nThe `STRING` `class{label=comm%2Cequal%3Dsign}` must appear in WarpScript as:\n\n```\n'class{label=comm%252Cequal%253Dsign'\n```\n\nCombined with `TOSELECTOR`, it can be used to build a selector from a subset of GTS.\n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature'\n  { 'sensorId' '=01' }\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\nFETCH\n\n```\nThis can be used to simplify the syntax of a FETCH or FIND request. \n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature{sensorId=01}' PARSESELECTOR\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\n\nFETCH\n```\n\n\n\n@param `selector` String selector.\n\n@param `labelselector` MAP of label selectors.\n\n@param `classselector` Class name selector.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PARSESELECTOR"},{name:"PARSEVALUE",detail:"input<STRING>  PARSEVALUE  value<ANY>",documentation:"The `PARSEVALUE` function parses a STRING representing a valid value in the Geo Time Series™ input format.\n\nThe underlying implementation being the internal WarpScript function, some of the returned types might not be easily handled in the rest of the calling script. Most notably, some floating point representations might lead to BigDecimal instances being produced.\n\n@param `input` String representation of the value to parse.\n\n@param `value` Parsed value, could be a STRING, LONG, DOUBLE, BIGDECIMAL, BOOLEAN or BYTES elements.\n\n",tags:["gts"],since:"2.1.0",OPB64name:"PARSEVALUE"},{name:"PARTITION",detail:"lgts<LIST<GTS>> labels<LIST<STRING>>  PARTITION  result<MAP>",documentation:"The `PARTITION` function splits a Geo Time Series™ list in equivalence classes based on label values.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels` plus all labels with common values among the GTS in the equivalence class.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PARTITION"},{name:"PATTERNDETECTION",detail:"gts<GTS> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNDETECTION  result<GTS>\nlgts<LIST<GTS>> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNDETECTION  lresult<LIST<GTS>>",documentation:"The `PATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it\n\n@param `lresult` The list of result GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNDETECTION"},{name:"PATTERNS",detail:"gts<GTS> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNS  result<GTS>\nlgts<LIST<GTS>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNS  lresult<LIST<GTS>>",documentation:"The `PATTERNS` function extracts symbolic patterns (or motifs) from a Geo Time Series™. Those patterns are similar to [iSAX](http://www.cs.ucr.edu/~eamonn/iSAX/iSAX.html) symbols.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNS` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNS"},{name:"PEEK",detail:" PEEK ",documentation:"Displays the top of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PEEK"},{name:"PEEKN",detail:"distance<NUMBER>  PEEKN ",documentation:"Displays the content of the level of the stack at the given distance from the top.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `distance` Distance (in stack levels) between the top of the stack and the level to display.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PEEKN"},{name:"PERMUTE",detail:"tensor<LIST> pattern<LIST>  PERMUTE  tensor<LIST>\n{ tensor<LIST> pattern<LIST> fast<BOOLEAN>  } PERMUTE  tensor<LIST>",documentation:"Permute the dimensions of a nested LIST as if it were a tensor or a multidimensional array.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent before operating. Default to false.\n\n@param `pattern` The permutation pattern (a LIST of LONG).\n\n@param `tensor` The resulting nested LIST.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"PERMUTE"},{name:"PFILTER",detail:"[ gtsList<LIST<GTS>> labels<LIST<STRING>> filter<FILTER> ]  PFILTER  result<MAP>",documentation:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `PFILTER framework allows for advanced filtering using N-ary functions \n(functions which accept N parameters). Returned GTS are grouped by equivalence classes.\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A map keyed by the label set of each equivalence class whose values are lists of selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `PFILTER`.\n\n",tags:["framework","filter"],since:"1.0.0",OPB64name:"PFILTER"},{name:"PGraphics",detail:"width<LONG> height<LONG> imgtype<STRING>  PGraphics  pg<PGRAPHICS>",documentation:'Warp 10 includes a large subset of the [Processing](http://www.processing.org) drawing library. You can create and manipulate images, then push a base64 encoded png onto the stack.\n\n+ Step 1: create a processing graphic object with `PGraphics` function.\n+ Step 2: manipulate this object with Processing functions.\n+ Step 3: render the processing graphic with `Pencode` function.\n\nDocumentation of every function has a link to original Processing website. Original website includes more examples for each function.\n\nProcessing functions offers a lot of different signatures for colors. The most efficient is to keep the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n\nUp to Warp 10 1.2.18, antialiasing was not available. It is now available, by appending a digit to the **imgtype** string argument. The maximum anti-aliasing level is determined by the hardware of the machine that is running the software, so 2D4 and 2D8 mode will not work with every computer.\n\n+ "2D": no antialiasing\n+ "2D2": bilinear smoothing\n+ "2D3": bicubic smoothing\n+ "2D4": 4x antialiasing\n+ "2D8": 8x antialiasing\n\n\nYou can adjust the maximal number of pixel allowed in Warp 10 configuration file.\n\n@param `imgtype` \'2D\', \'3D\', or \'2Dx\', where x is the level of anti aliasing (2, 3, 4, or 8).\n\n@param `width` Pixel width of the image.\n\n@param `height` Pixel height of the image.\n\n@param `pg` Processing graphic object.\n\n',tags:["processing"],since:"1.0.0",OPB64name:"PGraphics"},{name:"PI",detail:" PI  pi<DOUBLE>",documentation:"Alias of [pi](/doc/R5Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"J3Z"},{name:"PICK",detail:"level<NUMBER>  PICK  result<ANY>",documentation:"The `PICK` function copies on top of the stack the element at level N. Parameter N is consumed off the top of the stack when `PICK` is called.\n\n@param `level` Level of the stack\n\n@param `result` What is on stack at *level*\n\n",tags:["stack"],since:"1.0.0",OPB64name:"PICK"},{name:"PICKLE->",detail:"input<BYTES>  PICKLE->  output<ANY>",documentation:"The `PICKLE->` function decodes some Pickle encoded content contained in a byte array.\nThe conversion is done using [Pyrolite v4](https://github.com/irmen/pickle).\n\nIt can read all pickle protocol versions (0 to 4, so this includes\nthe latest additions made in Python 3.4).\n\n```python\n>>> myobject={ 'apple':3.5,'banana':18 }\n>>> pickle.dumps(myobject).encode(\"hex\")\n'286470300a53276170706c65270a70310a46332e350a73532762616e616e61270a70320a4931380a732e'\n```\n\n@param `input` Byte array of a pickle encoded content\n\n@param `output` Warp 10 object\n\n",tags:["platform"],since:"1.0.7",OPB64name:"J3_2Hol4AIs"},{name:"PIGSCHEMA",detail:"elt<ANY*>  PIGSCHEMA  elt<ANY*> schema<STRING>",documentation:"The `PIGSCHEMA` function produces on top of the stack a STRING representing the [Pig](https://en.wikipedia.org/wiki/Pig_(programming_tool)) schema definition for the current stack content.\n\n@param `elt` Stack content.\n\n@param `schema` Schema for the current stack, usable when working with WarpScript in Pig.\n\n",tags:["pig","stack"],since:"1.2.5",OPB64name:"PIGSCHEMA"},{name:"PIVOT",detail:"input<LIST<GTS>> pivot<LIST<GTS>>  PIVOT  result<LIST<GTS>>",documentation:"The `PIVOT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick of GTS from the first list, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n1// C3{C1=C} 2\n2// C4{C2=F} 30\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n4// C3{} 5\n4// C4{} 50\n```\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",tags:["gts"],since:"2.2.0",OPB64name:"PIVOT"},{name:"PIVOTSTRICT",detail:"input<LIST<GTS>> pivot<LIST<GTS>>  PIVOTSTRICT  result<LIST<GTS>>",documentation:"The `PIVOTSTRICT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™ in a way similar to what [`PIVOT`](/doc/PIVOT) does.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick common to Geo Time Series™ of both lists, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOTSTRICT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n```\n\nOnly ticks 0 and 3 appear in the result as those are the only ticks present in both `C1` and `C2`.\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",tags:["gts"],since:"2.2.0",OPB64name:"PIVOTSTRICT"},{name:"POPR",detail:"value<ANY>  POPR ",documentation:"Pops a value from the top of the stack and stores it into the designated register.\n\nThe `POPR` function is really a family of functions named `POPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"POPR"},{name:"PREDUCE",detail:"[ gts<LIST<GTS>+> labels<LIST<STRING>> reducer<AGGREGATOR> ]  PREDUCE  result<MAP>",documentation:"Behaves as [`REDUCE`](/doc/REDUCE) but produces a map of results keyed by the label map of each equivalence class.\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` Map keyed by the label map of each equivalence class and whose values are the Geo Time Series™ produced for each class.\n\n",tags:["reducer","framework"],since:"1.0.5",OPB64name:"PREDUCE"},{name:"PRNG",detail:"seed<LONG>  PRNG ",documentation:"The `PRNG` function initializes the stack's seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator). This PRNG can later be used by the [`SRAND`](/doc/SRAND) function to produce random numbers in a deterministic way (!).\n\n@param `seed` The seed to use for initializing the PRNG.\n\n",tags:["math"],since:"1.2.9",OPB64name:"PRNG"},{name:"PROB",detail:"gts<GTS>  PROB  result<GTS>\ngtslist<LIST<GTS>>  PROB  resultList<LIST<GTS>>",documentation:"Computes probability for each value of the input Geo Time Series™.\n\nThe function `PROB` consumes a GTS or a list of the GTS from the top of the stack. It pushes back the probability for each value.\n\nThe probabilities are computed using the value histogram.\n\n@param `gts` The input Geo Time Series™\n\n@param `gtslist` The input list of Geo Time Series™\n\n@param `result` The Geo Time Series™ wit probability for each value\n\n@param `resultList` The List of Geo Time Series™ with probability for each value\n\n",tags:["gts","statistics"],since:"1.0.6",OPB64name:"PROB"},{name:"PROBABILITY",detail:"valueHistogram<MAP>  PROBABILITY  result<STRING>",documentation:"Pushes on the stack a function which computes probabilities according to a provided value histogram.\n\nTo use the function pushed by `PROBABILITY` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function expects a value on top of the stack and will output the probability of occurrence of this value.\n\n",tags:["math","statistics"],since:"1.0.0",OPB64name:"PROBABILITY"},{name:"PSTACK",detail:"",documentation:"When in interactive (REPL) mode, prints the content of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PSTACK"},{name:"PUSHR",detail:" PUSHR  value<ANY>",documentation:"Pushes onto the stack the value currently contained in the designated register.\n\nThe `PUSHR` function is really a family of functions named `PUSHRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value from the designated register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PUSHR"},{name:"PUT",detail:"inputmap<MAP> newvalue<ANY> newkey<ANY>  PUT  outputmap<MAP>",documentation:"The `PUT` function inserts a new key-value pair in a map.\nIf the key already exists in the input MAP, the value is replaced by the new one.\n\n`PUT` function puts the reference of the MAP on top of the stack.\n\n@param `newkey` Depending on map construction, could be a number, a string, a boolean\n\n@param `newvalue` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `inputmap` reference to the map to be modified\n\n@param `outputmap` copy of input map reference. Useful to chain other instructions on the same map.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"PUT"},{name:"Palpha",detail:"pg<PGRAPHICS> color<NUMBER>  Palpha  pg<PGRAPHICS> alpha<DOUBLE>",documentation:"Extracts the alpha value from a color.\n\nThe `Palpha` function is easy to use and understand, but it is slower than bit shifting... \n\n\n[Link to original Processing doc](https://processing.org/reference/alpha_.html)\n\n@param `color` Any value of the color datatype\n\n@param `alpha` Alpha component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Palpha"},{name:"Parc",detail:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> start<DOUBLE> stop<DOUBLE>  Parc  pg<PGRAPHICS>\npg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> start<DOUBLE> stop<DOUBLE> mode<STRING>  Parc  pg<PGRAPHICS>",documentation:"Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse defined by the **a**, **b**, **c**, and **d** parameters. The origin of the arc's ellipse may be changed with the [`PellipseMode`](/doc/PellipseMode) function. Use the **start** and **stop** parameters to specify the angles (in radians) at which to draw the arc.\n\n\n\nThere are three ways to draw an arc; the rendering technique used is defined by the optional seventh parameter. The three options, depicted in the examples, are PIE, OPEN, and CHORD. The default mode is the OPEN stroke with a PIE fill.\n\n\n\nIn some cases, the `Parc` function isn't accurate enough for smooth drawing. For example, the shape may jitter on screen when rotating slowly. If you're having an issue with how arcs are rendered, you'll need to draw the arc yourself with [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) or a **PShape**.\n\n\n[Link to original Processing doc](https://processing.org/reference/arc_.html)\n\n@param `b` y-coordinate of the arc's ellipse\n\n@param `a` x-coordinate of the arc's ellipse\n\n@param `c` width of the arc's ellipse by default\n\n@param `d` height of the arc's ellipse by default\n\n@param `start` angle to start the arc, specified in radians\n\n@param `stop` angle to stop the arc, specified in radians\n\n@param `mode` closing mode. either PIE, OPEN, or CHORD\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Parc"},{name:"Pbackground",detail:"pg<PGRAPHICS> argb<LONG>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> image<PIMAGE>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> rgb<LONG> alpha<NUMBER>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE> alpha<NUMBER>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Pbackground  pg<PGRAPHICS>",documentation:"The `Pbackground` function sets the color used for the background of the processing graphics object. \n\nAn image object can also be used as the background for a sketch, although the image's width and height must match that of the processing object. Images used with `Pbackground` will ignore the current [`Ptint`](/doc/Ptint) setting. \n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pbackground` calls internally [`Pcolor`](/doc/Pcolor).\n\n\n[Link to original Processing doc](https://processing.org/reference/background_.html)\n\n@param `argb` any argb color value.\n\n@param `rgb` any rgb color value.\n\n@param `alpha` opacity of the background. 0 = transparent, 255 = opaque.\n\n@param `gray` a value between white (255) and black (0)\n\n@param `image` PImage to set as background (must be same size as pg)\n\n@param `v1` red or hue value (depending on the current color mode)\n\n@param `v2` green or saturation value (depending on the current color mode)\n\n@param `v3` blue or brightness value (depending on the current color mode)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbackground"},{name:"PbeginContour",detail:"pg<PGRAPHICS>  PbeginContour  pg<PGRAPHICS>",documentation:"Use the `PbeginContour` and [`PendContour`](/doc/PendContour) function to create negative shapes within shapes such as the center of the letter 'O'. `PbeginContour` begins recording vertices for the shape and [`PendContour`](/doc/PendContour) stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\n\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a `PbeginContour`/[`PendContour`](/doc/PendContour) pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginContour_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbeginContour"},{name:"PbeginShape",detail:"pg<PGRAPHICS> kind<STRING>  PbeginShape  pg<PGRAPHICS>\npg<PGRAPHICS>  PbeginShape  pg<PGRAPHICS>",documentation:"Using the `PbeginShape` and [`PendShape`](/doc/PendShape) functions allow creating more complex forms. `PbeginShape` begins recording vertices for a shape and [`PendShape`](/doc/PendShape) stops recording. \n\nThe value of the **kind** parameter tells it which types of shapes to create from the provided vertices. The parameters available for beginShape() are POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the `PbeginShape` function, a series of [`Pvertex`](/doc/Pvertex) commands must follow. To stop drawing the shape, call [`PendShape`](/doc/PendShape). The [`Pvertex`](/doc/Pvertex) function with two parameters specifies a position in 2D. Each shape will be outlined with the current stroke color and filled with the fill color. \n\n\nTransformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within `PbeginShape`. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within `PbeginShape`. \n\n\nThe P2D and P3D renderers allow [`Pstroke`](/doc/Pstroke) and [`Pfill`](/doc/Pfill) to be altered on a per-vertex group basis. Settings such as [`PstrokeWeight`](/doc/PstrokeWeight), [`PstrokeCap`](/doc/PstrokeCap), and [`PstrokeJoin`](/doc/PstrokeJoin) cannot be changed while inside a `PbeginShape`/[`PendShape`](/doc/PendShape) block with any renderer.\n\nUp to Warp 10 1.2.18, `PbeginShape` could be called without the **kind** parameter. It defaults to POLYGON.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginShape_.html)\n\n@param `kind` Either POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbeginShape"},{name:"Pbezier",detail:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  Pbezier  pg<PGRAPHICS>\npg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> z1<DOUBLE> x2<DOUBLE> y2<DOUBLE> z2<DOUBLE> x3<DOUBLE> y3<DOUBLE> z3<DOUBLE> x4<DOUBLE> y4<DOUBLE> z4<DOUBLE>  Pbezier  pg<PGRAPHICS>",documentation:"Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezier_.html)\n\n@param `x1` coordinates for the first anchor point\n\n@param `y1` coordinates for the first anchor point\n\n@param `z1` coordinates for the first anchor point\n\n@param `x2` coordinates for the first control point\n\n@param `y2` coordinates for the first control point\n\n@param `z2` coordinates for the first control point\n\n@param `x3` coordinates for the second control point\n\n@param `y3` coordinates for the second control point\n\n@param `z3` coordinates for the second control point\n\n@param `x4` coordinates for the second anchor point\n\n@param `y4` coordinates for the second anchor point\n\n@param `z4` coordinates for the second anchor point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbezier"},{name:"PbezierDetail",detail:"pg<PGRAPHICS> detail<NUMBER>  PbezierDetail  pg<PGRAPHICS>",documentation:"Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the **P3D** renderer; the default **P2D** renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierDetail_.html)\n\n@param `detail` resolution of the curves\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierDetail"},{name:"PbezierPoint",detail:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PbezierPoint  pg<PGRAPHICS> out<DOUBLE>",documentation:"Evaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierPoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierPoint"},{name:"PbezierTangent",detail:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PbezierTangent  pg<PGRAPHICS> out<DOUBLE>",documentation:"Calculates the tangent of a point on a Bezier curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierTangent"},{name:"PbezierVertex",detail:"pg<PGRAPHICS> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  PbezierVertex  pg<PGRAPHICS>",documentation:"Specifies vertex coordinates for Bezier curves. Each call to `PbezierVertex` defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PbezierVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only with POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/bezierVertex_.html)\n\n@param `x2` The x-coordinate of the 1st control point\n\n@param `y2` The y-coordinate of the 1st control point\n\n@param `x3` The x-coordinate of the 2nd control point\n\n@param `y3` The y-coordinate of the 2nd control point\n\n@param `x4` The x-coordinate of the anchor point\n\n@param `y4` The y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierVertex"},{name:"Pblend",detail:"pg<PGRAPHICS> src<PIMAGE> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG> mode<STRING>  Pblend  pg<PGRAPHICS>\npg<PGRAPHICS> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG> mode<STRING>  Pblend  pg<PGRAPHICS>",documentation:"Blends a region of pixels from one image into another (or in itself again) with full alpha channel support.\n\nHere are the available modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n\n+ BLEND - linear interpolation of colours: C = A*factor + B\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - Multiply the colors, result will always be darker.\n+ SCREEN - Opposite multiply, uses inverse values of the colors.\n+ OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values,and screens light values.\n+ HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n+ SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n+ DODGE - Lightens light tones and increases contrast, ignores darks.Called \"Color Dodge\" in Illustrator and Photoshop.\n+ BURN - Darker areas are applied, increasing contrast, ignores lights.Called \"Color Burn\" in Illustrator and Photoshop.\n\nAll modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the **src** parameter is not used, the display window is used as the source image.\n\n[Link to original Processing doc](https://processing.org/reference/blend_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `mode` Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pblend"},{name:"PblendMode",detail:"pg<PGRAPHICS> mode<STRING>  PblendMode  pg<PGRAPHICS>",documentation:"Blends the pixels in the display window according to a defined mode. \n\nHere are the available modes to blend the source pixels (A) with the ones of pixels already in the display window (B). \n\n+ BLEND - linear interpolation of colours: C = A*factor + B. This is the default blending mode.\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - multiply the colors, result will always be darker.\n+ SCREEN - opposite multiply, uses inverse values of the colors.\n+ REPLACE - the pixels entirely replace the others and don't utilize alpha (transparency) values\n\nA pixel's final color is the result of applying one of the above blend modes with each channel of (A) and (B) independently. For example, red is compared with red, green with green, and blue with blue.\n\nWe recommend using `PblendMode` and not the previous [`Pblend`](/doc/Pblend) function. However, unlike [`Pblend`](/doc/Pblend), the `PblendMode` function does not support the following: HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN. On older hardware, the LIGHTEST, DARKEST, and DIFFERENCE modes might not be available as well. \n\n[Link to original Processing doc](https://processing.org/reference/blendMode_.html)\n\n@param `mode` The blending mode to use\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PblendMode"},{name:"Pblue",detail:"pg<PGRAPHICS> rgb<NUMBER>  Pblue  pg<PGRAPHICS> blue<DOUBLE>",documentation:"Extracts the blue value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pblue` function is easy to use and understand, but it is slower than bit masking. \n\n\n[Link to original Processing doc](https://processing.org/reference/blue_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `blue` Blue component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pblue"},{name:"Pbox",detail:"pg<PGRAPHICS> size<NUMBER>  Pbox  pg<PGRAPHICS>\npg<PGRAPHICS> w<NUMBER> h<NUMBER> d<NUMBER>  Pbox  pg<PGRAPHICS>",documentation:"A box is an extruded rectangle. A box with equal dimensions on all sides is a cube.\n\n\n[Link to original Processing doc](https://processing.org/reference/box_.html)\n\n@param `size` dimension of the box in all dimensions (creates a cube)\n\n@param `w` dimension of the box in the x-dimension\n\n@param `h` dimension of the box in the y-dimension\n\n@param `d` dimension of the box in the z-dimension\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbox"},{name:"Pbrightness",detail:"pg<PGRAPHICS> rgb<NUMBER>  Pbrightness  pg<PGRAPHICS> brightness<DOUBLE>",documentation:"Extracts the brightness value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/brightness_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `brightness` Brightness component of input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbrightness"},{name:"Pclear",detail:"pg<PGRAPHICS>  Pclear  pg<PGRAPHICS>",documentation:"Clears the pixels. This function clears everything in a **PGraphics** object to make all of the pixels 100% transparent.\n\n\n[Link to original Processing doc](https://processing.org/reference/clear_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pclear"},{name:"Pclip",detail:"pg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Pclip  pg<PGRAPHICS>",documentation:"Limits the rendering to the boundaries of a rectangle defined by the parameters. The boundaries are drawn based on the state of the [`PimageMode`](/doc/PimageMode) function, either CORNER, CORNERS, or CENTER. \n\n\n[Link to original Processing doc](https://processing.org/reference/clip_.html)\n\n@param `a` x-coordinate of the rectangle, by default\n\n@param `b` y-coordinate of the rectangle, by default\n\n@param `c` width of the rectangle, by default\n\n@param `d` height of the rectangle, by default\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pclip"},{name:"Pcolor",detail:"pg<PGRAPHICS> gray<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> gray<NUMBER> alpha<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>",documentation:"`Pcolor` creates colors for storing in ARGB LONG datatype.\n\n+ RGB: The most efficient is to skip Pcolor function, using the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n+ HSB: For Hue Saturation Brightness to RGB conversion, use [`PcolorMode`](/doc/PcolorMode) to specify HSB, then use Pcolor to convert to ARGB.\n\nThe parameters are interpreted as RGB or HSB values depending on the current [`PcolorMode`](/doc/PcolorMode). The default mode is RGB values from 0 to 255.\n\nNote that if only one value is provided to `Pcolor`, it will be interpreted as a grayscale value. Add a second value, and it will be used for alpha transparency. When three values are specified, they are interpreted as either RGB or HSB values. Adding a fourth value applies alpha transparency.\n\n\n[Link to original Processing doc](https://processing.org/reference/color_.html)\n\n@param `gray` int: number specifying value between white and black\n\n@param `alpha` float, or int: relative to current color range\n\n@param `v1` float, or int: red or hue values relative to the current color range\n\n@param `v2` float, or int: green or saturation values relative to the current color range\n\n@param `v3` float, or int: blue or brightness values relative to the current color range\n\n@param `color` ARGB color.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pcolor"},{name:"PcolorMode",detail:"pg<PGRAPHICS> mode<STRING>  PcolorMode  pg<PGRAPHICS>\npg<PGRAPHICS> mode<STRING> max<DOUBLE>  PcolorMode  pg<PGRAPHICS>\npg<PGRAPHICS> mode<STRING> max1<DOUBLE> max2<DOUBLE> max3<DOUBLE>  PcolorMode  pg<PGRAPHICS>\npg<PGRAPHICS> mode<STRING> max1<DOUBLE> max2<DOUBLE> max3<DOUBLE> maxA<DOUBLE>  PcolorMode  pg<PGRAPHICS>",documentation:"Changes the way Processing interprets color data. By default, the parameters for [`Pfill`](/doc/Pfill), [`Pstroke`](/doc/Pstroke), [`Pbackground`](/doc/Pbackground), and [`Pcolor`](/doc/Pcolor) are defined by values between 0 and 255 using the RGB color model. The `PcolorMode` function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling **colorMode(RGB, 1.0)** will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters **max**, **max1**, **max2**, **max3**, and **maxA**.\n\nWhen using max different from default values, do not work with grayscale.\n\nAfter changing the range of values for colors with code like **colorMode(HSB, 360, 100, 100)**, those ranges remain in use until they are explicitly changed again. For example, after running **colorMode(HSB, 360, 100, 100)** and then changing back to **colorMode(RGB)**, the range for R will be 0 to 360 and the range for G and B will be 0 to 100. To avoid this, be explicit about the ranges when changing the color mode. For instance, instead of **colorMode(RGB)**, write **colorMode(RGB, 255, 255, 255)**. \n\n\n[Link to original Processing doc](https://processing.org/reference/colorMode_.html)\n\n@param `mode` Either 'RGB' or 'HSB', corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n\n@param `max` range for all color elements\n\n@param `max1` range for the red or hue depending on the current color mode\n\n@param `max2` range for the green or saturation depending on the current color mode\n\n@param `max3` range for the blue or brightness depending on the current color mode\n\n@param `maxA` range for the alpha\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcolorMode"},{name:"Pconstrain",detail:"pg<PGRAPHICS> x<DOUBLE> low<DOUBLE> high<DOUBLE>  Pconstrain  pg<PGRAPHICS> clamped<DOUBLE>",documentation:"Constrains a value to not exceed a maximum and minimum value. Also known as clamping a value. \n\nIt could be done with warpscript MIN MAX functions, see example.\n\n[Link to original Processing doc](https://processing.org/reference/constrain_.html)\n\n@param `x` The value to clamp.\n\n@param `low` Minimum limit.\n\n@param `high` Maximum limit.\n\n@param `clamped` Clamped value of x in [low high] range.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pconstrain"},{name:"Pcopy",detail:"pg<PGRAPHICS> src<PIMAGE> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG>  Pcopy  pg<PGRAPHICS>\npg<PGRAPHICS> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG>  Pcopy  pg<PGRAPHICS>\npg<PGRAPHICS>  Pcopy  pg<PGRAPHICS> img<PIMAGE>",documentation:"Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an image used as the **src** parameter into the display window. If the source and destination regions are not the same size, it will automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/copy_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `img` PIMAGE object, copy of pg\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pcopy"},{name:"PcreateFont",detail:"pg<PGRAPHICS> name<STRING>  PcreateFont  pg<PGRAPHICS> font<PFONT>\npg<PGRAPHICS> name<STRING> size<NUMBER>  PcreateFont  pg<PGRAPHICS> font<PFONT>\npg<PGRAPHICS> name<STRING> size<NUMBER> smooth<BOOLEAN>  PcreateFont  pg<PGRAPHICS> font<PFONT>\npg<PGRAPHICS> name<STRING> size<NUMBER> smooth<BOOLEAN> charset<STRING>  PcreateFont  pg<PGRAPHICS> font<PFONT>",documentation:"Dynamically converts a font to the format used by Processing from a font that is installed on the computer.  Not all fonts can be used and some might work with one operating system and not others.\n\nThe **size** parameter states the font size you want to generate. The **smooth** parameter specifies if the font should be antialiased or not.\n\nSince the 2.5.0 version, the name of the font can be a URI to a OpenType or Type1 font which will be resolved by a macro defined by the `processing.font.resolver` configuration.\n\n[Link to original Processing doc](https://processing.org/reference/createFont_.html)\n\n@param `name` Name of the font to load or URI from where to load the font.\n\n@param `size` Point size of the font\n\n@param `smooth` True for an antialiased font, false for aliased\n\n@param `charset` subset of ascii characters to be generated.\n\n@param `font` Processing font object compatible with PtextFont.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcreateFont"},{name:"Pcurve",detail:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  Pcurve  pg<PGRAPHICS>\npg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> z1<DOUBLE> x2<DOUBLE> y2<DOUBLE> z2<DOUBLE> x3<DOUBLE> y3<DOUBLE> z3<DOUBLE> x4<DOUBLE> y4<DOUBLE> z4<DOUBLE>  Pcurve  pg<PGRAPHICS>",documentation:"Draws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of `Pcurve` functions together or using [`PcurveVertex`](/doc/PcurveVertex). An additional function called [`PcurveTightness`](/doc/PcurveTightness) provides control for the visual quality of the curve. The `Pcurve` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n[Link to original Processing doc](https://processing.org/reference/curve_.html)\n\n@param `x1` float: coordinates for the beginning control point\n\n@param `y1` float: coordinates for the beginning control point\n\n@param `x2` float: coordinates for the first point\n\n@param `y2` float: coordinates for the first point\n\n@param `x3` float: coordinates for the second point\n\n@param `y3` float: coordinates for the second point\n\n@param `x4` float: coordinates for the ending control point\n\n@param `y4` float: coordinates for the ending control point\n\n@param `z1` float: coordinates for the beginning control point\n\n@param `z2` float: coordinates for the first point\n\n@param `z3` float: coordinates for the second point\n\n@param `z4` float: coordinates for the ending control point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pcurve"},{name:"PcurveDetail",detail:"pg<PGRAPHICS> detail<NUMBER>  PcurveDetail  pg<PGRAPHICS>",documentation:"Sets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveDetail_.html)\n\n@param `detail` Resolution of the curves\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveDetail"},{name:"PcurvePoint",detail:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PcurvePoint  pg<PGRAPHICS> out<DOUBLE>",documentation:"Evaluates the curve at point **t** for points **a**, **b**, **c**, **d**. The parameter **t** may range from 0 (the start of the curve) and 1 (the end of the curve). **a** and **d** are points on the curve, and **b** and **c** are the control points. This can be used once with the **x** coordinates and a second time with the **y** coordinates to get the location of a curve at **t**.\n\n\n[Link to original Processing doc](https://processing.org/reference/curvePoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of second point on the curve\n\n@param `c` coordinate of third point on the curve\n\n@param `d` coordinate of fourth point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurvePoint"},{name:"PcurveTangent",detail:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PcurveTangent  pg<PGRAPHICS> out<DOUBLE>",documentation:"Calculates the tangent of a point on a curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTangent"},{name:"PcurveTightness",detail:"pg<PGRAPHICS> tightness<NUMBER>  PcurveTightness  pg<PGRAPHICS>",documentation:"Modifies the quality of forms created with [`Pcurve`](/doc/Pcurve) and [`PcurveVertex`](/doc/PcurveVertex). The parameter **tightness** determines how the curve fits to the vertex points. The value 0.0 is the default value for **tightness** (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTightness_.html)\n\n@param `tightness` Amount of deformation from the original vertices\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTightness"},{name:"PcurveVertex",detail:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  PcurveVertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  PcurveVertex  pg<PGRAPHICS>",documentation:"Specifies vertex coordinates for curves. This function may only be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). The first and last points in a series of `PcurveVertex` lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with `PcurveVertex` will draw the curve between the second, third, and fourth points. The `PcurveVertex` function is an implementation of Catmull-Rom splines. \n\n[Link to original Processing doc](https://processing.org/reference/curveVertex_.html)\n\n@param `x` The x-coordinate of the vertex\n\n@param `y` The y-coordinate of the vertex\n\n@param `z` The z-coordinate of the vertex\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveVertex"},{name:"Pdecode",detail:"b64img<STRING>  Pdecode  img<PIMAGE>\nrawimg<BYTES>  Pdecode  img<PIMAGE>",documentation:"`Pdecode` takes the image representation on the stack and pushes a Pimage object on the stack. This object can only be used as an input for [`Pset`](/doc/Pset), [`Pimage`](/doc/Pimage), [`Pbackground`](/doc/Pbackground).\n\nInput string must start with the header `data:image/png;base64,`.\n\nSupported input types: PNG, GIF, JPG.\n\n@param `img` Processing Pimage object.\n\n@param `rawimg` Image bytes.\n\n@param `b64img` Base64 encoded image string\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pdecode"},{name:"Pdist",detail:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> z1<DOUBLE> x2<DOUBLE> y2<DOUBLE> z2<DOUBLE>  Pdist  pg<PGRAPHICS>\npg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE>  Pdist  pg<PGRAPHICS>",documentation:"Calculates the distance between two points, in 2D or 3D space.\n\n\n[Link to original Processing doc](https://processing.org/reference/dist_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `z1` z-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pdist"},{name:"Pellipse",detail:"pg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Pellipse  pg<PGRAPHICS>",documentation:"Draws an ellipse (oval) to the screen. An ellipse with equal width and height is a circle. By default, the first two parameters set the location, and the third and fourth parameters set the shape's width and height. The origin may be changed with the [`PellipseMode`](/doc/PellipseMode) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/ellipse_.html)\n\n@param `a` float: x-coordinate of the ellipse\n\n@param `b` float: y-coordinate of the ellipse\n\n@param `c` float: width of the ellipse by default\n\n@param `d` float: height of the ellipse by default\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pellipse"},{name:"PellipseMode",detail:"pg<PGRAPHICS> mode<STRING>  PellipseMode  pg<PGRAPHICS>",documentation:"Modifies the location from which ellipses are drawn by changing the way in which parameters given to [`Pellipse`](/doc/Pellipse) are intepreted.\n\nThe default mode is **ellipseMode(CENTER)**, which interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**ellipseMode(RADIUS)** also uses the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, but uses the third and fourth parameters to specify half of the shapes's width and height.\n\n**ellipseMode(CORNER)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**ellipseMode(CORNERS)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the location of one corner of the ellipse's bounding box, and the third and fourth parameters as the location of the opposite corner.\n\n[Link to original Processing doc](https://processing.org/reference/ellipseMode_.html)\n\n@param `mode` Either CENTER, RADIUS, CORNER, or CORNERS\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PellipseMode"},{name:"Pencode",detail:"pg<PGRAPHICS>  Pencode  b64img<STRING>\npg<PGRAPHICS> metadata<MAP>  Pencode  b64img<STRING>",documentation:"`Pencode` function takes a processing graphic object on the top of the stack, render it to a png file, encode it in base64, prefix the result with the standard png header \"data:image/png;base64,\".\n\nThe resulting string is ready to use in an html document.\n\n@param `pg` Processing graphic object.\n\n@param `b64img` Base64 encoded image string, ready to use in an html page.\n\n@param `metadata` Map of metadata to add to the PNG. Accepted keys are 'tEXt', 'zTXt' and 'iTXt', while values are lists of maps with 'keyword' and 'text' keys.\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pencode"},{name:"PendContour",detail:"pg<PGRAPHICS>  PendContour  pg<PGRAPHICS>",documentation:"Use the [`PbeginContour`](/doc/PbeginContour) and `PendContour` function to create negative shapes within shapes such as the center of the letter 'O'. [`PbeginContour`](/doc/PbeginContour) begins recording vertices for the shape and `PendContour` stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a [`PbeginContour`](/doc/PbeginContour)/`PendContour` pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n[Link to original Processing doc](https://processing.org/reference/endContour_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PendContour"},{name:"PendShape",detail:"pg<PGRAPHICS> mode<STRING>  PendShape  pg<PGRAPHICS>\npg<PGRAPHICS>  PendShape  pg<PGRAPHICS>",documentation:"The `PendShape` function is the companion to [`PbeginShape`](/doc/PbeginShape) and may only be called after [`PbeginShape`](/doc/PbeginShape). When `Pendshape` is called, all of image data defined since the previous call to [`PbeginShape`](/doc/PbeginShape) is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end). \n\nUp to Warp 10 1.2.18, `PendShape` could be called without the **mode** parameter. It defaults to OPEN.\n\n[Link to original Processing doc](https://processing.org/reference/endShape_.html)\n\n@param `mode` Use CLOSE to close the shape, OPEN otherwise.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PendShape"},{name:"Pfill",detail:"pg<PGRAPHICS> argb<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> gray<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> argb<LONG> alpha<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> v1<LONG> v2<LONG> v3<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> v1<LONG> v2<LONG> v3<LONG> alpha<LONG>  Pfill  pg<PGRAPHICS>",documentation:'Sets the color used to fill shapes. For example, if you run **fill(204, 102, 0)**, all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current [`PcolorMode`](/doc/PcolorMode). The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\nThe value for the "gray" parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\nTo change the color of an image or a texture, use [`Ptint`](/doc/Ptint).\n\n[Link to original Processing doc](https://processing.org/reference/fill_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n',tags:["processing"],since:"1.0.0",OPB64name:"Pfill"},{name:"Pfilter",detail:"pg<PGRAPHICS> kind<STRING>  Pfilter  pg<PGRAPHICS>\npg<PGRAPHICS> kind<STRING> param<DOUBLE>  Pfilter  pg<PGRAPHICS>",documentation:"Filters the display window using a preset filter or with a custom shader. Using a shader with `Pfilter` is much faster than without. Shaders require the P2D or P3D renderer in size().\n\n\nThe presets options are:\n\n+ **THRESHOLD** Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The parameter must be between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n+ **GRAY** Converts any colors in the image to grayscale equivalents. No parameter is used.\n+ **OPAQUE** Sets the alpha channel to entirely opaque. No parameter is used.\n+ **INVERT** Sets each pixel to its inverse value. No parameter is used.\n+ **POSTERIZE** Limits each channel of the image to the number of colors specified as the parameter. The parameter can be set to values between 2 and 255, but results are most noticeable in the lower ranges.\n+ **BLUR** Executes a Guassian blur with the level parameter specifying the extent of the blurring. If no parameter is used, the blur is equivalent to Guassian blur of radius 1. Larger values increase the blur.\n+ **ERODE** Reduces the light areas. No parameter is used.\n+ **DILATE** Increases the light areas. No parameter is used.\n\n\n[Link to original Processing doc](https://processing.org/reference/filter_.html)\n\n@param `kind` Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE\n\n@param `param` unique for each, see above\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.2.17",OPB64name:"J5OdQ6G_RV"},{name:"Pget",detail:"pg<PGRAPHICS>  Pget  pg<PGRAPHICS> img<PIMAGE>\npg<PGRAPHICS> x<NUMBER> y<NUMBER>  Pget  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> w<NUMBER> h<NUMBER>  Pget  pg<PGRAPHICS> img<PIMAGE>",documentation:"Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned (same as `Pcopy`). Use the **x** and **y** parameters to get the value of one pixel. Get a section of the display window by specifying additional **w** and **h** parameters. When getting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\nIf the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with **colorMode(HSB)**, the numbers returned will be in RGB format.\n\nGetting the color of a single pixel with **get(x, y)** is easy, but not as fast as grabbing the data directly from [`Ppixels`](/doc/Ppixels).\n\n[Link to original Processing doc](https://processing.org/reference/get_.html)\n\n@param `x` int: x-coordinate of the pixel\n\n@param `y` int: y-coordinate of the pixel\n\n@param `w` int: width of pixel rectangle to get\n\n@param `h` int: height of pixel rectangle to get\n\n@param `img` PIMAGE object\n\n@param `color` Color of the pixel, 32bits ARGB format.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pget"},{name:"Pgreen",detail:"pg<PGRAPHICS> rgb<NUMBER>  Pgreen  pg<PGRAPHICS> green<DOUBLE>",documentation:"Extracts the green value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pgreen` function is easy to use and understand, but it is slower than bit shifting. \n\n\n[Link to original Processing doc](https://processing.org/reference/green_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `green` Green component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pgreen"},{name:"Phue",detail:"pg<PGRAPHICS> rgb<NUMBER>  Phue  pg<PGRAPHICS> hue<DOUBLE>",documentation:"Extracts the hue value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/hue_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `hue` Hue component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Phue"},{name:"Pimage",detail:"pg<PGRAPHICS> img<PIMAGE> a<NUMBER> b<NUMBER>  Pimage  pg<PGRAPHICS>\npg<PGRAPHICS> img<PIMAGE> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Pimage  pg<PGRAPHICS>",documentation:"The `Pimage` function draws a Pimage (see [`Pdecode`](/doc/Pdecode)) on a PGraphic object.\n\nThe **img** parameter specifies the image to display and by default the **a** and **b** parameters define the location of its upper-left corner. The image is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PimageMode`](/doc/PimageMode) function can be used to change the way these parameters draw the image.\n\nThe color of an image may be modified with the [`Ptint`](/doc/Ptint) function. This function will maintain transparency for GIF and PNG images.\n\n[Link to original Processing doc](https://processing.org/reference/image_.html)\n\n@param `img` PImage: the image to display\n\n@param `a` float: x-coordinate of the image by default\n\n@param `b` float: y-coordinate of the image by default\n\n@param `c` float: width to display the image by default\n\n@param `d` float: height to display the image by default\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pimage"},{name:"PimageMode",detail:"pg<PGRAPHICS> mode<STRING>  PimageMode  pg<PGRAPHICS>",documentation:"Modifies the location from which images are drawn by changing the way in which parameters given to [`Pimage`](/doc/Pimage) are intepreted.\n\nThe default mode is **imageMode(CORNER)**, which interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the upper-left corner of the image. If two additional parameters are specified, they are used to set the image's width and height.\n\n**imageMode(CENTER)** interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the image's center point. If two additional parameters are specified, they are used to set the image's width and height.\n\n\n[Link to original Processing doc](https://processing.org/reference/imageMode_.html)\n\n@param `mode` could be CORNER or CENTER\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PimageMode"},{name:"Plerp",detail:"pg<PGRAPHICS> start<NUMBER> stop<NUMBER> amt<NUMBER>  Plerp  pg<PGRAPHICS>",documentation:"Calculates a number between two numbers at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for creating motion along a straight path and for drawing dotted lines, or any linear interpolation.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerp_.html)\n\n@param `start` first value\n\n@param `stop` second value\n\n@param `amt` float between 0.0 and 1.0\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Plerp"},{name:"PlerpColor",detail:"pg<PGRAPHICS> c1<NUMBER> c2<NUMBER> amt<NUMBER>  PlerpColor  pg<PGRAPHICS> outcolor<LONG>",documentation:"Calculates a color between two colors at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 is equal to the first point, 0.1 is very near the first point, 0.5 is halfway in between, etc. \n\nAn amount below 0 will be treated as 0. Likewise, amounts above 1 will be capped at 1. This is different from the behavior of `Plerp`, but necessary because otherwise numbers outside the range will produce strange and unexpected colors.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerpColor_.html)\n\n@param `c1` interpolate from this color\n\n@param `c2` interpolate to this color\n\n@param `amt` between 0.0 and 1.0\n\n@param `outcolor` the interpolated result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PlerpColor"},{name:"Pline",detail:"pg<PGRAPHICS> x1<NUMBER> y1<NUMBER> x2<NUMBER> y2<NUMBER>  Pline  pg<PGRAPHICS>\npg<PGRAPHICS> x1<NUMBER> y1<NUMBER> z1<NUMBER> x2<NUMBER> y2<NUMBER> z2<NUMBER>  Pline  pg<PGRAPHICS>",documentation:"Draws a line (a direct path between two points) to the screen. The version of `Pline` with four parameters draws the line in 2D.  To color a line, use the [`Pstroke`](/doc/Pstroke) function. A line cannot be filled, therefore the [`Pfill`](/doc/Pfill) function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the [`PstrokeWeight`](/doc/PstrokeWeight) function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the **z** parameter requires the P3D parameter.\n\n\n[Link to original Processing doc](https://processing.org/reference/line_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z1` z-coordinate of the first point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pline"},{name:"PloadShape",detail:"svg<STRING>  PloadShape  Pshape<PSHAPE>",documentation:"`PloadShape` can load a [SVG image](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) and return a PSHAPE object. WarpScript does not support [OBJ files](https://en.wikipedia.org/wiki/Wavefront_.obj_file) yet. \n\nThis feature is experimental, some files may render empty. \n\n@param `svg` A one line or a multiline SVG string.\n\n@param `Pshape` A PSHAPE object which can be used with Pshape.\n\n",tags:["processing"],since:"1.2.18",OPB64name:"PloadShape"},{name:"Pmag",detail:"pg<PGRAPHICS> a<NUMBER> b<NUMBER>  Pmag  pg<PGRAPHICS> mag<DOUBLE>",documentation:'Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly used in computer graphics and linear algebra. Because it has no "start" position, the magnitude of a vector can be thought of as the distance from the coordinate 0,0 to its x,y value. Therefore, `Pmag` is a shortcut for writing **0 0 x y Pdist**. It is exactly the same as warpscript function [`HYPOT`](/doc/HYPOT).\n\n3D is not yet supported.\n\n[Link to original Processing doc](https://processing.org/reference/mag_.html)\n\n@param `a` first value\n\n@param `b` second value\n\n@param `mag` result\n\n@param `pg` Processing graphic object\n\n',tags:["processing"],since:"1.0.0",OPB64name:"Pmag"},{name:"Pmap",detail:"pg<PGRAPHICS> value<DOUBLE> start1<DOUBLE> stop1<DOUBLE> start2<DOUBLE> stop2<DOUBLE>  Pmap  pg<PGRAPHICS> output<DOUBLE>",documentation:"Re-maps a number from one range to another.\n\nIn the first example, the number 25 is converted from a value in the range of 0 to 100 into a value that ranges from the left edge of the window (0) to the right edge (width).\n\n\nAs shown in the second example, numbers outside of the range are not clamped to the minimum and maximum parameters values, because out-of-range values are often intentional and useful.\n\n\n[Link to original Processing doc](https://processing.org/reference/map_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start1` lower bound of the value's current range\n\n@param `stop1` upper bound of the value's current range\n\n@param `start2` lower bound of the value's target range\n\n@param `stop2` upper bound of the value's target range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pmap"},{name:"Pmask",detail:"mask_image<PIMAGE> orginal_img<PIMAGE>  Pmask  masked_image<PIMAGE>\nmask_image<PIMAGE> orginal_grp<PGRAPHICS>  Pmask  masked_grp<PGRAPHICS>\nmask_grp<PGRAPHICS> orginal_img<PIMAGE>  Pmask  masked_image<PIMAGE>\nmask_grp<PGRAPHICS> orginal_grp<PGRAPHICS>  Pmask  masked_grp<PGRAPHICS>",documentation:"The `Pmask` function copies the blue channel of an image to the alpha channel of an other.\n\nAs **PGRAPHICS** intances are alse **PIMAGE** instances, you can use this fonction with **PGRAPHICS**.\n\n@param `orginal_img` PImage to be masked\n\n@param `mask_image` Pimage to serve as mask\n\n@param `masked_image` Masked Pimage\n\n@param `orginal_grp` PGraphics to be masked\n\n@param `mask_grp` PGraphics to serve as mask\n\n@param `masked_grp` Masked PGraphics\n\n",tags:["processing"],since:"2.7.0",OPB64name:"Pmask"},{name:"PnoClip",detail:"pg<PGRAPHICS>  PnoClip  pg<PGRAPHICS>",documentation:"Disables the clipping previously started by the [`Pclip`](/doc/Pclip) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/noClip_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoClip"},{name:"PnoFill",detail:"pg<PGRAPHICS>  PnoFill  pg<PGRAPHICS>",documentation:"Disables filling geometry. If both [`PnoStroke`](/doc/PnoStroke) and `PnoFill` are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noFill_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoFill"},{name:"PnoStroke",detail:"pg<PGRAPHICS>  PnoStroke  pg<PGRAPHICS>",documentation:"Disables drawing the stroke (outline). If both `PnoStroke` and [`PnoFill`](/doc/PnoFill) are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noStroke_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoStroke"},{name:"PnoTint",detail:"pg<PGRAPHICS>  PnoTint  pg<PGRAPHICS>",documentation:"Removes the current fill value for displaying images and reverts to displaying images with their original hues.\n\n\n[Link to original Processing doc](https://processing.org/reference/noTint_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoTint"},{name:"Pnorm",detail:"pg<PGRAPHICS> value<NUMBER> start<NUMBER> stop<NUMBER>  Pnorm  pg<PGRAPHICS> output<DOUBLE>",documentation:"Normalizes a number from another range into a value between 0 and 1. Identical to `value low high 0 1 Pmap`.\n\nNumbers outside of the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. \n\n\n[Link to original Processing doc](https://processing.org/reference/norm_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start` lower bound of the value's current range\n\n@param `stop` upper bound of the value's current range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pnorm"},{name:"Ppixels",detail:"pg<PGRAPHICS>  Ppixels  pg<PGRAPHICS> pixels<LIST<LONG>>\nimg<PIMAGE>  Ppixels  img<PIMAGE> pixels<LIST<LONG>>",documentation:"Returns an array containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. After **pixels** has been modified, the [`PupdatePixels`](/doc/PupdatePixels) function must be run to update the content of the display window.\n\n\n[Link to original Processing doc](https://processing.org/reference/pixels.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ppixels"},{name:"Ppoint",detail:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  Ppoint  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  Ppoint  pg<PGRAPHICS>",documentation:"Draws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point.\n\nUse [`Pstroke`](/doc/Pstroke) to set the color of a `Ppoint`.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight.\n\n\n[Link to original Processing doc](https://processing.org/reference/point_.html)\n\n@param `x` x-coordinate of the point\n\n@param `y` y-coordinate of the point\n\n@param `z` z-coordinate of the point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ppoint"},{name:"PpopMatrix",detail:"pg<PGRAPHICS>  PpopMatrix  pg<PGRAPHICS>",documentation:"Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The [`PpushMatrix`](/doc/PpushMatrix) function saves the current coordinate system to the stack and `PpopMatrix` restores the prior coordinate system. [`PpushMatrix`](/doc/PpushMatrix) and `PpopMatrix` are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/popMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpopMatrix"},{name:"PpopStyle",detail:"pg<PGRAPHICS>  PpopStyle  pg<PGRAPHICS>",documentation:"The [`PpushStyle`](/doc/PpushStyle) function saves the current style settings and `PpopStyle` restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with [`PpushStyle`](/doc/PpushStyle), it builds on the current style information. The [`PpushStyle`](/doc/PpushStyle) and `PpopStyle` functions can be nested to provide more control (see example for a demonstration.)\n\n\n[Link to original Processing doc](https://processing.org/reference/popStyle_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpopStyle"},{name:"PpushMatrix",detail:"pg<PGRAPHICS>  PpushMatrix  pg<PGRAPHICS>",documentation:"Pushes the current transformation matrix onto the matrix stack. Understanding `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) requires understanding the concept of a matrix stack. The `PpushMatrix` function saves the current coordinate system to the stack and [`PpopMatrix`](/doc/PpopMatrix) restores the prior coordinate system. `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpushMatrix"},{name:"PpushStyle",detail:"pg<PGRAPHICS>  PpushStyle  pg<PGRAPHICS>",documentation:"The `PpushStyle` function saves the current style settings and [`PpopStyle`](/doc/PpopStyle) restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `PpushStyle`, it builds on the current style information. The `PpushStyle` and [`PpopStyle`](/doc/PpopStyle) functions can be nested to provide more control. (See example for a demonstration.)\n\n\nThe style information controlled by the following functions are included in the style:fill, stroke, tint, strokeWeight, strokeCap, strokeJoin, imageMode, rectMode, ellipseMode, shapeMode, colorMode, textAlign, textFont, textMode, textSize, textLeading, emissive, specular, shininess, ambient.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushStyle_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpushStyle"},{name:"Pquad",detail:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  Pquad  pg<PGRAPHICS>",documentation:"A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n\n\n[Link to original Processing doc](https://processing.org/reference/quad_.html)\n\n@param `x1` float: x-coordinate of the first corner\n\n@param `y1` float: y-coordinate of the first corner\n\n@param `x2` float: x-coordinate of the second corner\n\n@param `y2` float: y-coordinate of the second corner\n\n@param `x3` float: x-coordinate of the third corner\n\n@param `y3` float: y-coordinate of the third corner\n\n@param `x4` float: x-coordinate of the fourth corner\n\n@param `y4` float: y-coordinate of the fourth corner\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pquad"},{name:"PquadraticVertex",detail:"pg<PGRAPHICS> cx<DOUBLE> cy<DOUBLE> x3<DOUBLE> y3<DOUBLE>  PquadraticVertex  pg<PGRAPHICS>",documentation:"Specifies vertex coordinates for quadratic Bezier curves. Each call to `PquadraticVertex` defines the position of one control point and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PquadraticVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when there is no MODE parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/quadraticVertex_.html)\n\n@param `cx` the x-coordinate of the control point\n\n@param `cy` the y-coordinate of the control point\n\n@param `x3` the x-coordinate of the anchor point\n\n@param `y3` the y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PquadraticVertex"},{name:"Prect",detail:"pg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Prect  pg<PGRAPHICS>\npg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER> r<NUMBER>  Prect  pg<PGRAPHICS>\npg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER> tl<NUMBER> tr<NUMBER> br<NUMBER> bl<NUMBER>  Prect  pg<PGRAPHICS>",documentation:"Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. The way these parameters are interpreted, however, may be changed with the [`PrectMode`](/doc/PrectMode) function.\n\n\n\nTo draw a rounded rectangle, add a fifth parameter, which is used as the radius value for all four corners.\n\n\n\nTo use a different radius value for each corner, include eight parameters. When using eight parameters, the latter four set the radius of the arc at each corner separately, starting with the top-left corner and moving clockwise around the rectangle.\n\n\n[Link to original Processing doc](https://processing.org/reference/rect_.html)\n\n@param `a` float: x-coordinate of the rectangle by default\n\n@param `b` float: y-coordinate of the rectangle by default\n\n@param `c` float: width of the rectangle by default\n\n@param `d` float: height of the rectangle by default\n\n@param `r` float: radii for all four corners\n\n@param `tl` float: radius for top-left corner\n\n@param `tr` float: radius for top-right corner\n\n@param `br` float: radius for bottom-right corner\n\n@param `bl` float: radius for bottom-left corner\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Prect"},{name:"PrectMode",detail:"pg<PGRAPHICS> mode<STRING>  PrectMode  pg<PGRAPHICS>",documentation:"Modifies the location from which rectangles are drawn by changing the way in which parameters given to [`Prect`](/doc/Prect) are intepreted.\n\nThe default mode is **CORNER**, which interprets the first two parameters of [`Prect`](/doc/Prect) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**CORNERS** interprets the first two parameters of [`Prect`](/doc/Prect) as the location of one corner, and the third and fourth parameters as the location of the opposite corner.\n\n**CENTER** interprets the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**RADIUS** also uses the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, but uses the third and fourth parameters to specify half of the shape's width and height.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n\n[Link to original Processing doc](https://processing.org/reference/rectMode_.html)\n\n@param `mode` either CORNER, CORNERS, CENTER, or RADIUS\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PrectMode"},{name:"Pred",detail:"pg<PGRAPHICS> rgb<NUMBER>  Pred  pg<PGRAPHICS> red<DOUBLE>",documentation:"Extracts the red value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pred` function is easy to use and understand, but it is slower than bit shifting. \n\n[Link to original Processing doc](https://processing.org/reference/red_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `red` Red component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pred"},{name:"PresetMatrix",detail:"pg<PGRAPHICS>  PresetMatrix  pg<PGRAPHICS>",documentation:"Replaces the current matrix with the identity matrix. \n\n\n[Link to original Processing doc](https://processing.org/reference/resetMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PresetMatrix"},{name:"Protate",detail:"pg<PGRAPHICS> angle<NUMBER>  Protate  pg<PGRAPHICS>",documentation:"Rotates the amount specified by the **angle** parameter. Angles must be specified in radians (values from **0** to **2 PI**). \n\nThe coordinates are always rotated around their relative position to the origin. Positive numbers rotate objects in a clockwise direction and negative numbers rotate in the couterclockwise direction. Transformations apply to everything that happens afterward, and subsequent calls to the function compound the effect. For example, calling `pi 2.0 / Protate` once and then calling `pi 2.0 / Protate` a second time is the same as a single `pi Protate`. \n \n\nTechnically, `Protate` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/rotate_.html)\n\n@param `angle` angle of rotation specified in radians\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Protate"},{name:"Psaturation",detail:"pg<PGRAPHICS> rgb<NUMBER>  Psaturation  pg<PGRAPHICS> saturation<DOUBLE>",documentation:"Extracts the saturation value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/saturation_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `saturation` Saturation component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Psaturation"},{name:"Pscale",detail:"pg<PGRAPHICS> s<NUMBER>  Pscale  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER>  Pscale  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  Pscale  pg<PGRAPHICS>",documentation:"Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call `2.0 Pscale` increases the dimension of a shape by 200%.\n\n\n\nTransformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling `2.0 Pscale` and then `1.5 Pscale` is the same as `3.0 Pscale`. This function can be further controlled with [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/scale_.html)\n\n@param `s` percentage to scale the object\n\n@param `x` percentage to scale the object in the x-axis\n\n@param `y` percentage to scale the object in the y-axis\n\n@param `z` percentage to scale the object in the z-axis\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pscale"},{name:"Pset",detail:"pg<PGRAPHICS> x<NUMBER> y<NUMBER> c<NUMBER>  Pset  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> img<PIMAGE>  Pset  pg<PGRAPHICS>",documentation:"Changes the color of any pixel, or writes an image directly to the display window.\n\n\n\nThe **x** and **y** parameters specify the pixel to change and the **c** parameter specifies the color value. The **c** parameter is interpreted according to the current color mode.  (The default color mode is RGB values from 0 to 255.)  When setting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\n\n\nSetting the color of a single pixel with **set(x, y)** is easy, but not as fast as putting the data directly into the list of pixels returned by  [`Ppixels`](/doc/Ppixels).\n\n\n[Link to original Processing doc](https://processing.org/reference/set_.html)\n\n@param `x` X-coordinate of the pixel\n\n@param `y` Y-coordinate of the pixel\n\n@param `c` Any value of the color datatype\n\n@param `img` Image to copy into the original image\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pset"},{name:"Pshape",detail:"pg<PGRAPHICS> shape<PSHAPE>  Pshape  pg<PGRAPHICS>\npg<PGRAPHICS> shape<PSHAPE> x<DOUBLE> y<DOUBLE>  Pshape  pg<PGRAPHICS>\npg<PGRAPHICS> shape<PSHAPE> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE>  Pshape  pg<PGRAPHICS>",documentation:"Draws shapes to the display window. Shapes must be loaded with [`PloadShape`](/doc/PloadShape). Processing currently works with SVG, OBJ, and custom-created shapes. WrapScript only support SVG. The **shape** parameter specifies the shape to display and the coordinate parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PshapeMode`](/doc/PshapeMode) function can be used to change the way these parameters are interpreted.\n\n\n[Link to original Processing doc](https://processing.org/reference/shape_.html)\n\n@param `shape` the shape to display\n\n@param `x` x-coordinate of the shape\n\n@param `y` y-coordinate of the shape\n\n@param `a` x-coordinate of the shape\n\n@param `b` y-coordinate of the shape\n\n@param `c` width to display the shape\n\n@param `d` height to display the shape\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.2.18",OPB64name:"Pshape"},{name:"PshapeMode",detail:"pg<PGRAPHICS> mode<STRING>  PshapeMode  pg<PGRAPHICS>",documentation:"Modifies the location from which shapes draw. The default mode is **shapeMode(CORNER)**, which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. The syntax **shapeMode(CORNERS)** uses the first and second parameters of [`Pshape`](/doc/Pshape) to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax **shapeMode(CENTER)** draws the shape from its center point and uses the third and forth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. \n\n\n[Link to original Processing doc](https://processing.org/reference/shapeMode_.html)\n\n@param `mode` int: either CORNER, CORNERS, CENTER\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PshapeMode"},{name:"PshearX",detail:"pg<PGRAPHICS> angle<NUMBER>  PshearX  pg<PGRAPHICS>",documentation:"Shears a shape around the x-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearX` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearX_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PshearX"},{name:"PshearY",detail:"pg<PGRAPHICS> angle<NUMBER>  PshearY  pg<PGRAPHICS>",documentation:"Shears a shape around the y-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearY` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearY_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PshearY"},{name:"Psize",detail:"img<PIMAGE>  Psize  width<LONG> height<LONG>\npg<PGRAPHICS>  Psize  width<LONG> height<LONG>",documentation:"The `Psize` function returns the pixel `width` and `height` of a Pimage or PGraphics object.\n\n@param `img` PImage instance to measure.\n\n@param `pg` PGraphics instance to measure.\n\n@param `height` Object height in pixels.\n\n@param `width` Object height in pixels.\n\n",tags:["processing"],since:"2.6.0",OPB64name:"Psize"},{name:"Psphere",detail:"pg<PGRAPHICS> r<NUMBER>  Psphere  pg<PGRAPHICS>",documentation:"A sphere is a hollow ball made from tessellated triangles.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphere_.html)\n\n@param `r` the radius of the sphere\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Psphere"},{name:"PsphereDetail",detail:"pg<PGRAPHICS> res<NUMBER>  PsphereDetail  pg<PGRAPHICS>\npg<PGRAPHICS> ures<NUMBER> vres<NUMBER>  PsphereDetail  pg<PGRAPHICS>",documentation:"Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you are going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until `PsphereDetail` is called again with a new parameter and so should **not** be called prior to every [`Psphere`](/doc/Psphere) statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphereDetail_.html)\n\n@param `res` int: number of segments (minimum 3) used per full circle revolution\n\n@param `ures` int: number of segments used longitudinally per full circle revolutoin\n\n@param `vres` int: number of segments used latitudinally from top to bottom\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PsphereDetail"},{name:"Pstroke",detail:"pg<PGRAPHICS> argb<LONG>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> argb<LONG> alpha<DOUBLE>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE> alpha<DOUBLE>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Pstroke  pg<PGRAPHICS>",documentation:"Sets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current **colorMode** The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n[Link to original Processing doc](https://processing.org/reference/stroke_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pstroke"},{name:"PstrokeCap",detail:"pg<PGRAPHICS> cap<STRING>  PstrokeCap  pg<PGRAPHICS>",documentation:"Sets the style for rendering line endings. These ends are either squared, extended, or rounded, each of which specified with the corresponding parameters: SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n\n\n[Link to original Processing doc](https://processing.org/reference/strokeCap_.html)\n\n@param `cap` Either SQUARE, PROJECT, or ROUND\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeCap"},{name:"PstrokeJoin",detail:"pg<PGRAPHICS> join<STRING>  PstrokeJoin  pg<PGRAPHICS>",documentation:"Sets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER. \n\n\n[Link to original Processing doc](https://processing.org/reference/strokeJoin_.html)\n\n@param `join` Either MITER, BEVEL, ROUND\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeJoin"},{name:"PstrokeWeight",detail:"pg<PGRAPHICS> weight<NUMBER>  PstrokeWeight  pg<PGRAPHICS>",documentation:"Sets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight. See [`Ppoint`](/doc/Ppoint) example.\n\n[Link to original Processing doc](https://processing.org/reference/strokeWeight_.html)\n\n@param `weight` The weight (in pixels) of the stroke.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeWeight"},{name:"Ptext",detail:"pg<PGRAPHICS> s<STRING> x<DOUBLE> y<DOUBLE>  Ptext  pg<PGRAPHICS>\npg<PGRAPHICS> s<STRING> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE>  Ptext  pg<PGRAPHICS>",documentation:"Draws text to the screen. Displays the information specified in the first parameter on the screen in the position specified by the additional parameters. A default font will be used unless a font is set with the [`PtextFont`](/doc/PtextFont) function and a default size will be used unless a font is set with [`PtextSize`](/doc/PtextSize). Change the color of the text with the [`Pfill`](/doc/Pfill) function. The text displays in relation to the [`PtextAlign`](/doc/PtextAlign) function, which gives the option to draw to the left, right, and center of the coordinates.\n\n\n\nThe **x2** and **y2** parameters define a rectangular area to display within and may only be used with string data. When these parameters are specified, they are interpreted based on the current [`PrectMode`](/doc/PrectMode) setting. Text that does not fit completely within the rectangle specified will not be drawn to the screen.\n\n\n\nNote that Processing now lets you call `Ptext` without first specifying a PFont with [`PtextFont`](/doc/PtextFont). In that case, a generic sans-serif font will be used instead.\n\n\n[Link to original Processing doc](https://processing.org/reference/text_.html)\n\n@param `s` the string to be displayed\n\n@param `x` by default, x-coordinate of text\n\n@param `y` by default, y-coordinate of text\n\n@param `x1` by default, the x-coordinate of text, see PrectMode for more info\n\n@param `y1` by default, the y-coordinate of text, see PrectMode for more info\n\n@param `x2` by default, the width of the text box, see PrectMode for more info\n\n@param `y2` by default, the height of the text box, see PrectMode for more info\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptext"},{name:"PtextAlign",detail:"pg<PGRAPHICS> alignX<STRING>  PtextAlign  pg<PGRAPHICS>\npg<PGRAPHICS> alignX<STRING> alignY<STRING>  PtextAlign  pg<PGRAPHICS>",documentation:"Sets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the **x** and **y** parameters of the [`Ptext`](/doc/Ptext) function.\n\n\n\nAn optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current [`PtextDescent`](/doc/PtextDescent). For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.\n\n\n\nWhen using [`Ptext`](/doc/Ptext) with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)\n\n\n\nThe vertical alignment is based on the value of [`PtextAscent`](/doc/PtextAscent), which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of [`PtextAscent`](/doc/PtextAscent) or [`PtextDescent`](/doc/PtextDescent) so that the hack works even if you change the size of the font.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAlign_.html)\n\n@param `alignX` Horizontal alignment, either LEFT, CENTER, or RIGHT\n\n@param `alignY` Vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextAlign"},{name:"PtextAscent",detail:"pg<PGRAPHICS>  PtextAscent  pg<PGRAPHICS> ascent<DOUBLE>",documentation:"Returns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the `PtextAscent` and [`PtextDescent`](/doc/PtextDescent) values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAscent_.html)\n\n@param `ascent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextAscent"},{name:"PtextDescent",detail:"pg<PGRAPHICS>  PtextDescent  pg<PGRAPHICS> descent<DOUBLE>",documentation:"Returns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the [`PtextAscent`](/doc/PtextAscent) and `PtextDescent` values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textDescent_.html)\n\n@param `descent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextDescent"},{name:"PtextFont",detail:"pg<PGRAPHICS> font<PFONT>  PtextFont  pg<PGRAPHICS>\npg<PGRAPHICS> font<PFONT> size<NUMBER>  PtextFont  pg<PGRAPHICS>",documentation:"Sets the current font that will be drawn with the [`Ptext`](/doc/Ptext) function. Fonts must be created for Processing with [`PcreateFont`](/doc/PcreateFont) before they can be used. The font set through `PtextFont` will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/textFont_.html)\n\n@param `font` Any variable of the type PFont\n\n@param `size` the size of the letters in pixel.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextFont"},{name:"PtextLeading",detail:"pg<PGRAPHICS> leading<NUMBER>  PtextLeading  pg<PGRAPHICS>",documentation:"Sets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.  Note, however, that the leading is reset by [`PtextSize`](/doc/PtextSize). For example, if the leading is set to 20 with `20 PtextLeading`, then if `48 PtextSize` is run at a later point, the leading will be reset to the default for the text size of 48.\n\n\n[Link to original Processing doc](https://processing.org/reference/textLeading_.html)\n\n@param `leading` The size in pixels for spacing between lines\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextLeading"},{name:"PtextMode",detail:"pg<PGRAPHICS> mode<STRING>  PtextMode  pg<PGRAPHICS>",documentation:"Sets the way text draws to the screen, either as texture maps or as vector geometry. The default **textMode(MODEL)**, uses textures to render the fonts. The **textMode(SHAPE)** mode draws text using the glyph outlines of individual characters rather than as textures. This mode is only supported with the **PDF** and **P3D** renderer settings. With the **PDF** renderer, you must call **textMode(SHAPE)** before any other drawing occurs. If the outlines are not available, then **textMode(SHAPE)** will be ignored and **textMode(MODEL)** will be used instead.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/textMode_.html)\n\n@param `mode` int: either MODEL or SHAPE\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextMode"},{name:"PtextSize",detail:"pg<PGRAPHICS> size<NUMBER>  PtextSize  pg<PGRAPHICS>",documentation:"Sets the current font size. This size will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function. Font size is measured in units of pixels.\n\n\n[Link to original Processing doc](https://processing.org/reference/textSize_.html)\n\n@param `size` float: the size of the letters in units of pixels\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextSize"},{name:"PtextWidth",detail:"pg<PGRAPHICS> str<STRING>  PtextWidth  pg<PGRAPHICS> w<DOUBLE>",documentation:"Calculates and returns the width of any character or text string.\n\n\n[Link to original Processing doc](https://processing.org/reference/textWidth_.html)\n\n@param `str` The String of characters to measure\n\n@param `w` The width of the input string\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextWidth"},{name:"Ptint",detail:"pg<PGRAPHICS> argb<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> gray<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> argb<NUMBER> alpha<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Ptint  pg<PGRAPHICS>",documentation:"Sets the fill value for displaying images. Images can be tinted to specified colors or made transparent by including an alpha value.\n\n\n\nTo apply transparency to an image without affecting its color, use white as the tint color and specify an alpha value. For instance, **tint(255, 128)** will make an image 50pc transparent (assuming the default alpha range of 0-255, which can be changed with [`PcolorMode`](/doc/PcolorMode)).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/tint_.html)\n\n@param `argb` any argb color value.\n\n@param `alpha` opacity of the image\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptint"},{name:"PtoImage",detail:"pg<PGRAPHICS>  PtoImage  img<PIMAGE>",documentation:"The `PtoImage` function transforms a `PGRAPHICS` to a `PIMAGE`.\n\nThe `PGRAPHICS` can still be used after the transformation as this function copies the pixel values. This is equivalent to `Pencode Pdecode` but it is a lot faster.\n\n@param `pg` Processing graphic object.\n\n@param `img` Processing Pimage object.\n\n",tags:["processing"],since:"2.1.0",OPB64name:"PtoImage"},{name:"Ptranslate",detail:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  Ptranslate  pg<PGRAPHICS>",documentation:"Specifies an amount to displace objects within the display window. The **x** parameter specifies left/right translation, the **y** parameter specifies up/down translation.\n\n\n\nTransformations are cumulative and apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling **50 0 Ptranslate** and then **20 0 Ptranslate** is the same as **70 0 Ptranslate**. This function can be further controlled by using [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/translate_.html)\n\n@param `x` left/right translation\n\n@param `y` up/down translation\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptranslate"},{name:"Ptriangle",detail:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE>  Ptriangle  pg<PGRAPHICS>",documentation:"A triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point. \n\n\n[Link to original Processing doc](https://processing.org/reference/triangle_.html)\n\n@param `x1` float: x-coordinate of the first point\n\n@param `y1` float: y-coordinate of the first point\n\n@param `x2` float: x-coordinate of the second point\n\n@param `y2` float: y-coordinate of the second point\n\n@param `x3` float: x-coordinate of the third point\n\n@param `y3` float: y-coordinate of the third point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptriangle"},{name:"PupdatePixels",detail:"pg<PGRAPHICS> pixels<LIST<LONG>>  PupdatePixels  pg<PGRAPHICS>\nimg<PIMAGE> pixels<LIST<LONG>>  PupdatePixels  img<PIMAGE>",documentation:"Updates the display window with the data in the **pixels[]** array. Use in conjunction with [`Ppixels`](/doc/Ppixels). If you are only reading pixels from the array, there's no need to call `PupdatePixels` - updating is only necessary to apply changes.\n\n[Link to original Processing doc](https://processing.org/reference/updatePixels_.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PupdatePixels"},{name:"Pvertex",detail:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  Pvertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  Pvertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> u<NUMBER> v<NUMBER>  Pvertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER> u<NUMBER> v<NUMBER>  Pvertex  pg<PGRAPHICS>",documentation:"All shapes are constructed by connecting a series of vertices. `Pvertex` is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons. It is used exclusively within the [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/vertex_.html)\n\n@param `x` x-coordinate of the vertex\n\n@param `y` y-coordinate of the vertex\n\n@param `z` float: z-coordinate of the vertex\n\n@param `u` float: horizontal coordinate for the texture mapping\n\n@param `v` float: vertical coordinate for the texture mapping\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pvertex"},{name:"Q->",detail:"input<LONG>  Q->  w<DOUBLE> x<DOUBLE> y<DOUBLE> z<DOUBLE>",documentation:"The `Q->` function consumes on the stack a [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long and push back the quaternion into\n4 doubles (w, x, y, z, with z being on top).\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `input` Quaternion representation\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"JHoy"},{name:"QCONJUGATE",detail:"quaternion<LONG>  QCONJUGATE  result<LONG>",documentation:"The `QCONJUGATE` function performs a [conjugation](https://en.wikipedia.org/wiki/Quaternion#Conjugation,_the_norm,_and_reciprocal) of a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the quaternion conjugate into a long.\n\n@param `quaternion` The input quaternion\n\n@param `result` The conjugated quaternion\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QCONJUGATE"},{name:"QDIVIDE",detail:"q<LONG> r<LONG>  QDIVIDE  result<LONG>",documentation:"The `QDIVIDE` function divides a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of dividing them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from division *q* by *r*\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QDIVIDE"},{name:"QMULTIPLY",detail:"q<LONG> r<LONG>  QMULTIPLY  result<LONG>",documentation:"The `QMULTIPLY` function multiplies a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of multiplying them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from multiplication *q* by *r*\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QMULTIPLY"},{name:"QROTATE",detail:"x<DOUBLE> y<DOUBLE> z<DOUBLE> quaternion<LONG>  QROTATE  x<DOUBLE> y<DOUBLE> z<DOUBLE>",documentation:"Rotates a vector by a [quaternion](https://en.wikipedia.org/wiki/Quaternion).\n\nThe `QROTATE` function consumes on the top of the stack three doubles representing a vector(x, y, z) and a long representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the vector rotated into 3 doubles (x, y, z with z being on top).\n\n@param `quaternion` The quaternion used to rotate the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATE"},{name:"QROTATION",detail:"quaternion<LONG>  QROTATION  x<DOUBLE> y<DOUBLE> z<DOUBLE> angle<DOUBLE>",documentation:"The `QROTATION` extracts the axis and angle of the rotation represented by the [quaternion](https://en.wikipedia.org/wiki/Quaternion) on the stack.\n\n@param `quaternion` The input quaternion\n\n@param `angle` The angle of rotation\n\n@param `x` The X axis\n\n@param `y` The Y axis\n\n@param `z` The Z axis\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATION"},{name:"QUANTIZE",detail:"gts<GTS> bounds<LIST<DOUBLE>> values<LIST>  QUANTIZE  qgts<GTS>\nlgts<LIST<GTS>> bounds<LIST<DOUBLE>> values<LIST>  QUANTIZE  lqgts<LIST<GTS>>",documentation:'The `QUANTIZE` function produces a quantized version of a Geo Time Series™ by replacing each value with a value from a finite list according to the interval the original value falls in. This function only works on numeric Geo Time Series™.\nThis function can help to "discretify" data before calling [`VALUEHISTOGRAM`](/doc/VALUEHISTOGRAM).\nThe list of intervals is defined as: [-∞,bounds<sub>0</sub>], (bounds<sub>0</sub>,bounds_<sub>1</sub>], (bounds<sub>1</sub>,bounds<sub>2</sub>], ..., (bounds<sub>n-1</sub>,+∞]\n\n@param `values` List of `n+1` values, one for each interval defined by `bounds`. If empty, the list `[ `0` `1` ... `n+1` ]` will be used.\n\n@param `bounds` Sorted list of `n` finite bounds defining `n+1` intervals.\n\n@param `gts` Geo Time Series™ to quantize.\n\n@param `qgts` Quantized GTS.\n\n@param `lgts` List of Geo Time Series™ to quantize.\n\n@param `lqgts` List of quantized GTS.\n\n',tags:["gts"],since:"1.0.0",OPB64name:"QUANTIZE"},{name:"RAND",detail:" RAND  num<DOUBLE>",documentation:"The `RAND` function pushes onto the stack a random floating point number between 0.0 (inclusive) and 1.0 (exlusive) generated by the default random generator.\n\nThis generation is cryptographically secure.\n\n@param `num` Generated random number between 0 and 1.\n\n",tags:["math"],since:"1.0.0",OPB64name:"RAND"},{name:"RANDOM",detail:" RANDOM  num<DOUBLE>",documentation:"The `RANDOM` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThis function is very similar to [SRAND](/doc/SRAND) except the seed is choosen pseudorandomly when the function is first called. Subsequent calls use the same generator.\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",tags:["math"],since:"1.2.23",OPB64name:"RANDOM"},{name:"RANDPDF",detail:"valueHistogram<MAP>  RANDPDF  result<STRING>",documentation:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe result if a function pushed onto the stack. This function does not have any arguments.\n\nTo use the function pushed by `RANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",tags:["math","statistics"],since:"1.0.7",OPB64name:"RANDPDF"},{name:"RANGE",detail:"[ end<LONG> ]  RANGE  output<LIST<LONG>>\n[ start<LONG> end<LONG> ]  RANGE  output<LIST<LONG>>\n[ start<LONG> end<LONG> step<LONG> ]  RANGE  output<LIST<LONG>>",documentation:"`RANGE` pushes onto the stack a list of integers in the given range [start included, end excluded[. If start is not in the parameter list, start=0.\n\n`RANGE` also accepts a step parameter in the parameter list.\n\n\n@param `start` The start of range, default is 0\n\n@param `end` The end of range\n\n@param `step` The step between integers, default is 1\n\n@param `output` The list of every integers in the range [start end[\n\n",tags:["counters"],since:"1.0.0",OPB64name:"RANGE"},{name:"RANGECOMPACT",detail:"gts<GTS>  RANGECOMPACT  compacted<GTS>\nlgts<LIST<GTS>>  RANGECOMPACT  lcompacted<LIST<GTS>>",documentation:"The `RANGECOMPACT` simplifies a Geo Time Series™ by simplifying ranges of identical values (with identical latitude, longitude and elevation), retaining only the first and last ticks of each range.\n\n@param `gts` Geo Time Series™ to compact.\n\n@param `compacted` Compacted GTS.\n\n@param `lgts` List of Geo Time Series™ to compact.\n\n@param `lcompacted` List of compacted GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RANGECOMPACT"},{name:"RAWDTW",detail:"gts1<GTS> gts2<GTS> threshold<DOUBLE>  RAWDTW  dtw<DOUBLE>",documentation:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe computation is performed on the raw Geo Time Series™, no transformation is applied to them.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",tags:["gts","distance"],since:"1.2.11",OPB64name:"RAWDTW"},{name:"REDEFS",detail:"flag<BOOLEAN>  REDEFS ",documentation:"The `REDEFS` function allows or disallows execution of redefined functions.\n\n@param `flag` Shall we allow or disallow the execution of redefined functions.\n\n",tags:["stack"],since:"1.2.5",OPB64name:"REDEFS"},{name:"REDUCE",detail:"[ gts<LIST<GTS>+> labels<LIST<STRING>> reducer<AGGREGATOR> ]  REDUCE  result<LIST<GTS>>\n[ gts<LIST<GTS>+> labels<LIST<STRING>> reducer<AGGREGATOR> overrideTick<BOOLEAN> ]  REDUCE  result<LIST<GTS>>",documentation:"The `REDUCE` framework groups Geo Time Series™ by equivalence classes based on label values and applies a function on each equivalence class of Geo Time Series™, considering the values of each tick and producing one GTS per equivalence class.\n\nAs the selected reducer function is applied tick by tick, it is usually wise to [`BUCKETIZE`](/doc/BUCKETIZE) the GTS first with a common value of `lastbucket`.\n\nThe labels whose values are common to all the GTS in an equivalence class will be retained.\n\nSince 2.1 you can make REDUCE override the GTSs ticks. This usage in mainly to be used in conjuction with [`MACROREDUCER`](/doc/MACROREDUCER).\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` List of resulting Geo Time Series™.\n\n@param `overrideTick` Boolean, if true allows the reducer to modify the ticks of the GTSs. If not set, the reducer cannot modify the ticks.\n\n",tags:["reducer","framework"],since:"1.0.0",OPB64name:"REDUCE"},{name:"RELABEL",detail:"gts<GTS> labels<MAP>  RELABEL  gts<GTS>\nlgts<LIST<GTS>> labels<MAP>  RELABEL  lgts<LIST<GTS>>\nencoder<GTSENCODER> labels<MAP>  RELABEL  encoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> labels<MAP>  RELABEL  lencoder<LIST<GTSENCODER>>",documentation:"Modifies the labels of a Geo Time Series™. The `RELABEL` function expects a parameter MAP whose entries are labels to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `RELABEL` function will use the rest of the MAP as the actual labels to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing labels.\n\nAn entry with an empty STRING value or a NULL value will have the effect of removing the label from the GTS' labels.        \n\n@param `labels` Parameter map of label names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `encoder` Encoder to relabel\n\n@param `lencoder` List of encoders to relabel\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RELABEL"},{name:"REMOVE",detail:"inputlist<LIST> index<LONG>  REMOVE  outputlist<LIST> removeditem<ANY>\ninputmap<MAP> key<ANY>  REMOVE  outputmap<MAP> removeditem<ANY>\ninputgts<GTS> pointindex<LONG>  REMOVE  outputgts<GTS> removedpoint<LIST>",documentation:"Removes an entry from a MAP or from a LIST.\n\nThe `REMOVE` function consumes a list (or a map) and a index (or a key), then remove the entry.\nIt lets the input on the stack and puts the removed item on top of the stack. \nAs a result, the input map or list is modified and the map or list left on top of the stack is *not* a copy. \n\nIf the index is out of bound, the returned value is `NULL` and the list or array is unmodified.\nIf the key does not exist in the map, it returns null as the removed entry.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **GTS**.\n\nSince 2.7, `REMOVE` can be called on a **GTS**.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean\n\n@param `inputmap` The reference to the map to be modified\n\n@param `index` The index of the list, 0 for the first item\n\n@param `inputlist` The reference to the list to be modified\n\n@param `removeditem` Depending on map or list content, could be any type\n\n@param `outputmap` The input map modified\n\n@param `outputlist` The input list modified\n\n@param `pointindex` Index of the point in the GTS, 0-indexed, handles negative indexing.\n\n@param `inputgts` The GTS to remove the point from.\n\n@param `removedpoint` The removed point. List of timestamp, latitude, longitude, elevation and value.\n\n@param `outputgts` The acopy of the original GTS with the requested point removed.\n\n",tags:["maps","lists"],since:"1.0.0",OPB64name:"REMOVE"},{name:"REMOVETICK",detail:"gts<GTS> tick<LONG>  REMOVETICK  pruned<GTS>\ngts<GTS> lticks<LIST<LONG>>  REMOVETICK  pruned<GTS>\ngts<GTS> lticks<SET<LONG>>  REMOVETICK  pruned<GTS>",documentation:"The `REMOVETICK` function transforms a Geo Time Series™ by removing all occurrences of a tick or ticks.\n\n@param `tick` Tick (timestamp) to remove.\n\n@param `lticks` List or Set of ticks to remove.\n\n@param `gts` Geo Time Series™ to transform.\n\n@param `pruned` Tranformed Geo Time Series™.\n\n",tags:["gts"],since:"1.2.19",OPB64name:"REMOVETICK"},{name:"RENAME",detail:"gts<GTS> name<STRING>  RENAME  gts<GTS>\nlgts<LIST<GTS>> name<STRING>  RENAME  lgts<LIST<GTS>>\nencoder<GTSENCODER> name<STRING>  RENAME  encoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> name<STRING>  RENAME  lencoder<LIST<GTSENCODER>>",documentation:"The `RENAME` function changes the name of a Geo Time Series™, an Encoder or a list thereof. This operation may be required prior to using some functions. If the name starts with '+', the specified name will be appended to the current name of the GTS or Encoder.\n\nIf you want to rename a Geo Time Series™ or an Encoder so its name starts with a '+', you must first set its name to the empty string then use rename with the desired name prefixed with an additional '+'.\n\n@param `gts` Geo Time Series™ instance to rename.\n\n@param `lgts` List of Geo Time Series™ instances to rename.\n\n@param `encoder` Encoder to rename.\n\n@param `lencoder` Encoder to rename.\n\n@param `name` New name to give to the GTS.\n\n",tags:["gts","encoder"],since:"1.0.0",OPB64name:"RENAME"},{name:"REOPTALT",detail:"alternatives<LIST<STRING>>  REOPTALT  regexp<STRING>",documentation:"Produces a **R**egular **E**xpression **OPT**imized for **ALT**ernation from a list of STRINGs. Large alternations in regular expressions can lead to excessive backtracking and poor matching performance. In order to mitigate this, the `REOPTALT` function will produce a regular expression from a list of STRINGs which reduces the backtracking thus leading to better matching performance.\n\n@param `alternatives` List of STRINGs which should be used in the alternation.\n\n@param `regexp` Regular expression\n\n",tags:["strings"],since:"1.2.16",OPB64name:"REOPTALT"},{name:"REPLACE",detail:"original<ANY> pattern<ANY> replacement<ANY>  REPLACE  result<STRING>",documentation:"Replaces the first occurrence of a pattern by its substitution.\n\nThe `REPLACE` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with the replaced value if it was found\n\n",tags:["strings"],since:"1.1.0",OPB64name:"REPLACE"},{name:"REPLACEALL",detail:"original<ANY> pattern<ANY> replacement<ANY>  REPLACEALL  result<STRING>",documentation:"Replaces all occurrence of a pattern by its substitution.\n\nThe `REPLACEALL` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with all occurrences of pattern replaced by its value\n\n",tags:["strings"],since:"1.1.0",OPB64name:"REPLACEALL"},{name:"REPORT",detail:"secret<STRING>  REPORT  report<STRING>",documentation:"The `REPORT` function pushes onto the stack a STRING containing configuration and usage informations which can be useful when investigating issues.\n\n@param `secret` Secret configured for using the `REPORT` function.\n\n@param `report` Actual report.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"REPORT"},{name:"RESET",detail:"depth<LONG>  RESET ",documentation:"The `RESET` function resets the stack to the given depth, discarding any items above those 'depth' items.\n\n@param `depth` Depth at which the stack should be reset.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"RESET"},{name:"RESETS",detail:"gts<GTS> decreasingGTS<BOOLEAN>  RESETS  result<GTS>\nlgts<LIST<GTS>> decreasingGTS<BOOLEAN>  RESETS  lresult<LIST<GTS>>",documentation:"The `RESETS` functions transforms a numerical Geo Time Series™, shifting values so no offset (*i.e.* a decrease or increase of values) appears after the operation.\n\nThe parameter to `RESETS` determines if the Geo Time Series should be considered as decreasing instead of increasing.\n\n@param `decreasingGTS` Flag set to `true` to indicate the GTS is decreasing.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `lgts` List of Geo Time Series™ or list thereof to transform.\n\n@param `result` GTS with resets compensated.\n\n@param `lresult` List of GTS with resets compensated.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RESETS"},{name:"RESHAPE",detail:"input<LIST> shape<LIST<LONG>>  RESHAPE  output<LIST>",documentation:"The `RESHAPE` function modifies the shape of a list.\n\nThe new shape is specified using a list of dimensions, the first being the outer dimension. Such a shape can be produced by `SHAPE`.\n\nNote that the number of elements in the array must be compatible with the requested shape, i.e. the product of the dimensions must match the number of elements in the input list.\n\n@param `input` List to reshape.\n\n@param `shape` Shape specification, list of dimensions, the first element being the outer list.\n\n@param `output` Reshaped list.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"RESHAPE"},{name:"RESTORE",detail:"context<CONTEXT>  RESTORE ",documentation:"The `RESTORE` function resets the stack's symbol table to the state recorded in the context passed as parameter.\n\n@param `context` Stack context produced by [`SAVE`](doc/SAVE).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"RESTORE"},{name:"RETHROW",detail:" RETHROW ",documentation:"Inside the *catch* or *finally* macro of a [`TRY`](/doc/TRY), rethrows the last thrown error. If no error was previously thrown, `RETHROW` does nothing.\n\n",tags:["control"],since:"1.2.11",OPB64name:"RETHROW"},{name:"RETURN",detail:" RETURN ",documentation:"Returns immediately from the currently executing macro. If called outside a macro, `RETURN` will stop the execution of the current script, behaving like [`STOP`](/doc/STOP).\n\n",tags:["control"],since:"1.0.0",OPB64name:"RETURN"},{name:"REV",detail:" REV  revision<STRING>",documentation:"The `REV` function pushes onto the stack the revision of the Warp 10 instance.`\n\n@param `revision` Revision of the Warp 10 platform.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"REV"},{name:"REVBITS",detail:"long<LONG>  REVBITS  gnol<LONG>",documentation:"Reverses the order of the bits of a LONG value.\n\n@param `long` LONG value from which to revert the bits.\n\n@param `gnol` LONG value whose bits are in reverse order compared to those of `long`.\n\n",tags:["math"],since:"1.0.0",OPB64name:"REVBITS"},{name:"REVERSE",detail:"originalList<LIST>  REVERSE  reversedObj<LIST>\noriginalString<STRING>  REVERSE  reversedObj<STRING>\noriginalString<BYTES>  REVERSE  reversedObj<BYTES>",documentation:"Reverses the order of the elements of the list or the string.\n\nThe `REVERSE` function inverts the order of the elements of the list or the string on the top of the stack.\nBeware, `REVERSE` do not create a new object. Use [`CLONEREVERSE`](/doc/CLONEREVERSE) if you want to keep input.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n\n@param `originalList` The list to reverse\n\n@param `originalString` The string to reverse\n\n@param `reversedObj` The original object with the elements in reverse order\n\n",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"REVERSE"},{name:"REXEC",detail:"warpscript<STRING> endpoint<STRING>  REXEC  stack<ANY*>",documentation:"The `REXEC` function executes some WarpScript code on a remote Warp 10 instance. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",tags:["extensions","stack"],since:"1.0.8",OPB64name:"REXEC"},{name:"REXECZ",detail:"warpscript<STRING> endpoint<STRING>  REXECZ  stack<ANY*>",documentation:"The `REXECZ` function executes some WarpScript code on a remote Warp 10 instance just like [`REXEC`](/doc/REXEC) does, but compresses the WarpScript code prior to sending it. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",tags:["extensions","stack"],since:"1.2.5",OPB64name:"REXECZ"},{name:"RINT",detail:"value<NUMBER>  RINT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  RINT  lresult<LIST<DOUBLE>>",documentation:"The `RINT` function consumes a numeric parameter from the top of the stack and pushes back the DOUBLE the closest to the parameter and equal to a mathematical integer.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `result` Closest floating-point value to a that is equal to a mathematical integer.\n\n@param `lvalue` List of Numeric values.\n\n@param `lresult` List of closest floating-point values to a that is equal to a mathematical integer.\n\n",tags:["math"],since:"1.0.0",OPB64name:"RINT"},{name:"RLOWESS",detail:"gts<GTS> q<LONG> r<LONG> d<LONG> p<LONG>  RLOWESS  result<GTS>\ngtsList<LIST<GTS>> q<LONG> r<LONG> d<LONG> p<LONG>  RLOWESS  resultList<LIST<GTS>>",documentation:"The `RLOWESS` function applies an iterative smoothing program on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is done via locally weighted regression, and is robust to outliers.\n\n> ### REFERENCE\n>\n> **Cleveland, W. S.** (1979) Robust locally weighted regression and smoothing scatterplots. J. American Statistical Association 74, 829–836.\n> **Cleveland, W. S.** (1981) LOWESS: A program for smoothing scatterplots by robust locally weighted regression. The American Statistician 35, 54.\n\n@param `p` The degree for the polynomial fit of the regression\n\n@param `d` The delta radius (in time units) whithin which the local regression is computed only once (other points are interpolated). For very large datasets, it can be wise to set `d` > 0 to speed up the computations.\n\n@param `r` The number of robustifying iterations. The higher the value of `r`, the better the program is robust to outliers.\n\n@param `q` The bandwidth of the local regression. To obtain a good smoothing, it is advised to choose an odd number of at least 5.\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RLOWESS"},{name:"ROLL",detail:"eltN<ANY> elt2<ANY> elt1<ANY> N<LONG>  ROLL  elt2<ANY> elt1<ANY> eltN<ANY>",documentation:"`ROLL` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element at level *N* to the top of the stack and moving the other elements up one level.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ROLL"},{name:"ROLLD",detail:"eltN<ANY> elt2<ANY> elt1<ANY> N<LONG>  ROLLD  elt1<ANY> eltN<ANY> elt2<ANY>",documentation:"`ROLLD` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element on top of the stack to level *N* and moving the other *N-1* elements down the stack.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ROLLD"},{name:"ROT",detail:"level3<ANY> level2<ANY> top<ANY>  ROT  level2<ANY> top<ANY> level3<ANY>",documentation:"`ROT` cycles through the 3 topmost elements of the stack by moving the element at level 3 to the top of the stack and pushing the other 2 elements up the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n@param `level3` The element at the third level of the stack prior to the function execution\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ROT"},{name:"ROTATIONQ",detail:"x<DOUBLE> y<DOUBLE> z<DOUBLE> angle<DOUBLE>  ROTATIONQ  quaternion<QUATERNION>",documentation:"The `ROTATIONQ` function consumes on the stack 4 doubles representing a rotation vector and pushes back [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long.\n\n@param `quaternion` The quaternion representation\n\n@param `angle` The angle of the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"ROTATIONQ"},{name:"ROUND",detail:"input<NUMBER>  ROUND  output<LONG>",documentation:"The `ROUND` function consumes a numeric parameter from the top of the stack and pushes back the long number the closest to the parameter.\n\n@param `input` Input to round.\n\n@param `output` Input rounded to the nearest Long.\n\n",tags:["math"],since:"1.0.0",OPB64name:"ROUND"},{name:"RSADECRYPT",detail:"cipher<BYTES> key<KEY>  RSADECRYPT  data<BYTES>",documentation:"Decrypts content encrypted with an RSA key.\n\n@param `key` RSA key to use for decryption (a public key if content was encrypted with a private key, a private key otherwise).\n\n@param `cipher` Encrypted data.\n\n@param `data` Cleartext data.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSADECRYPT"},{name:"RSAENCRYPT",detail:"data<BYTES> key<KEY>  RSAENCRYPT  encrypted<BYTES>",documentation:"Encrypts a byte array using an RSA key (either public or private).\n\n@param `key` Instance of the RSA private or public key to use for encryption.\n\n@param `data` Data to encrypt.\n\n@param `encrypted` Ciphered version of `data`.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAENCRYPT"},{name:"RSAGEN",detail:"publicExponent<LONG> keylen<LONG>  RSAGEN  privkeyparams<MAP> pubkeyparams<MAP>",documentation:"Generates an RSA public key pair.\n\n@param `keylen` Key length in bits.\n\n@param `publicExponent` RSA public exponent, typically 65537.\n\n@param `pubkeyparams` Parameters of the generated RSA public key. Can be converted to a public key using [`RSAPUBLIC`](/doc/RSAPUBLIC).\n\n@param `privkeyparams` Parameters of the generated RSA privsate key. Can be converted to a private key using [`RSAPRIVATE`](/doc/RSAPRIVATE)\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAGEN"},{name:"RSAPRIVATE",detail:"privkeyparams<MAP>  RSAPRIVATE  privkey<KEY>",documentation:"Creates an RSA private key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `privkeyparams` Map of private key parameters.\n\n@param `privkey` RSA private key instance.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPRIVATE"},{name:"RSAPUBLIC",detail:"pubkeyparams<MAP>  RSAPUBLIC  pubkey<KEY>",documentation:"Creates an RSA public key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `pubkeyparams` Map of public key parameters.\n\n@param `pubkey` RSA public key instance.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPUBLIC"},{name:"RSASIGN",detail:"data<BYTES> alg<STRING> privkey<KEY>  RSASIGN  signature<BYTES>",documentation:"Signs a byte array with an RSA private key.\n\n@param `privkey` RSA private key to use for signing.\n\n@param `alg` Name of algorithm to use for computing the data fingerprint. Supported algorithms are those provided by [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `data` Data to sign.\n\n@param `signature` Computed signature.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSASIGN"},{name:"RSAVERIFY",detail:"content<BYTES> signature<BYTES> alg<STRING> pubkey<KEY>  RSAVERIFY  verified<BOOLEAN>",documentation:"The `RSAVERIFY` function verify a signature generated with [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) cryptosystem and a hash algorithm.\n\nAlgorithms are those supported by [BouncyCastle](http://stackoverflow.com/questions/8778531/bouncycastle-does-not-find-algorithms-that-it-provides).\n\n@param `pubkey` RSA public key to use for verifying the signature.\n\n@param `alg` Algorithm used for generating the signature. See [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `signature` Signature to verify.\n\n@param `content` Signed content.\n\n@param `verified` Status of the signature verification.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAVERIFY"},{name:"RSORT",detail:"gts<GTS>  RSORT  result<GTS>\ngtsList<LIST<GTS>>  RSORT  resultList<LIST<GTS>>",documentation:"Sort Geo Time Series™ values (and associated locations/elevations) by reverse order of their ticks (i.e. most recent ticks first).\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RSORT"},{name:"RTFM",detail:" RTFM  url<STRING>",documentation:"The `RTFM` function pushes onto the stack the URL of the Warp 10 documentation, so whenever you are lost you can rapidly retrieve the URL you need to get back on track!\n\n@param `url` URL of the Warp 10 documentation.\n\n",tags:["misc","help"],since:"1.0.7",OPB64name:"RTFM"},{name:"RUN",detail:"macroName<STRING>  RUN \nmacroRegister<LONG>  RUN ",documentation:"The `RUN` function attempts to execute the macro whose name is on top of the stack. It is equivalent to `@macro` if called with `macro` on top of the stack.\n\n@param `macroName` Name of macro to execute, without a leading '@'\n\n@param `macroRegister` Register number in which the macro is stored, without a leading '@'\n\n",tags:["platform"],since:"1.0.0",OPB64name:"RUN"},{name:"RUNNERNONCE",detail:"nonce<STRING>  RUNNERNONCE  time<LONG>",documentation:"The `RUNNERNONCE` function decrypts the content of a runner *nonce* as generated when a script is executed by a Warp 10 runner instance.\n\nWhen a script is executed by a runner instance, the following symbols are defined when the script is invoked:\n\n| Symbol | Description |\n| --- | --- |\n| `runner.periodicity` | Periodicity at which the script is supposed to run, in ms. |\n| `runner.path` | Path of the script. |\n| `runner.scheduledat` | Time at which the current execution was scheduled, in ms since the [UNIX Epoch](). |\n| `runner.nonce` | Encrypted time of execution, in time units since the [UNIX Epoch](). |\n\nNote that if the runner pre-shared key is not configured via `runner.psk`, the `RUNNERNONCE` function will push `NULL` onto the stack. Note that in this case, the `runner.nonce` symbol will not be defined.\n\n@param `nonce` Runner *nonce* as stored in `runner.nonce`.\n\n@param `time` Time retrieved from the *nonce*.\n\n",tags:["stack"],since:"1.2.7",OPB64name:"RUNNERNONCE"},{name:"RUNR",detail:" RUNR ",documentation:"Run the macro currently contained in the designated register.\n\nThe `RUNR` function is really a family of functions named `RUNRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n",tags:["maps"],since:"2.7.0",OPB64name:"RUNR"},{name:"RVALUESORT",detail:"gts<GTS>  RVALUESORT  result<GTS>\ngtsList<LIST<GTS>>  RVALUESORT  resultList<LIST<GTS>>",documentation:"Sort Geo Time Series™ values (and associated locations/elevations) by by reverse order of their values.\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RVALUESORT"},{name:"SAVE",detail:" SAVE  context<CONTEXT>",documentation:"The `SAVE` function pushes onto the stack a *context* object which contains all the symbols currently defined in the current stack. This context can be passed as a parameter to the [`RESTORE`](doc/RESTORE) function to later reset the symbol table to the state store in the context. Any symbol created after the context was saved and before it is restored will be discarded when `RESTORE` is called.\n\n@param `context` Stack context, suitable as a parameter to [`RESTORE`](doc/RESTORE).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"SAVE"},{name:"SCALB",detail:"d<NUMBER> scaleFactor<LONG>  SCALB  result<TYPE>",documentation:'The `SCALB` function consumes a scale factor *scaleFactor* and a numeric parameter *d* and pushes back <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo>&#xD7;</mo><msup><mn>2</mn><mi>scaleFactor</mi></msup></math>. The scale factor must fit into an INT.\n\n@param `scaleFactor` The scaling factor, must fit into an INT\n\n@param `d` The value to be scaled\n\n@param `result` The scaled value\n\n',tags:["math"],since:"1.2.23",OPB64name:"SCALB"},{name:"SECTION",detail:"section<STRING>  SECTION ",documentation:"The `SECTION` function modifies the value of the *section* attribute of the stack. This value appears in the error messages and can therefore help you debug your WarpScript code. Typically, the `SECTION` function is used to separate your code in different logical units.\n\n@param `section` Name to assign to the *section* attribute.\n\n",tags:["stack","debug"],since:"1.2.7",OPB64name:"SECTION"},{name:"SECURE",detail:"script<STRING>  SECURE  encrypted<STRING>",documentation:"The `SECURE` function encrypts a STRING representing a WarpScript code fragment using the platform's secure script cryptographic key and the current secret set via [`SECUREKEY`](doc/SECUREKEY).\n\nSecure scripts can also be created using the `<S .... S>` syntax.\n\n@param `script` Cleartext version of the WarpScript fragment to encrypt.\n\n@param `encrypted` Encrypted secure script.\n\n",tags:["crypto","stack"],since:"1.2.11",OPB64name:"SECURE"},{name:"SECUREKEY",detail:"key<STRING>  SECUREKEY ",documentation:"The `SECUREKEY` function sets the secret which will be used to decrypt further secure scripts.\n\nSecure scripts are WarpScript fragments which are encrypted with a cryptographic key specific to the platform they were created on. They can be executed on a platform configured with the same cryptographic key.\n\n@param `key` Secret to use for unlocking the cleartext versions of future secure scripts.\n\n",tags:["crypto","stack"],since:"1.0.0",OPB64name:"SECUREKEY"},{name:"SENSISION.DUMP",detail:"valueTimestamp<BOOLEAN>  SENSISION.DUMP  dump<STRING>",documentation:"The `SENSISION.DUMP` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) metrics in the JVM.\n\nThe STRING produced by `SENSISION.DUMP` can be parsed using `PARSE`.\n\n@param `valueTimestamp` Flag indicating whether to dump the Geo Time Series™ with the timestamp of last updates or the timestamp at which the value is read.\n\n@param `dump` Latest values of all Geo Time Series™ known to Sensision in Geo Time Series™ output input.\n\n",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMP"},{name:"SENSISION.DUMPEVENTS",detail:" SENSISION.DUMPEVENTS  dump<STRING>",documentation:"The `SENSISION.DUMPEVENTS` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) events in the events history.\n\nThe STRING produced by `SENSISION.DUMPEVENTS` can be parsed using `PARSE`.\n\nNote that if the system property `sensision.events.history` is not set to a value greater than 0, the function will always return an empty STRING.\n\nThe Sensision event history is a circular buffer.\n\n@param `dump` Latest values of all events in the Sensision event history.\n\n",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMPEVENTS"},{name:"SENSISION.EVENT",detail:"[ value<LONG> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<STRING> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<BOOLEAN> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<LONG> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT \n[ value<DOUBLE> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT \n[ value<STRING> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT \n[ value<BOOLEAN> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT ",documentation:"The `SENSISION.EVENT` function creates a [Sensision](https://github.com/senx/sensision) event.\n\n@param `class` Name of the class of the Sensision event to emit.\n\n@param `labels` Map of label names to values, both STRINGs of the Sensision event.\n\n@param `value` Value associated with the event.\n\n@param `ts` Optional timestamp for the event (in Sensision time units), if omitted, the current timestamp will be used.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.EVENT"},{name:"SENSISION.GET",detail:"selector<STRING>  SENSISION.GET  gts<GTS>\nclass<STRING> labels<MAP>  SENSISION.GET  gts<GTS>",documentation:"The `SENSISION.GET` function reads the current value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to read.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to read.\n\n@param `selector` Geo Time Series™ selector (`class{labels}`) of the Sensision metric to read.\n\n@param `gts` A Geo Time Series™ containing the current value of the Sensision metric. If the metric does not exist, the resulting GTS will be empty.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.GET"},{name:"SENSISION.SET",detail:"[ value<LONG> labels<MAP> class<STRING> ]  SENSISION.SET \n[ value<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.SET \n[ value<STRING> labels<MAP> class<STRING> ]  SENSISION.SET \n[ value<BOOLEAN> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<LONG> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<STRING> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<BOOLEAN> labels<MAP> class<STRING> ]  SENSISION.SET ",documentation:"The `SENSISION.SET` function sets a value for a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `value` Value to assign to the Sensision metric.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.SET"},{name:"SENSISION.UPDATE",detail:"[ delta<LONG> labels<MAP> class<STRING> ]  SENSISION.UPDATE \n[ delta<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.UPDATE \n[ ttl<LONG> delta<LONG> labels<MAP> class<STRING> ]  SENSISION.UPDATE \n[ ttl<LONG> delta<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.UPDATE ",documentation:"The `SENSISION.UPDATE` function updates the numerical value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `delta` Delta to add to the current value of the Sensision metric. If the metric does not exist it will be created with this value.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.UPDATE"},{name:"SET",detail:"inputlist<LIST> item<ANY> index<LONG>  SET  outputlist<LIST>\ninputlist<LIST> item<ANY> index<LIST>  SET  outputlist<LIST>\narray<BYTES> bytevalue<LONG> index<LONG>  SET  outputarray<LIST>",documentation:"The `SET` function replaces item at specified index in a list.\nIf the index is greater than the size of the list, it will raise an error.\n\nWhen used on a **BYTE ARRAY**, SET replaces the byte by the byte value. The byte value, signed or not, must be in the range of [-128,255].\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, SET can set an element in a nested list. In this case, the index is a list.\n\n@param `index` The index in the list, 0 for the first item.\n\n@param `inputlist` The input list to modified.\n\n@param `outputlist` The input list modified,  this is not a new list object.\n\n@param `item` The item to update in the inputlist at index, could be any type.\n\n@param `array` Byte array to which write a byte.\n\n@param `bytevalue` The value of the byte, signed or unsigned (from -128 to 255).\n\n@param `outputarray` The input byte array modified, this is not a new byte array.\n\n",tags:["lists","binary"],since:"1.0.0",OPB64name:"SET"},{name:"SET->",detail:"input<SET>  SET->  output<LIST>",documentation:"The `SET->` function converts the set on top of the stack into a **LIST**.\n\n@param `input` Input set.\n\n@param `output` A list containing input elements.\n\n",tags:["sets"],since:"1.0.0",OPB64name:"JoKJAIs"},{name:"SETATTRIBUTES",detail:"gts<GTS> attributes<MAP>  SETATTRIBUTES  gts<GTS>\nlgts<LIST<GTS>> attributes<MAP>  SETATTRIBUTES  lgts<LIST<GTS>>\nencoder<GTSENCODER> attributes<MAP>  SETATTRIBUTES  encoder<GTSENCODER>\nlencoder<LIST<GTS>> attributes<MAP>  SETATTRIBUTES  lencoder<LIST<GTS>>",documentation:"Modifies the attributes of a Geo Time Series™, an encoder or a list thereof. The `SETATTRIBUTES` function expects a parameter MAP whose entries are attributes to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `SETATTRIBUTES` function will use the rest of the MAP as the actual attributes to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing attributes.\n\nAn entry with an empty STRING value will have the effect of removing the attribute from the attributes of the GTSs or encoders.   \n\n@param `attributes` Parameter map of attributes names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lencoder` List of Encoders.\n\n@param `encoder` Encoder to relabel\n\n",tags:["gts","encoder"],since:"1.0.0",OPB64name:"SETATTRIBUTES"},{name:"SETMACROCONFIG",detail:"value<STRING> key<STRING> secret<STRING>  SETMACROCONFIG ",documentation:"The `SETMACROCONFIG` function allows you to set or modify the value of a configuration key accessible via the [`MACROCONFIG`](/doc/MACROCONFIG) or [`MACROCONFIGDEFAULT`](/doc/MACROCONFIGDEFAULT) functions or via the runner script variable expansion.\n\nThis function can only be used if the `warpscript.macroconfig.secret` is set in the Warp 10™ configuration.\n\nThe configuration keys which can be set using `SETMACROCONFIG` must have the format `key@path/tomacro` or `key@/path/to/runner/script`.\n\nSetting the value of a configuration key to `NULL` has the effect of removing the configuration key altogether.\n\n@param `key` Configuration key to set.\n\n@param `secret` Macro config secret.\n\n@param `value` String value to set for the key or `NULL`.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"SETMACROCONFIG"},{name:"SETVALUE",detail:"gts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<STRING>  SETVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<BOOLEAN>  SETVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<DOUBLE>  SETVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<LONG>  SETVALUE  result<GTS>",documentation:"The `SETVALUE` function adds a value to a GTS or override an existing value. If the tick already exists, this function will overwrite the first one it encounters in the GTS. If the tick does not exist, it is appended. \nThe [`ADDVALUE`](/doc/ADDVALUE) function adds a value to a GTS but do not override an existing value.\n\nThe `SETVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `SETVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, using [`GET`](/doc/GET) for instance.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Serie\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `elevation` Elevation or NaN\n\n@param `result` modified Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"SETVALUE"},{name:"SHA1",detail:"input<BYTES>  SHA1  result<BYTES>",documentation:"The `SHA1` function digests a byte array on the stack with the cryptographic hash function [SHA-1](https://en.wikipedia.org/wiki/SHA-1).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1"},{name:"SHA1HMAC",detail:"message<BYTES> secret<BYTES>  SHA1HMAC  result<BYTES>",documentation:"The `SHA1HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-1](https://en.wikipedia.org/wiki/SHA-1) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1HMAC"},{name:"SHA256",detail:"input<BYTES>  SHA256  result<BYTES>",documentation:"The `SHA256` function digests a byte array on the stack with the cryptographic hash function [SHA-256](https://en.wikipedia.org/wiki/SHA-2).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256"},{name:"SHA256HMAC",detail:"message<BYTES> secret<BYTES>  SHA256HMAC  result<BYTES>",documentation:"The `SHA256HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-256](https://en.wikipedia.org/wiki/SHA-2) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256HMAC"},{name:"SHAPE",detail:"list<LIST>  SHAPE  shape<LIST>\n{ list<LIST> fast<BOOLEAN>  } SHAPE  shape<LIST>",documentation:"Return the shape of an input list if it could be a tensor (or multidimensional array), or raise an Exception.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent and it returns a shape based on the first nested lists at each level. Default to false.\n\n@param `list` The input list.\n\n@param `shape` The shape of the input list.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"SHAPE"},{name:"SHMLOAD",detail:"symbol<STRING>  SHMLOAD  object<ANY>",documentation:"The `SHMLOAD` function loads data previously stored by [`SHMSTORE`](/doc/SHMSTORE) in shared memory, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the requested shared symbol is not known or if the calling script does not currently hold the mutex associated with the symbol.\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to retrieve.\n\n@param `object` Object currently stored under `symbol`.\n\n",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMLOAD"},{name:"SHMSTORE",detail:"object<ANY> symbol<STRING>  SHMSTORE ",documentation:"The `SHMSTORE` function stores an object in a named shared memory location, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the calling script is not currently holding a mutex (in a call to [`MUTEX`](/doc/MUTEX)). The call will have no effect if the named memory location was already set by a previous call to `SHMSTORE`.\n\nIn order to overwrite a shared memory location, its content must first be cleared by storing [`NULL`](/doc/NULL).\n\n\nIf the calling script currently holds a mutex, this mutex will be associated with the shared memory location, the same mutex will have to be held when retrieving the content of the memory location via [`SHMLOAD`](/doc/SHMLOAD).\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to store.\n\n@param `object` Object to store under `symbol` or `NULL` to clear its content.\n\n",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMSTORE"},{name:"SHOW",detail:"levels<LONG>  SHOW ",documentation:"The `SHOW` function makes visible some levels of the stack which were previously hidden by a call to [`HIDE`](/doc/HIDE).\n\nThe levels made visible are the ones closest to the top of the stack. Depending on the `levels` parameter to the call to `SHOW`, the revealed levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there are at most a certain number ((*abs(`levels`)*) with `levels` < 0) of visible levels after the call.\n\nWhen called with `NULL` as parameter, `SHOW` wil reveal all levels currently hidden.\n\n@param `levels` Number of levels to reveal, or `NULL` to reveal them all.\n\n",tags:["stack"],since:"2.7.1",OPB64name:"SHOW"},{name:"SHRINK",detail:"gts<GTS> size<LONG>  SHRINK  result<GTS>",documentation:"Shrink the number of values of a Geo Time Series™ to `size`. The oldest values are kept if `size` is non negative. The earliest ones are kept in the other case.\n\nThis function has the side effect of sorting the Geo Time Series™. If the Geo Time Series™ has fewer than `size` values the function raises an error.\n\n@param `size` Size used to shrink the Geo Time Series™\n\n@param `gts` A Geo Time Series™\n\n@param `result` A shrinked Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"SHRINK"},{name:"SHUFFLE",detail:"input<LIST>  SHUFFLE  shuffled<LIST>",documentation:"The `SHUFFLE` function shuffles a list.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `input` The reference of the list to shuffle\n\n@param `shuffled` The original list shuffled, this is not a new list object\n\n",tags:["lists"],since:"2.1.0",OPB64name:"SHUFFLE"},{name:"SIGNUM",detail:"value<NUMBER>  SIGNUM  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SIGNUM  lresult<LIST<DOUBLE>>",documentation:"The `SIGNUM` function consumes a numeric parameter from the top of the stack and pushes back its signum.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Signum, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of signum for each given value, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"SIGNUM"},{name:"SIN",detail:"value<NUMBER>  SIN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SIN  lresult<LIST<DOUBLE>>",documentation:"The `SIN` function consumes a floating point number from the top of the stack and pushes back its sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Sine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of sine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SIN"},{name:"SINGLEEXPONENTIALSMOOTHING",detail:"gts<GTS> alpha<DOUBLE>  SINGLEEXPONENTIALSMOOTHING  result<GTS>",documentation:"The `SINGLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Simple Exponential Smoothing](https://www.otexts.org/fpp/7/1) formula.\n\nIt consumes two parameters from the top of the stack:\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** is pushed onto the stack.\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The smoothed Geo Time Series™\n\n",tags:["gts","statistics"],since:"1.0.0",OPB64name:"SINGLEEXPONENTIALSMOOTHING"},{name:"SINH",detail:"value<NUMBER>  SINH  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SINH  lresult<LIST<DOUBLE>>",documentation:"The `SINH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic sine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic sine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SINH"},{name:"SIZE",detail:"input<LIST>  SIZE  size<LONG>\ninput<MAP>  SIZE  size<LONG>\ninput<GTS>  SIZE  size<LONG>\ninput<STRING>  SIZE  size<LONG>\ninput<BYTES>  SIZE  size<LONG>\ninput<GEOSHAPE>  SIZE  size<LONG>\ninput<GTSENCODER>  SIZE  size<LONG>\ninput<SET>  SIZE  size<LONG>",documentation:"Returns the size of the input parameter.\n\nThe `SIZE` function computes the size of a LIST, MAP, GTS or ENCODER (number of values), STRING, byte array of GEOSHAPE (number of cells).\n\n@param `input` The input parameter\n\n@param `size` The size of the input parameter\n\n",tags:["strings","lists","maps","gts","geo"],since:"1.0.0",OPB64name:"SIZE"},{name:"SKEWNESS",detail:"gts<GTS> bessel<BOOLEAN>  SKEWNESS  skewness<DOUBLE>\nlgts<LIST<GTS>> bessel<BOOLEAN>  SKEWNESS  lskewness<LIST<DOUBLE>>",documentation:"The `SKEWNESS` function computes the [skewness](https://en.wikipedia.org/wiki/Skewness) of a Geo Time Series™.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the skewness.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `skewness` Computed skewness of the Geo Time Series™ instance.\n\n@param `lskewness` List of computed skewness of the Geo Time Series™ instances.\n\n",tags:["statistics","gts"],since:"1.2.13",OPB64name:"SKEWNESS"},{name:"SMARTPARSE",detail:"string<STRING> regexp<STRING>  SMARTPARSE  results<LIST<GTS>>\ngts<GTS> regexp<STRING>  SMARTPARSE  results<LIST<GTS>>\nlgts<LIST<GTS>> regexp<STRING>  SMARTPARSE  lresults<LIST<LIST<GTS>>>",documentation:"The `SMARTPARSE` function parses STRING values, either from a single STRING parameter or from STRING Geo Time Series™, and produces a number of GTS from the parsed data.\n\nThe parsing is done according to a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) which contains [named capturing groups](https://www.regular-expressions.info/named.html) with the Java/.NET syntax, *i.e.* `(?<name>...)`.\n\nThe captured group is interpreted differently based on the syntax of the name.\n\n| Syntax | Interpretation |\n| --- | --- |\n| Lxxx | Captured content is used as the value of label `xxx` |\n| TU | Captured group is interpreted as a timestamp in unit `U` from the [UNIX Epoch](https://en.wikipedia.org/wiki/Unix_time) origin. Valid values for U are `s`, `ms`, `us`, `ns` |\n| lat | Captured group is interpreted as the latitude if another group named `lon` is also present |\n| lon | Captured group is interpreted as the longitude if another group named `lat` is also present |\n| elevU | Captured group is interpreted as the elevation in unit `U`, where `U` can be `m`, `cm`, `mm`, `ft`, `km`, `mi`, `nm` (Nautical Mile). The value is parsed as a DOUBLE and converted to a LONG in `mm` |\n| VTxxx | Captured group is interpreted as a value for a GTS with class `xxx`. The type of the value is determined by the value of `T` which can be `B`(oolean) `S`(tring) `L`(ong) or `D`(ouble) |\n\nThis function is ideally suited for parsing log messages and producing Geo Time Series™ from their content.\n\n@param `regexp` Regular expression to use for parsing. See the function description for the syntax to use.\n\n@param `string` String to parse\n\n@param `results` List of Geo Time Series™ created from the parsed data.\n\n@param `lresults` List of list of GTS created from the parsed data.\n\n@param `gts` STRING valued Geo Time Series™ whose values are to be parsed.\n\n@param `lgts` List of STRING valued GTS whose values are to be parsed.\n\n",tags:["gts","strings"],since:"1.2.13",OPB64name:"SMARTPARSE"},{name:"SNAPSHOT",detail:"stack<ANY*>  SNAPSHOT  snapshot<STRING>",documentation:"The `SNAPSHOT` functions produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOT` was called.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.6",OPB64name:"SNAPSHOT"},{name:"SNAPSHOTALL",detail:"stack<ANY*>  SNAPSHOTALL  snapshot<STRING>",documentation:"The `SNAPSHOTALL` functions acts similarly as [`SNAPSHOT`](/doc/SNAPSHOT) and produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOTALL` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALL"},{name:"SNAPSHOTALLTOMARK",detail:"mark<MARK> stack<ANY*>  SNAPSHOTALLTOMARK  snapshot<STRING>",documentation:"The `SNAPSHOTALLTOMARK` functions acts similarly as [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) and produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTALLTOMARK` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALLTOMARK"},{name:"SNAPSHOTCOPY",detail:"stack<ANY*>  SNAPSHOTCOPY  snapshot<STRING>",documentation:"The `SNAPSHOTCOPY` function behaves like [`SNAPSHOT`](/doc/SNAPSHOT) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPY` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPY"},{name:"SNAPSHOTCOPYALL",detail:"stack<ANY*>  SNAPSHOTCOPYALL  snapshot<STRING>",documentation:"The `SNAPSHOTCOPYALL` function behaves like [`SNAPSHOTALL`](/doc/SNAPSHOTALL) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALL"},{name:"SNAPSHOTCOPYALLTOMARK",detail:"stack<ANY*>  SNAPSHOTCOPYALLTOMARK  snapshot<STRING>",documentation:"The `SNAPSHOTCOPYALLTOMARK` function behaves like [`SNAPSHOTALLTOMARK`](/doc/SNAPSHOTALLTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALLTOMARK"},{name:"SNAPSHOTCOPYN",detail:"stack<ANY*> n<LONG>  SNAPSHOTCOPYN  snapshot<STRING>",documentation:"Performs a [`SNAPSHOTCOPY`](/doc/SNAPSHOTCOPY) on the top *N* elements of the stack.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTCOPYN"},{name:"SNAPSHOTCOPYTOMARK",detail:"stack<ANY*>  SNAPSHOTCOPYTOMARK  snapshot<STRING>",documentation:"The `SNAPSHOTCOPYTOMARK` function behaves like [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYTOMARK"},{name:"SNAPSHOTN",detail:"stack<ANY*> n<LONG>  SNAPSHOTN  snapshot<STRING>",documentation:"Produces a WarpScript code fragment which will regenerate the *N* top levels of the stack. The content of those levels is consumed off the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTN"},{name:"SNAPSHOTTOMARK",detail:"mark<MARK> stack<ANY*>  SNAPSHOTTOMARK  snapshot<STRING>",documentation:"The `SNAPSHOTTOMARK` functions produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTTOMARK` was called.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTTOMARK"},{name:"SORT",detail:"gts<GTS>  SORT  sgts<GTS>\nlgts<LIST<GTS>>  SORT  slist<LIST<GTS>>",documentation:"Sorts a Geo Time Series™ or each GTS of a list of GTS in ascending tick order.\n\n@param `gts` Single Geo Time Series™ instance to sort.\n\n@param `sgts` Sorted Geo Time Series™, this is the same instance as `gts`.\n\n@param `lgts` List of Geo Time Series™ instances to sort.\n\n@param `slist` List of sorted Geo Time Series™. Each instance is the same as the input one.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"SORT"},{name:"SORTBY",detail:"list<LIST> macro<MACRO>  SORTBY  lsorted<LIST>\nmap<MAP> macro<MACRO>  SORTBY  msorted<MAP>",documentation:"The `SORTBY` function sorts a **LIST** or a **MAP** according to a value returned by a macro. The macro must return a value of the same type (LONG, DOUBLE or STRING) for each element.\n\nOnly **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nBefore release `1.2.22`, the `SORTBY` function could only sort lists of Geo Time Series™.\n\nBefore release `2.7.0`, the `SORTBY` function could only sort lists but not maps.\n\n@param `macro` Macro used for sorting, consumes a list element off the stack and produces a LONG, DOUBLE or STRING value.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",tags:["lists","gts"],since:"1.0.11",OPB64name:"SORTBY"},{name:"SORTWITH",detail:"list<LIST> macro<MACRO>  SORTWITH  lsorted<LIST>\nmap<MAP> macro<MACRO>  SORTWITH  msorted<MAP>",documentation:"The `SORTWITH` function sorts a **LIST** or a **MAP** according to a value returned by a comparison macro. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nIn used a on **LIST**, the comparison macro is given 2 elements of the **LIST** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest element in the stack is respectively strictly less than, equal to or strictly more than than the element on the stack.\n\nIn used a on **MAP**, the comparison macro is given 2 entries (key deepest, value shallowest) of the **MAP** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest entry in the stack is respectively strictly less than, equal to or strictly more than than the shallowest entry on the stack.\n\nBefore release `2.7.0`, the `SORTWITH` function could only sort lists but not maps.\n\n@param `macro` Macro used for comparison, must consume two elements of the stack and produces a LONG.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",tags:["lists","gts"],since:"2.2.0",OPB64name:"SORTWITH"},{name:"SPLIT",detail:"s<STRING> delimiter<STRING>  SPLIT  result<LIST<STRING>>",documentation:"The SPLIT function split a string in segments given a delimiter.\n\n\nIt consumes two parameters from the top of the stack: the delimiter and the string to test matching with. The delimiter must be a string of length 1, i.e. only one character.\n\n\nThe function will return a list with all the segments. If delimiter is not found, the output list contains the input string.\n\n@param `delimiter` One character delimiter.\n\n@param `s` The string to split\n\n@param `result` List of strings.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"SPLIT"},{name:"SQRT",detail:"value<NUMBER>  SQRT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SQRT  lresult<LIST<DOUBLE>>",documentation:"The `SQRT` function consumes a numeric parameter from the top of the stack and pushes back its square root.\n\nFor negative numbers, SQRT returns NaN.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Square root of the given value, NaN if it is negative.\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of square root of each given value, NaN if it is negative.\n\n",tags:["math"],since:"1.0.0",OPB64name:"SQRT"},{name:"SRAND",detail:" SRAND  num<DOUBLE>",documentation:"The `SRAND` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThe seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",tags:["math"],since:"1.2.9",OPB64name:"SRAND"},{name:"SRANDPDF",detail:"valueHistogram<MAP>  SRANDPDF  result<STRING>",documentation:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe randomization is seeded. The seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThe result is a function. This function does not have any arguments.\n\nTo use the function pushed by `SRANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",tags:["math","statistics"],since:"2.2.1",OPB64name:"SRANDPDF"},{name:"STACKATTRIBUTE",detail:"name<STRING>  STACKATTRIBUTE  value<ANY>",documentation:"Retrieves the value of a stack attribute.\n\n@param `name` Name of the stack attribute to retrieve.\n\n@param `value` Associated value or null if attribute is not set.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"STACKATTRIBUTE"},{name:"STACKPSSECRET",detail:"newsecret<STRING> secret<STRING>  STACKPSSECRET ",documentation:"Modifies the secret needed for using functions such as `WSPS`, `WSSTOP` and `WSKILL`.\n\nThis function is only useable if a secret was configured using `stackps.secret`.\n\n@param `secret` Current secret for process status operations, initially the value configured via `stackps.secret`.\n\n@param `newsecret` New secret to set for process status operations.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"STACKPSSECRET"},{name:"STACKTOLIST",detail:"stack<ANY*>  STACKTOLIST  list<LIST>",documentation:"Converts the whole stack into a list and pushes this list on top of the stack. The elements are consumed off the stack in the way [`->LIST`](/doc/AItBHKCJ) does it.\n\n@param `stack` Content of the stack.\n\n@param `list` List containing the elements of the stack.\n\n",tags:["stack"],since:"1.0.14",OPB64name:"STACKTOLIST"},{name:"STANDARDIZE",detail:"gts<GTS>  STANDARDIZE  result<GTS>\ngtsList<LIST<GTS>>  STANDARDIZE  resultList<LIST<GTS>>",documentation:"Standardizes a single (or a list of) numeric Geo Time Series™ (i.e. it replaces X by (X-mu)/sd).\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"STANDARDIZE"},{name:"STDERR",detail:"msg<STRING>  STDERR ",documentation:"The `STDERR` function prints text to the standard error stream.\n\nThe `STDERR` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"STDERR"},{name:"STDOUT",detail:"obj<ANY>  STDOUT ",documentation:"The `STDOUT` function prints text to the standard output stream.\n\nThe `STDOUT` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `obj` The object to print. Its `.toString()` method is used to generate the outputed String.\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"STDOUT"},{name:"STL",detail:"gts<GTS> { p<LONG>  } STL  result<GTS>\ngtsList<LIST<GTS>> { p<LONG>  } STL  resultList<LIST<GTS>>",documentation:'The `STL` function applies a Seasonal Trend decomposition on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is based on multiple calls of [`RLOWESS`](/doc/RLOWESS).\n\nThese Geo Time Series™ are the seasonal part and the trend part of the input Geo Time Series™. Their classnames are suffixed with "_seasonal" and "_trend".\n\nThis function can only be applied to [bucketized](/doc/BUCKETIZE) Geo Time Series™ of numeric type.\n\nThe **MAP** parameter must have at least the field `PERIOD`. You can provide additional optional parameters:\n\n## Optional parameters\n### Global\n- `ROBUST` if TRUE, set defaults of number of inner and outer loops to 1 and 15 instead of 2 and 0. Default is FALSE\n- `PRECISION` number of inner loops (a LONG). Default is 2 or 1\n- `ROBUSTNESS` number of outer loops (a LONG). Default is 0 or 15\n\n### Seasonal extract\n- `BANDWIDTH_S` the bandwidth (a LONG) of the local regression. Default is 7\n- `DEGREE_S` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_S` the number of values interpolated instead of estimated. Default is BANDWIDTH_S/10\n\n### Low frequency filtering\n- `BANDWIDTH_L` the bandwidth (a LONG) of the local regression. Default is nextOdd(PERIOD)\n- `DEGREE_L` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_L` the number of values interpolated instead of estimated. Default is BANDWIDTH_L/10\n\n### Trend extract\n- `BANDWIDTH_T` the bandwidth (a LONG) of the local regression. Default is nextOdd(ceiling(1.5*PERIOD/(1-(1.5/BANDWIDTH_S))))\n- `DEGREE_T` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_T` the number of values interpolated instead of estimated. Default is BANDWIDTH_T/10\n\n### Post seasonal smoothing\n- `BANDWIDTH_P` the bandwidth (a LONG) of the local regression. Default is 0 (i.e. no post smoothing)\n- `DEGREE_P` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_P` the number of values interpolated instead of estimated. Default is BANDWIDTH_P/10\n\n### Additional fields\n- `BANDWIDT` value of all BANDWIDTH_X fields that are not set\n- `DEGREE` value of all DEGREE_X fields that are not set\n- `SPEED` value of all SPEED_X fields that are not set\n\n> ### REFERENCE\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `p` The number of buckets that compose a period\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n',tags:["gts","bucketize"],since:"1.0.0",OPB64name:"STL"},{name:"STLESDTEST",detail:"gts<GTS> p<LONG> k<LONG> alpha<DOUBLE> STLOption<MAP>  STLESDTEST  result<LIST<LONG>>\ngts<GTS> p<LONG> k<LONG> alpha<DOUBLE>  STLESDTEST  result<LIST<LONG>>\ngts<GTS> p<LONG> k<LONG> STLOption<MAP>  STLESDTEST  result<LIST<LONG>>\ngts<GTS> p<LONG> k<LONG>  STLESDTEST  result<LIST<LONG>>\ngtsList<LIST<GTS>> p<LONG> k<LONG> alpha<DOUBLE> STLOption<MAP>  STLESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> p<LONG> k<LONG> alpha<DOUBLE>  STLESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> p<LONG> k<LONG> STLOption<MAP>  STLESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> p<LONG> k<LONG>  STLESDTEST  resultList<LIST<LIST<LONG>>>",documentation:'The \'STLESDTEST\' function detects outliers in a Geo Time Series™ (or a **LIST** of Geo Time Series™) which has a seasonal part.\n\nThe seasonal part and the trend part of the Geo Time Series™ are extracted using [`STL`](/doc/STL) decomposition, then an [`ESDTEST`](/doc/ESDTEST) is performed on the remainder.\n\nThis function only applies to [bucketized](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ### References\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n> **Rosner, Bernard (May 1983)**, "Percentage Points for a Generalized ESD Many-Outlier Procedure",Technometrics, 25(2), pp. 165-172.\n\n@param `STLOption` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `p` The number of buckets that compose a period\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `resultList` A **LIST** of ticks corresponding to the outliers\n\n@param `result` A **LIST** of LIST of ticks corresponding to the outliers\n\n',tags:["outlier","gts"],since:"1.0.0",OPB64name:"STLESDTEST"},{name:"STOP",detail:"",documentation:"The `STOP` function stops the current execution by throwing a `WarpScriptStopException`. This means that the current script execution will be aborted unless the call to `STOP` was in a macro invoked via [`TRY`](/doc/TRY).\n\n",tags:["stack","debug"],since:"1.0.0",OPB64name:"STOP"},{name:"STORE",detail:"value<ANY> symbol<STRING>  STORE \nvalue<ANY> register<LONG>  STORE \nvalues<ANY*> symbols<LIST<STRING>>  STORE ",documentation:"The `STORE` function stores a value in a symbol.\n\nSince 2.7, when the list of symbols contains duplicates only the last occurence in the list is assigned to its corresponding value.\n\n@param `symbol` Name of the symbol to modify.\n\n@param `register` Index of the register to modify.\n\n@param `symbols` List of symbols or registers to modify. The last element of the list will contain the top of the stack.\n\n@param `value` Value to store under `symbol`.\n\n@param `values` Multiple values to store in `symbols`.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"STORE"},{name:"STRICTMAPPER",detail:"mapper<AGGREGATOR> min<NUMBER> max<NUMBER>  STRICTMAPPER  wrapped<AGGREGATOR>",documentation:"Wraps a *mapper* in such a way that the mapper will only be called if the number of ticks in the window is in the specified range.\n\nSince 2.1 STRICTMAPPER can also take a timespan definition by inputing negative numbers. Number of ticks and timespan can also be mixed to specify, for instance, more than 2 points but less than 5 seconds.\n\n@param `max` If positive, maximum number of ticks in the window. If negative, maximum timespan of the window.\n\n@param `min` If positive, minimum number of ticks in the window. If negative, minimum timespan of the window.\n\n@param `mapper` Mapper to wrap.\n\n@param `wrapped` Wrapped mapper.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"STRICTMAPPER"},{name:"STRICTPARTITION",detail:"lgts<LIST<GTS>> labels<LIST<STRING>>  STRICTPARTITION  result<MAP>",documentation:"The `STRICTPARTITION` splits a Geo Time Series™ list in equivalence classes based on label values just like [`PARTITION`](/doc/PARTITION) but only retains in each equivalence class key the labels on which the partitioning was done.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels`.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"STRICTPARTITION"},{name:"STRICTREDUCER",detail:"reducer<AGGREGATOR>  STRICTREDUCER  wrapped<AGGREGATOR>",documentation:"Wraps a *reducer* so it is only applied if there are values for all the Geo Time Series™ being reduced.\n\n@param `reducer` Reducer to wrap.\n\n@param `wrapped` Wrapped version of the reducer.\n\n",tags:["reducer"],since:"1.0.6",OPB64name:"STRICTREDUCER"},{name:"STRINGFORMAT",detail:"format<STRING> args<LIST>  STRINGFORMAT  formattedString<STRING>\nformat<STRING> args<LIST> locale<STRING>  STRINGFORMAT  formattedString<STRING>",documentation:"The STRINGFORMAT function format a String in the same ways as Java [String.format](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.util.Locale-java.lang.String-java.lang.Object...-) does.\n\nThis fonction consumes an optional locale in [ISO 639](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry), a list of Objects to be used in the format string and a [format string](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax).\n\nIf no locale is specified, it defaults to the default JVM locale.\n\n@param `format` A format string.\n\n@param `args` Arguments referenced by the format specifiers in the format string.\n\n@param `locale` The locale to apply during formatting.\n\n@param `formattedString` A formatted string.\n\n",tags:["strings"],since:"2.2.0",OPB64name:"STRINGFORMAT"},{name:"STU",detail:" STU  numberTimeUnits<LONG>",documentation:"The `STU` function pushes onto the stack the number of platform time units in one second. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one second.\n\n",tags:["date","time","platform"],since:"1.0.0",OPB64name:"STU"},{name:"SUBLIST",detail:"base<LIST<ANY>> arguments<LIST<LONG>>  SUBLIST  result<LIST<ANY>>\nbase<LIST<ANY>> start<NUMBER>  SUBLIST  result<LIST<ANY>>\nbase<LIST<ANY>> start<NUMBER> end<NUMBER>  SUBLIST  result<LIST<ANY>>\nbase<LIST<ANY>> start<NUMBER> end<NUMBER> step<NUMBER>  SUBLIST  result<LIST<ANY>>",documentation:"It creates a new list with the elements of the base list whose indices are in the argument list.\n\nIf the argument list contains two indices [a,b] then `SUBLIST` returns the list of elements from index a to index b (included). If the argument list contains more than two indices, the result of `SUBLIST` contains all the elements at the specified indices, with possible duplicates.\n\nNegative indexing is allowed, with negative index effectively refering to index + size.\n\nSince 2.1 a new signature allowing the step to be defined has been introduced. Instead of specifying a list has range, you can put the start, end (optional) and step (optional) as **LONG** values.\n\n@param `arguments` List of indices. Negative indices are considered to be calculated from the end of the list.\n\n@param `base` Base list\n\n@param `result` Filtred list\n\n@param `start` The first index to consider, will be included.\n\n@param `end` The last index to consider, will be included. If not specified, defaults to -1.\n\n@param `step` The delta between two consecutive indexes to consider. If end is after start in the list, step must be strictly positive. If start is after end in the list, step must be strictly negative. If not specified, defaults to 1 or -1 depending on start and end.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"SUBLIST"},{name:"SUBMAP",detail:"base<MAP> arguments<LIST<STRING>>  SUBMAP  result<MAP>",documentation:"It creates a new map with the key-value pairs from the base map whose keys are in the argument list.\n\n@param `arguments` List of indices.\n\n@param `base` Base map\n\n@param `result` Filtred map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"SUBMAP"},{name:"SUBSTRING",detail:"str<STRING> start<LONG> len<LONG>  SUBSTRING  substr<STRING>\nstr<STRING> start<LONG>  SUBSTRING  substr<STRING>\narray<BYTES> start<LONG> len<LONG>  SUBSTRING  subarray<BYTES>\narray<BYTES> start<LONG>  SUBSTRING  subarray<BYTES>",documentation:"Extract a substring from a **STRING** input, or a subarray from a **BYTE ARRAY** input.  \nIf the length is ommitted, it extracts until the end of the string or byte array. If length is greater than max length, extract stops at the input end.\n\nIf the start is greater than the input size, `SUBSTRING` raises an error.\n\nSince 2.1, the start index can be negative. In this case the effective index is index + size of the **STRING**.\n\n@param `len` Length of substring to extract.\n\n@param `start` First character to include in the substring (0 based).\n\n@param `str` String from which to extract a substring.\n\n@param `substr` Extracted substring.\n\n@param `array` Byte array from which to extract a sub array.\n\n@param `subarray` Extracted sub array.\n\n",tags:["strings","binary"],since:"1.0.0",OPB64name:"SUBSTRING"},{name:"SUBTRACTEXACT",detail:"x<NUMBER> y<NUMBER>  SUBTRACTEXACT  diff<LONG>\nlist<LIST<NUMBER>>  SUBTRACTEXACT  sdiff<LONG>\nlx<LIST<NUMBER>> y<NUMBER>  SUBTRACTEXACT  ldiff<LIST<LONG>>",documentation:"The `SUBTRACTEXACT` function consumes two LONGs from the top of the stack and puts back the difference between them. If the difference overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `diff` The difference of x and y\n\n@param `list` List of numeric values\n\n@param `sdiff` The first element of the list minus all the others\n\n@param `lx` List of numeric values\n\n@param `ldiff` List of **LONG** where each value is the difference of y and an element in lx\n\n",tags:["math"],since:"1.2.23",OPB64name:"SUBTRACTEXACT"},{name:"SWAP",detail:"level2<ANY> top<ANY>  SWAP  top<ANY> level2<ANY>",documentation:"Exchanges the positions of the top two elements of the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n",tags:["stack"],since:"1.0.0",OPB64name:"SWAP"},{name:"SWITCH",detail:"cond1<MACRO> exec1<MACRO> condn<MACRO> execn<MACRO> default<MACRO> n<LONG>  SWITCH ",documentation:"Performs a [switch statement](https://en.wikipedia.org/wiki/Switch_statement) allowing to select a macro execution based on a series of condition macros or to fallback on to the execution of a default macro.\n\n@param `n` Number of cases to consider. The `SWITCH` function will expect `n` pairs of condition/execution macros plus a default macro on the stack.\n\n@param `default` Macro which will be executed if all condition macros returned false.\n\n@param `cond1` First condition macro. All condition macros are expected to push a boolean on the stack.\n\n@param `condn` `n`th condition macro.\n\n@param `exec1` First execution macro, this macro will be executed if `cond1` left `true` on the stack.\n\n@param `execn` `n`th execution macro.\n\n",tags:["control"],since:"1.0.0",OPB64name:"SWITCH"},{name:"SYMBOLS",detail:" SYMBOLS  symbols<LIST>",documentation:"The `SYMBOLS` function outputs the list of all defined symbols.\n\n@param `symbols` The list of the names of all defined symbols.\n\n",tags:["stack"],since:"2.2.1",OPB64name:"SYMBOLS"},{name:"SYNC",detail:"macro<MACRO>  SYNC ",documentation:"Executes a macro in a synchronized way while in a parallel execution triggered by a call to [`CEVAL`](/doc/CEVAL). If `SYNC` is called outside of a parallel execution, it simply executes the macro.\n\nWhen called within a `CEVAL` execution, the use of `SYNC` guarantees that only one of the concurrently executing threads will execute the specified macro at any given time.\n\n@param `macro` Macro to execute in a synchronized way.\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"SYNC"},{name:"T",detail:" T  b<BOOLEAN>",documentation:"`T` stand for `true`. It is a boolean constant.\n\n\n@param `b` true\n\n",tags:["logic","constants"],since:"1.0.0",OPB64name:"T"},{name:"TAN",detail:"value<NUMBER>  TAN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  TAN  lresult<LIST<DOUBLE>>",documentation:"The `TAN` function consumes a floating point number from the top of the stack and pushes back its tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Tangent of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of tangent of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TAN"},{name:"TANH",detail:"value<NUMBER>  TANH  result<DOUBLE>\nlvalue<LIST<NUMBER>>  TANH  lresult<LIST<DOUBLE>>",documentation:"The `TANH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic tangent of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic tangent of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TANH"},{name:"TDESCRIBE",detail:"object<ANY>  TDESCRIBE  description<STRING>",documentation:"The `TDESCRIBE` function is a recursive [`TYPEOF`](/doc/TYPEOF).\n\nWhen `TDESCRIBE` finds a LIST, it takes the first element of the list to look for his type. When `TDESCRIBE` finds a MAP, it takes a random key in the map to look for the type of the key and the type of the value.\n\n**By design, TDESCRIBE cannot describe heterogeneous lists or maps.**\n\nTDESCRIBE output is subject to change in the future. Do not try to parse it. This function is here to help you during Warpscript development.\n\n\nThe `TDESCRIBE` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `object` Any kind of reference\n\n@param `description` The description of the object\n\n",tags:["extensions","debug"],since:"1.2.19",OPB64name:"TDESCRIBE"},{name:"TEMPLATE",detail:"template<STRING> dictionnary<MAP>  TEMPLATE  output<STRING>\ntemplate<STRING> listofmaps<LIST<MAP>>  TEMPLATE  output<STRING>",documentation:"`TEMPLATE` fills a template with values contained in a map. See example for syntax help.\n\nThe `TEMPLATE` function expects the map of values on top of the stack and will operate on the string template below it.\n\nValues speficied with `{{key}}` will be url-escaped. If you do not want that behavior, use `{{{key}}}`.\n\n@param `dictionnary` Each key will be replaced in a {{key}} template. Value could be string long, double, boolean, or a list of maps. If Value is a list of maps, each subkey/value will be replaced in a {{#key}}{{subkey}}{{/key}} template. \n\n@param `listofmaps` Contains a list of subkey/value map. Will be replaced in a {{#key}}{{subkey}}{{/key}} template.\n\n@param `template` Input template.\n\n@param `output` Result of substitution.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TEMPLATE"},{name:"THRESHOLDTEST",detail:"gts<GTS> threshold<DOUBLE>  THRESHOLDTEST  ticks<LIST<LONG>>\nlgts<LIST<GTS>> threshold<DOUBLE>  THRESHOLDTEST  lticks<LIST<LIST<LONG>>>",documentation:"Analyzes Geo Time Series™, identifying ticks where values are outliers above the given threshold.\n\n@param `threshold` Threshold above which values are considered outliers.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `ticks` List of ticks where outliers were found.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lticks` List of lists of ticks where outliers were found.\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"THRESHOLDTEST"},{name:"TICKINDEX",detail:"gts<GTS>  TICKINDEX  indexed<GTS>\nlgts<LIST<GTS>>  TICKINDEX  lindexed<LIST<GTS>>\nencoder<GTSENCODER>  TICKINDEX  indexedenc<GTSENCODER>\nlencoder<LIST<GTSENCODER>>  TICKINDEX  lindexedenc<LIST<GTSENCODER>>",documentation:"Creates a clone of a Geo Time Series™, replacing each tick with the index (0 based) at which it appears at the moment of the call.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `encoder` Geo Time Series™ Encoder instance to transform.\n\n@param `indexed` Transformed GTS.\n\n@param `indexedenc` Transformed GTS Encoder.\n\n@param `lgts` List of Geo Time Series™ instances to transform.\n\n@param `lencoder` List of Geo Time Series™ Encoder instances to transform.\n\n@param `lindexed` List of indexed Geo Time Series™.\n\n@param `lindexedenc` List of indexed Geo Time Series™ Encoder.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TICKINDEX"},{name:"TICKLIST",detail:"gts<GTS>  TICKLIST  ticks<LIST<LONG>>\nlgts<LIST<GTS>>  TICKLIST  lticks<LIST<LIST<LONG>>>\nencoder<GTSENCODER>  TICKLIST  ticks<LIST<LONG>>\nlencoder<LIST<GTSENCODER>>  TICKLIST  lticks<LIST<LIST<LONG>>>",documentation:"Pushes onto the stack the list of ticks of a Geo Time Series™ or encoder. The ticks appear in the order in which they are found.\n\nIf a list of Geo Time Series™ is given, the result is a list of list of ticks as if the TICKLIST function was applied to each Geo Time Series™ separately.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n@param `encoder` Instance of encoder from which to extract the ticks.\n\n@param `lencoder` List of encoders.\n\n@param `ticks` List of extracted ticks.\n\n@param `lticks` List of lists of ticks.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TICKLIST"},{name:"TICKS",detail:"gts<GTS>  TICKS  ticks<LIST<LONG>>\nlgts<LIST<GTS>>  TICKS  ticks<LIST<LONG>>",documentation:"Pushes onto the stack the sorted list of **distinct** ticks of a Geo Time Series™. If a list of Geo Time Series™ is given, all the **distinct** ticks are returned in a single sorted list as if all Geo Time Series™ were merged.\n\nThis function is not to be confused with [`TICKLIST`](/doc/TICKLIST) as this function returns **distinct** ticks and acts as it merges Geo Time Series™.\n\n@param `ticks` List of extracted ticks.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TICKS"},{name:"TIMEBOX",detail:"macro<MACRO> maxtime<LONG>  TIMEBOX ",documentation:"The `TIMEBOX` executes a macro with a maximum execution time. If the maximum time is reached, an exception will be thrown which can be caught using [`TRY`](/doc/TRY).\n\n@param `maxtime` Maximum execution time, in platform time units.\n\n@param `macro` Macro to execute.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"TIMEBOX"},{name:"TIMECLIP",detail:"gts<GTS> end<LONG> duration<LONG>  TIMECLIP  clipped<GTS>\nlgts<LIST<GTS>> end<LONG> duration<LONG>  TIMECLIP  lclipped<LIST<GTS>>\ngts<GTS> stop<STRING> start<STRING>  TIMECLIP  clipped<GTS>\nlgts<LIST<GTS>> stop<STRING> start<STRING>  TIMECLIP  lclipped<LIST<GTS>>\nencoder<GTSENCODER> end<LONG> duration<LONG>  TIMECLIP  clippedEncoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> end<LONG> duration<LONG>  TIMECLIP  lclippedEncoders<LIST<GTSENCODER>>\nencoder<GTSENCODER> stop<STRING> start<STRING>  TIMECLIP  clippedEncoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> stop<STRING> start<STRING>  TIMECLIP  lclippedEncoders<LIST<GTSENCODER>>",documentation:"Clips Geo Time Series™ instances by restricting their ticks to those within a time interval.      \n\n@param `duration` Width of the time interval to retain, in time units.\n\n@param `end` Most recent timestamp to retain.\n\n@param `start` Start timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `stop` End timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `clipped` Clipped Geo Time Series™.\n\n@param `lclipped` List of clipped GTS.\n\n@param `encoder` Single GTS Encoder instance.\n\n@param `lencoder` List of GTS Encoder instances.\n\n@param `clippedEncoder` Clipped GST encoder.\n\n@param `lclippedEncoders` List of clipped GTS encoders.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMECLIP"},{name:"TIMED",detail:"macro<MACRO> name<STRING>  TIMED  timedMacro<MACRO>",documentation:"The `TIMED` function converts a macro to a timed macro, recording its execution time and its number of calls.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\n@param `name` A name identifying the macro.\n\n@param `macro` The macro you want to monitor.\n\n@param `timedMacro` A macro which, when called, will update the statitics associated with the given name.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"TIMED"},{name:"TIMEMODULO",detail:"gts<GTS> modulus<LONG> label<STRING>  TIMEMODULO  splits<LIST<GTS>>\nlgts<LIST<GTS>> modulus<LONG> label<STRING>  TIMEMODULO  lsplits<LIST<LIST<GTS>>>",documentation:"Splits Geo Time Series™ into sub-GTS whose timestamps are the original timestamp modulo a given modulus value. Each sub-GTS will bear a label with the quotient of the original timestamps divided by the modulus. The output list order is not guaranteed, use [`SORTBY`](/doc/SORTBY) if you want to order the output by label.\n\nThis function can be used to generate for example one Geo Time Series™ per day with ticks from 0 to 86400 s (excluded).\n\n@param `label` Name of the label which will have the quotient value.\n\n@param `modulus` Value by which to divide the original timestamps.\n\n@param `gts` Geo Time Series™ to split.\n\n@param `splits` Resulting splits.\n\n@param `lgts` List of GTS to split.\n\n@param `lsplits` List of lists of resulting splits.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMEMODULO"},{name:"TIMEOFF",detail:" TIMEOFF ",documentation:"Turns off the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"TIMEOFF"},{name:"TIMEON",detail:" TIMEON ",documentation:"Turns on the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"TIMEON"},{name:"TIMESCALE",detail:"gts<GTS> scale<DOUBLE>  TIMESCALE  scaled<GTS>\ngts<GTS> scale<LONG>  TIMESCALE  scaled<GTS>\nlgts<LIST<GTS>> scale<DOUBLE>  TIMESCALE  lscaled<LIST<GTS>>\nlgts<LIST<GTS>> scale<LONG>  TIMESCALE  lscaled<LIST<GTS>>",documentation:"Modifies the ticks of Geo Time Series™ instances by multiplying each tick by a provided scale.      \n\nThe resulting tick will be converted to a LONG after multiplication by the scale.\n\nIf the Geo Time Series™ instance is bucketized, the `lastbucket` and `bucketspan` parameters will also be scaled. If the scale would incur a `bucketspan` of 0, the call will end with an error.\n\n@param `scale` Scale by which to multiply each tick.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `scaled` Geo Time Series™ result.\n\n@param `lscaled` List of Geo Time Series™ result.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMESCALE"},{name:"TIMESHIFT",detail:"gts<GTS> offset<LONG>  TIMESHIFT  shifted<GTS>\nlgts<LIST<GTS>> offset<LONG>  TIMESHIFT  lshifted<LIST<GTS>>",documentation:"Shifts the ticks of Geo Time Series™ instances by a given amount.\n\n@param `offset` Offset to apply to the ticks, in time units.\n\n@param `gts` Single Geo Time Series™ instance to shift.\n\n@param `lgts` List of GTS to shift.\n\n@param `shifted` Shifted Geo Time Series™.\n\n@param `lshifted` List of shifted Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMESHIFT"},{name:"TIMESPLIT",detail:"gts<GTS> quietperiod<LONG> minvalues<LONG> label<STRING>  TIMESPLIT  splits<LIST<GTS>>\nlgts<LIST<GTS>> quietperiod<LONG> minvalues<LONG> label<STRING>  TIMESPLIT  lsplits<LIST<LIST<GTS>>>",documentation:"The `TIMESPLIT` functions splits Geo Time Series™ instances based on *quiet periods*, *i.e.* periods during which the GTS has no values.\n\nWhenever a quiet period longer than a minimum duration is encountered, the Geo Time Series™ is split.\n\nIf input gts has no values or if 'label' is already part of the labels of 'gts', then the resulting list of GTS will only contain a clone of 'gts'. **Make sure to test your GTS split size if needed.**\n\n@param `label` Name of label in which to store the sequence number.\n\n@param `minvalues` Minimum number of values a split should contain. Splits with less than that many values will be discarded.\n\n@param `quietperiod` Minimum duration of the silent period (*i.e.* with no values) between splits.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMESPLIT"},{name:"TIMINGS",detail:"",documentation:"Turns on the collection of timing information for each line of the script. The collected timings can be put onto the stack by using [`ELAPSED`](/doc/ELAPSED).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"TIMINGS"},{name:"TLTTB",detail:"gts<GTS> samples<LONG>  TLTTB  downsampled<GTS>\nlgts<LIST<GTS>> samples<LONG>  TLTTB  ldownsampled<LIST<GTS>>",documentation:"The `TLTTB` function performs downsampling of Geo Time Series™ by applying the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data. It differs from the [`LTTB`](doc/LTTB) function by the fact that it considers time based buckets instead of buckets based on a number of values.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",tags:["gts"],since:"1.0.11",OPB64name:"TLTTB"},{name:"TOBIN",detail:"param<LONG>  TOBIN  result<STRING>",documentation:"Converts the long on top of the stack to its 64 bits binary representation.\n\n@param `param` value to convert\n\n@param `result` String converted binary representation of param\n\n",tags:["conversion","strings","binary"],since:"1.0.0",OPB64name:"TOBIN"},{name:"TOBITS",detail:"number<NUMBER>  TOBITS  bits<LONG>\ngts<GTS>  TOBITS  longgts<GTS>",documentation:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n**Deprecation notice** the `TOBITS` function will be removed, please use `->DOUBLEBITS` or `->FLOATBITS`.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",tags:["math","gts"],since:"1.0.0",OPB64name:"TOBITS"},{name:"TOBOOLEAN",detail:"value<BOOLEAN>  TOBOOLEAN  result<BOOLEAN>\nvalue<NUMBER>  TOBOOLEAN  result<BOOLEAN>\nvalue<STRING>  TOBOOLEAN  result<BOOLEAN>",documentation:"Converts a value of primitive type into a boolean value.\n\nThe `TOBOOLEAN` function consumes a parameter from the top of the stack and pushes back its conversion to boolean.\nNumbers will be false if they are equal to 0 and true otherwise.\nStrings will be false if they are equals to '' and true otherwise.\n\n@param `value` The value of primitive type\n\n@param `result` The boolean conversion of the value\n\n",tags:["conversion"],since:"1.0.5",OPB64name:"TOBOOLEAN"},{name:"TODEGREES",detail:"angle<NUMBER>  TODEGREES  result<DOUBLE>\nlangle<LIST<NUMBER>>  TODEGREES  lresult<LIST<DOUBLE>>",documentation:"Converts an angle measured in radians to its equivalent in degrees.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from radians to degrees.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in radian to convert in degree\n\n@param `result` Result of the conversion from radians to degrees\n\n@param `langle` List of angles in radian to convert in degree\n\n@param `lresult` List of results of the conversion from radians to degrees\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TODEGREES"},{name:"TODOUBLE",detail:"value<BOOLEAN>  TODOUBLE  result<DOUBLE>\nvalue<NUMBER>  TODOUBLE  result<DOUBLE>\nvalue<STRING>  TODOUBLE  result<DOUBLE>",documentation:"Converts a value of primitive type into a double value.\n\nThe `TODOUBLE` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to double.\n\n@param `value` The value of primitive type\n\n@param `result` The double conversion of the value\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TODOUBLE"},{name:"TOHEX",detail:"input<LONG>  TOHEX  output<STRING>",documentation:"Converts a long to its 64 bits hexadecimal representation.\n\n@param `input` Signed long integer.\n\n@param `output` Hexadecimal string representation of input.\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TOHEX"},{name:"TOINTEXACT",detail:"value<NUMBER>  TOINTEXACT  result<LONG>\nlvalue<LIST<NUMBER>>  TOINTEXACT  lresult<LIST<LONG>>",documentation:"The `TOINTEXACT` function consumes one LONG from the top of the stack and puts back the value. If the result overflows an INT, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be checked not to overflow an INT\n\n@param `result` The given value, converted to Long\n\n@param `lvalue` List of values to be checked not to overflow an INT\n\n@param `lresult` List of given values, converted to Long\n\n",tags:["math"],since:"1.2.23",OPB64name:"TOINTEXACT"},{name:"TOKENDUMP",detail:"token<STRING>  TOKENDUMP  map<MAP>\ntoken<STRING> secret<STRING>  TOKENDUMP  map<MAP>",documentation:"Deciphers a token and outputs a map describing the various elements of the token.\n\nThe map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Original token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| params | MAP | Map of token parameters, can be used as input to [`TOKENGEN`](/doc/TOKENGEN) |\n\nThe `params` map contains the following entries for both `READ` and `WRITE` tokens:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| type  | STRING | `READ` or `WRITE` depending on the type of token |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in ms since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in ms since the Unix Epoch |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nAdditionally, for `READ` tokens, the map contains those entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, those will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nNote that the `TOKENDUMP` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration key was not set.\n\n\n@param `token` Token to decode.\n\n@param `map` Map with the extracted parameters, the original token and its *ident*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENDUMP` from Worf.\n\n",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENDUMP"},{name:"TOKENGEN",detail:"params<MAP>  TOKENGEN  result<MAP>\nparams<MAP> secret<STRING>  TOKENGEN  result<MAP>",documentation:"Generates a token given a map of parameters. The `TOKENGEN` function outputs a map.\n\nThe input parameter map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| id | STRING | Optional identifier that will be put verbatim in the result map |\n| type  | STRING | `READ` or `WRITE` depending on the type of token to generate |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in **milliseconds** since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in **milliseconds** since the Unix Epoch |\n| ttl | LONG | If `expiry` is not specified, a time to live can be set with this key. The TTL is expressed in **milliseconds**, the computed expiry timestamp will be the issuance timestamp plus the ttl |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nWhen generating a `READ` token, the following parameters are needed to ensure data isolation:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, they will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nIf one of these parameter key is not set or set to an empty list, then the generated `READ` token will be granted access to all the scope associated with the parameter key. For example, if `owners` is not set, data from all owners will be accessible to this token.\n\nThe `TOKENGEN` function outputs a map with the following keys:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Generated token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| id | STRING | Optional identifier if the `id` key was specified in the parameter map |\n\nNote that the `TOKENGEN` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration was not set.\n\n@param `params` Map of parameters used to generate the token.\n\n@param `result` Map containing the token, its *ident* and an optional *id*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENGEN` from Worf.\n\n",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENGEN"},{name:"TOKENINFO",detail:"token<STRING>  TOKENINFO  infos<MAP>",documentation:"Retrieves information from token.\n\nThe `TOKENINFO` function consumes a token from the top of the stack and pushes back a map containing the token information:\n* type: type of token 'Read' or 'Write'\n* issuance: timestamp of token creation, in **milliseconds** since the Unix Epoch \n* expiry: timestamp of token expiration, in **milliseconds** since the Unix Epoch \n* application: name of the application accessing the data\n* apps: list of applications whose data can be accessed (usually limited to a single application)\n\n@param `token` Token to extract informations\n\n@param `infos` Token informations extract from the tokens\n\n",tags:["platform"],since:"1.0.0",OPB64name:"TOKENINFO"},{name:"TOKENSECRET",detail:"newsecret<STRING> secret<STRING>  TOKENSECRET ",documentation:"Modifies the secret needed for using `TOKENGEN` or `TOKENDUMP`.\n\nThis function is only useable if a secret was configured using `token.secret`.\n\n@param `secret` Current secret for token operations, initially the value configured via `token.secret`.\n\n@param `newsecret` New secret to set for token operations.\n\n",tags:["extensions","platform"],since:"2.0.3",OPB64name:"TOKENSECRET"},{name:"TOLONG",detail:"value<BOOLEAN>  TOLONG  result<LONG>\nvalue<NUMBER>  TOLONG  result<LONG>\nvalue<STRING>  TOLONG  result<LONG>\narray<BYTES>  TOLONG  result<LONG>",documentation:"Converts a value of primitive type or a **BYTE ARRAY** into a long value.\n\nThe `TOLONG` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to long.\n\n@param `value` The value of primitive type\n\n@param `result` The long conversion of the value\n\n@param `array` Maximum 8 bytes to convert to a LONG. Sign is kept.\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"TOLONG"},{name:"TOLOWER",detail:"input<STRING>  TOLOWER  output<STRING>",documentation:"Converts the **STRING** on top of the stack to lower case.\n\n@param `input` input string\n\n@param `output` Lower case string\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TOLOWER"},{name:"TORADIANS",detail:"angle<NUMBER>  TORADIANS  result<DOUBLE>\nlangle<LIST<NUMBER>>  TORADIANS  lresult<LIST<DOUBLE>>",documentation:"Converts an angle measured in degrees to its equivalent in radians.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from degrees to radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in degree to convert in radian\n\n@param `result` Result of the conversion from degree to radian\n\n@param `langle` List of angles in degree to convert in radian\n\n@param `lresult` List of results of the conversion from degree to radian\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TORADIANS"},{name:"TOSELECTOR",detail:"gts<GTS>  TOSELECTOR  selector<STRING>\ngtslist<LIST<GTS>>  TOSELECTOR  selectorlist<LIST<STRING>>\nencoder<GTSENCODER>  TOSELECTOR  selector<STRING>\nencoderlist<LIST<GTSENCODER>>  TOSELECTOR  selectorlist<LIST<STRING>>",documentation:"The `TOSELECTOR` function takes a Geo Time Series™ or Geo Time Series™ LIST from the top of the stack and, for each encountered GTS, replace it with a selector which would select it.\n\nThis selector can be used as input of [`PARSESELECTOR`](/doc/PARSESELECTOR) for a [`FETCH`](/doc/FETCH).\n\n@param `gts` The input Geo Time Series™.\n\n@param `gtslist` The input list of Geo Time Series™.\n\n@param `encoder` The input encoder.\n\n@param `encoderlist` The input list of encoders.\n\n@param `selector` The selector string.\n\n@param `selectorlist` The list of selector strings, one per GTS in gtslist.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TOSELECTOR"},{name:"TOSTRING",detail:"value<NUMBER>  TOSTRING  result<STRING>\nvalue<BOOLEAN>  TOSTRING  result<STRING>\nvalue<STRING>  TOSTRING  result<STRING>\nvalue<GTS>  TOSTRING  result<STRING>",documentation:"Converts a value of primitive type into a string value.\n\nThe `TOSTRING` function consumes a parameter from the top of the stack and pushes back its conversion to string.\n\nNote that GTS are converted to input format and that the string ends with CRLF to follow HTTP recommendations.\n\n@param `value` The value of primitive type\n\n@param `result` The string conversion of the value\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"TOSTRING"},{name:"TOTIMESTAMP",detail:"input<STRING>  TOTIMESTAMP  result<LONG>",documentation:"Converts a date in format ISO8601 into a timestamp in the platform's time unit.\n\nThe `TOTIMESTAMP` function consumes a string parameter (date + time + time zone) from the top of the stack and pushes back its conversion to a number of time units since the Unix Epoch.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nThe supported format is ISO8601 and are:\n* yyyy-mm-dddThh:mm:ss.ssssssZ\n* yyyy-mm-dddThh:mm:ss+hh:mm\n\nAs the string are URL encoded, the symbol + have to be replaced by %2B, otherwise a space will replace the + in the string.\n\n@param `input` ISO8601 string.\n\n@param `result` timestamp in the platform unit.\n\n",tags:["conversion","date"],since:"1.0.0",OPB64name:"TOTIMESTAMP"},{name:"TOUPPER",detail:"input<STRING>  TOUPPER  output<STRING>",documentation:"Converts the **STRING** on top of the stack to upper case.\n\n@param `input` input string\n\n@param `output` Upper case string\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TOUPPER"},{name:"TR",detail:"matrix<MATRIX>  TR  trace<DOUBLE>",documentation:"Computes the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a square matrix. If the input matrix is not square, an error is raised.\n\n@param `matrix` The square matrix for which to compute the trace.\n\n@param `trace` The computed trace.\n\n",tags:["math"],since:"1.0.6",OPB64name:"TR"},{name:"TRANSPOSE",detail:"matrix<MATRIX>  TRANSPOSE  transpose<MATRIX>",documentation:"Computes the [transpose](https://en.wikipedia.org/wiki/Transpose) of a matrix.\n\n@param `matrix` Matrix to transpose.\n\n@param `transpose` The transpose of the original matrix.\n\n",tags:["math"],since:"1.0.6",OPB64name:"TRANSPOSE"},{name:"TRIM",detail:"str<STRING>  TRIM  trimmedstr<STRING>",documentation:"Trims whitespaces from both ends of the string on top of the stack.\n\n@param `str` String to trim\n\n@param `trimmedstr` String trimmed\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TRIM"},{name:"TRY",detail:"try<MACRO> catch<MACRO> finally<MACRO>  TRY ",documentation:"The `TRY` function provides a way to execute a macro in a safety harness with [Exception handling](https://en.wikipedia.org/wiki/Exception_handling).\n\nIf an error is thrown, it is recorded and will be available via [`ERROR`](/doc/ERROR).\n\n@param `try` Macro whose execution is *attempted*.\n\n@param `catch` Macro which will be executed if an error is encountered while executing the `try` macro.\n\n@param `finally` Macro which will be executed unconditionally after either the `try` or `try`/`catch` execution.\n\n",tags:["control"],since:"1.2.11",OPB64name:"TRY"},{name:"TSELEMENTS",detail:"timestamp<LONG>  TSELEMENTS  dateAndTimeElements<LIST<LONG>>\ntimestamp<LONG> timezone<STRING>  TSELEMENTS  dateAndTimeElements<LIST<LONG>>",documentation:"Alias of [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nThe `TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"TSELEMENTS"},{name:"TSELEMENTS->",detail:"dateAndTimeElements<LIST<LONG>>  TSELEMENTS->  timestamp<LONG>\ndateAndTimeElements<LIST<LONG>> timezone<STRING>  TSELEMENTS->  timestamp<LONG>",documentation:"The `TSELEMENTS->` function consumes an optional **STRING** timezone and a **LIST** of **LONG** describing a time and date and pushes back the **LONG** timestamp. The **LIST** of **LONG** follows the format given by [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",tags:["date","time"],since:"1.2.0",OPB64name:"K4C4I3KCGJtJJmoy"},{name:"TYPEOF",detail:"object<ANY>  TYPEOF  type<STRING>",documentation:"Gets the type of an element.\n\nThe `TYPEOF` function consumes the top element on the stack and pushes back a string containing the type. The output could be:\n+ AGGREGATOR\n+ BITSET\n+ BOOLEAN\n+ BYTES\n+ CONTEXT\n+ COUNTER\n+ DOUBLE\n+ FILLER\n+ FILTER\n+ GEOSHAPE\n+ GTS\n+ GTSENCODER\n+ KEY\n+ LIST\n+ LONG\n+ MACRO\n+ MAP\n+ MARK\n+ MATCHER\n+ MATRIX\n+ NULL\n+ OPERATOR\n+ PFONT\n+ PGRAPHICS\n+ PIMAGE\n+ PSHAPE\n+ REDUCER\n+ SET\n+ STRING\n+ VECTOR\n+ VLIST\n\nFor any object introduced by a WarpScript extension whose output of TYPEOF is not in the list thereof, the output would be preceded by \"X-\".\n\nNote: since revision 2.5.0, the TYPEOF output of bucketizers, mappers, reducers is changed from 'MAPPER' to 'AGGREGATOR'.\n\n\n@param `object` Any kind of reference\n\n@param `type` The type of the object\n\n",tags:["stack","debug"],since:"1.0.0",OPB64name:"TYPEOF"},{name:"UDF",detail:"class<STRING>  UDF ",documentation:"The `UDF` function invokes a User Defined Function from a Jar. A new function instance is loaded at each invocation.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",tags:["control"],since:"1.0.0",OPB64name:"UDF"},{name:"ULP",detail:"value<NUMBER>  ULP  ulp<DOUBLE>\nlvalue<LIST<NUMBER>>  ULP  lulp<LIST<DOUBLE>>",documentation:"Returns the size of the [ULP (Unit in the Last Place)](https://en.wikipedia.org/wiki/Unit_in_the_last_place) for the argument. The ulp for a DOUBLE is the positive distance between this floating-point value and the DOUBLE value next larger in magnitude.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `ulp` Computed ULP.\n\n@param `lvalue` List of numeric values.\n\n@param `lulp` List of computed ULPs.\n\n",tags:["math"],since:"1.0.0",OPB64name:"ULP"},{name:"UNBUCKETIZE",detail:"gts<GTS>  UNBUCKETIZE  gts<GTS>\nlgts<LIST<GTS>>  UNBUCKETIZE  lgts<LIST<GTS>>",documentation:"Transforms a bucketized Geo Time Series™ into a non bucketized one. Note that this function transforms the original GTS, it does not clone it.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™ instances.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"UNBUCKETIZE"},{name:"UNBUCKETIZE.CALENDAR",detail:"gts<GTS>  UNBUCKETIZE.CALENDAR  gts<GTS>\nlgts<LIST<GTS>>  UNBUCKETIZE.CALENDAR  lgts<LIST<GTS>>",documentation:"On a GTS that is calendar-bucketized, this function replaces the ticks with the timestamp end boundaries of each bucket, and unbucketize it.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `lgts` One or more lists of Geo Time Series™\n\n",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"UNBUCKETIZE.CALENDAR"},{name:"UNGZIP",detail:"compressed<BYTES>  UNGZIP  uncompressed<BYTES>",documentation:"Decompresses a byte array containing data compressed by [`GZIP`](doc/GZIP).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",tags:["conversion"],since:"1.0.11",OPB64name:"UNGZIP"},{name:"UNION",detail:"setA<SET> setB<SET>  UNION  output<SET>",documentation:"Computes the union &#x222a; of two sets.\n\nThe `UNION` function consumes two sets from the top of the stack and pushes back its mathematical union.\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x222a; *B*\n\n",tags:["sets"],since:"1.0.0",OPB64name:"UNION"},{name:"UNIQUE",detail:"input<LIST>  UNIQUE  output<LIST>",documentation:"The `UNIQUE` function eliminates duplicate elements on the LIST on the top of the stack.\nThe order of the resulting LIST is not the same than the original one.\n\nIt makes elements of a list unique by converting it to a set temporarily. See [()](/doc/91Z) for more informations.\n\n@param `input` The list to parse\n\n@param `output` The new list object, without any duplicates\n\n",tags:["lists"],since:"1.0.0",OPB64name:"UNIQUE"},{name:"UNLIST",detail:"list<LIST>  UNLIST  mark<MARK> elts<ANY*>",documentation:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`]`](/doc/MF).\n\n@param `list` List to expand.\n\n@param `elts` Elements of `list`.\n\n@param `mark` Instance of MARK.\n\n",tags:["lists"],since:"1.0.11",OPB64name:"UNLIST"},{name:"UNMAP",detail:"map<MAP>  UNMAP  mark<MARK> k1<ANY> v1<ANY> kN<ANY> vN<ANY>",documentation:"Unpacks a map, pushing its keys and values onto the stack along a mark as the deepest stack element such that one can use [`}`](/doc/UF) to rebuild the map.\n\n@param `k1` First map key.\n\n@param `v1` First map value.\n\n@param `kN` Nth map key.\n\n@param `vN` Nth map value.\n\n@param `map` Map to unpack.\n\n@param `mark` Mark indicating the deepest level to consider when building the map.\n\n",tags:["maps"],since:"1.0.11",OPB64name:"UNMAP"},{name:"UNPACK",detail:"list<BYTES> format<STRING>  UNPACK  result<LIST<ANY>>",documentation:"The `UNPACK` function unpacks a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n* **<**: No bigendian\n* **>**: Bigendian\n* **L**: Long\n* **B**: Boolean\n* **D**: Double length always equals 64.\n* **<L32**: No bigendian 32 bits Long\n\n@param `list` Pqcked list to unpack\n\n@param `format` Format used to unpack\n\n@param `result` Unpacked list\n\n",tags:["lists"],since:"1.0.7",OPB64name:"UNPACK"},{name:"UNSECURE",detail:"secure<STRING>  UNSECURE  script<STRING>",documentation:"The `UNSECURE` function decrypts a secure script. The correct secret MUST have been set unsing [`SECUREKEY`](doc/SECUREKEY) prior to calling this function.\n\n@param `secure` STRING with the secure script to decode.\n\n@param `script` Decoded scripted.\n\n",tags:["crypto","stack"],since:"1.0.0",OPB64name:"UNSECURE"},{name:"UNSET",detail:"set<SET>  UNSET  mark<MARK> elts<ANY*>",documentation:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`)`](/doc/9F).\n\n@param `set` Set to expand.\n\n@param `elts` Elements of `set`.\n\n@param `mark` Instance of MARK.\n\n",tags:["sets"],since:"2.6.0",OPB64name:"UNSET"},{name:"UNTIL",detail:"code<MACRO> condition<MACRO>  UNTIL \ncode<MACRO> condition<MACRO> index<BOOLEAN>  UNTIL ",documentation:"The `UNTIL` function implements an until loop. It takes two macros as arguments from the stack: the code to execute until the condition is true and the condition to evaluate after every iteration.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force UNTIL to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `code` Macro executed on each loop\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",tags:["control"],since:"1.0.0",OPB64name:"UNTIL"},{name:"UNWRAP",detail:"wrapped<STRING>  UNWRAP  gts<GTS>\nwrappedbytes<BYTES>  UNWRAP  gts<GTS>\nlwrapped<LIST<STRING>>  UNWRAP  lgts<LIST<GTS>>\nlwrapped<LIST<BYTES>>  UNWRAP  lgts<LIST<GTS>>",documentation:"Unwraps packed Geo Time Series™ instances.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"UNWRAP"},{name:"UNWRAPEMPTY",detail:"wrapped<STRING>  UNWRAPEMPTY  gts<GTS>\nwrappedbytes<BYTES>  UNWRAPEMPTY  gts<GTS>\nlwrapped<LIST<STRING>>  UNWRAPEMPTY  lgts<LIST<GTS>>\nlwrapped<LIST<BYTES>>  UNWRAPEMPTY  lgts<LIST<GTS>>",documentation:"Unwraps wrapped Geo Time Series™ instances without unpacking the actual datapoints. This is handy to extract the metadata (class, labels, attributes) from a set of wrapped GTS.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPEMPTY"},{name:"UNWRAPENCODER",detail:"wrapped<STRING>  UNWRAPENCODER  encoder<GTSENCODER>\nwrappedbytes<BYTES>  UNWRAPENCODER  encoder<GTSENCODER>\nlwrapped<LIST<STRING>>  UNWRAPENCODER  lencoder<LIST<GTSENCODER>>\nlwrapped<LIST<BYTES>>  UNWRAPENCODER  lencoder<LIST<GTSENCODER>>",documentation:"Unwraps packed Geo Time Series™ into encoders.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `encoder` Encoder with decoded Geo Time Series™ datapoints.\n\n@param `lencoder` List of encoders with decoded Geo Time Series™.\n\n",tags:["gts"],since:"1.2.9",OPB64name:"UNWRAPENCODER"},{name:"UNWRAPSIZE",detail:"wrapped<STRING>  UNWRAPSIZE  size<LONG>\nwrappedbytes<BYTES>  UNWRAPSIZE  size<LONG>\nlwrapped<LIST<STRING>>  UNWRAPSIZE  lsize<LIST<LONG>>\nlwrapped<LIST<BYTES>>  UNWRAPSIZE  lsize<LIST<LONG>>",documentation:"Extracts the size (number of datapoints) of wrapped Geo Time Series™ instances.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `size` Decoded Geo Time Series™ size.\n\n@param `lsize` List of decoded Geo Time Series™ sizes.\n\n",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPSIZE"},{name:"UPDATE",detail:"gts<GTS> token<STRING>  UPDATE \nencoder<GTSENCODER> token<STRING>  UPDATE \nlist<LIST<GTS>> token<STRING>  UPDATE \nlist<LIST<GTSENCODER>> token<STRING>  UPDATE ",documentation:"Pushes Geo Time Series™ data to the Warp 10 instance.\n\nThe `UPDATE` function allows you to push data directly from your WarpScript code without having to retrieve the data and use the `/update` endpoint.\n\nThe GTS or Encoder instances to push *MUST* have a non empty name and in the case of Geo Time Series™ *MUST* have been renamed (to avoid pushing data by mistake which could override existing data you just retrieved).\n\n@param `token` Write token to use for pushing the data.\n\n@param `gts` Geo Time Series™ to push.\n\n@param `encoder` GTS Encoder to push.\n\n@param `list` List containing Geo Time Series™ and/or GTS Encoder instances to push.\n\n",tags:["gts","platform"],since:"1.0.0",OPB64name:"UPDATE"},{name:"UPDATEOFF",detail:"message<STRING> secret<STRING>  UPDATEOFF ",documentation:"Disables update operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when an update operation is attempted.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEOFF"},{name:"UPDATEON",detail:"secret<STRING>  UPDATEON ",documentation:"Enables update operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEON"},{name:"URLDECODE",detail:"encoded<STRING>  URLDECODE  decoded<STRING>",documentation:"Decodes a [URL encoded](https://en.wikipedia.org/wiki/Percent-encoding) STRING.\n\n@param `encoded` Encoded STRING to decode.\n\n@param `decoded` Decoded STRING.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"URLDECODE"},{name:"URLENCODE",detail:"string<STRING>  URLENCODE  encoded<STRING>",documentation:"Encodes a STRING using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and replacing occurrences of '+' with '%20'.\n\nThe character set used is [UTF-8](https://en.wikipedia.org/wiki/UTF-8).\n\n@param `string` Input STRING to encode.\n\n@param `encoded` Encoded version of 'string' using the UTF-8 character set.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"URLENCODE"},{name:"URLFETCH",detail:"url<STRING>  URLFETCH  result<LIST<LIST>>\nurl<STRING> headers<MAP>  URLFETCH  result<LIST<LIST>>\nurls<LIST<STRING>>  URLFETCH  result<LIST<LIST>>\nurls<LIST<STRING>> headers<MAP>  URLFETCH  result<LIST<LIST>>",documentation:"The `URLFETCH` function sends HTTP(S) GET requests, waits for the responses and puts them on the stack.\n\nFor security reasons, the stack must be authenticated for this function to work, see [`AUTHENTICATE`](/doc/AUTHENTICATE).\n\nSince 2.7.0, this function also accepts a MAP of headers.\n\n@param `url` The URL to send the GET request to. Must begin with `http://` or `https://`.\n\n@param `urls` The list of URLs to send the GET requests to. Each URL must begin with `http://` or `https://`. \n\n@param `result` A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\n\n@param `headers` \n\n",tags:["extensions","web"],since:"1.0.2",OPB64name:"URLFETCH"},{name:"UUID",detail:" UUID  uuid<STRING>",documentation:"Pushes onto the stack a randomly generated [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n@param `uuid` Generated UUID string\n\n",tags:["misc"],since:"1.0.0",OPB64name:"UUID"},{name:"V->",detail:"list<VLIST>  V->  result<LIST>",documentation:"The `V->` function converts a Vector (VLIST) on top of the stack into a list.\n\n@param `list` Input Vector.\n\n@param `result` Result list.\n\n",tags:["lists","conversion","pig"],since:"1.0.11",OPB64name:"KXoy"},{name:"VALUEDEDUP",detail:"gts<GTS> order<BOOLEAN>  VALUEDEDUP  dedupgts<GTS>\nlgts<LIST<GTS>> order<BOOLEAN>  VALUEDEDUP  ldedupgts<LIST<GTS>>",documentation:"Deletes duplicated values of the Geo Time Series™.\n\nThe `VALUEDEDUP` function takes as parameter a **GTS** or a **LIST** of **GTS** and it removes its duplicate values.\n\nExpects a boolean indicating whether we keep the oldest or most recent datapoint for a given value.\n\n@param `order` Boolean value, true for keeping the oldest datapoint for a given value, false otherwise.\n\n@param `gts` Geo Time Series™ for which to remove the duplicated values.\n\n@param `lgts` List of Geo Time Series™ for which to remove the duplicated values.\n\n@param `dedupgts` Geo Time Series™ with unique values.\n\n@param `ldedupgts` List of Geo Time Series™ with unique values.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUEDEDUP"},{name:"VALUEHISTOGRAM",detail:"gts<GTS>  VALUEHISTOGRAM  histogram<MAP>\nencoder<GTSENCODER>  VALUEHISTOGRAM  histogram<MAP>\nlist<LIST<GTS>>  VALUEHISTOGRAM  lhistogram<LIST<MAP>>",documentation:"Produces the value histogram of a Geo Time Series™ or (since 2.2.0) of a GTS Encoder.\n\nThe histogram is a map with an entry for each value (used as the map key), with an associated value equal to the number of occurrences of the value in the series.\n\nIf the input is a bucketized Geo Time Series™, the `NULL` key will have an associated value which is the number of buckets without values (assuming no datapoints were added at timestamps other than those of buckets).\n\nWhen the input is a GTS Encoder, keys may be BigDecimal, LONG, DOUBLE, BOOLEAN or STRING, binary values are not used as keys, their STRING representation (in ISO-8859-1) is used.\n\n@param `gts` Geo Time Series™ for which to compute the histogram\n\n@param `encoder` GTS Encoder for which to compute the histogram\n\n@param `histogram` The value histogram for the input Geo Time Series™ or GTS Encoder\n\n@param `list` List of Geo Time Series™ or GTS Encoders\n\n@param `lhistogram` The list of value histogram maps\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUEHISTOGRAM"},{name:"VALUELIST",detail:"map<MAP>  VALUELIST  values<LIST>",documentation:"Gets values from a **MAP**.\n\nThe function `VALUELIST` extracts the values of a **MAP** on the top of the stack and pushes on the stack a list with those values. The **MAP** is consumed.\n\n\n@param `map` Map for which to get the values.\n\n@param `values` List of values for the input MAP.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"VALUELIST"},{name:"VALUES",detail:"gts<GTS>  VALUES  values<LIST>\nlgts<LIST<GTS>>  VALUES  lvalues<LIST<LIST>>\nencoder<GTSENCODER>  VALUES  values<LIST>\nlencoder<LIST<GTSENCODER>>  VALUES  lvalues<LIST<LIST>>",documentation:"Gets the values of Geo Time Series™ or encoders.\n\nThe `VALUES` function consumes a Geo Time Series™, an encoder or a list thereof from the stack, and it replaces each instance of Geo Time Series™ or encoder by a list of its values.\n\n@param `gts` Geo Time Series™ for which to get the values.\n\n@param `lgts` List of Geo Time Series™ for which to get the values.\n\n@param `encoder` Encoder for which to get the values.\n\n@param `lencoder` List of encoders for which to get the values.\n\n@param `values` List of values from the input Geo Time Series™.\n\n@param `lvalues` List of list of values from the input Geo Time Series™ list.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUES"},{name:"VALUESORT",detail:"gts<GTS>  VALUESORT  sortedgts<GTS>\nlgts<LIST<GTS>>  VALUESORT  lsortedgts<LIST<GTS>>",documentation:"Sorts values of the Geo Time Series™ in ascending order.\n\nThe function `VALUESORT` takes the **GTS** on top of the stack and sort its values (and associated locations/elevations) in ascending order.\n\n@param `gts` Geo Time Series™ for which to sort the values.\n\n@param `sortedgts` Geo Time Series™ with sorted values.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lsortedgts` List of Geo Time Series™ with sorted values.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUESORT"},{name:"VALUESPLIT",detail:"gts<GTS> label<STRING>  VALUESPLIT  splitedgts<LIST<GTS>>\nlgts<LIST<GTS>> label<STRING>  VALUESPLIT  lsplitedgts<LIST<LIST<GTS>>>",documentation:"Splits Geo Time Series™ by values.\n\nThe function `VALUESPLIT` takes one **STRING** on top of the stack plus one **GTS** or a list of **GTS**. It splits **GTS** by values and creates a **GTS** for each different value. For each new **GTS**, the label specified in parameter will be added.\n\nThe new **GTS** will be sorted by value with `VALUESORT`.\n\n@param `label` Label to add to the new Geo Time Series™.\n\n@param `gts` Geo Time Series™ to split by value.\n\n@param `splitedgts` List of Geo Time Series™ splited by value.\n\n@param `lgts` List of Geo Time Series™ to split by value.\n\n@param `lsplitedgts` List of Geo Time Series™ splited by value.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUESPLIT"},{name:"VARINT->",detail:"encoded<BYTES>  VARINT->  numbers<LIST<LONG>>\nencoded<BYTES> count<LONG>  VARINT->  numbers<LIST<LONG>> processed<LONG>",documentation:"The `VARINT` function decodes [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoded numbers.\n\n@param `numbers` List of decoded numbers.\n\n@param `encoded` Byte array containing the encoded number(s) to decode.\n\n@param `count` Maximum number of `LONG`s to decode.\n\n@param `processed` Number of bytes which were processed to decode the numbers.\n\n",tags:["conversion","binary"],since:"2.6.0",OPB64name:"KZ4HHJtJAIs"},{name:"VARS",detail:"macro<MACRO>  VARS  vars<LIST<STRING>>\nmacro<MACRO> onlyPoprAndStore<BOOLEAN>  VARS  vars<LIST<STRING>>",documentation:"Extracts all variables used in a macro. The `VARS` function scans the macro for occurrences of `LOAD`, `STORE` or `CSTORE` functions and inspects the associated variable name. If such a name is not an explicit STRING, the call to `VARS` will fail with an error.\n\nThe list of symbols is sorted according to the number of occurrences encountered, decreasing.\n\n@param `macro` Macro to inspect.\n\n@param `vars` List of encountered symbols.\n\n@param `onlyPoprAndStore` Returns only variables used by POPR, CPOPR and STORE. Defaults to false.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"VARS"},{name:"VEC->",detail:"input<VECTOR>  VEC->  result<LIST>",documentation:"The `VEC->` function converts a Vector into a list.\n\n\n@param `input` Vector to convert\n\n@param `result` list\n\n",tags:["lists","conversion","math"],since:"1.0.6",OPB64name:"KZK2AIs"},{name:"WEBCALL",detail:"token<STRING> method<STRING> url<STRING> headers<MAP> body<STRING>  WEBCALL  uuid<STRING>",documentation:"Makes an outbound HTTP call.\n\nNote that the hosts which may be reached via `WEBCALL` might have been restricted through the use of the `webcall.host.patterns` Warp&nbsp;10 configuration parameter.\n\nThe write token is here to check you have the right to send a webcall. If the write token is valid, then the request is sent. It will never be sent in the request.\n\nThe call to `WEBCALL` returns a UUID on the stack. The actual request is performed asynchronously, the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`.\n\n@param `body` body of the request.\n\n@param `headers` map of additionnal http headers.\n\n@param `url` supported schemes are http and https.\n\n@param `method` `GET` or `POST` string.\n\n@param `token` valid write token\n\n@param `uuid` the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`\n\n",tags:["web"],since:"1.0.0",OPB64name:"WEBCALL"},{name:"WF.ADDREPO",detail:"url<STRING>  WF.ADDREPO ",documentation:"The `WF.ADDREPO` function allows you to add a repository to the list of repositories taken into account by the WarpFleet™ macro resolver.\n\nIf the URL is valid (syntaxically), then it will be added at the end of the current list of repositories scanned by the resolver. All repository URLs will then be validated by the `validator` macro defined in the configuration (`warpfleet.macros.validator`). Those URLs for which the `validator` macro returned true will be retained.\n\nNote that the repository is only added in the scope of the current stack.\n\n@param `url` URL to add to the list of repositories.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"WF.ADDREPO"},{name:"WF.GETREPOS",detail:" WF.GETREPOS  repos<LIST<STRING>>",documentation:"Retrieves the current list of repositories used by the WarpFleet™ resolver.\n\nNote that if the configuration disabled the use of this function (via `warpfleet.getrepos.disable`), the returned list will be empty even though it contains repositories.\n\n@param `repos` Current list of repository URLs.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"WF.GETREPOS"},{name:"WF.SETREPOS",detail:"repos<LIST<STRING>>  WF.SETREPOS ",documentation:"Sets the list of repositories used by the WarpFleet™ resolver to the given value (list of valid URLs).\n\nEach URL is tested against WarpFleet™ validator macro to check if it is allowed. Non-valid ones are discarded.\n\nNote that this changes the list only for the scope of the current WarpScript execution.\n\n@param `repos` List of URLs to use for the WarpFleet™ resolver.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"WF.SETREPOS"},{name:"WFOFF",detail:" WFOFF ",documentation:"The `WFOFF` function disables the WarpFleet™ Resolver. It can be re-enabled using `WFON`.\n\nThis is useful when you want to ensure that a macro call only looks it up locally.\n\n",tags:["stack"],since:"2.1.0",OPB64name:"WFOFF"},{name:"WFON",detail:" WFON ",documentation:"The `WFON` function enables the WarpFleet™ Resolver after it has been disabled by `WFOFF`.\n\n",tags:["stack"],since:"2.1.0",OPB64name:"WFON"},{name:"WHILE",detail:"condition<MACRO> code<MACRO>  WHILE \ncondition<MACRO> code<MACRO> index<BOOLEAN>  WHILE ",documentation:"The `WHILE` function implements a while loop. It takes two macros as arguments from the stack: the condition macro to evaluate and the macro to execute while the condition is true.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force WHILE to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `code` Macro executed on each loop\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",tags:["control"],since:"1.0.0",OPB64name:"WHILE"},{name:"WRAP",detail:"encoder<GTSENCODER>  WRAP  wrapped<STRING>\nlencoder<GTSENCODER>  WRAP  lwrapped<LIST<STRING>>\ngts<GTS>  WRAP  wrapped<STRING>\nlgts<LIST<GTS>>  WRAP  lwrapped<LIST<STRING>>",documentation:"The `WRAP` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a STRING.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"1.0.0",OPB64name:"WRAP"},{name:"WRAPFAST",detail:"encoder<GTSENCODER>  WRAPFAST  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPFAST  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPFAST  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPFAST  lwrapped<LIST<BYTES>>",documentation:"The `WRAPFAST` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a byte array. For fast execution, the content of the GTS is not compressed, so the resulting byte array will be larger than that produced by `WRAPRAW`.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"2.1.0",OPB64name:"WRAPFAST"},{name:"WRAPMV",detail:"encoder<GTSENCODER>  WRAPMV  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPMV  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPMV  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPMV  lwrapped<LIST<BYTES>>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPRAWOPT`, `WRAPMV` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"WRAPMV"},{name:"WRAPMV!",detail:"encoder<GTSENCODER>  WRAPMV!  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPMV!  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPMV!  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPMV!  lwrapped<LIST<BYTES>>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPMV`, `WRAPMV!` attempts to optimize the representation of DOUBLE values for Geo Time Series™ but unlike `WARPMV`, it does not increase the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder","multivariate"],since:"2.6.0",OPB64name:"Kp80J3pL7F"},{name:"WRAPOPT",detail:"encoder<GTSENCODER>  WRAPOPT  wrapped<STRING>\nlencoder<GTSENCODER>  WRAPOPT  lwrapped<LIST<STRING>>\ngts<GTS>  WRAPOPT  wrapped<STRING>\nlgts<LIST<GTS>>  WRAPOPT  lwrapped<LIST<STRING>>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a STRING. The packing performed by `WRAPOPT` differs from that of [`WRAP`](/doc/WRAP) only by the fact that `WRAPOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",tags:["gts"],since:"1.2.3",OPB64name:"WRAPOPT"},{name:"WRAPRAW",detail:"encoder<GTSENCODER>  WRAPRAW  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPRAW  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPRAW  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPRAW  lwrapped<LIST<BYTES>>",documentation:"The `WRAPRAW` function packs a Geo Time Series™ into a byte array.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"1.0.7",OPB64name:"WRAPRAW"},{name:"WRAPRAWOPT",detail:"encoder<GTSENCODER>  WRAPRAWOPT  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPRAWOPT  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPRAWOPT  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPRAWOPT  lwrapped<LIST<BYTES>>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES. The packing performed by `WRAPRAWOPT` differs from that of [`WRAPRAW`](/doc/WRAPRAW) only by the fact that `WRAPRAWOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"1.2.3",OPB64name:"WRAPRAWOPT"},{name:"WSINFO",detail:"session<STRING>  WSINFO  infos<LIST<MAP>>",documentation:"Displays informations about WarpScript environments with a given session id. The informations are returned as a map identical to that returned by [`WSPS`](/doc/WSPS):\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `session` Session of the environments to inspect.\n\n@param `infos` List of informations about each WarpScript execution environment with 'session' as their session name.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSINFO"},{name:"WSKILL",detail:"uuid<STRING> secret<STRING>  WSKILL  status<BOOLEAN>",documentation:"Kills the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP) and marking the environment as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to kill.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILL"},{name:"WSKILLSESSION",detail:"session<STRING>  WSKILLSESSION  count<LONG>",documentation:"Kills the execution WarpScript programs by forcing a call to [`STOP`](/doc/STOP) and marking the environments as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `session` Session id of the WarpScript execution environments to kill.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILLSESSION"},{name:"WSNAME",detail:"name<STRING>  WSNAME  current<STRING>",documentation:"Modifies the name associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stack.name` in the attributes map.\n\nName size is limited to 128 characters.\n\n@param `name` Name to assign to the calling execution environment, or `NULL` to simply read the current name.\n\n@param `current` Name assigned to the execution environment.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSNAME"},{name:"WSPS",detail:"secret<STRING>  WSPS  procs<LIST<MAP>>",documentation:"Lists all the registers WarpScript execution environments. For each environment a map is returned with the following fields:\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `secret` Secret for process status operations.\n\n@param `procs` List of informations about each registered WarpScript execution environment.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSPS"},{name:"WSSESSION",detail:"session<STRING>  WSSESSION  current<STRING>",documentation:"Modifies the session id associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stackps.session` in the attributes map.\n\nSession id size is limited to 128 characters.\n\nSession can also be set by setting the `X-Warp10-WarpScriptSession` header.\n\nOnce the session has been set it cannot be modified.\n\n@param `session` Session id to assign to the calling execution environment, or NULL to simply read the current session id.\n\n@param `current` The session id assigned to the execution environment.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSESSION"},{name:"WSSTACK",detail:" WSSTACK ",documentation:"Select the WarpScript™ (*i.e.* SNAPSHOT) format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"WSSTACK"},{name:"WSSTOP",detail:"uuid<STRING> secret<STRING>  WSSTOP  status<BOOLEAN>",documentation:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to stop.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOP"},{name:"WSSTOPSESSION",detail:"session<STRING>  WSSTOPSESSION  count<LONG>",documentation:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\nThe environments to stop are identified by a session id.\n\n@param `session` Session of the WarpScript execution environments to stop.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOPSESSION"},{name:"Z->",detail:"z<BYTES> n<LONG> bitwidth<LONG>  Z->  longs<LIST<LONG>>",documentation:"Unpacks LONG values from a [Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) stored in a byte array.\n\n@param `bitwidth` Size in bits of the LONG values to extract, from 1 to 63.\n\n@param `n` Number of LONG values to extract.\n\n@param `z` Byte array containing the Morton Code to unpack.\n\n@param `longs` List of extracted LONG values.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"LXoy"},{name:"ZDISCORDS",detail:"window_size<LONG> maximum<LONG> overlapping<BOOLEAN> distance<DOUBLE>  ZDISCORDS  result<GTS>",documentation:"The `ZDISCORDS` function detects discords in a standardized ([`STANDARDIZE`](/doc/STANDARDIZE) Geo Time Series™. The discord detection\n algorithm is based on identifying outlier patterns in the Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `ZDISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\nGiven the `ZDISCORDS` expects the Geo Time Series™ it operates on to be standardized ([`STANDARDIZE`](/doc/STANDARDIZE), the discord detection \nalgorithm is more sensitive than that of [`DISCORDS`](/doc/DISCORDS).\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0.\n\n@param `overlapping` Flag indicating whether or not the `ZDISCORDS` function should report overlapping discords.\n\n@param `maximum` The maximum number of discords to identify.\n\n@param `window_size` Window size which is the width of each interval on which the pattern extraction should be performed, a pattern length which will determine how the window is segmented, and lastly a quantization scale which will determine how many different buckets will be used to ventilate the series values. (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `result` Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™.\n\n",tags:["gts","outlier"],since:"1.0.13",OPB64name:"ZDISCORDS"},{name:"ZDTW",detail:"gts1<GTS> gts2<GTS> threshold<DOUBLE>  ZDTW  dtw<DOUBLE>",documentation:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be Z-normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",tags:["gts","distance"],since:"1.2.11",OPB64name:"ZDTW"},{name:"ZIP",detail:"input<LIST<LIST>>  ZIP  output<LIST<LIST>>",documentation:"The function ZIP takes a list of lists as parameters. Each list which are not singletons must be of same size.\n\nIt returns a list of lists where the i-th list contains the i-th elements of each input list in the same order.\n\nAlso, it considers singletons as a list of the same size with a duplicated value.\n\n@param `input` List of lists\n\n@param `output` List of lists\n\n",tags:["lists"],since:"1.0.0",OPB64name:"ZIP"},{name:"ZPATTERNDETECTION",detail:"gts<GTS> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNDETECTION  result<GTS>\nlgts<LIST<GTS>> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNDETECTION  lresult<LIST<GTS>>",documentation:"The `ZPATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`ZPATTERNS`](/doc/ZPATTERNS) or [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe `ZPATTERNDETECTION` does not standardize the datapoints in the sliding window, assuming (wrongly) they already are.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `ZPATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform.\n\n@param `gts` The single GTS to transform.\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it.\n\n@param `lresult` The list of result GTS.\n\n",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNDETECTION"},{name:"ZPATTERNS",detail:"gts<GTS> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNS  result<GTS>\nlgts<LIST<GTS>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNS  lresult<LIST<GTS>>",documentation:"Extracts symbolic patterns from Geo Time Series™ as [`PATTERNS`](/doc/PATTERNS) does, but does not standardize each window, assuming (wrongly) the GTS windows are already standardized.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNS"},{name:"ZSCORE",detail:"gts<GTS> flag<BOOLEAN>  ZSCORE  result<GTS>\ngtsList<LIST<GTS>> flag<BOOLEAN>  ZSCORE  resultList<LIST<GTS>>",documentation:"The 'ZSCORE' function consumes a flag, then normalizes a Geo Time Series™ or a **LIST** of Geo Time Series™ that are below by replacing their values by their [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe flag indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median).\n\nIf the GTS isn’t of type **DOUBLE** or if the deviation equals 0, an exception is raised.\n\n@param `flag` Indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ZSCORE"},{name:"ZSCORETEST",detail:"gts<GTS> mad<BOOLEAN>  ZSCORETEST  result<LIST<LONG>>\nlgts<LIST<GTS>> mad<BOOLEAN>  ZSCORETEST  lresult<LIST<LIST<LONG>>>\ngts<GTS> mad<BOOLEAN> trigger<DOUBLE>  ZSCORETEST  result<LIST<LONG>>\nlgts<LIST<GTS>> mad<BOOLEAN> trigger<DOUBLE>  ZSCORETEST  lresult<LIST<LIST<LONG>>>",documentation:"The ZSCORETEST function detects outliers in a GTS by comparing the Z-score of its values with a given threshold.\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median). If this value is greater than the given threshold, it is flagged as an outlier.\n\nA LIST of ticks, corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n@param `gts` The Geo Time Series™ to test\n\n@param `result` List of the detected outliers timestamps\n\n@param `lgts` The list of Geo Time Series™ to test\n\n@param `lresult` List of list of the detected outliers timestamps\n\n@param `mad` False: use the mean/sigma, true: use the median/mad to calculate the Z-score\n\n@param `trigger` Optional threshold. Default value is 3.5\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ZSCORETEST"},{name:"[",detail:" [  mark<MARK>",documentation:"Starts a list creation.\n\nThe `[` function creates a list by pushing a mark onto the stack. This is a syntactic help to better present list constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",tags:["lists","stack"],since:"1.0.0",OPB64name:"Lk"},{name:"[[",detail:" [[  mark<MARK>",documentation:"Pushes a MARK on the stack. This is a syntaxic help to better present Vector (VLIST) constructions.\n \n\n@param `mark` A MARK instance.\n\n",tags:["pig"],since:"1.2.13",OPB64name:"Lpg"},{name:"[[]]",detail:" [[]]  vector<VLIST>",documentation:"Pushes an empty Vector onto the stack.\n\n@param `vector` Empty Vector.\n\n",tags:["lists"],since:"1.2.13",OPB64name:"LphSMF"},{name:"[]",detail:"content<ANY>  []  newlist<LIST>",documentation:"The [] function creates an empty LIST on the top of the stack.\n\n\n@param `content` 0 to n elements.\n\n@param `newlist` list instance, initialized with content.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"Lpo"},{name:"]",detail:"mark<MARK> v1<ANY> vN<ANY>  ]  list<LIST>",documentation:"Closes a currently open list and pushes it onto the stack.\n\n  The `]` function pops from the stack the elements of the list up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",tags:["lists"],since:"1.0.0",OPB64name:"MF"},{name:"]]",detail:"mark<MARK> v1<ANY> vN<ANY>  ]]  list<VLIST>",documentation:"Closes a currently open Vector (VLIST) and pushes it onto the stack. The elements on the stack are those up to the first mark encountered. The mark is discarded.\n\nVLIST are represented as lists on the stack.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",tags:["pig"],since:"1.2.13",OPB64name:"MKo"},{name:"^",detail:"p1<LONG> p2<LONG>  ^  result<LONG>\ninputgts<GTS> mask<LONG>  ^  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  ^  outputgts<GTS>",documentation:"Performs a bitwise **XOR** operation.\n\nThe `^` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **XOR**.\n\nSince Warp 10™ 2.1, `^` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be XOR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with XOR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts XOR with mask\n\n",tags:["binary","operators"],since:"1.0.0",OPB64name:"MV"},{name:"bucketizer.and",detail:" bucketizer.and  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.and` function applies the logical operator **AND** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.and"},{name:"bucketizer.count",detail:" bucketizer.count  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.count` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count"},{name:"bucketizer.count.exclude-nulls",detail:" bucketizer.count.exclude-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.count.exclude-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.exclude-nulls` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.exclude-nulls"},{name:"bucketizer.count.include-nulls",detail:" bucketizer.count.include-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.count.include-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.include-nulls function computes the number of values, including null values, found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.include-nulls"},{name:"bucketizer.count.nonnull",detail:" bucketizer.count.nonnull  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.count.nonnull` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.nonnull"},{name:"bucketizer.first",detail:" bucketizer.first  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.first` function returns the first value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.first` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.first"},{name:"bucketizer.join",detail:"separator<STRING>  bucketizer.join  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.join` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join"},{name:"bucketizer.join.forbid-nulls",detail:"separator<STRING>  bucketizer.join.forbid-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.join.forbid-nulls` has the same behavior as `bucketizer.join`, use `bucketizer.join` instead.\n\nThe `bucketizer.join.forbid-nulls` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join.forbid-nulls"},{name:"bucketizer.last",detail:" bucketizer.last  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.last` function returns the last value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.last` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.last"},{name:"bucketizer.mad",detail:" bucketizer.mad  bucketizer<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) of each bucket.\n\nThe returned location is the median of all the locations in the bucket, and the returned elevation is the median of all the elevations in the bucket.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.2.0",OPB64name:"bucketizer.mad"},{name:"bucketizer.max",detail:" bucketizer.max  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.max` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max"},{name:"bucketizer.max.forbid-nulls",detail:" bucketizer.max.forbid-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.max.forbid-nulls` has the same behavior as `bucketizer.max`, use `bucketizer.max` instead.\n\nThe `bucketizer.max.forbid-nulls` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\nThe `bucketizer.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max.forbid-nulls"},{name:"bucketizer.mean",detail:" bucketizer.mean  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.mean` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean"},{name:"bucketizer.mean.circular",detail:"modulo<NUMBER>  bucketizer.mean.circular  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.mean.circular` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`bucketizer.mean.circular.exclude-nulls`](/doc/bucketizer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `bucketizer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular"},{name:"bucketizer.mean.circular.exclude-nulls",detail:"modulo<NUMBER>  bucketizer.mean.circular.exclude-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.mean.circular.exclude-nulls` has the same behavior as `bucketizer.mean.circular`, use `bucketizer.mean.circular` instead.\n        \nThe `bucketizer.mean.circular.exclude-nulls` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned.\n\nThe `bucketizer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular.exclude-nulls"},{name:"bucketizer.mean.exclude-nulls",detail:" bucketizer.mean.exclude-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.mean.exclude-nulls` has the same behavior as `bucketizer.mean`, use `bucketizer.mean` instead.\n \nThe `bucketizer.mean.exclude-nulls` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.exclude-nulls"},{name:"bucketizer.median",detail:" bucketizer.median  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.median` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.median"},{name:"bucketizer.median.forbid-nulls",detail:" bucketizer.median.forbid-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.median.forbid-nulls` has the same behavior as `bucketizer.median`, use `bucketizer.median` instead.\n\nThe `bucketizer.median.forbid-nulls` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"2.4.0",OPB64name:"bucketizer.median.forbid-nulls"},{name:"bucketizer.min",detail:" bucketizer.min  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.min` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min"},{name:"bucketizer.min.forbid-nulls",detail:" bucketizer.min.forbid-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.min.forbid-nulls` has the same behavior as `bucketizer.min`, use `bucketizer.min` instead.\n\nThe `bucketizer.min.forbid-nulls` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min.forbid-nulls"},{name:"bucketizer.or",detail:" bucketizer.or  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.or` function applies the logical operator **OR** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.or"},{name:"bucketizer.percentile",detail:"percentile<NUMBER>  bucketizer.percentile  bucketizer<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the bucket.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `percentile` Percentile to consider\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.percentile"},{name:"bucketizer.rms",detail:" bucketizer.rms  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.rms` function returns the root mean square of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are the last one encountered for each bucket.\n\nThe `bucketizer.rms` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.2.18",OPB64name:"bucketizer.rms"},{name:"bucketizer.sd",detail:"bessel<BOOLEAN>  bucketizer.sd  result<AGGREGATOR>",documentation:"This bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Bucketizer to apply\n\n",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd"},{name:"bucketizer.sd.forbid-nulls",detail:"bessel<BOOLEAN>  bucketizer.sd.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.sd.forbid-nulls` has the same behavior as `bucketizer.sd`, use `bucketizer.sd` instead.\n\nThis bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd.forbid-nulls"},{name:"bucketizer.sum",detail:" bucketizer.sum  bucketizer<AGGREGATOR>",documentation:"The `bucketizer.sum` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum"},{name:"bucketizer.sum.forbid-nulls",detail:" bucketizer.sum.forbid-nulls  bucketizer<AGGREGATOR>",documentation:"**Deprecated**: `bucketizer.sum.forbid-nulls` has the same behavior as `bucketizer.sum`, use `bucketizer.sum` instead.\n\nThe `bucketizer.sum.forbid-nulls` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum.forbid-nulls"},{name:"d",detail:"input<NUMBER>  d  output<LONG>",documentation:"Converts a number of days (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of days from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of days to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of days\n\n",tags:["date"],since:"1.0.0",OPB64name:"d"},{name:"e",detail:" e  eValue<DOUBLE>",documentation:"Alias of [E](/doc/GF).\n\nThe `e` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"OF"},{name:"filler.interpolate",detail:" filler.interpolate  filler<FILLER>",documentation:"Pushes onto the stack a *filler* function which fills missing values with a linear interpolation of enclosing values in a Geo Time Series™.\n\nNote that this function will not fill missing leading or trailing ticks as there is no possible interpolation.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.interpolate"},{name:"filler.next",detail:" filler.next  filler<FILLER>",documentation:"Pushes onto the stack a *filler* function which fills missing values with the next value in a Geo Time Series™.\n\nNote that this function will not fill missing trailing ticks as there is no next value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.next"},{name:"filler.previous",detail:" filler.previous  filler<FILLER>",documentation:"Pushes onto the stack a *filler* function which fills missing values with the previous value in a Geo Time Series™.\n\nNote that this function will not fill missing leading ticks as there is no previous value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.previous"},{name:"filler.trend",detail:" filler.trend  filler<FILLER>",documentation:"Pushes onto the stack a *filler* function which fills missing values with the centroid of the points computed by projecting trends from both sides of the missing point.\n\nNote that this function will fill all missing points.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.trend"},{name:"filter.all.eq",detail:"filter-value<LONG>  filter.all.eq  result<FILTER>\nfilter-value<DOUBLE>  filter.all.eq  result<FILTER>\nfilter-value<BOOLEAN>  filter.all.eq  result<FILTER>\nfilter-value<STRING>  filter.all.eq  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose every value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.eq"},{name:"filter.all.ge",detail:"filter-value<LONG>  filter.all.ge  result<FILTER>\nfilter-value<DOUBLE>  filter.all.ge  result<FILTER>\nfilter-value<STRING>  filter.all.ge  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose every value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ge"},{name:"filter.all.gt",detail:"filter-value<LONG>  filter.all.gt  result<FILTER>\nfilter-value<DOUBLE>  filter.all.gt  result<FILTER>\nfilter-value<STRING>  filter.all.gt  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose every value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.gt"},{name:"filter.all.le",detail:"filter-value<LONG>  filter.all.le  result<FILTER>\nfilter-value<DOUBLE>  filter.all.le  result<FILTER>\nfilter-value<STRING>  filter.all.le  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose every value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.le"},{name:"filter.all.lt",detail:"filter-value<LONG>  filter.all.lt  result<FILTER>\nfilter-value<DOUBLE>  filter.all.lt  result<FILTER>\nfilter-value<STRING>  filter.all.lt  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose every value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.lt"},{name:"filter.all.ne",detail:"filter-value<LONG>  filter.all.ne  result<FILTER>\nfilter-value<DOUBLE>  filter.all.ne  result<FILTER>\nfilter-value<BOOLEAN>  filter.all.ne  result<FILTER>\nfilter-value<STRING>  filter.all.ne  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose every value does not equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ne"},{name:"filter.any.eq",detail:"filter-value<LONG>  filter.any.eq  result<FILTER>\nfilter-value<DOUBLE>  filter.any.eq  result<FILTER>\nfilter-value<BOOLEAN>  filter.any.eq  result<FILTER>\nfilter-value<STRING>  filter.any.eq  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose at least one value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.eq"},{name:"filter.any.ge",detail:"filter-value<LONG>  filter.any.ge  result<FILTER>\nfilter-value<DOUBLE>  filter.any.ge  result<FILTER>\nfilter-value<STRING>  filter.any.ge  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ge"},{name:"filter.any.gt",detail:"filter-value<LONG>  filter.any.gt  result<FILTER>\nfilter-value<DOUBLE>  filter.any.gt  result<FILTER>\nfilter-value<STRING>  filter.any.gt  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.gt"},{name:"filter.any.le",detail:"filter-value<LONG>  filter.any.le  result<FILTER>\nfilter-value<DOUBLE>  filter.any.le  result<FILTER>\nfilter-value<STRING>  filter.any.le  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.le"},{name:"filter.any.lt",detail:"filter-value<LONG>  filter.any.lt  result<FILTER>\nfilter-value<DOUBLE>  filter.any.lt  result<FILTER>\nfilter-value<STRING>  filter.any.lt  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.lt"},{name:"filter.any.ne",detail:"filter-value<LONG>  filter.any.ne  result<FILTER>\nfilter-value<DOUBLE>  filter.any.ne  result<FILTER>\nfilter-value<BOOLEAN>  filter.any.ne  result<FILTER>\nfilter-value<STRING>  filter.any.ne  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose at least one value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ne"},{name:"filter.byattr",detail:"filter<MAP>  filter.byattr  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose attributes match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.11",OPB64name:"filter.byattr"},{name:"filter.byclass",detail:"filter<STRING>  filter.byclass  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose class name matches the filter parameter.\n\n@param `filter` The filter parameter is a **STRING**, if it starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.byclass"},{name:"filter.bylabels",detail:"filter<MAP>  filter.bylabels  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.bylabels"},{name:"filter.bylabelsattr",detail:"filter<MAP>  filter.bylabelsattr  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose attributes or labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes or labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.11",OPB64name:"filter.bylabelsattr"},{name:"filter.bymetadata",detail:"lgts<LIST<GTS>>  filter.bymetadata  filter<FILTER>",documentation:"Filter GTSs by retaining those whose metadata **exactly** match at least one metadata from the given GTS list. \n\nThe metadata consists of the classname and labels.\n\n@param `lgts` List of GTSs to extract the metadata from.\n\n@param `filter` Filter to apply which will keep only GTSs with exact metadata matching.\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.bymetadata"},{name:"filter.byselector",detail:"selector<STRING>  filter.byselector  result<FILTER>",documentation:"This filter allow to select GTS with a standard or an extended selector.\n###### Standard selector: `classname{labelOrAttribute=x}`\n- If classname match, `filter.byselector` looks into input labels to check if labelOrAttribute exists and equals x. If labelOrAttribute is not found among input labels, it looks into input attributes if the label exists and equals x.\n###### Extended selector: `classname{labelname=x}{attributename=y}` matches if:\n- classname matches\n- input have labelname in its labels, and label value matches\n- input have attributename in its labels, and attribute value matches\n\n###### Selectors example:\n- `~.*{}` matches everything.\n- `={}` matches only emtpy classnames, whatever the labels and attributes.\n- `~.*{label=value}{} filter.byselector` is equivalent to `{ 'label' 'value' } filter.bylabels`.\n- `~.*{}{attribute~value} filter.byselector` is equivalent to `{ 'attribute' '~value' } filter.byattr`.\n\n\n@param `selector` The selector parameter. It could be a standard or an extended selector.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.byselector"},{name:"filter.bysize",detail:"min<LONG> max<LONG>  filter.bysize  result<FILTER>",documentation:"Filter GTSs by retaining those whose size is contained between specified bounds (inclusive).\n\n@param `min` The minimum size\n\n@param `max` The maximum size\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.bysize"},{name:"filter.last.eq",detail:"filter-value<LONG>  filter.last.eq  result<FILTER>\nfilter-value<DOUBLE>  filter.last.eq  result<FILTER>\nfilter-value<BOOLEAN>  filter.last.eq  result<FILTER>\nfilter-value<STRING>  filter.last.eq  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose last value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.eq"},{name:"filter.last.ge",detail:"filter-value<LONG>  filter.last.ge  result<FILTER>\nfilter-value<DOUBLE>  filter.last.ge  result<FILTER>\nfilter-value<STRING>  filter.last.ge  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose last value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ge"},{name:"filter.last.gt",detail:"filter-value<LONG>  filter.last.gt  result<FILTER>\nfilter-value<DOUBLE>  filter.last.gt  result<FILTER>\nfilter-value<STRING>  filter.last.gt  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose last value is greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.gt"},{name:"filter.last.le",detail:"filter-value<LONG>  filter.last.le  result<FILTER>\nfilter-value<DOUBLE>  filter.last.le  result<FILTER>\nfilter-value<STRING>  filter.last.le  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose last value is less or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.le"},{name:"filter.last.lt",detail:"filter-value<LONG>  filter.last.lt  result<FILTER>\nfilter-value<DOUBLE>  filter.last.lt  result<FILTER>\nfilter-value<STRING>  filter.last.lt  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose last value is less than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.lt"},{name:"filter.last.ne",detail:"filter-value<LONG>  filter.last.ne  result<FILTER>\nfilter-value<DOUBLE>  filter.last.ne  result<FILTER>\nfilter-value<BOOLEAN>  filter.last.ne  result<FILTER>\nfilter-value<STRING>  filter.last.ne  result<FILTER>",documentation:"This filter function only selects the Geo Time Series™ whose last value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ne"},{name:"filter.latencies",detail:"minLatency<LONG> maxLatency<LONG> options<LIST<STRING>>  filter.latencies  filter<FILTER>",documentation:"Pushes onto the stack a *pseudo* FILTER which computes latencies in a network. It uses the [`FILTER`](/doc/FILTER) framework for conveniency but really returns new GTS.\n\nThe input Geo Time Series™ are assumed to have values which are fingerprints of packet payloads. The first GTS is assumed to be the *uplink* and all the other GTS the *downlinks*.\n\nThe ticks are the time at which a packet with the given fingerprint was observed.\n\nThe generated Geo Time Series™ will have the same ticks as the uplink one, except the values will be latencies instead of packet fingerprints.\n\nThe `filter.latencies` function accepts a number of options:\n\n| Option | Description |\n|--------|-------------|\n| uplink.latency.min | Compute minimum latency on the uplink. |\n| uplink.latency.max | Compute maximum latency on the uplink. |\n| downlink.latency.min | Compute minimum latency on each downlink. |\n| downlink.latency.max | Compute maximum latency on each downlink. |\n| downlink.matches | Compute the number of matches for each downlink. |\n| downlinks.totalmatches | Computes the total number of matches across downlinks. |\n| downlinks.bitsets | Computes a bitset of downlinks which saw the packet (limited to 64 downlinks). |\n| downlinks.withmatches | Computes the number of downlinks with matches for the given packet. |\n\nThis pseudo FILTER is very specific to a networking use case, but it is a good demonstration of the power of WarpScript and its frameworks.\n\n@param `options` List of options, see above for their description.\n\n@param `maxLatency` Maximum allowable latency, packets with latency above this threshold are ignored.\n\n@param `minLatency` Minimum latency, packets with a latency below this threshold are ignored.\n\n@param `filter` Instance of `filter.latencies`.\n\n",tags:["filter","gts"],since:"1.0.0",OPB64name:"filter.latencies"},{name:"h",detail:"input<NUMBER>  h  output<LONG>",documentation:"Converts a number of hours (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of hours from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of hours to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of hours\n\n",tags:["date"],since:"1.0.0",OPB64name:"h"},{name:"m",detail:"input<NUMBER>  m  output<LONG>",documentation:"Converts a number of minutes (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of minutes from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of minutes to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of minutes\n\n",tags:["date"],since:"1.0.0",OPB64name:"m"},{name:"mapper.abs",detail:" mapper.abs  result<AGGREGATOR>",documentation:"This mapper function returns the absolute value of single value in a sliding window.\n\nThe `mapper.abs` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.abs"},{name:"mapper.add",detail:"constant<DOUBLE>  mapper.add  result<AGGREGATOR>\nconstant<LONG>  mapper.add  result<AGGREGATOR>",documentation:"This mapper function adds a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.add` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.add` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Value to add\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.add"},{name:"mapper.and",detail:" mapper.and  result<AGGREGATOR>",documentation:"This mapper function applies the logical operator **AND** on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.and"},{name:"mapper.ceil",detail:" mapper.ceil  result<AGGREGATOR>",documentation:"This mapper function rounds the single value in a sliding window to the closests greater **LONG**.\n\nThe `mapper.ceil` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.ceil"},{name:"mapper.count",detail:" mapper.count  result<AGGREGATOR>",documentation:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count"},{name:"mapper.count.exclude-nulls",detail:" mapper.count.exclude-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.count.exclude-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.exclude-nulls"},{name:"mapper.count.include-nulls",detail:" mapper.count.include-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.count.include-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.include-nulls"},{name:"mapper.count.nonnull",detail:" mapper.count.nonnull  result<AGGREGATOR>",documentation:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.nonnull"},{name:"mapper.day",detail:"timezone<STRING>  mapper.day  result<AGGREGATOR>\noffset<NUMBER>  mapper.day  result<AGGREGATOR>",documentation:"This mapper function returns the day of the tick for which it is computed.\n\nThe `mapper.day` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n@param `timezone` Timezone to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.day"},{name:"mapper.delta",detail:" mapper.delta  result<AGGREGATOR>",documentation:"This mapper function computes the delta between the last and first values (delta = last - first) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.delta` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does \nnot return any value.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.delta"},{name:"mapper.dotproduct",detail:"vector<LIST>  mapper.dotproduct  result<AGGREGATOR>",documentation:"The `mapper.dotproduct` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct"},{name:"mapper.dotproduct.positive",detail:"vector<LIST>  mapper.dotproduct.positive  result<AGGREGATOR>",documentation:"The `mapper.dotproduct.positive` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it sets all negative results to 0.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.positive"},{name:"mapper.dotproduct.sigmoid",detail:"vector<LIST>  mapper.dotproduct.sigmoid  result<AGGREGATOR>",documentation:"The `mapper.dotproduct.sigmoid` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the sigmoid of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.sigmoid"},{name:"mapper.dotproduct.tanh",detail:"vector<LIST>  mapper.dotproduct.tanh  result<AGGREGATOR>",documentation:"The `mapper.dotproduct.tanh` function consumes a vector as parameter (a **LIST* of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the \n[hyperbolic tangent](https://en.wikipedia.org/wiki/Hyperbolic_function) of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.tanh"},{name:"mapper.eq",detail:"parameter<LONG>  mapper.eq  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.eq  result<AGGREGATOR>\nparameter<BOOLEAN>  mapper.eq  result<AGGREGATOR>\nparameter<STRING>  mapper.eq  result<AGGREGATOR>",documentation:"This mapper function returns the first value in a sliding window which is equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.eq` function can be applied to data of any type.\n\nThe `mapper.eq` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.eq"},{name:"mapper.eq.elev",detail:"parameter<LONG>  mapper.eq.elev  result<AGGREGATOR>",documentation:"This mapper function returns the first elevation in a sliding window which is equal to a given value.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.eq.elev` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.elev"},{name:"mapper.eq.hhcode",detail:"parameter<LONG>  mapper.eq.hhcode  result<AGGREGATOR>",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is equal to a given value.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.eq.hhcode` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.hhcode"},{name:"mapper.eq.lat",detail:"parameter<LONG>  mapper.eq.lat  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.eq.lat  result<AGGREGATOR>",documentation:"This mapper function returns the first latitude in a sliding window which is equal to a given value.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.eq.lat` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lat"},{name:"mapper.eq.lon",detail:"parameter<LONG>  mapper.eq.lon  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.eq.lon  result<AGGREGATOR>",documentation:"This mapper function returns the first longitude in a sliding window which is equal to a given value.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.eq.lon` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lon"},{name:"mapper.eq.tick",detail:"parameter<LONG>  mapper.eq.tick  result<AGGREGATOR>",documentation:"This mapper function returns the first tick in a sliding window which is equal to a given value.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.eq.tick` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.tick"},{name:"mapper.exp",detail:"constant<LONG>  mapper.exp  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.exp  result<AGGREGATOR>",documentation:"This mapper function raises a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.exp` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.exp` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\n> ## Note\n> The `mapper.exp` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n>\n> So you are looking for a way to apply the exponential function, ex, to a series of Geo Time Series™. It’s very easy to do it using `mapper.exp` and the\n> [`e`](/doc/OF) constant.\n\n@param `result` Mapper to apply\n\n@param `constant` Constant to use\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.exp"},{name:"mapper.finite",detail:" mapper.finite  result<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which returns its input value only if it is finite (*i.e.* a non DOUBLE or a DOUBLE which is neither NaN nor Infinity).\n\n@param `result` Instance of mapper.finite.\n\n",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.finite"},{name:"mapper.first",detail:" mapper.first  result<AGGREGATOR>",documentation:"This mapper function returns the first value of each sliding window with its associated location and elevation.\n\nThe `mapper.first` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.first"},{name:"mapper.floor",detail:" mapper.floor  result<AGGREGATOR>",documentation:"This mapper function rounds the *single value* in a sliding window to the closests lower **LONG**.\n\nThe `mapper.floor` function can be applied to data of type **LONG** or **DOUBLE**.      \n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.floor"},{name:"mapper.ge",detail:"threshold<LONG>  mapper.ge  result<AGGREGATOR>\nthreshold<STRING>  mapper.ge  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ge  result<AGGREGATOR>",documentation:"This mapper function returns the first value in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ge` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.ge` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ge"},{name:"mapper.ge.elev",detail:"threshold<LONG>  mapper.ge.elev  result<AGGREGATOR>",documentation:"This mapper function returns the first elevation in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ge.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.elev"},{name:"mapper.ge.hhcode",detail:"threshold<LONG>  mapper.ge.hhcode  result<AGGREGATOR>",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ge.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.hhcode"},{name:"mapper.ge.lat",detail:"threshold<LONG>  mapper.ge.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ge.lat  result<AGGREGATOR>",documentation:"This mapper function returns the first latitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ge.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lat"},{name:"mapper.ge.lon",detail:"threshold<LONG>  mapper.ge.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ge.lon  result<AGGREGATOR>",documentation:"This mapper function returns the first longitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ge.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lon"},{name:"mapper.ge.tick",detail:"threshold<LONG>  mapper.ge.tick  result<AGGREGATOR>",documentation:"This mapper function returns the first tick in a sliding window which is greater or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ge.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.tick"},{name:"mapper.geo.approximate",detail:"resolution<LONG>  mapper.geo.approximate  result<AGGREGATOR>",documentation:"Pushes onto the stack a mapper instance which will transform the input Geo Time Series™ by approximating the location to the givnen resolution.\n\nApproximation is done by clearing lower bits of the location [HHCode](https://en.wikipedia.org/wiki/HHCode). At resolution `R`, the lower `64 - 2R` bits are cleared.\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\n\n\n@param `resolution` HHCode resolution at which to approximate the locations. Resoluion is an even number between 2 (coarsest) and 32 (finest).\n\n@param `result` Instance of mapper.\n\n",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.approximate"},{name:"mapper.geo.clear",detail:" mapper.geo.clear  result<AGGREGATOR>",documentation:"Pushes onto the stack a mapper which will discard location and elevation information when applied to a Geo Time Series™.\n\nThis mapper can only be applied to single values\n\n@param `result` Instance of the `mapper.geo.clear` mapper.\n\n",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.geo.clear"},{name:"mapper.geo.fence",detail:"zone<GEOSHAPE>  mapper.geo.fence  result<AGGREGATOR>",documentation:"This function produces a `mapper` which outputs a `BOOLEAN` for each point with an associated location. The value of the output is `true` if the location is inside the provided `GEOSHAPE` and `false` otherwise.\nThe geo zone can be defined in [WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using [`GEO.WKT`](/doc/GEO.WKT) or in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) using [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `zone` Geographical zone.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","geo"],since:"2.7.1",OPB64name:"mapper.geo.fence"},{name:"mapper.geo.outside",detail:"geoZone<GEOSHAPE>  mapper.geo.outside  result<AGGREGATOR>",documentation:"This mapper filters the Geo Time Series™, keeping only the points outside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.outside"},{name:"mapper.geo.within",detail:"geoZone<GEOSHAPE>  mapper.geo.within  result<AGGREGATOR>",documentation:"This mapper filters the Geo Time Series™, keeping only the points inside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.within"},{name:"mapper.gt",detail:"threshold<LONG>  mapper.gt  result<AGGREGATOR>\nthreshold<STRING>  mapper.gt  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.gt  result<AGGREGATOR>",documentation:"This mapper function returns the first value in a sliding window which is greater than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.gt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.gt` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.gt"},{name:"mapper.gt.elev",detail:"threshold<LONG>  mapper.gt.elev  result<AGGREGATOR>",documentation:"This mapper function returns the first elevation in a sliding window which is greater than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.gt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.elev"},{name:"mapper.gt.hhcode",detail:"threshold<LONG>  mapper.gt.hhcode  result<AGGREGATOR>",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.gt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.hhcode"},{name:"mapper.gt.lat",detail:"threshold<LONG>  mapper.gt.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.gt.lat  result<AGGREGATOR>",documentation:"This mapper function returns the first latitude in a sliding window which is greater than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.gt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lat"},{name:"mapper.gt.lon",detail:"threshold<LONG>  mapper.gt.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.gt.lon  result<AGGREGATOR>",documentation:"This mapper function returns the first longitude in a sliding window which is greater than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.gt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lon"},{name:"mapper.gt.tick",detail:"threshold<LONG>  mapper.gt.tick  result<AGGREGATOR>",documentation:"This mapper function returns the first tick in a sliding window which is greater than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.gt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.tick"},{name:"mapper.hdist",detail:" mapper.hdist  hdistMapper<AGGREGATOR>",documentation:"The `mapper.hdist` function computes the total distance traveled while going through the points in the sliding window in chronological order. This distance is in meters.\n\nThe distance used is the loxodromic distance aka rhumb line. As a consequence, elevation is not taken into account in the distance.\n\nIf a point has no position in the sliding window, it is ignored.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe `mapper.hdist` function can be applied to data of any type since it only considers locations.\n\n@param `hdistMapper` A function which can be used in a mapper.\n\n",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.hdist"},{name:"mapper.highest",detail:" mapper.highest  result<AGGREGATOR>",documentation:"This mapper function returns the value associated with the highest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the most recent is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.highest"},{name:"mapper.hour",detail:"timezone<STRING>  mapper.hour  result<AGGREGATOR>\noffset<NUMBER>  mapper.hour  result<AGGREGATOR>",documentation:"This mapper function returns the hour of the tick for which it is computed.\n\nThe `mapper.hour` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.hour"},{name:"mapper.hspeed",detail:" mapper.hspeed  result<AGGREGATOR>",documentation:"This mapper function computes the horizontal speed along the path traveled in the sliding window.\n\nThe distance is computed by summing the distances along the rhumb line between two consecutive locations.\n\nIf there is only one tick in the sliding window, the speed is 0.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.hspeed` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.hspeed"},{name:"mapper.join",detail:"separator<STRING>  mapper.join  result<AGGREGATOR>",documentation:"This mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join"},{name:"mapper.join.forbid-nulls",detail:"separator<STRING>  mapper.join.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.join.forbid-nulls` has the same behavior as `mapper.join`, use `mapper.join` instead.\n\nThis mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join.forbid-nulls"},{name:"mapper.kernel.cosine",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.cosine  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [cosine kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics.\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.cosine"},{name:"mapper.kernel.epanechnikov",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.epanechnikov  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using an [epanechnikov kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.epanechnikov"},{name:"mapper.kernel.gaussian",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.gaussian  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [gaussian kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.gaussian"},{name:"mapper.kernel.logistic",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.logistic  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [logistic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.logistic"},{name:"mapper.kernel.quartic",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.quartic  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [quartic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.quartic"},{name:"mapper.kernel.silverman",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.silverman  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [silverman kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.silverman"},{name:"mapper.kernel.triangular",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.triangular  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triangular kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triangular"},{name:"mapper.kernel.tricube",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.tricube  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [tricube kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.tricube"},{name:"mapper.kernel.triweight",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.triweight  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triweight kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triweight"},{name:"mapper.kernel.uniform",detail:"bandwidth<LONG> step<LONG>  mapper.kernel.uniform  result<AGGREGATOR>",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [uniform kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.uniform"},{name:"mapper.last",detail:" mapper.last  result<AGGREGATOR>",documentation:"This [`mapper`](/doc/MAP) function returns the last value of each sliding window with its associated location and elevation.\n\nThe `mapper.last` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.last"},{name:"mapper.le",detail:"threshold<DOUBLE>  mapper.le  result<AGGREGATOR>\nthreshold<LONG>  mapper.le  result<AGGREGATOR>\nthreshold<STRING>  mapper.le  result<AGGREGATOR>",documentation:"This mapper function returns the first value in a sliding window which is less or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.le` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.le` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.le"},{name:"mapper.le.elev",detail:"threshold<LONG>  mapper.le.elev  result<AGGREGATOR>",documentation:"This mapper function returns the first elevation in a sliding window which is less or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.le.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.elev"},{name:"mapper.le.hhcode",detail:"threshold<LONG>  mapper.le.hhcode  result<AGGREGATOR>",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.le.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.hhcode"},{name:"mapper.le.lat",detail:"threshold<LONG>  mapper.le.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.le.lat  result<AGGREGATOR>",documentation:"This mapper function returns the first latitude in a sliding window which is less or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.le.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lat"},{name:"mapper.le.lon",detail:"threshold<LONG>  mapper.le.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.le.lon  result<AGGREGATOR>",documentation:"This mapper function returns the first longitude in a sliding window which is less or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.le.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lon"},{name:"mapper.le.tick",detail:"threshold<LONG>  mapper.le.tick  result<AGGREGATOR>",documentation:"This mapper function returns the first tick in a sliding window which is less or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.le.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.tick"},{name:"mapper.log",detail:"constant<DOUBLE>  mapper.log  result<AGGREGATOR>\nconstant<LONG>  mapper.log  result<AGGREGATOR>",documentation:"This mapper function takes the log of the **single value** in a sliding window in the base used as parameter to `mapper.log`.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.log` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.log` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\nThe `mapper.log` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n\n@param `constant` Constant parameter\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.log"},{name:"mapper.lowest",detail:" mapper.lowest  result<AGGREGATOR>",documentation:"This mapper function returns the value associated with the lowest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the one appearing first chronologically is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.lowest"},{name:"mapper.lt",detail:"threshold<DOUBLE>  mapper.lt  result<AGGREGATOR>\nthreshold<LONG>  mapper.lt  result<AGGREGATOR>\nthreshold<STRING>  mapper.lt  result<AGGREGATOR>",documentation:"This mapper function returns the first value in a sliding window which is less than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.lt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.lt` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.lt"},{name:"mapper.lt.elev",detail:"threshold<LONG>  mapper.lt.elev  result<AGGREGATOR>",documentation:"This mapper function returns the first elevation in a sliding window which is less than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.lt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.elev"},{name:"mapper.lt.hhcode",detail:"threshold<LONG>  mapper.lt.hhcode  result<AGGREGATOR>",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.lt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.hhcode"},{name:"mapper.lt.lat",detail:"threshold<LONG>  mapper.lt.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.lt.lat  result<AGGREGATOR>",documentation:"This mapper function returns the first latitude in a sliding window which is less than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.lt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lat"},{name:"mapper.lt.lon",detail:"threshold<LONG>  mapper.lt.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.lt.lon  result<AGGREGATOR>",documentation:"This mapper function returns the first longitude in a sliding window which is less than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.lt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lon"},{name:"mapper.lt.tick",detail:"threshold<LONG>  mapper.lt.tick  result<AGGREGATOR>",documentation:"This mapper function returns the first tick in a sliding window which is less than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.lt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.tick"},{name:"mapper.mad",detail:" mapper.mad  result<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) over each sliding window.\n\nThe returned location is the median of all the locations in the sliding window, and the returned elevation is the median of all the elevations in the window.\n\n@param `result` Instance of `mapper.mad`.\n\n",tags:["mapper"],since:"1.2.0",OPB64name:"mapper.mad"},{name:"mapper.max",detail:" mapper.max  result<AGGREGATOR>",documentation:"This mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max"},{name:"mapper.max.forbid-nulls",detail:" mapper.max.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.max.forbid-nulls` has the same behavior as `mapper.max`, use `mapper.max` instead.\n\nThis mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max.forbid-nulls"},{name:"mapper.max.x",detail:"constant<DOUBLE>  mapper.max.x  result<AGGREGATOR>\nconstant<LONG>  mapper.max.x  result<AGGREGATOR>\nconstant<STRING>  mapper.max.x  result<AGGREGATOR>\nconstant<BOOLEAN>  mapper.max.x  result<AGGREGATOR>",documentation:"This mapper function returns the max between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.max.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.max.x"},{name:"mapper.mean",detail:" mapper.mean  result<AGGREGATOR>",documentation:"This mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean"},{name:"mapper.mean.circular",detail:"modulo<NUMBER>  mapper.mean.circular  result<AGGREGATOR>",documentation:"This function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`mapper.mean.circular.exclude-nulls`](/doc/mapper.mean.circular.exclude-nulls) if your sliding windows may contain nulls.\n\nThe `mapper.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular"},{name:"mapper.mean.circular.exclude-nulls",detail:"modulo<NUMBER>  mapper.mean.circular.exclude-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.mean.circular.exclude-nulls` has the same behavior as `mapper.mean.circular`, use `mapper.mean.circular` instead.\n\nThis function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular.exclude-nulls` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `mapper.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular.exclude-nulls"},{name:"mapper.mean.exclude-nulls",detail:" mapper.mean.exclude-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.mean.exclude-nulls` has the same behavior as `mapper.mean`, use `mapper.mean` instead.\n        \nThis mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.exclude-nulls"},{name:"mapper.median",detail:" mapper.median  result<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median`.\n\n",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.median"},{name:"mapper.median.forbid-nulls",detail:" mapper.median.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.median.forbid-nulls` has the same behavior as `mapper.median`, use `mapper.median` instead.\n\nPushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median.forbid-nulls`.\n\n",tags:["mapper","gts"],since:"2.4.0",OPB64name:"mapper.median.forbid-nulls"},{name:"mapper.min",detail:" mapper.min  result<AGGREGATOR>",documentation:"This mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min"},{name:"mapper.min.forbid-nulls",detail:" mapper.min.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.min.forbid-nulls` has the same behavior as `mapper.min`, use `mapper.min` instead.\n\nThis mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min.forbid-nulls"},{name:"mapper.min.x",detail:"constant<DOUBLE>  mapper.min.x  result<AGGREGATOR>\nconstant<LONG>  mapper.min.x  result<AGGREGATOR>\nconstant<STRING>  mapper.min.x  result<AGGREGATOR>\nconstant<BOOLEAN>  mapper.min.x  result<AGGREGATOR>",documentation:"This mapper function returns the min between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.min.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.min.x"},{name:"mapper.minute",detail:"timezone<STRING>  mapper.minute  result<AGGREGATOR>\noffset<NUMBER>  mapper.minute  result<AGGREGATOR>",documentation:"This mapper function returns the minute of the tick for which it is computed.\n\nThe `mapper.minute` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.minute"},{name:"mapper.mod",detail:"modulus<NUMBER>  mapper.mod  result<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which computes the remainder of a value given a modulus.\n\nThis MAPPER can only be applied to a single value.\n\n@param `modulus` Modulus to consider when computing the remainder.\n\n@param `result` Instance of `mapper.mod`.\n\n",tags:["mapper","gts"],since:"1.2.3",OPB64name:"mapper.mod"},{name:"mapper.month",detail:"timezone<STRING>  mapper.month  result<AGGREGATOR>\noffset<NUMBER>  mapper.month  result<AGGREGATOR>",documentation:"This mapper function returns the month of the tick for which it is computed.\n\nThe `mapper.month` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.month"},{name:"mapper.mul",detail:"constant<LONG>  mapper.mul  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.mul  result<AGGREGATOR>",documentation:"This mapper function multiplies by a constant the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.mul` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.mul` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.mul"},{name:"mapper.ne",detail:"parameter<LONG>  mapper.ne  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.ne  result<AGGREGATOR>\nparameter<BOOLEAN>  mapper.ne  result<AGGREGATOR>\nparameter<STRING>  mapper.ne  result<AGGREGATOR>",documentation:"This mapper function returns the first value in a sliding window which is not equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ne` function can be applied to data of any type.\n\nThe `mapper.ne` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ne"},{name:"mapper.ne.elev",detail:"threshold<LONG>  mapper.ne.elev  result<AGGREGATOR>",documentation:"This mapper function returns the first elevation in a sliding window which is not equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ne.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.elev"},{name:"mapper.ne.hhcode",detail:"threshold<LONG>  mapper.ne.hhcode  result<AGGREGATOR>",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is not equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ne.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.hhcode"},{name:"mapper.ne.lat",detail:"threshold<LONG>  mapper.ne.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ne.lat  result<AGGREGATOR>",documentation:"This mapper function returns the first latitude in a sliding window which is not equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ne.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lat"},{name:"mapper.ne.lon",detail:"threshold<LONG>  mapper.ne.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ne.lon  result<AGGREGATOR>",documentation:"This mapper function returns the first longitude in a sliding window which is not equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ne.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lon"},{name:"mapper.ne.tick",detail:"threshold<LONG>  mapper.ne.tick  result<AGGREGATOR>",documentation:"This mapper function returns the first tick in a sliding window which is not equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ne.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.tick"},{name:"mapper.npdf",detail:"mu<DOUBLE> sigma<DOUBLE>  mapper.npdf  result<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which returns the probability of a value given a normal distribution.\n\n@param `mu` Mean of the normal (Gaussian) distribution to consider.\n\n@param `sigma` Standard deviation of the normal (Gaussian) distribution to consider.\n\n@param `result` Instance of `mapper.npdf`.\n\n",tags:["gts","mapper"],since:"1.0.0",OPB64name:"mapper.npdf"},{name:"mapper.or",detail:" mapper.or  result<AGGREGATOR>",documentation:"This mapper function applies the logical operator OR on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.or"},{name:"mapper.parsedouble",detail:"tag<STRING>  mapper.parsedouble  result<AGGREGATOR>",documentation:"This mapper function converts a **STRING** single value in a sliding window to **DOUBLE**.\n\nThe `mapper.parsedouble` function can be applied to data of type **STRING**.\n\nThis function expects a [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) \nparameter in top of the mapper. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `tag` [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) parameter. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.2.5",OPB64name:"mapper.parsedouble"},{name:"mapper.percentile",detail:"percentile<NUMBER>  mapper.percentile  result<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the sliding window.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `percentile` Percentile to consider.\n\n@param `result` Instance of `mapper.percentile`.\n\n",tags:["mapper","gts"],since:"1.0.0",OPB64name:"mapper.percentile"},{name:"mapper.pow",detail:"constant<LONG>  mapper.pow  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.pow  result<AGGREGATOR>",documentation:"This mapper function raises the single value in a sliding window to a constant power.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.pow` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.pow` function must be parameterized with the constant.\n\nThe result is always of type DOUBLE.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.pow"},{name:"mapper.product",detail:" mapper.product  result<AGGREGATOR>",documentation:"This mapper function computes the product of all the values found in the sliding window.\n\nThe `mapper.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\nOn [bucketized](/doc/BUCKETIZE) Geo Time Series™, it is necessary to fill gaps with [`FILLVALUE`](/doc/FILLVALUE)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.product"},{name:"mapper.rate",detail:" mapper.rate  result<AGGREGATOR>",documentation:"This mapper function computes the rate of change between the first and last values (rate = (last - first) / (lastick - firsttick)) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.rate` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value. If the\nsliding window contains less than 2 values, the rate of change will be 0.0.\n\nThe rate of change is expressed in units per second.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.rate"},{name:"mapper.replace",detail:"constant<LONG>  mapper.replace  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.replace  result<AGGREGATOR>\nconstant<STRING>  mapper.replace  result<AGGREGATOR>\nconstant<BOOLEAN>  mapper.replace  result<AGGREGATOR>",documentation:"This mapper function replaces windows with at least one value with a constant. The location and elevation returned are those associated with the most \nrecent value in the sliding window.\n\n@param `constant` constant used for replacement\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.replace"},{name:"mapper.rms",detail:" mapper.rms  result<AGGREGATOR>",documentation:"This mapper function returns the root mean square of all the values found in each sliding window. The associated location is the last one of the window.\n\nThe `mapper.rms` function can only be applied to values of type **LONG** or **DOUBLE**.\n\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.2.18",OPB64name:"mapper.rms"},{name:"mapper.round",detail:" mapper.round  result<AGGREGATOR>",documentation:"This mapper function rounds the *single value* in a sliding window to the closests **LONG**.\n\nThe `mapper.round` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.round"},{name:"mapper.sd",detail:"bessel<BOOLEAN>  mapper.sd  result<AGGREGATOR>",documentation:"This mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd"},{name:"mapper.sd.forbid-nulls",detail:"bessel<BOOLEAN>  mapper.sd.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.sd.forbid-nulls` has the same behavior as `mapper.sd`, use `mapper.sd` instead.\n\nThis mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd.forbid-nulls"},{name:"mapper.second",detail:"timezone<STRING>  mapper.second  result<AGGREGATOR>\noffset<NUMBER>  mapper.second  result<AGGREGATOR>",documentation:"This mapper function returns the second of the tick for which it is computed.\n\nThe `mapper.second` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.second"},{name:"mapper.sigmoid",detail:" mapper.sigmoid  result<AGGREGATOR>",documentation:"This mapper function returns the sigmoid of *single value* in a sliding window.\n\nThe `mapper.sigmoid` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sigmoid"},{name:"mapper.sqrt",detail:" mapper.sqrt  result<AGGREGATOR>",documentation:"This mapper function computes the square root of the single value in a sliding window.\n\nFor negative numerics, this mapper returns **NaN**. For string values, this mapper returns 0.\n\nThe associated location and elevation are those of the single value.\n\n> ### Note\n> The `mapper.sqrt` mapper needs a single value sliding window, i.e. pre-window and post-window to 0\n\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.2.11",OPB64name:"mapper.sqrt"},{name:"mapper.sum",detail:" mapper.sum  result<AGGREGATOR>",documentation:"This mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum"},{name:"mapper.sum.forbid-nulls",detail:" mapper.sum.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.sum.forbid-nulls` has the same behavior as `mapper.sum`, use `mapper.sum` instead.\n\nThis mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum.forbid-nulls"},{name:"mapper.tanh",detail:" mapper.tanh  result<AGGREGATOR>",documentation:"This mapper function returns the hyperbolic tangent of *single value* in a sliding window.\n\nThe `mapper.tanh` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tanh"},{name:"mapper.tick",detail:" mapper.tick  result<AGGREGATOR>",documentation:"This mapper function returns the tick for which it is computed. The associated location and elevation are those of the selected value.\n\nThe `mapper.tick` function can be applied to values of any type.        \n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.tick"},{name:"mapper.toboolean",detail:" mapper.toboolean  result<AGGREGATOR>",documentation:"This mapper function converts the single value in a sliding window to **BOOLEAN**.\n\nThe `mapper.toboolean` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.toboolean"},{name:"mapper.todouble",detail:" mapper.todouble  result<AGGREGATOR>",documentation:"This mapper function converts the single value in a sliding window to **DOUBLE**.\n\nThe `mapper.todouble` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.todouble"},{name:"mapper.tolong",detail:" mapper.tolong  result<AGGREGATOR>",documentation:"This mapper function converts the single value in a sliding window to **LONG**.\n\nThe `mapper.tolong` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tolong"},{name:"mapper.tostring",detail:" mapper.tostring  result<AGGREGATOR>",documentation:"This mapper function converts the single value in a sliding window to **STRING**.\n\nThe `mapper.tostring` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tostring"},{name:"mapper.truecourse",detail:" mapper.truecourse  result<AGGREGATOR>",documentation:"Pushes onto the stack a mapper which will compute the initial [true course]http://www.edwilliams.org/avform.htm#Crs) on a great circle from the first to the last datapoint in the sliding window.\n\nThe location and elevation of the result is that of the tick being considered.\n\n@param `result` Instance of mapper.truecourse.\n\n",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.truecourse"},{name:"mapper.var",detail:"bessel<BOOLEAN>  mapper.var  result<AGGREGATOR>",documentation:"This mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var"},{name:"mapper.var.forbid-nulls",detail:"bessel<BOOLEAN>  mapper.var.forbid-nulls  result<AGGREGATOR>",documentation:"**Deprecated**: `mapper.var.forbid-nulls` has the same behavior as `mapper.var`, use `mapper.var` instead.\n\nThis mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var.forbid-nulls"},{name:"mapper.vdist",detail:" mapper.vdist  result<AGGREGATOR>",documentation:"This mapper function computes the total distance traveled in the vertical plane in the sliding window.\n\nThe distance is computed by summing the distances between consecutive elevations (this differs from the computation done in [`mapper.vspeed`](/doc/mapper.vspeed))\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed distance is expressed in meters.\n\nThe `mapper.vdist` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vdist"},{name:"mapper.vspeed",detail:" mapper.vspeed  result<AGGREGATOR>",documentation:"This mapper function computes the vertical speed between the first and last readings of the sliding window. It does not compute the speed based on the total\nvertical distance traveled in the sliding window, it only considers its extrema (it differs significantly of what is done for horizontal speed in\n[`mapper.hspeed`](/doc/mapper.hspeed)), thus the result can be positive or negative.\n\nIf one of the extrema of the sliding window has no elevation, no value is returned.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.vspeed` function can be applied to data of any type since it only considers elevations.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vspeed"},{name:"mapper.weekday",detail:"timezone<STRING>  mapper.weekday  result<AGGREGATOR>\noffset<NUMBER>  mapper.weekday  result<AGGREGATOR>",documentation:"This mapper function returns the day of the week of the tick for which it is computed.\n\nThe `mapper.weekday` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.weekday"},{name:"mapper.year",detail:"timezone<STRING>  mapper.year  result<AGGREGATOR>\noffset<NUMBER>  mapper.year  result<AGGREGATOR>",documentation:"This mapper function returns the year of the tick for which it is computed.\n\nThe `mapper.year` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.year"},{name:"max.tick.sliding.window",detail:" max.tick.sliding.window  max<LONG>",documentation:"Pushes onto the stack [`MAXLONG`](/doc/MAXLONG) divided by 2, to serve as the maximum number of ticks left or right of the current tick in a [`MAP`](/doc/MAP) sliding window.\n\nGiven that a Geo Time Series™ can have no more than 2**32 datapoints, this value is sufficient to cover the whole GTS left or right of the current tick.\n\n@param `max` Value pushed onto the stack.\n\n",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.tick.sliding.window"},{name:"max.time.sliding.window",detail:" max.time.sliding.window  max<LONG>",documentation:"Pushes onto the stack half of the minimum LONG value, to serve as a *pre* or *post* extension of a [`MAP`](/doc/MAP) sliding window in time units.\n\nThis value spans a lot of time but may not be enough to cover the entirety of a GTS.\n\n@param `max` Value pushed onto the stack.\n\n",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.time.sliding.window"},{name:"ms",detail:"input<NUMBER>  ms  output<LONG>",documentation:"Converts a number of milliseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of milliseconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of milliseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of milliseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"ms"},{name:"ns",detail:"input<NUMBER>  ns  output<LONG>",documentation:"Converts a number of nanoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of nanoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of nanoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of nanoseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"ns"},{name:"op.add",detail:" op.add  op<OPERATOR>",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter Geo Time Series™.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator forbids null values, *i.e.* if a `null` is encountered, then there will be no result for the given tick.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.add"},{name:"op.add.ignore-nulls",detail:" op.add.ignore-nulls  op<OPERATOR>",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter GTS.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.2.4",OPB64name:"op.add.ignore-nulls"},{name:"op.and",detail:" op.and  op<OPERATOR>",documentation:"To apply an `op.and` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.and"},{name:"op.and.ignore-nulls",detail:" op.and.ignore-nulls  op<OPERATOR>",documentation:"To apply an `op.and.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and.ignore-nulls` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.and.ignore-nulls"},{name:"op.div",detail:" op.div  op<OPERATOR>",documentation:"To apply an `op.div` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.div is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.div` operation can only operate on equivalence classes which have two GTS (if the equivalence class has more than two GTS, there is no result guaranted). It will divide at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.div"},{name:"op.eq",detail:" op.eq  op<OPERATOR>",documentation:"To apply an `op.eq` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.eq is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.eq` operation will check for equality at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.eq"},{name:"op.ge",detail:" op.ge  op<OPERATOR>",documentation:"To apply an `op.ge` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ge` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ge` operation will check at each tick if the value of the current GTS is greater or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.ge"},{name:"op.gt",detail:" op.gt  op<OPERATOR>",documentation:"To apply an `op.gt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.gt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.gt` operation will check at each tick if the value of the current GTS is greater than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.gt"},{name:"op.le",detail:" op.le  op<OPERATOR>",documentation:"To apply an `op.le` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.le` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.le` operation will check at each tick if the value of the current GTS is lesser or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.le"},{name:"op.lt",detail:" op.lt  op<OPERATOR>",documentation:"To apply an `op.lt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.lt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.lt` operation will check at each tick if the value of the current GTS is lesser than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.lt"},{name:"op.mask",detail:" op.mask  op<OPERATOR>",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), retains datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.mask"},{name:"op.mul",detail:" op.mul  op<OPERATOR>",documentation:"To apply an `op.mul` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.mul"},{name:"op.mul.ignore-nulls",detail:" op.mul.ignore-nulls  op<OPERATOR>",documentation:"To apply an `op.mul.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul.ignore-nulls` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.2.4",OPB64name:"op.mul.ignore-nulls"},{name:"op.ne",detail:" op.ne  op<OPERATOR>",documentation:"To apply an `op.ne` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ne` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ne` operation will check for inequality at each tick all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.ne"},{name:"op.negmask",detail:" op.negmask  op<OPERATOR>",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), removes datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The operator instance.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.negmask"},{name:"op.or",detail:" op.or  op<OPERATOR>",documentation:"To apply an `op.or` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.or"},{name:"op.or.ignore-nulls",detail:" op.or.ignore-nulls  op<OPERATOR>",documentation:"To apply an `op.or.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or.ignore-nulls` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.or.ignore-nulls"},{name:"op.sub",detail:" op.sub  op<OPERATOR>",documentation:"To apply an `op.sub` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.sub` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe sub operator can only operate on equivalence classes which have **exactly two GTS**. It will substract at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.sub"},{name:"pi",detail:" pi  pi<DOUBLE>",documentation:"Alias of [PI](/doc/J3Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"R5Z"},{name:"ps",detail:"input<NUMBER>  ps  output<LONG>",documentation:"Converts a number of picoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of picoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of picoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of picoseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"ps"},{name:"reducer.and",detail:" reducer.and  reducer<AGGREGATOR>",documentation:"The `reducer.and` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and"},{name:"reducer.and.exclude-nulls",detail:" reducer.and.exclude-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.and.exclude-nulls` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ \nwhich are in the same equivalence class, excluding nulls from the computation.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, \nthe current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and.exclude-nulls"},{name:"reducer.argmax",detail:"label<STRING> maximum<LONG>  reducer.argmax  reducer<AGGREGATOR>",documentation:"The `reducer.argmax` function outputs for each tick, the tick and the concatenation separated by ‘,’ of the values of the labels for which the\nvalue is the maximum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the maximum to report (use 0 to report all), and a **STRING**\nparameter to choose on which label it operates.\n\n@param `maximum` Maximum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmax"},{name:"reducer.argmin",detail:"label<STRING> minimum<LONG>  reducer.argmin  reducer<AGGREGATOR>",documentation:"The `reducer.argmin` function outputs for each tick, the tick and the concatenation separated by ‘,’ \nwith the values of the labels for which the value is the minimum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the minimum to report (use 0 to report all), and a **STRING** \nparameter to choose on which label it operates.\n\n@param `minimum` Minimum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmin"},{name:"reducer.count",detail:" reducer.count  reducer<AGGREGATOR>",documentation:"The `reducer.count` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe include null version, [`reducer.count.include-nulls`](/doc/reducer.count.include-nulls), will include null values when computing the count. The exclude null version, \n[`reducer.count.exclude-nulls`](/doc/reducer.count.exclude-nulls), will exclude null values when computing the count.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count"},{name:"reducer.count.exclude-nulls",detail:" reducer.count.exclude-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.count.exclude-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.exclude-nulls"},{name:"reducer.count.include-nulls",detail:" reducer.count.include-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.count.include-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are included.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.include-nulls"},{name:"reducer.count.nonnull",detail:" reducer.count.nonnull  reducer<AGGREGATOR>",documentation:"The `reducer.count.nonnull` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.nonnull"},{name:"reducer.join",detail:"separator<STRING>  reducer.join  reducer<AGGREGATOR>",documentation:"The 'reducer.join' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will exclude all null values when computing the join.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join"},{name:"reducer.join.forbid-nulls",detail:"separator<STRING>  reducer.join.forbid-nulls  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.join.nonnull`](/doc/reducer.join.nonnull).\n\nThe 'reducer.join.forbid-nulls' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.forbid-nulls"},{name:"reducer.join.nonnull",detail:"separator<STRING>  reducer.join.nonnull  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.join.forbid-nulls`](/doc/reducer.join.forbid-nulls).\n\nThe 'reducer.join.nonnull' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.nonnull"},{name:"reducer.join.urlencoded",detail:"separator<STRING>  reducer.join.urlencoded  reducer<AGGREGATOR>",documentation:"The 'reducer.join.urlencoded' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) charset.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.urlencoded"},{name:"reducer.mad",detail:" reducer.mad  reducer<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) for each ticks. Null values are removed before computing the MAD for each ticks.\n\nThe returned location is the median of all the locations and the returned elevation is the median of all the elevations.\n\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.2.0",OPB64name:"reducer.mad"},{name:"reducer.max",detail:" reducer.max  reducer<AGGREGATOR>",documentation:"The `reducer.max` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will exclude all null values when computing the maximum.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max"},{name:"reducer.max.forbid-nulls",detail:" reducer.max.forbid-nulls  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.max.nonnull`](/doc/reducer.max.nonnull).\n\nThe `reducer.max.forbid-nulls` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.forbid-nulls"},{name:"reducer.max.nonnull",detail:" reducer.max.nonnull  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.max.forbid-nulls`](/doc/reducer.max.forbid-nulls).\n\nThe `reducer.max.nonnull` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.nonnull"},{name:"reducer.mean",detail:" reducer.mean  reducer<AGGREGATOR>",documentation:"The `reducer.mean` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean"},{name:"reducer.mean.circular",detail:"modulo<NUMBER>  reducer.mean.circular  reducer<AGGREGATOR>",documentation:"The `reducer.mean.circular` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`reducer.mean.circular.exclude-nulls`](/doc/reducer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `reducer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular"},{name:"reducer.mean.circular.exclude-nulls",detail:"modulo<NUMBER>  reducer.mean.circular.exclude-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.mean.circular.exclude-nulls` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `reducer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular.exclude-nulls"},{name:"reducer.mean.exclude-nulls",detail:" reducer.mean.exclude-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.mean.exclude-nulls` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will exclude all null values when computing the mean.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.exclude-nulls"},{name:"reducer.median",detail:" reducer.median  reducer<AGGREGATOR>",documentation:"The `reducer.median` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.median"},{name:"reducer.median.forbid-nulls",detail:" reducer.median.forbid-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.median.forbid-nulls` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value, ie ticks do not match between Geo Times Series™ in the same equivalence class, it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"2.4.0",OPB64name:"reducer.median.forbid-nulls"},{name:"reducer.min",detail:" reducer.min  reducer<AGGREGATOR>",documentation:"The `reducer.min` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will exclude all null values when computing the minimum.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min"},{name:"reducer.min.forbid-nulls",detail:" reducer.min.forbid-nulls  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.min.nonnull`](/doc/reducer.min.nonnull).\n\nThe `reducer.min.forbid-nulls` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.forbid-nulls"},{name:"reducer.min.nonnull",detail:" reducer.min.nonnull  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.min.forbid-nulls`](/doc/reducer.min.forbid-nulls).\n\nThe `reducer.min.nonnull` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.nonnull"},{name:"reducer.or",detail:" reducer.or  reducer<AGGREGATOR>",documentation:"The `reducer.or` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or"},{name:"reducer.or.exclude-nulls",detail:" reducer.or.exclude-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.or.exclude-nulls` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or.exclude-nulls"},{name:"reducer.percentile",detail:" reducer.percentile  reducer<AGGREGATOR>",documentation:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values for each tick.\n\nFor this reducer, GTS must be aligned and must have a value for each tick of each GTS. \n\nThe returned location and elevation are those of the chosen value.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.percentile"},{name:"reducer.product",detail:" reducer.product  reducer<AGGREGATOR>",documentation:"This reducer function computes the product of all the values for each tick.\n\nThe `reducer.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.product"},{name:"reducer.rms",detail:" reducer.rms  reducer<AGGREGATOR>",documentation:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIf one value is null, there won't be any result for the concerned tick.\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms"},{name:"reducer.rms.exclude-nulls",detail:" reducer.rms.exclude-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms. Even if input GTS are misaligned, there will be one result per tick.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms.exclude-nulls"},{name:"reducer.sd",detail:"bessel<BOOLEAN>  reducer.sd  reducer<AGGREGATOR>",documentation:"The `reducer.sd` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd"},{name:"reducer.sd.forbid-nulls",detail:"bessel<BOOLEAN>  reducer.sd.forbid-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.sd.forbid-nulls` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd.forbid-nulls"},{name:"reducer.shannonentropy.0",detail:" reducer.shannonentropy.0  reducer<AGGREGATOR>",documentation:"The `reducer.shannonentropy.0` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 0 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.0"},{name:"reducer.shannonentropy.1",detail:" reducer.shannonentropy.1  reducer<AGGREGATOR>",documentation:"The `reducer.shannonentropy.1` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 1 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.1"},{name:"reducer.sum",detail:" reducer.sum  reducer<AGGREGATOR>",documentation:"The `reducer.sum` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum"},{name:"reducer.sum.forbid-nulls",detail:" reducer.sum.forbid-nulls  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.sum.nonnull`](/doc/reducer.sum.nonnull).\n\nThe `reducer.sum.forbid-nulls` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.forbid-nulls"},{name:"reducer.sum.nonnull",detail:" reducer.sum.nonnull  reducer<AGGREGATOR>",documentation:"Alias of [`reducer.sum.forbid-nulls`](/doc/reducer.sum.forbid-nulls).\n\nThe `reducer.sum.nonnull` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.nonnull"},{name:"reducer.var",detail:"bessel<BOOLEAN>  reducer.var  reducer<AGGREGATOR>",documentation:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var"},{name:"reducer.var.forbid-nulls",detail:"bessel<BOOLEAN>  reducer.var.forbid-nulls  reducer<AGGREGATOR>",documentation:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var.forbid-nulls"},{name:"s",detail:"input<NUMBER>  s  output<LONG>",documentation:"Converts a number of seconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of seconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of seconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of seconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"s"},{name:"us",detail:"input<NUMBER>  us  output<LONG>",documentation:"Converts a number of microseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of microseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of microseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of microseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"us"},{name:"w",detail:"input<NUMBER>  w  output<LONG>",documentation:"Converts a number of weeks (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of weeks from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of weeks to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of weeks\n\n",tags:["date"],since:"1.0.0",OPB64name:"w"},{name:"{",detail:" {  mark<MARK>",documentation:"Starts a map creation.\n\nThe `{` function creates a map by pushing a mark onto the stack. This is a syntactic help to better present map constructions. This function behaves like [`MARK`].\n\n@param `mark` A MARK object.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"Tk"},{name:"{}",detail:" {}  newmap<MAP>",documentation:"The {} function creates an empty MAP on the top of the stack.\n\n\n@param `newmap` Empty map instance.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"Tro"},{name:"|",detail:"p1<LONG> p2<LONG>  |  result<LONG>\ninputgts<GTS> mask<LONG>  |  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  |  outputgts<GTS>",documentation:"Performs a bitwise **OR** operation.\n\nThe `|` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **OR**.\n \nSince Warp 10™ 2.1, `|` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be OR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with OR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts OR with mask\n\n",tags:["binary","operators"],since:"1.0.0",OPB64name:"U."},{name:"||",detail:"p1<BOOLEAN> p2<BOOLEAN>  ||  result<BOOLEAN>\nl<LIST>  ||  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  ||  gtsresult<GTS>",documentation:"The `||` operator is a synonymous for [`OR`](/doc/OR).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `||` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"U6k"},{name:"}",detail:"mark<MARK> k1<ANY> v1<ANY> kN<ANY> vN<ANY>  }  map<MAP>",documentation:"Closes a currently open map and pushes it onto the stack.\n\nThe `}` function pops from the stack the elements (key/value pairs) of the map up to the first mark. The marks are consumed.\n\n@param `k1` The first key\n\n@param `v1` The first value\n\n@param `kN` The Nth key\n\n@param `vN` The Nth value\n\n@param `map` The built map\n\n@param `mark` The mark indicating the deepest level to consider when building the map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"UF"},{name:"~",detail:"param<LONG>  ~  result<LONG>",documentation:"Computes the unary bitwise complement of the long value on top of the stack.\n\n@param `param` Value to compute\n\n@param `result` Bitwise result\n\n",tags:["operators","binary","math"],since:"1.0.0",OPB64name:"UV"},{name:"~=",detail:"p2<DOUBLE> p1<DOUBLE> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<LONG> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<LONG> p1<DOUBLE> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<COUNTER> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<COUNTER> p1<DOUBLE> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<DOUBLE> lambda<LONG>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<LONG> lambda<LONG>  ~=  result<BOOLEAN>\np2<LONG> p1<DOUBLE> lambda<LONG>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<COUNTER> lambda<LONG>  ~=  result<BOOLEAN>\np2<COUNTER> p1<DOUBLE> lambda<LONG>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<DOUBLE> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<LONG> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<LONG> p1<DOUBLE> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<COUNTER> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<COUNTER> p1<DOUBLE> lambda<COUNTER>  ~=  result<BOOLEAN>",documentation:"The `~=` operator consumes three parameters from the top of the stack, two operands p1 and p2 and a tolerance factor lambda, \nand pushes onto the stack true if *|p1-p2| < lambda*, i.e. the difference between the two operands is lesser than lambda.\n\nThe two parameters must be of numeric types.\n\nThe operator `~=` is useful when making comparaisons between doubles, where floating point operations generate rounding errors.\n\n@param `p1` First number\n\n@param `p2` Second number\n\n@param `lambda` Tolerance factor lambda\n\n@param `result` \n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"UYo"}];var L=t.languages.CompletionItemKind,N=function(){function e(e){this.languageId=e}return e.prototype._provideCompletionItems=function(n,a,i,o,s,r){var l=this,c={suggestions:[]};return s.forEach((function(t){var n={label:l.transformKeyWord(t.name),insertText:l.transformKeyWord(t.name),range:void 0,kind:e.getType(t.tags,t.name)};c.suggestions.push(n)})),Object.keys(r).forEach((function(e){var n=r[e];c.suggestions.push({label:e,kind:t.languages.CompletionItemKind.Snippet,insertTextRules:t.languages.CompletionItemInsertTextRule.InsertAsSnippet,documentation:n.prefix,insertText:n.body.join("\n")})})),Promise.resolve(c)},e.getType=function(e,t){var n=e.join(" ");return n.indexOf("constant")>-1?L.Enum:n.indexOf("reducer")>-1&&"REDUCE"!==t||n.indexOf("mapper")>-1&&"MAP"!==t||n.indexOf("bucketize")>-1&&"BUCKETIZE"!==t||n.indexOf("filter")>-1&&"FILTER"!==t?L.Interface:n.indexOf("control")>-1?L.Keyword:n.indexOf("operators")>-1?L.Method:n.indexOf("stack")>-1?L.Module:L.Function},e}(),v=function(){function e(){}return e.formatElapsedTime=function(e){return e<1e3?e.toFixed(3)+" ns":e<1e6?(e/1e3).toFixed(3)+" μs":e<1e9?(e/1e6).toFixed(3)+" ms":e<1e12?(e/1e9).toFixed(3)+" s ":(e/6e10).toFixed(3)+" m "},e}();v.WARPSCRIPT_LANGUAGE="warpscript",v.FLOWS_LANGUAGE="flows";var w=function(){};w.snippets={macro:{prefix:"macro (example)",body:["{","  'name' '${1:euclideanDivision}'","  'desc' ","  <'","${2:This macro returns the quotient and the remainder of a/b.}","  '>","  'sig' [ [ [ ${3:'a:LONG' 'b:LONG'} ] [ ${4:'q:LONG' 'r:LONG'} ] ] ] // Signature","  'params' {","    // Signature params description","    ${5:'b' 'parameter b TOP of the stack'","    'a' 'parameter a just below on the stack'","    'q' 'the quotient of a/b, N-1 on the stack'","    'r' 'the remainder of a/b, on the TOP of the stack'}","  }","  'examples' [","    <'","${6:10 3 @mymacros/euclideanDivision [ 'q' 'r' ] STORE","'quotient is  :' \\$q TOSTRING +","'remainder is :' \\$r TOSTRING +}","    '>","  ]","} 'info' STORE","","<%","  !\\$info INFO","  SAVE 'context' STORE","  <%","    // Code of the actual macro","    ${7:[ 'a' 'b' ] STORE","    \\$a \\$b / TOLONG","    \\$a \\$b %}","      ","  %>","  <% // catch any exception","    RETHROW","  %>","  <% // finally, restore the context","    \\$context RESTORE","  %> TRY","%>","'macro' STORE","","// Unit tests","${8:10 3 @macro [ 'q' 'r' ] STORE","\\$q 3 == ASSERT","\\$r 1 == ASSERT","\\$q TYPEOF 'LONG' == ASSERT","\\$r TYPEOF 'LONG' == ASSERT}","","\\$macro"],description:"Macro"},"macro(empty)":{prefix:"macro (empty)",body:["{","  'name' '${1: }'","  'desc' ","  <'","${2: }","  '>","  'sig' [ [ [   ] [   ] ] ] // Signature","  'params' {","    // Signature params description","  }","  'examples' [","    <'","","    '>","  ]","} 'info' STORE","","<%","  !\\$info INFO","  SAVE 'context' STORE","  <%","    // Code of the actual macro","    ${3:  }","  %>","  <% // catch any exception","    RETHROW","  %>","  <% // finally, restore the context","    \\$context RESTORE","  %> TRY","%>","'macro' STORE","","// Unit tests","","\\$macro"],description:"Macro"},fetch:{prefix:"fetch",body:["[ 'TOKEN' 'className'  { 'label0' '=value0'  'label1' '~val.' }  start timespan ] FETCH"]},bucketize:{prefix:"bucketize",body:["[ ${1:gts} ${2|MACROBUCKETIZER,bucketizer.and,bucketizer.count,bucketizer.count.exclude-nulls,bucketizer.count.include-nulls,bucketizer.count.nonnull,bucketizer.first,bucketizer.join,bucketizer.join.forbid-nulls,bucketizer.last,bucketizer.max,bucketizer.max.forbid-nulls,bucketizer.mean,bucketizer.mean.circular,bucketizer.mean.circular.exclude-nulls,bucketizer.mean.exclude-nulls,bucketizer.median,bucketizer.min,bucketizer.min.forbid-nulls,bucketizer.or,bucketizer.sum,bucketizer.sum.forbid-nulls|} ${3:lastbucket} ${4:bucketspan} ${5:bucketcount} ] BUCKETIZE"]},filter:{prefix:"filter",body:["[ ${1:gts} [${2:labels}] ${3|MACROFILTER,filter.byattr,filter.byclass,filter.bylabels,filter.bylabelsattr,filter.bymetadata,filter.last.eq,filter.last.ge,filter.last.gt,filter.last.le,filter.last.lt,filter.last.ne,filter.latencies|} ] FILTER"]},map:{prefix:"map",body:["[ ${1:gts} ${2|MACROMAPPER,mapper.abs,mapper.add,mapper.and,mapper.ceil,mapper.count,mapper.count.exclude-nulls,mapper.count.include-nulls,mapper.count.nonnull,mapper.day,mapper.delta,mapper.dotproduct,mapper.dotproduct.positive,mapper.dotproduct.sigmoid,mapper.dotproduct.tanh,mapper.eq,mapper.exp,mapper.finite,mapper.first,mapper.floor,mapper.ge,mapper.geo.approximate,mapper.geo.clear,mapper.geo.outside,mapper.geo.within,mapper.gt,mapper.hdist,mapper.highest,mapper.hour,mapper.hspeed,mapper.join,mapper.join.forbid-nulls,mapper.kernel.cosine,mapper.kernel.epanechnikov,mapper.kernel.gaussian,mapper.kernel.logistic,mapper.kernel.quartic,mapper.kernel.silverman,mapper.kernel.triangular,mapper.kernel.tricube,mapper.kernel.triweight,mapper.kernel.uniform,mapper.last,mapper.le,mapper.log,mapper.lowest,mapper.lt,mapper.mad,mapper.max,mapper.max.forbid-nulls,mapper.max.x,mapper.mean,mapper.mean.circular,mapper.mean.circular.exclude-nulls,mapper.mean.exclude-nulls,mapper.median,mapper.min,mapper.min.forbid-nulls,mapper.min.x,mapper.minute,mapper.mod,mapper.month,mapper.mul,mapper.ne,mapper.npdf,mapper.or,mapper.parsedouble,mapper.percentile,mapper.pow,mapper.product,mapper.rate,mapper.replace,mapper.round,mapper.sd,mapper.sd.forbid-nulls,mapper.second,mapper.sigmoid,mapper.sqrt,mapper.sum,mapper.sum.forbid-nulls,mapper.tanh,mapper.tick,mapper.toboolean,mapper.todouble,mapper.tolong,mapper.tostring,mapper.truecourse,mapper.var,mapper.var.forbid-nulls,mapper.vdist,mapper.vspeed,mapper.weekday,mapper.year,max.tick.sliding.window,max.time.sliding.window|} ${3:pre} ${4:post} ${5:occurrences} ] MAP"]},reduce:{prefix:"reduce",body:["[ ${1:gts} [${2:labels}] ${3|MACROREDUCER,reducer.and,reducer.and.exclude-nulls,reducer.argmax,reducer.argmin,reducer.count,reducer.count.exclude-nulls,reducer.count.include-nulls,reducer.count.nonnull,reducer.join,reducer.join.forbid-nulls,reducer.join.nonnull,reducer.join.urlencoded,reducer.max,reducer.max.forbid-nulls,reducer.max.nonnull,reducer.mean,reducer.mean.circular,reducer.mean.circular.exclude-nulls,reducer.mean.exclude-nulls,reducer.median,reducer.min,reducer.min.forbid-nulls,reducer.min.nonnull,reducer.or,reducer.or.exclude-nulls,reducer.sd,reducer.sd.forbid-nulls,reducer.shannonentropy.0,reducer.shannonentropy.1,reducer.sum,reducer.sum.forbid-nulls,reducer.sum.nonnull,reducer.var,reducer.var.forbid-nulls|} ] REDUCE"]},apply:{prefix:"apply",body:["[ ${1:gts} [${2:labels}] ${3|OP,op.add,op.add.ignore-nulls,op.and,op.and.ignore-nulls,op.div,op.eq,op.ge,op.gt,op.le,op.lt,op.mask,op.mul,op.mul.ignore-nulls,op.ne,op.negmask,op.or,op.or.ignore-nulls,op.sub|} ] APPLY"],description:"Apply framework"},ift:{prefix:"ift",body:["<% ${1:condition} %>","<% ${2:action_if_true} %>","IFT"],description:"If statement"},ifte:{prefix:"ifte",body:["<% ${1:condition} %>","<% ${2:action_if_true} %>","<% ${3:action_if_false} %>","IFTE"],description:"If then else statement"},switch:{prefix:"switch",body:["<% ${1:case_1} %> <% ${2:action_1} %>","<% ${3:case_2} %> <% ${4:action_2} %>","<% ${5:case_3} %> <% ${6:action_3} %>","<% ${7:default} %>","${8:number_of_cases}","SWITCH"],description:"Switch statement"},try:{prefix:"try",body:["<% ${1:try} %>","<% ${2:catch} %>","<% ${3:finally} %>","TRY"],description:"Try/Catch statement"},while:{prefix:"while",body:["<% ${1:condition} %>","<% ${2:action_while_true} %>","WHILE"],description:"While loop"},until:{prefix:"until",body:["<% ${1:action_until_true} %>","<% ${2:condition} %>","UNTIL"],description:"Until loop"},for:{prefix:"for",body:["${1:initial_value} ${2:final_value}","<% ${3:action} %>","FOR"],description:"For loop"},foreach:{prefix:"foreach",body:["${1:object}","<% ","  //[ 'key' 'value' ] STORE // object is a map","  //[ 'value' ] STORE // object is a list","  ${2:action}","%>","FOREACH"],description:"Foreach loop"},forstep:{prefix:"forstep",body:["${1:initial_value} ${2:final_value} <% ${3:1 +} %>","<% ${4:action} %>","FORSTEP"],description:"Forstep loop"},shm:{prefix:"shm",body:["<%","  <%","    //try to read data from SHared Memory","    'gtsList' SHMLOAD DROP","  %>","  <%","    //when not found, store data in SHM","    ${1:[ \\$token 'classname' {\\} NOW 365 d ] FETCH} 'gtsList' SHMSTORE","  %>","  <%","    //finally, load the reference from SHM and store it ","    'gtsList' SHMLOAD 'gtsList' STORE","  %> TRY","","  //analytics on \\$gtsList","  ${2:\\$gtsList}","","","","%> 'myMutex' MUTEX //prevent a concurrent execution on the same SHM data"],description:"Keep fetched data in RAM. You need to enable the SHM extension."}};var R=function(e){function t(){return e.call(this,v.WARPSCRIPT_LANGUAGE)||this}return T(t,e),t.prototype.transformKeyWord=function(e){return e},t.prototype.provideCompletionItems=function(t,n,a,i){return e.prototype._provideCompletionItems.call(this,t,n,a,i,b.reference,w.snippets)},t}(N),I=function(){};I.rules={keywords:["!","!=","%","&","&&","(","()",")","*","**","+","+!","-","->B64","->B64URL","->BIN","->BYTES","->DOUBLEBITS","->ENCODER","->ENCODERS","->FLOATBITS","->GEOCELL","->GEOHASH","->GEOJSON","->GEOSHAPE","->GTS","->GTSHHCODE","->GTSHHCODELONG","->HEX","->HHCODE","->HHCODELONG","->JSON","->LIST","->LONGBYTES","->MAP","->MAT","->MVSTRING","->OPB64","->PICKLE","->Q","->SET","->TSELEMENTS","->V","->VARINT","->VEC","->WKB","->WKT","->Z","/","<","<<","<=","==",">",">=",">>",">>>","ABS","ACCEL.CACHE","ACCEL.NOCACHE","ACCEL.NOPERSIST","ACCEL.PERSIST","ACCEL.REPORT","ACOS","ADDDAYS","ADDDURATION","ADDEXACT","ADDMONTHS","ADDVALUE","ADDYEARS","AESUNWRAP","AESWRAP","AGO","AND","APPEND","APPLY","ASENCODERS","ASIN","ASREGS","ASSERT","ASSERTMSG","ATAN","ATAN2","ATBUCKET","ATINDEX","ATTICK","ATTRIBUTES","AUTHENTICATE","B64->","B64TOHEX","B64URL->","BBOX","BIN->","BINTOHEX","BITCOUNT","BITGET","BITSTOBYTES","BOOTSTRAP","BREAK","BUCKETCOUNT","BUCKETIZE","BUCKETIZE.CALENDAR","BUCKETSPAN","BYTES->","BYTESTOBITS","CALL","CBRT","CEIL","CEVAL","CHECKMACRO","CHECKSHAPE","CHRONOEND","CHRONOSTART","CHRONOSTATS","CHUNK","CHUNKENCODER","CLEAR","CLEARDEFS","CLEARREGS","CLEARSYMBOLS","CLEARTOMARK","CLIP","CLONE","CLONEEMPTY","CLONEREVERSE","COMMONTICKS","COMPACT","CONTAINS","CONTAINSKEY","CONTAINSVALUE","CONTINUE","COPYGEO","COPYSIGN","CORRELATE","COS","COSH","COUNTER","COUNTERDELTA","COUNTERSET","COUNTERVALUE","COUNTTOMARK","CPOPR","CPROB","CROP","CSTORE","DEBUGOFF","DEBUGON","DECREMENTEXACT","DEDUP","DEF","DEFINED","DEFINEDMACRO","DEFLATE","DELETE","DELETEOFF","DELETEON","DEPTH","DEREF","DET","DIFFERENCE","DISCORDS","DOC","DOCMODE","DOUBLEBITS->","DOUBLEEXPONENTIALSMOOTHING","DROP","DROPN","DTW","DUP","DUPN","DURATION","DWTSPLIT","E","ECGEN","ECHOOFF","ECHOON","ECPRIVATE","ECPUBLIC","ECSIGN","ECVERIFY","ELAPSED","ELEVATIONS","EMPTY","ENCODER->","ERROR","ESDTEST","EVALSECURE","EVERY","EXP","EXPM1","EXPORT","EXTLOADED","F","FDWT","FETCH","FETCHBOOLEAN","FETCHDOUBLE","FETCHLONG","FETCHSTRING","FFT","FFTAP","FFTWINDOW","FILL","FILLNEXT","FILLPREVIOUS","FILLTICKS","FILLVALUE","FILTER","FILTERBY","FIND","FINDSETS","FINDSTATS","FIRSTTICK","FLATTEN","FLOATBITS->","FLOOR","FLOORDIV","FLOORMOD","FORGET","FROMBIN","FROMBITS","FROMHEX","FUNCTIONS","FUSE","GEO.BUFFER","GEO.COVER","GEO.COVER.RL","GEO.DIFFERENCE","GEO.INTERSECTION","GEO.INTERSECTS","GEO.JSON","GEO.JSON.UNIFORM","GEO.NORMALIZE","GEO.OPTIMIZE","GEO.REGEXP","GEO.UNION","GEO.WITHIN","GEO.WKB","GEO.WKB.UNIFORM","GEO.WKT","GEO.WKT.UNIFORM","GEOCELL->","GEOHASH->","GEOPACK","GEOSHAPE->","GEOSHIFT","GEOSPLIT","GEOUNPACK","GET","GETEXPONENT","GETHOOK","GETSECTION","GOLDWRAP","GROUPBY","GRUBBSTEST","GTSHHCODE->","GZIP","HASH","HAVERSINE","HEADER","HEX->","HEXTOB64","HEXTOBIN","HHCODE->","HHCODE.BBOX","HHCODE.CENTER","HHCODE.EAST","HHCODE.NORTH","HHCODE.NORTH.EAST","HHCODE.NORTH.WEST","HHCODE.SOUTH","HHCODE.SOUTH.EAST","HHCODE.SOUTH.WEST","HHCODE.WEST","HIDE","HLOCATE","HULLSHAPE","HUMANDURATION","HYBRIDTEST","HYBRIDTEST2","HYPOT","IDENT","IDWT","IEEEREMAINDER","IFFT","IMMUTABLE","IMPORT","INCREMENTEXACT","INFLATE","INFO","INFOMODE","INTEGRATE","INTERPOLATE","INTERSECTION","INV","ISAUTHENTICATED","ISNULL","ISNaN","ISO8601","ISODURATION","ISONORMALIZE","JOIN","JSON->","JSONLOOSE","JSONSTACK","JSONSTRICT","KEYLIST","KURTOSIS","LABELS","LASTACTIVITY","LASTBUCKET","LASTSORT","LASTTICK","LBOUNDS","LFLATMAP","LIMIT","LINEOFF","LINEON","LIST->","LMAP","LOAD","LOCATIONOFFSET","LOCATIONS","LOCSTRINGS","LOG","LOG10","LOG1P","LOGEVENT->","LOGMSG","LOWESS","LR","LSORT","LTTB","MACROBUCKETIZER","MACROCONFIG","MACROCONFIGDEFAULT","MACROCONFIGSECRET","MACROFILLER","MACROTTL","MAKEGTS","MAN","MAP","MAP->","MAPID","MARK","MAT->","MATCH","MATCHER","MAX","MAXBUCKETS","MAXDEPTH","MAXGEOCELLS","MAXGTS","MAXJSON","MAXLONG","MAXLOOP","MAXOPS","MAXPIXELS","MAXRECURSION","MAXSYMBOLS","MAXURLFETCHCOUNT","MAXURLFETCHSIZE","MD5","MERGE","META","METADIFF","METAOFF","METAON","METASET","METASORT","MIN","MINLONG","MINREV","MMAP","MODE","MONOTONIC","MOTIONSPLIT","MSORT","MSTU","MULTIPLYEXACT","MUSIGMA","MUTEX","MVELEVATIONS","MVHHCODES","MVINDEXSPLIT","MVLOCATIONS","MVTICKS","MVTICKSPLIT","MVVALUES","NAME","NBOUNDS","NDEBUGON","NEGATEEXACT","NEWENCODER","NEWGTS","NEXTAFTER","NEXTDOWN","NEXTUP","NOLOG","NONEMPTY","NONNULL","NOOP","NORMALIZE","NOT","NOTAFTER","NOTBEFORE","NOTIMINGS","NOW","NPDF","NPEEK","NSUMSUMSQ","ONLYBUCKETS","OPB64->","OPB64TOHEX","OPS","OPTDTW","OPTIMIZE","OR","PACK","PAPPLY","PARSE","PARSESELECTOR","PARSEVALUE","PARTITION","PATTERNDETECTION","PATTERNS","PEEK","PEEKN","PERMUTE","PFILTER","PGraphics","PI","PICK","PICKLE->","PIGSCHEMA","PIVOT","PIVOTSTRICT","POPR","PREDUCE","PRNG","PROB","PROBABILITY","PSTACK","PUSHR","PUT","Palpha","Parc","Pbackground","PbeginContour","PbeginShape","Pbezier","PbezierDetail","PbezierPoint","PbezierTangent","PbezierVertex","Pblend","PblendMode","Pblue","Pbox","Pbrightness","Pclear","Pclip","Pcolor","PcolorMode","Pconstrain","Pcopy","PcreateFont","Pcurve","PcurveDetail","PcurvePoint","PcurveTangent","PcurveTightness","PcurveVertex","Pdecode","Pdist","Pellipse","PellipseMode","Pencode","PendContour","PendShape","Pfill","Pfilter","Pget","Pgreen","Phue","Pimage","PimageMode","Plerp","PlerpColor","Pline","PloadShape","Pmag","Pmap","Pmask","PnoClip","PnoFill","PnoStroke","PnoTint","Pnorm","Ppixels","Ppoint","PpopMatrix","PpopStyle","PpushMatrix","PpushStyle","Pquad","PquadraticVertex","Prect","PrectMode","Pred","PresetMatrix","Protate","Psaturation","Pscale","Pset","Pshape","PshapeMode","PshearX","PshearY","Psize","Psphere","PsphereDetail","Pstroke","PstrokeCap","PstrokeJoin","PstrokeWeight","Ptext","PtextAlign","PtextAscent","PtextDescent","PtextFont","PtextLeading","PtextMode","PtextSize","PtextWidth","Ptint","PtoImage","Ptranslate","Ptriangle","PupdatePixels","Pvertex","Q->","QCONJUGATE","QDIVIDE","QMULTIPLY","QROTATE","QROTATION","QUANTIZE","RAND","RANDOM","RANDPDF","RANGE","RANGECOMPACT","RAWDTW","REDEFS","REDUCE","RELABEL","REMOVE","REMOVETICK","RENAME","REOPTALT","REPLACE","REPLACEALL","REPORT","RESET","RESETS","RESHAPE","RESTORE","REV","REVBITS","REVERSE","REXEC","REXECZ","RINT","RLOWESS","ROLL","ROLLD","ROT","ROTATIONQ","ROUND","RSADECRYPT","RSAENCRYPT","RSAGEN","RSAPRIVATE","RSAPUBLIC","RSASIGN","RSAVERIFY","RSORT","RTFM","RUN","RUNNERNONCE","RUNR","RVALUESORT","SAVE","SCALB","SECTION","SECURE","SECUREKEY","SENSISION.DUMP","SENSISION.DUMPEVENTS","SENSISION.EVENT","SENSISION.GET","SENSISION.SET","SENSISION.UPDATE","SET","SET->","SETATTRIBUTES","SETMACROCONFIG","SETVALUE","SHA1","SHA1HMAC","SHA256","SHA256HMAC","SHAPE","SHMLOAD","SHMSTORE","SHOW","SHRINK","SHUFFLE","SIGNUM","SIN","SINGLEEXPONENTIALSMOOTHING","SINH","SIZE","SKEWNESS","SMARTPARSE","SNAPSHOT","SNAPSHOTALL","SNAPSHOTALLTOMARK","SNAPSHOTCOPY","SNAPSHOTCOPYALL","SNAPSHOTCOPYALLTOMARK","SNAPSHOTCOPYN","SNAPSHOTCOPYTOMARK","SNAPSHOTN","SNAPSHOTTOMARK","SORT","SORTBY","SORTWITH","SPLIT","SQRT","SRAND","SRANDPDF","STACKATTRIBUTE","STACKPSSECRET","STACKTOLIST","STANDARDIZE","STDERR","STDOUT","STL","STLESDTEST","STOP","STORE","STRICTPARTITION","STRINGFORMAT","STU","SUBLIST","SUBMAP","SUBSTRING","SUBTRACTEXACT","SWAP","SYMBOLS","SYNC","T","TAN","TANH","TDESCRIBE","TEMPLATE","THRESHOLDTEST","TICKINDEX","TICKLIST","TICKS","TIMEBOX","TIMECLIP","TIMED","TIMEMODULO","TIMEOFF","TIMEON","TIMESCALE","TIMESHIFT","TIMESPLIT","TIMINGS","TLTTB","TOBIN","TOBITS","TOBOOLEAN","TODEGREES","TODOUBLE","TOHEX","TOINTEXACT","TOKENDUMP","TOKENGEN","TOKENINFO","TOKENSECRET","TOLONG","TOLOWER","TORADIANS","TOSELECTOR","TOSTRING","TOTIMESTAMP","TOUPPER","TR","TRANSPOSE","TRIM","TSELEMENTS","TSELEMENTS->","TYPEOF","ULP","UNBUCKETIZE","UNBUCKETIZE.CALENDAR","UNGZIP","UNION","UNIQUE","UNLIST","UNMAP","UNPACK","UNSECURE","UNSET","UNWRAP","UNWRAPEMPTY","UNWRAPENCODER","UNWRAPSIZE","UPDATE","UPDATEOFF","UPDATEON","URLDECODE","URLENCODE","URLFETCH","UUID","V->","VALUEDEDUP","VALUEHISTOGRAM","VALUELIST","VALUES","VALUESORT","VALUESPLIT","VARINT->","VARS","VEC->","WEBCALL","WF.ADDREPO","WF.GETREPOS","WF.SETREPOS","WFOFF","WFON","WRAP","WRAPFAST","WRAPMV","WRAPMV!","WRAPOPT","WRAPRAW","WRAPRAWOPT","WSINFO","WSKILL","WSKILLSESSION","WSNAME","WSPS","WSSESSION","WSSTACK","WSSTOP","WSSTOPSESSION","Z->","ZDISCORDS","ZDTW","ZIP","ZPATTERNDETECTION","ZPATTERNS","ZSCORE","ZSCORETEST","[","[[","[[]]","[]","]","]]","^","bucketizer.and","bucketizer.or","d","e","filler.interpolate","filler.next","filler.previous","filler.trend","filter.latencies","h","m","mapper.and","mapper.finite","mapper.geo.approximate","mapper.geo.clear","mapper.geo.fence","mapper.geo.outside","mapper.geo.within","mapper.hdist","mapper.median","mapper.median.forbid-nulls","mapper.mod","mapper.npdf","mapper.or","mapper.percentile","mapper.truecourse","max.tick.sliding.window","max.time.sliding.window","ms","ns","op.add","op.add.ignore-nulls","op.and","op.and.ignore-nulls","op.div","op.eq","op.ge","op.gt","op.le","op.lt","op.mask","op.mul","op.mul.ignore-nulls","op.ne","op.negmask","op.or","op.or.ignore-nulls","op.sub","pi","ps","reducer.and","reducer.and.exclude-nulls","s","us","w","{","{}","|","||","}","~","~="],constants:["E","F","MAXLONG","MINLONG","NULL","NaN","PI","T","e","pi"],functions:["BUCKETIZE","BUCKETIZE.CALENDAR","FILTER","MACROBUCKETIZER","MACROFILTER","MACROMAPPER","MACROREDUCER","MAP","PFILTER","PREDUCE","REDUCE","STRICTMAPPER","STRICTREDUCER","UNBUCKETIZE.CALENDAR","bucketizer.and","bucketizer.count","bucketizer.count.exclude-nulls","bucketizer.count.include-nulls","bucketizer.count.nonnull","bucketizer.first","bucketizer.join","bucketizer.join.forbid-nulls","bucketizer.last","bucketizer.mad","bucketizer.max","bucketizer.max.forbid-nulls","bucketizer.mean","bucketizer.mean.circular","bucketizer.mean.circular.exclude-nulls","bucketizer.mean.exclude-nulls","bucketizer.median","bucketizer.median.forbid-nulls","bucketizer.min","bucketizer.min.forbid-nulls","bucketizer.or","bucketizer.percentile","bucketizer.rms","bucketizer.sd","bucketizer.sd.forbid-nulls","bucketizer.sum","bucketizer.sum.forbid-nulls","filter.all.eq","filter.all.ge","filter.all.gt","filter.all.le","filter.all.lt","filter.all.ne","filter.any.eq","filter.any.ge","filter.any.gt","filter.any.le","filter.any.lt","filter.any.ne","filter.byattr","filter.byclass","filter.bylabels","filter.bylabelsattr","filter.bymetadata","filter.byselector","filter.bysize","filter.last.eq","filter.last.ge","filter.last.gt","filter.last.le","filter.last.lt","filter.last.ne","filter.latencies","mapper.abs","mapper.add","mapper.and","mapper.ceil","mapper.count","mapper.count.exclude-nulls","mapper.count.include-nulls","mapper.count.nonnull","mapper.day","mapper.delta","mapper.dotproduct","mapper.dotproduct.positive","mapper.dotproduct.sigmoid","mapper.dotproduct.tanh","mapper.eq","mapper.eq.elev","mapper.eq.hhcode","mapper.eq.lat","mapper.eq.lon","mapper.eq.tick","mapper.exp","mapper.finite","mapper.first","mapper.floor","mapper.ge","mapper.ge.elev","mapper.ge.hhcode","mapper.ge.lat","mapper.ge.lon","mapper.ge.tick","mapper.geo.approximate","mapper.geo.clear","mapper.geo.fence","mapper.geo.outside","mapper.geo.within","mapper.gt","mapper.gt.elev","mapper.gt.hhcode","mapper.gt.lat","mapper.gt.lon","mapper.gt.tick","mapper.hdist","mapper.highest","mapper.hour","mapper.hspeed","mapper.join","mapper.join.forbid-nulls","mapper.kernel.cosine","mapper.kernel.epanechnikov","mapper.kernel.gaussian","mapper.kernel.logistic","mapper.kernel.quartic","mapper.kernel.silverman","mapper.kernel.triangular","mapper.kernel.tricube","mapper.kernel.triweight","mapper.kernel.uniform","mapper.last","mapper.le","mapper.le.elev","mapper.le.hhcode","mapper.le.lat","mapper.le.lon","mapper.le.tick","mapper.log","mapper.lowest","mapper.lt","mapper.lt.elev","mapper.lt.hhcode","mapper.lt.lat","mapper.lt.lon","mapper.lt.tick","mapper.mad","mapper.max","mapper.max.forbid-nulls","mapper.max.x","mapper.mean","mapper.mean.circular","mapper.mean.circular.exclude-nulls","mapper.mean.exclude-nulls","mapper.median","mapper.median.forbid-nulls","mapper.min","mapper.min.forbid-nulls","mapper.min.x","mapper.minute","mapper.mod","mapper.month","mapper.mul","mapper.ne","mapper.ne.elev","mapper.ne.hhcode","mapper.ne.lat","mapper.ne.lon","mapper.ne.tick","mapper.npdf","mapper.or","mapper.parsedouble","mapper.percentile","mapper.pow","mapper.product","mapper.rate","mapper.replace","mapper.rms","mapper.round","mapper.sd","mapper.sd.forbid-nulls","mapper.second","mapper.sigmoid","mapper.sqrt","mapper.sum","mapper.sum.forbid-nulls","mapper.tanh","mapper.tick","mapper.toboolean","mapper.todouble","mapper.tolong","mapper.tostring","mapper.truecourse","mapper.var","mapper.var.forbid-nulls","mapper.vdist","mapper.vspeed","mapper.weekday","mapper.year","max.tick.sliding.window","max.time.sliding.window","reducer.and","reducer.and.exclude-nulls","reducer.argmax","reducer.argmin","reducer.count","reducer.count.exclude-nulls","reducer.count.include-nulls","reducer.count.nonnull","reducer.join","reducer.join.forbid-nulls","reducer.join.nonnull","reducer.join.urlencoded","reducer.mad","reducer.max","reducer.max.forbid-nulls","reducer.max.nonnull","reducer.mean","reducer.mean.circular","reducer.mean.circular.exclude-nulls","reducer.mean.exclude-nulls","reducer.median","reducer.median.forbid-nulls","reducer.min","reducer.min.forbid-nulls","reducer.min.nonnull","reducer.or","reducer.or.exclude-nulls","reducer.percentile","reducer.product","reducer.rms","reducer.rms.exclude-nulls","reducer.sd","reducer.sd.forbid-nulls","reducer.shannonentropy.0","reducer.shannonentropy.1","reducer.sum","reducer.sum.forbid-nulls","reducer.sum.nonnull","reducer.var","reducer.var.forbid-nulls"],control:["BREAK","CHECKMACRO","CONTINUE","CUDF","DEFINED","DEFINEDMACRO","EVAL","FAIL","FOR","FOREACH","FORSTEP","IFT","IFTE","MSGFAIL","NRETURN","RETHROW","RETURN","SWITCH","TRY","UDF","UNTIL","WHILE"],operators:["!","!=","%","&","&&","*","**","+","+!","-","/","<","<<","<=","==",">",">=",">>",">>>","AND","NOT","OR","^","|","||","~","~="],escapes:"\\\\(?:[abfnrtv\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})",tokenizer:{root:[["\\@[A-Za-z0-9._\\/]+","variable"],["\\$[A-Za-z0-9._\\/]+","variable"],["true|false","number"],["[A-Za-z_][.\\w$]*",{cases:{"@constants":"regexp","@keywords":"keyword","@functions":"type","@control":"metatag","@default":"identifier"}}],["[{}()[\\]]","@brackets"],["\\d*\\.\\d+([eE][-+]?\\d+)?[fFdD]?","number.float"],["0[xX][0-9a-fA-F_]*[0-9a-fA-F][Ll]?","number.hex"],["0[0-7_]*[0-7][Ll]?","number.octal"],["0[bB][0-1_]*[0-1][Ll]?","number.binary"],["\\d+[lL]?","number"],{include:"@whitespace"},['"([^"\\\\]|\\\\.)*$',"string.invalid"],['"',"string","@string"],["'([^'\\\\]|\\\\.)*$","string.invalid"],["'","string","@string2"],["<'","string","@string3"]],whitespace:[["[ \\t\\r\\n]+","white"],["\\/\\*","comment","@comment"],["\\/\\/.*$","comment"]],comment:[["[^\\/*]+","comment"],["\\/\\*","comment.invalid"],["\\*/","comment","@pop"],["[\\/*]","comment"]],string:[['[^\\"]+',"string"],["@escapes","string.escape"],["\\.","string.escape.invalid"],['"',"string","@pop"]],string2:[["[^\\']+","string"],["@escapes","string.escape"],["\\.","string.escape.invalid"],["'","string","@pop"]],string3:[["[^\\(<')]+","string"],["'>","string","@pop"]]}};var P=t.languages.IndentAction,y=function(){function e(){}return e.prototype.getConfiguration=function(){return{wordPattern:/[^\s\t]+/,comments:{lineComment:"//",blockComment:["/**","*/"]},brackets:[["{","}"],["[","]"],["(",")"],["<%","%>"],["<'","'>"],["[[","]]"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<%",close:"%>"},{open:"[[",close:"]]"},{open:" '",close:"'",notIn:["string","comment"]},{open:"<'",close:"'>"},{open:'"',close:'"',notIn:["string"]},{open:"`",close:"`",notIn:["string","comment"]},{open:"/**",close:" */",notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"[[",close:"]]"},{open:"<%",close:"%>"},{open:"<'",close:"'>"},{open:"'",close:"'"},{open:'"',close:'"'},{open:"`",close:"`"}],onEnterRules:[{beforeText:/^\s*\/\*\*(?!\/)([^*]|\*(?!\/))*$/,afterText:/^\s*\*\/$/,action:{indentAction:P.IndentOutdent,appendText:" * "}},{beforeText:/^\s*\/\*\*(?!\/)([^*]|\*(?!\/))*$/,action:{indentAction:P.None,appendText:" * "}},{beforeText:/^(\t|( {2}))* \*( ([^*]|\*(?!\/))*)?$/,action:{indentAction:P.None,appendText:"* "}},{beforeText:/^(\t|( {2}))* \*\/\s*$/,action:{indentAction:P.None,removeText:1}}]}},e}(),A={"!":{description:"Negates a boolean.\n\nThe `!` function is synonymous for [`NOT`](/doc/NOT). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nSince Warp 10™ 2.1, `!` can be applied on a boolean GTS to flip all values.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gtsinput` Since 2.1, a GTS with boolean value.\n\n@param `gtsresult` Since 2.1, a GTS with negated boolean value. GTS is not sorted by the operation. Metadata are kept.\n\n",signature:"input<BOOLEAN>  !  result<BOOLEAN>\ngtsinput<GTS>  !  gtsresult<GTS>",tags:["logic","operators"],since:"1.0.0",OPB64name:"7F"},"!=":{description:"Tests if both parameters are different.\n\nThe `!=` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are different, false otherwise.\n\nThe two parameters must be homogeneous of numeric, boolean or string types.\n\nSince Warp 10™ 2.1, as every other comparison operators, `!=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 !=` is strictly equivalent of a `42 mapper.ne` MAP operation, with a simplified syntax.\n\n@param `p1` First parameter to compare, anything except a GTS.\n\n@param `p2` Second parameter to compare, anything except a GTS.\n\n@param `result` True if p1 and p2 are different, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values different from constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is different from gts2 value.\n\n",signature:"p1<ANY> p2<ANY>  !=  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  !=  outgts<GTS>\nconstant<ANY> inputgts<GTS>  !=  outgts<GTS>\ngts1<GTS> gts2<GTS>  !=  outputgts<GTS>",tags:["operators"],since:"1.0.0",OPB64name:"7Io"},"%":{description:"The `%` operator consumes two parameters from the top of the stack and pushes back the remainder of the Euclidean division of the first one by the second one.\n\nThe two parameters must be of numeric types.\n\n@param `dividend` Number divided by divisor\n\n@param `divisor` Number used to divide dividend\n\n@param `modulo` Modulo of the two given parameters\n\n",signature:"divisor<LONG> dividend<LONG>  %  modulo<LONG>\ndivisor<DOUBLE> dividend<LONG>  %  modulo<DOUBLE>\ndivisor<LONG> dividend<DOUBLE>  %  modulo<DOUBLE>\ndivisor<DOUBLE> dividend<DOUBLE>  %  modulo<DOUBLE>\ndivisor<COUNTER> dividend<COUNTER>  %  modulo<LONG>\ndivisor<DOUBLE> dividend<COUNTER>  %  modulo<DOUBLE>\ndivisor<COUNTER> dividend<DOUBLE>  %  modulo<DOUBLE>\ndivisor<LONG> dividend<COUNTER>  %  modulo<LONG>\ndivisor<COUNTER> dividend<LONG>  %  modulo<LONG>",tags:["operators"],since:"1.0.0",OPB64name:"8F"},"&":{description:"Performs a bitwise **AND** operation.\n\nThe `&` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **AND**.\n\nSince Warp 10™ 2.1, `&` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be AND to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with AND between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts AND with mask\n\n",signature:"p1<LONG> p2<LONG>  &  result<LONG>\ninputgts<GTS> mask<LONG>  &  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  &  outputgts<GTS>",tags:["binary","operators"],since:"1.0.0",OPB64name:"8V"},"&&":{description:"The `&&` operator is a synonymous for [`AND`](/doc/AND).\n\nIt performs a logical **&&** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `&&` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical && applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with && between each common tick input values.\n\n",signature:"p1<BOOLEAN> p2<BOOLEAN>  &&  result<BOOLEAN>\nl<LIST>  &&  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  &&  gtsresult<GTS>",tags:["operators","logic"],since:"1.0.0",OPB64name:"8XN"},"(":{description:"Starts a set creation.\n\nThe `(` function creates a set by pushing a mark onto the stack. This is a syntactic help to better present set constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",signature:" (  mark<MARK>",tags:["sets"],since:"1.2.13",OPB64name:"9."},"()":{description:"The `()` function creates an empty SET on the top of the stack.\nA Set is a collection that cannot contain duplicate elements.\n\nThis is an implementation of java [HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html). NULL object is permitted. It makes no guarantees as to the iteration order of the set.\n\nThe SET object could not be represented on the stack.\nIt has to be converted in a list to be displayed.\n\nStoring GTS into sets do not guarantee uniqueness. each GTS has a hidden id. see example.\n\n\n@param `content` 0 to n elements.\n\n@param `newset` set instance, initialized with content.\n\n",signature:"content<ANY>  ()  newset<SET>",tags:["sets"],since:"1.2.13",OPB64name:"91Z"},")":{description:"Closes a currently open set and pushes it onto the stack.\n\nThe `)` function pops from the stack the elements of the set up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `set` The built set\n\n@param `mark` The mark indicating the deepest level to consider when building the set\n\n",signature:"mark<MARK> v1<ANY> vN<ANY>  )  set<SET>",tags:["sets"],since:"1.2.13",OPB64name:"9F"},"*":{description:"The `*` operator consumes two parameters from the top of the stack and pushes back the result of multiplying both of them.\n\nIf you want to multiply two matrices together, they have to be of the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Multiplication result\n\n",signature:"p1<NUMBER> p2<NUMBER>  *  result<NUMBER>\np1<VECTOR> p2<NUMBER>  *  result<VECTOR>\np1<NUMBER> p2<VECTOR>  *  result<VECTOR>\np1<MATRIX> p2<NUMBER>  *  result<MATRIX>\np1<NUMBER> p2<MATRIX>  *  result<MATRIX>\np1<MATRIX> p2<VECTOR>  *  result<VECTOR>\np1<VECTOR> p2<MATRIX>  *  result<VECTOR>\np1<MATRIX> p2<MATRIX>  *  result<VECTOR>\np2<GTS> p1<GTS>  *  result<GTS>\np2<GTS> p1<NUMBER>  *  result<GTS>\np2<NUMBER> p1<GTS>  *  result<GTS>",tags:["operators"],since:"1.0.0",OPB64name:"9V"},"**":{description:'Returns the value of the first argument raised to the power of the second argument.\n\nThe `**` operator consumes two parameters from the top of the stack (a base **b** and an exponent **n**) and pushes back the result raising b to the power of n,\ni.e. b<sup>n</sup>. For special cases see [pow()](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#pow-double-double- "javadoc").\n\nThe two parameters must be of numeric types.\n\n@param `b` First parameter, the base\n\n@param `n` Second parameter, the exponent\n\n@param `result` The result of b<sup>n</sup>\n\n',signature:"b<LONG> n<LONG>  **  result<LONG>\nb<DOUBLE> n<LONG>  **  result<DOUBLE>\nb<LONG> n<DOUBLE>  **  result<DOUBLE>\nb<DOUBLE> n<DOUBLE>  **  result<DOUBLE>\nb<COUNTER> n<COUNTER>  **  result<LONG>\nb<DOUBLE> n<COUNTER>  **  result<DOUBLE>\nb<COUNTER> n<DOUBLE>  **  result<DOUBLE>\nb<COUNTER> n<LONG>  **  result<LONG>\nb<LONG> n<COUNTER>  **  result<LONG>",tags:["math","operators"],since:"1.0.0",OPB64name:"9Xc"},"+":{description:"The `+` operator consumes two parameters from the top of the stack and pushes back the result of adding them.\n\nThe meaning of adding depends on the type of parameter:\n\n- If both parameters are numbers, the result is the sum of both numbers.\n\n- If both parameters are strings, the result is the concatenation of both strings.\n- If both parameters are byte arrays, the result is the concatenation of both byte arrays (version 2.1+).\n\n- If the first parameter is a list, the + operator clones the list and appends the second parameter to the cloned list.\n\n- If the first parameter is a set, the + operator clones the set and appends the second parameter to the cloned set.\n\n- If both parameters are macros, the result is a macro concatenating the two others in any other case + with throw an exception.\n\n- If the first parameter is a vector, the + operator adds the second numeric parameter to each element of the vector.\n- If the second parameter is a vector, the + operator adds the first numeric parameter to each element of the vector.\n- If both parameters are vectors, the + operator adds each element of vectors which are on the same index. Vectors must be the same size.\n\n- If the first parameter is a matrix, the + operator adds the second numeric parameter to each element of the matrix.\n- If the second parameter is a matrix, the + operator adds the first numeric parameter to each element of the matrix.\n- If both parameters are matrices, the + operator adds each element of matrices which are on the same index. Matrices must be the same size.\n- If one of the parameters is a Geo Time Series™, the result will be a Geo Time Series™ of type DOUBLE.\n\n@param `param1` First parameter\n\n@param `param2` Second parameter\n\n@param `result` Result of the addition\n\n",signature:"param1<STRING> param2<STRING>  +  result<STRING>\nparam1<LONG> param2<LONG>  +  result<LONG>\nparam1<DOUBLE> param2<LONG>  +  result<DOUBLE>\nparam1<COUNTER> param2<LONG>  +  result<LONG>\nparam1<LONG> param2<DOUBLE>  +  result<DOUBLE>\nparam1<DOUBLE> param2<DOUBLE>  +  result<DOUBLE>\nparam1<COUNTER> param2<DOUBLE>  +  result<DOUBLE>\nparam1<COUNTER> param2<COUNTER>  +  result<LONG>\nparam1<DOUBLE> param2<COUNTER>  +  result<DOUBLE>\nparam1<LONG> param2<COUNTER>  +  result<LONG>\nparam1<LIST> param2<ANY>  +  result<LIST>\nparam1<SET> param2<ANY>  +  result<SET>\nparam1<VECTOR> param2<NUMBER>  +  result<VECTOR>\nparam1<NUMBER> param2<VECTOR>  +  result<VECTOR>\nparam1<VECTOR> param2<VECTOR>  +  result<VECTOR>\nparam1<MACRO> param2<MACRO>  +  result<MACRO>\nparam1<MATRIX> param2<NUMBER>  +  result<MATRIX>\nparam1<NUMBER> param2<MATRIX>  +  result<MATRIX>\nparam1<MATRIX> param2<MATRIX>  +  result<MATRIX>\nparam2<GTS> param1<GTS>  +  result<GTS>\nparam2<GTS> param1<DOUBLE>  +  result<GTS>\nparam2<GTS> param1<LONG>  +  result<GTS>\nparam2<GTS> param1<STRING>  +  result<GTS>\nparam2<DOUBLE> param1<GTS>  +  result<GTS>\nparam2<LONG> param1<GTS>  +  result<GTS>\nparam2<STRING> param1<GTS>  +  result<GTS>\nparam1<BYTES> param2<BYTES>  +  result<BYTES>",tags:["math","operators"],since:"1.0.0",OPB64name:"9k"},"+!":{description:"The +! operator adds the element on top of the stack to the set or list below it. \nThe element is added to the existing collection. \n\n\n@param `input` reference to the list or set to be modified\n\n@param `output` copy of input list or set reference.\n\n@param `item` the item to append to inputlist. Depending on list content, could be any type.\n\n",signature:"input<LIST> item<ANY>  +!  output<LIST>\ninput<SET> item<ANY>  +!  output<SET>",tags:["lists","operators"],since:"1.2.0",OPB64name:"9m3"},"-":{description:"Subtracts two parameters.\n\nThe `-` operator consumes two parameters from the top of the stack and pushes back the result of subtracting the second one from the first one.\n\n- If both parameters are numbers, the result is the subtraction of both numbers.\n\n- If both parameters are vectors, the - operator subtracts each element of vectors which are on the same index. Vectors must be the same size.\n\n- If both parameters are matrices, the - operator subtracts each element of matrices which are on the same index. Matrices must be the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Subtraction result\n\n",signature:"p1<LONG> p2<LONG>  -  result<LONG>\np1<LONG> p2<DOUBLE>  -  result<DOUBLE>\np1<DOUBLE> p2<LONG>  -  result<DOUBLE>\np1<DOUBLE> p2<DOUBLE>  -  result<DOUBLE>\np1<COUNTER> p2<COUNTER>  -  result<LONG>\np1<COUNTER> p2<DOUBLE>  -  result<DOUBLE>\np1<DOUBLE> p2<COUNTER>  -  result<DOUBLE>\np1<LONG> p2<COUNTER>  -  result<LONG>\np1<COUNTER> p2<LONG>  -  result<LONG>\np1<MATRIX> p2<MATRIX>  -  result<MATRIX>\np1<VECTOR> p2<VECTOR>  -  result<VECTOR>\np2<GTS> p1<GTS>  -  result<GTS>\np2<GTS> p1<NUMBER>  -  result<GTS>\np2<NUMBER> p1<GTS>  -  result<GTS>",tags:["operators"],since:"1.0.0",OPB64name:"AF"},"->B64":{description:"Encodes the string on top of the stack in [base64](https://en.wikipedia.org/wiki/Base64).\n\n@param `input` String or byte array to encode\n\n@param `result` Base64 encoded string\n\n",signature:"input<STRING>  ->B64  result<STRING>\ninput<BYTES>  ->B64  result<STRING>",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYF"},"->B64URL":{description:"Encodes the string on top of the stack in [base64url](https://en.wikipedia.org/wiki/Base64#Variants_summary_table).\n\n@param `input` String to encode\n\n@param `bytes` Byte array to encode\n\n@param `result` Base64url encoded string\n\n",signature:"input<STRING>  ->B64URL  result<STRING>\nbytes<BYTES>  ->B64URL  result<STRING>",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYGKJZk"},"->BIN":{description:"The ->BIN function converts the byte array or the string on top of the stack \nto its binary representation.\n\nApplied on a string, `->BIN` replaces ` 'utf-8' ->BYTES ->BIN `\n\nIf the encoded content is not a \nvalid UTF-8 representation, the resulting string will reflect that. \n\n@param `input` Any string or byte array.\n\n@param `output` Binary representation of the input.\n\n",signature:"input<STRING>  ->BIN  output<STRING>\ninput<BYTES>  ->BIN  output<STRING>",tags:["conversion","binary"],since:"1.0.6",OPB64name:"AIt1HJs"},"->BYTES":{description:"->BYTES function converts a string into a bytes array given a charset\nand put the result on top of the stack.\n\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\nBytes array cannot be represented on the stack.\n\n\n@param `input` String input.\n\n@param `charset` Charset to use.\n\n@param `output` Byte array representation of input.\n\n",signature:"input<STRING> charset<STRING>  ->BYTES  output<BYTES>",tags:["conversion"],since:"1.0.6",OPB64name:"AIt1LKG4Jk"},"->DOUBLEBITS":{description:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",signature:"number<NUMBER>  ->DOUBLEBITS  bits<LONG>\ngts<GTS>  ->DOUBLEBITS  longgts<GTS>",tags:["math","gts","binary"],since:"1.2.3",OPB64name:"AIt3IpK1I3K1HKGI"},"->ENCODER":{description:"The `->ENCODER` function takes a list of points and encode them in a single encoder. Each point is a list of ( timestamp, latitude, longitude, elevation, value ). Since 2.1.1, a point can also be a Geo Time Series™ or a wrapped one. In that case all the points of the Geo Time Series™ are added to the encoder.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `elements` List of list of ( timestamp, latitude, longitude, elevation, value ). See example to see which element(s) can be omitted.\n\n@param `lgts` A list of Geo Time Series™ instances.\n\n@param `lwrappedgts` A list of wrapped Geo Time Series™ instances, such as produced by [`WRAP`](/doc/WRAP).\n\n@param `lrawwrappedgts` A list of raw wrapped Geo Time Series™ instances, such as produced by [`WRAPRAW`](/doc/WRAPRAW).\n\n@param `output` Encoder\n\n",signature:"elements<LIST>  ->ENCODER  output<GTSENCODER>\nlgts<LIST<GTS>>  ->ENCODER  output<GTSENCODER>\nlwrappedgts<LIST<STRING>>  ->ENCODER  output<GTSENCODER>\nlrawwrappedgts<LIST<BYTES>>  ->ENCODER  output<GTSENCODER>",tags:["encoder","conversion"],since:"1.2.9",OPB64name:"AIt4IZCEG3KH"},"->ENCODERS":{description:"The `->ENCODERS` function converts an encoder into one encoder per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content, when a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder.\n\n",signature:"encoder<GTSENCODER>  ->ENCODERS  output<MAP>\nwrappedencoder<STRING>  ->ENCODERS  output<MAP>\nrawwrappedencoder<BYTES>  ->ENCODERS  output<MAP>",tags:["gts","encoder","conversion"],since:"2.1.0",OPB64name:"AIt4IZCEG3KHJk"},"->FLOATBITS":{description:"Converts a numeric value to a **FLOAT** then to a **LONG** value of the raw bits of its representation.\n\nOnly the lower 32 bits of the **LONG** value are significant.\n\n@param `input` Double to convert\n\n@param `result` Raw bits representation\n\n",signature:"input<NUMBER>  ->FLOATBITS  result<LONG>",tags:["math","binary"],since:"1.2.3",OPB64name:"AIt5I3x0K388K4B"},"->GEOCELL":{description:"The `->GEOCELL` function converts a **STRING** or a **BYTES** HHCode prefix to a **LONG** geocell. The length of the input implicitly specifies the resolution of the cell.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `hhPrefixS` A HHCode prefix representing a cell. Resolution is twice the length of the **STRING**.\n\n@param `hhPrefixB` A HHCode prefix representing a cell. Resolution is four times the length of the **BYTES**.\n\n@param `geocell` The geocell representation.\n\n",signature:"hhPrefixS<STRING>  ->GEOCELL  geocell<LONG>\nhhPrefixB<BYTES>  ->GEOCELL  geocell<LONG>",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJx2GJlB"},"->GEOHASH":{description:"The `->GEOHASH` function packs a latitude and a longitude into a STRING [Geohash](https://en.wikipedia.org/wiki/Geohash), converts a [HHCode](https://en.wikipedia.org/wiki/HHCode) into its Geohash counterpart, or converts a `GEOSHAPE` into a list of Geohashes covering the same geographical area.\n\n@param `lat` Latitude to pack.\n\n@param `lon` Longitude to pack.\n\n@param `geohash` Geohash string packing the specified latitude and longitude.\n\n@param `hhcode` HHCode to transform.\n\n@param `shape` `GEOSHAPE` to convert.\n\n@param `geohashes` List of Geohashes covering the same area as `shape`.\n\n",signature:"lat<DOUBLE> lon<DOUBLE>  ->GEOHASH  geohash<STRING>\nhhcode<LONG>  ->GEOHASH  geohash<STRING>\nshape<GEOSHAPE>  ->GEOHASH  geohashes<LIST<STRING>>",tags:["geo"],since:"1.0.11",OPB64name:"AIt6GJx7FKC7"},"->GEOJSON":{description:"The `->GEOJSON` function translate the given GeoShape into a GeoJSON.\n\nThe resulting GeoJSON is a string representing a MultiPolygon geometry. By default, it defines the boundaries of the covered areas and any holes it these areas, if any.\n\nIt is also possible for this function to return a GeoJSON representing all the cells in the GeoShape.\n\n GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` The resulting GeoJSON.\n\n@param `wkt` A WKT string\n\n@param `wkb` WKB bytes\n\n",signature:"shape<GEOSHAPE>  ->GEOJSON  geojson<STRING>\nshape<GEOSHAPE> allCells<BOOLEAN>  ->GEOJSON  geojson<STRING>\nwkt<STRING>  ->GEOJSON  geojson<STRING>\nwkb<BYTES>  ->GEOJSON  geojson<STRING>",tags:["geo"],since:"2.4.1",OPB64name:"AIt6GJx9JoxD"},"->GEOSHAPE":{description:"The `->GEOSHAPE` function converts a list of **LONG** geocells or HHCode prefixes (**STRING** or **BYTES**) to a **GEOSHAPE**.\n\n@param `geocells` List of geocells, as **LONGs**.\n\n@param `hhPrefixesS` List of HHCode prefixes, as **STRINGs**.\n\n@param `hhPrefixesB` List of HHCode prefixes, as **BYTESs**.\n\n@param `geoshape` The resulting **GEOSHAPE**.\n\n",signature:"geocells<LIST<LONG>>  ->GEOSHAPE  geoshape<GEOSHAPE>\nhhPrefixesS<LIST<STRING>>  ->GEOSHAPE  geoshape<GEOSHAPE>\nhhPrefixesB<LIST<BYTES>>  ->GEOSHAPE  geoshape<GEOSHAPE>",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJxIH34FGF"},"->GTS":{description:"The `->GTS` function converts an encoder into one GTS per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\n###### Since 2.4.0:\n- `->GTS` function can also take a conversion MAP input. Using this conversion MAP, the output is always a list of GTS.\n- The conversion map can also take a list of selectors for each output type.\n- The conversion map can be empty: In this case, the GTS type is enforced by the type of the first element in the encoder input.\n- The first selector match stops the research. It means key order matters. See Examples.\n- A new '.type' label is added to each output GTS. This could be overriden with the 'label.type' parameter of the conversion MAP.\n- `->GTS` function can handle encoders, or list of encoders.\n\n###### What is an encoder ?\nA Geo Time Series™ is limited to the type of the first value stored.\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content.\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder. Values are GTS.\n\n@param `lencoder` List of encoders input (supported since 2.4.0).\n\n@param `lwrappedencoder` List of encoders after WRAP (supported since 2.4.0).\n\n@param `lrawwrappedencoder` List of encoders after WRAPRAW (supported since 2.4.0).\n\n@param `loutput` Map with a key/value per type encountered in the input encoder. Values are a list of GTS.\n\n@param `conversionmap` Map with type as keys, selectors or list of selectors as values. The special key `label` allow to change the default `.type` label. Set label to NULL to avoid any new label. The conversion map could be empty.\n\n@param `conversionoutput` A GTS, or a list of GTS.\n\n",signature:"encoder<GTSENCODER>  ->GTS  output<MAP>\nwrappedencoder<STRING>  ->GTS  output<MAP>\nrawwrappedencoder<BYTES>  ->GTS  output<MAP>\nlencoder<LIST<GTSENCODER>>  ->GTS  loutput<MAP>\nlwrappedencoder<LIST<STRING>>  ->GTS  loutput<MAP>\nlrawwrappedencoder<LIST<BYTES>>  ->GTS  loutput<MAP>\nencoder<GTSENCODER> conversionmap<MAP>  ->GTS  conversionoutput<GTS>\nwrappedencoder<STRING> conversionmap<MAP>  ->GTS  conversionoutput<GTS>\nrawwrappedencoder<BYTES> conversionmap<MAP>  ->GTS  conversionoutput<GTS>\nlencoder<LIST<GTSENCODER>> conversionmap<MAP>  ->GTS  conversionoutput<LIST<GTS>>\nlwrappedencoder<LIST<STRING>> conversionmap<MAP>  ->GTS  conversionoutput<LIST<GTS>>\nlrawwrappedencoder<LIST<BYTES>> conversionmap<MAP>  ->GTS  conversionoutput<LIST<GTS>>",tags:["gts","encoder","conversion","multivariate"],since:"1.2.9",OPB64name:"AIt6K4B"},"->GTSHHCODE":{description:"The `->GTSHHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",signature:"lat<NUMBER> lon<NUMBER>  ->GTSHHCODE  hhcode<STRING>",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3J"},"->GTSHHCODELONG":{description:"The `->GTSHHCODE` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",signature:"lat<NUMBER> lon<NUMBER>  ->GTSHHCODELONG  hhcode<STRING>",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3KBIot6"},"->HEX":{description:"Decodes an hex encoded string or a byte array.\nFor different encodings, use bytes array conversion [`BYTES->`](/doc/F__JGKBhEV).\n\n\nApplied on a string, `->HEX` replaces ` 'utf-8' ->BYTES ->HEX `\n\nIf the encoded content is not a\nvalid UTF-8 representation, the resulting string will reflect that.\n\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Decoded string of input, assuming utf-8 encoding of input.\n\n",signature:"input<STRING>  ->HEX  output<STRING>\ninput<BYTES>  ->HEX  output<STRING>",tags:["conversion"],since:"1.0.0",OPB64name:"AIt7GKV"},"->HHCODE":{description:"The `->HHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",signature:"lat<NUMBER> lon<NUMBER>  ->HHCODE  hhcode<STRING>",tags:["geo"],since:"1.0.11",OPB64name:"AIt7H3CEG3J"},"->HHCODELONG":{description:"The `->HHCODELONG` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",signature:"lat<NUMBER> lon<NUMBER>  ->HHCODELONG  hhcode<LONG>",tags:["geo"],since:"1.2.5",OPB64name:"AIt7H3CEG3KBIot6"},"->JSON":{description:"The `->JSON` functions serialize structures containing numbers, strings, booleans, lists, vlists and maps which do not reference the same list/map multiple times.\n\n@param `object` Object to serialize\n\n@param `output` JSON formatted string\n\n",signature:"object<ANY>  ->JSON  output<STRING>",tags:["conversion"],since:"1.0.0",OPB64name:"AIt9JoxD"},"->LIST":{description:"The `->LIST` function create a list from N elements on the stack.\nN and the N next elements on the stack are consumed.\n\nIf N is greater than current stack depth, the function raises an error.\n\n@param `N` The number of elements to take on the top of the stack to build the list.\n\n@param `newlist` The list of N elements. [deepest in stack ... TOP-1 ]\n\n@param `content` 0 to n elements\n\n",signature:"content<ANY*> N<LONG>  ->LIST  newlist<LIST>",tags:["lists","conversion"],since:"1.0.0",OPB64name:"AItBHKCJ"},"->LONGBYTES":{description:"`->LONGBYTES` converts a LONG to a byte array. It expects a number of bytes on the top of the stack.\n\nSince Warp 10™ 2.1, `->LONGBYTES` can also convert a list of LONG.\n\n@param `nbbytes` Number of bytes for number conversion: nbbytes could be 1 to 8. If less than 8, most significant bytes will be truncated.\n\n@param `number` must be a LONG\n\n@param `output` byte array, from 1 to 8 bytes per number\n\n@param `numberList` Since Warp 10 2.1, a list of LONG\n\n",signature:"number<LONG> nbbytes<LONG>  ->LONGBYTES  output<BYTES>\nnumberList<LIST<LONG>> nbbytes<LONG>  ->LONGBYTES  output<BYTES>",tags:["binary","conversion"],since:"2.1.0",OPB64name:"AItBIot6F__JGKB"},"->MAP":{description:"The ->MAP function creates a MAP from an even number N of elements on the stack. \nN is consumed off the top of the stack. For each pair, the deepest element is the key, the shallowest is the value.\n\n\n@param `content` 0 to n pairs of key-value elements. Keys must be different.\n\n@param `N` Number of content elements to consume on the stack. It must be even.\n\n@param `newmap` map instance, initialized with content.\n\n",signature:"N<LONG> content<ANY*> content<ANY*>  ->MAP  newmap<MAP>",tags:["maps","conversion"],since:"1.0.0",OPB64name:"AItCFK."},"->MAT":{description:"The `->MAT` function converts nested lists of numbers (2D array with same number of columns) into a Matrix.\n\nMATRIX objects cannot be represented on the stack. \n\nMatrix entries must be numbers.\n\n\n@param `input` List of lists of values\n\n@param `result` A MATRIX object\n\n",signature:"[ input<LIST> ]  ->MAT  result<MATRIX>",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItCFKF"},"->MVSTRING":{description:"The `->MVSTRING` function generates a STRING representation of an ENCODER in the format expected by the `/update` endpoint for multi values.\n\nWhen encountering a binary element, the function attempts to interpret it as a wrapped encoder, if that fails then it will output the element as a binary (`b64:...`) value.\n\n@param `input` Wrapped or unwrapped Geo Time Series™ or ENCODER.\n\n@param `mvstring` MultiValue format representation of the wrapped encoder/GTS.\n\n",signature:"input<STRING>  ->MVSTRING  mvstring<STRING>\ninput<BYTES>  ->MVSTRING  mvstring<STRING>\ninput<GTS>  ->MVSTRING  mvstring<STRING>\ninput<GTSENCODER>  ->MVSTRING  mvstring<STRING>",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"AItCK_CJJZ_DGk"},"->OPB64":{description:"Encode a String in order preserving base64. OPB64 is a Base64 like encoding which preserves the lexicographic order of\nthe original byte arrays in the encoded ones. This is useful to compare encoded byte arrays without having to first decode them.\n\n@param `input` Could be a string or a byte array.\n\n@param `output` OPB64 of input.\n\n",signature:"input<STRING>  ->OPB64  output<STRING>\ninput<BYTES>  ->OPB64  output<STRING>",tags:["conversion"],since:"1.0.6",OPB64name:"AItEJ37qC."},"->PICKLE":{description:"The `->PICKLE` function converts the object on top of the stack to a Python object and serializes it using Pickle protocol version 2.\nThe conversion table used is as follow:\n\n| WarpScript | Python |\n|------------|--------|\n| NULL | None |\n| BOOLEAN | bool |\n| BYTES | bytearray |\n| STRING | str/unicode |\n| DOUBLE | float |\n| LONG | int |\n| LIST | list |\n| MAP | dict |\n| SET | set |\n| GTS | dict |\n| ENCODER | dict |\n\nOther types are unsupported.\n\nPython example with `->PICKLE ->HEX` output:\n```python\n>>> s=\"80025d71002858060000005049434b4c4571015806000000535452494e4771025d7103284b0547400921fb54442d1865652e\"\n>>> import pickle\n>>> pickle.loads(s.decode(\"hex\"))\n[u'PICKLE', u'STRING', [5, 3.141592653589793]]\n```\n\n@param `input` A serializable object\n\n@param `output` Pickle encoded content\n\n",signature:"input<ANY>  ->PICKLE  output<BYTES>",tags:["platform"],since:"1.0.7",OPB64name:"AItFHJCAI3J"},"->Q":{description:"The `->Q` function consumes on the stack 4 doubles (w, x, y, z, with z being on top) representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion)\nand push back quaternion representation into a **LONG**.\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `result` Quaternion representation\n\n",signature:"w<DOUBLE> x<DOUBLE> y<DOUBLE> z<DOUBLE>  ->Q  result<LONG>",tags:["quaternions"],since:"1.0.0",OPB64name:"AItG"},"->SET":{description:"The -`>SET` function converts a **LIST** on top of the stack into a **SET**.\n\nSETs are not viewable, null will be return if it remains on the stack.\n\nThe order in the SET is not garanteed, see [`()`](/doc/91Z).\n\n\n@param `input` The input list\n\n@param `newset` The new set reference. SETs are not viewable, null remains on the stack.\n\n",signature:"input<LIST>  ->SET  newset<SET>",tags:["sets"],since:"1.0.0",OPB64name:"AItIGKF"},"->TSELEMENTS":{description:"The `->TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",signature:"timestamp<LONG>  ->TSELEMENTS  dateAndTimeElements<LIST<LONG>>\ntimestamp<LONG> timezone<STRING>  ->TSELEMENTS  dateAndTimeElements<LIST<LONG>>",tags:["date","time"],since:"1.2.0",OPB64name:"AItJJoKBGJp4I_GI"},"->V":{description:"The `->V` function converts a list of objects into a Pig Vector (VLIST).\n\nVLIST are represented as lists on the stack.\n\n@param `list` Input list\n\n@param `set` Input set\n\n@param `result` Result list\n\n",signature:"list<LIST>  ->V  result<VLIST>\nset<SET>  ->V  result<VLIST>",tags:["conversion","pig"],since:"1.0.11",OPB64name:"AItL"},"->VARINT":{description:"The `->VARINT` function encodes a `LONG` or a list of `LONG`s using [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoding. The result is a byte array containing the concatenation of the encoded numbers.\n\nThe `->VARINT` function is optimized for encoding unsigned `LONG`s, this means that negative numbers (with the most significant bit set to 1) will be encoded on 10 bytes. In order to reduce this footprint you can pre-process the numbers to encode so they are encoded unsing [ZigZag VarInt](https://developers.google.com/protocol-buffers/docs/encoding#types) encoding. The simple trick is to compute\n\n```\n$value 1 << $value 63 >> ^\n```\n\nthis will have the effect of alternatively encoding positive and negative numbers thus leading to a more efficient footprint for negative numbers.\n\nAt decoding time using `VARINT->`, simply undo the *Zig-Zag* trick:\n\n```\n$unsigned 63 << 63 >> $unsigned ^ 1 >>\n// Flip the top bit\n$unsigned 1 63 << & ^\n```\n\n@param `number` Single number to encode.\n\n@param `numbers` List of numbers to encode.\n\n@param `encoded` Byte array containing the encoded number(s).\n\n",signature:"number<LONG>  ->VARINT  encoded<BYTES>\nnumbers<LIST<LONG>>  ->VARINT  encoded<BYTES>",tags:["conversion","binary"],since:"2.6.0",OPB64name:"AItLFK88I_F"},"->VEC":{description:"The `->VEC` function converts a list of numbers into a Vector.\n\nVectors objects cannot be represented on the stack. \n\nVectors entries must be numbers.\n\n@param `list` List to convert\n\n@param `matrix` Matrix with a single column\n\n@param `result` Vector\n\n",signature:"list<LIST>  ->VEC  result<VECTOR>\nmatrix<MATRIX>  ->VEC  result<VECTOR>",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItLGJB"},"->WKB":{description:"The `->WKB` function converts a GeoJSON **STRING**, a WKT **STRING** or a **SHAPE** to WKB **BYTES**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` A WKT string\n\n@param `wkb` The resulting WKB.\n\n",signature:"shape<GEOSHAPE>  ->WKB  wkb<BYTES>\nshape<GEOSHAPE> allCells<BOOLEAN>  ->WKB  wkb<BYTES>\nwkt<STRING>  ->WKB  wkb<BYTES>\ngeojson<STRING>  ->WKB  wkb<BYTES>",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHo7"},"->WKT":{description:"The `->WKT` function converts a GeoJSON **STRING**, a WKB **BYTES** or a **SHAPE** to WKT **STRING**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` The resulting  WKT.\n\n@param `wkb` WKB bytes.\n\n",signature:"shape<GEOSHAPE>  ->WKT  wkt<STRING>\nshape<GEOSHAPE> allCells<BOOLEAN>  ->WKT  wkt<STRING>\ngeojson<STRING>  ->WKT  wkt<STRING>\nwkb<BYTES>  ->WKT  wkt<STRING>",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHpF"},"->Z":{description:"The `->Z` function packs multiple **LONG** arguments into a byte array by interleaving the bits of the arguments. This produces a \n[Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) value encoding the original arguments. The value might be right padded with bits set to 0 to reach a multiple of 8 bits.\n\n@param `bitwidth` Number of bits to consider for each LONG in 'longs', from 1 to 63.\n\n@param `longs` List of LONGs to pack. Each LONG *MUST* be positive, i.e. with bit 63 set to 0.\n\n@param `z` Byte array containing the packed values.\n\n",signature:"longs<LIST<LONG>> bitwidth<LONG>  ->Z  z<BYTES>",tags:["conversion"],since:"1.0.6",OPB64name:"AItP"},"/":{description:"The `/` operator consumes two parameters from the top of the stack and pushes back the result of dividing the first one by the second one.\n\nYou can't devide by zero.\n\nThe two parameters must be of numeric types, or Geo Time Series™, or a mix of the two.\n\n@param `long` Numeric integer\n\n@param `long-result` Numeric floor-rounded integer\n\n@param `double` Numeric floating point number\n\n@param `double-result` Numeric floating point number\n\n@param `counter` Numeric counter\n\n@param `param1` First parameter of the division.\n\n@param `param2` Second parameter of the division.\n\n@param `result` Resulting GTS, of type DOUBLE.\n\n",signature:"long<LONG> long<LONG>  /  long-result<LONG>\ndouble<DOUBLE> long<LONG>  /  double-result<DOUBLE>\nlong<LONG> double<DOUBLE>  /  double-result<DOUBLE>\ndouble<DOUBLE> double<DOUBLE>  /  double-result<DOUBLE>\ncounter<COUNTER> counter<COUNTER>  /  long-result<LONG>\ndouble<DOUBLE> counter<COUNTER>  /  long-result<DOUBLE>\ncounter<COUNTER> double<DOUBLE>  /  long-result<DOUBLE>\ncounter<COUNTER> long<LONG>  /  long-result<LONG>\nlong<LONG> counter<COUNTER>  /  long-result<LONG>\ndouble<VECTOR> double<NUMBER>  /  double-result<VECTOR>\nparam2<GTS> param1<GTS>  /  result<GTS>\nparam2<GTS> param1<NUMBER>  /  result<GTS>\nparam2<NUMBER> param1<GTS>  /  result<GTS>",tags:["operators","math"],since:"1.0.0",OPB64name:"Ak"},"<":{description:"The `<` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 < p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <` is strictly equivalent of a `42 mapper.lt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 < p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less than gts2 value.\n\n",signature:"p1<NUMBER> p2<NUMBER>  <  result<BOOLEAN>\np1<STRING> p2<STRING>  <  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  <  outgts<GTS>\nconstant<ANY> inputgts<GTS>  <  outgts<GTS>\ngts1<GTS> gts2<GTS>  <  outputgts<GTS>",tags:["operators","math"],since:"1.0.0",OPB64name:"E."},"<<":{description:"Shifts the bits of a long by a number of positions to the left. The least significant bit is filled with 0 after each shift.\n\nSince Warp 10™ 2.1, `<<` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",signature:"number<LONG> shift<LONG>  <<  result<LONG>\ninputgts<GTS> number<LONG>  <<  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  <<  outputgts<GTS>",tags:["operators"],since:"1.0.0",OPB64name:"E2k"},"<=":{description:"The `<=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 <= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <=` is strictly equivalent of a `42 mapper.le` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 <= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less or equal than gts2 value.\n\n",signature:"p1<NUMBER> p2<NUMBER>  <=  result<BOOLEAN>\np1<STRING> p2<STRING>  <=  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  <=  outgts<GTS>\nconstant<ANY> inputgts<GTS>  <=  outgts<GTS>\ngts1<GTS> gts2<GTS>  <=  outputgts<GTS>",tags:["operators","math"],since:"1.0.0",OPB64name:"E2o"},"==":{description:"Tests if both parameters are equal.\n\nThe `==` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are equal, false otherwise.\n\nThe two parameters must be of numeric, boolean, vector, matrix or string types.\nFor vector or matrix, the parameters must be the same size.\n\nSince 2.1.0, as every other comparison operators, `==` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 ==` is strictly equivalent of a `42 mapper.eq` MAP operation, with a simplified syntax.\n\nSince 2.1.1, `==` can be use to check equality between Lists, Maps and Sets. For for details about how this is defined, check the [java documentation](https://docs.oracle.com/en/java/javase/index.html).\n\n@param `p1` First parameter to compare\n\n@param `p2` Second parameter to compare\n\n@param `result` True if p1 and p2 are equal, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values equal to constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value equals gts2 value.\n\n",signature:"p1<ANY> p2<ANY>  ==  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  ==  outgts<GTS>\nconstant<ANY> inputgts<GTS>  ==  outgts<GTS>\ngts1<GTS> gts2<GTS>  ==  outputgts<GTS>",tags:["operators","math"],since:"1.0.0",OPB64name:"EIo"},">":{description:"The `>` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 > p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >` is strictly equivalent of a `42 mapper.gt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 > p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater than gts2 value.\n\n",signature:"p1<NUMBER> p2<NUMBER>  >  result<BOOLEAN>\np1<STRING> p2<STRING>  >  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  >  outgts<GTS>\nconstant<ANY> inputgts<GTS>  >  outgts<GTS>\ngts1<GTS> gts2<GTS>  >  outputgts<GTS>",tags:["operators","math"],since:"1.0.0",OPB64name:"EV"},">=":{description:"The `>=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 >= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >=` is strictly equivalent of a `42 mapper.ge` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 >= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater or equal than gts2 value.\n\n",signature:"p1<NUMBER> p2<NUMBER>  >=  result<BOOLEAN>\np1<STRING> p2<STRING>  >=  result<BOOLEAN>\ninputgts<GTS> constant<ANY>  >=  outgts<GTS>\nconstant<ANY> inputgts<GTS>  >=  outgts<GTS>\ngts1<GTS> gts2<GTS>  >=  outputgts<GTS>",tags:["operators","math"],since:"1.0.0",OPB64name:"EYo"},">>":{description:"Shifts the bits of a long by a number of positions to the right. The most significant bit after shifting depends on the sign of the unshifted long.\n\nSince Warp 10™ 2.1, `>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",signature:"number<LONG> shift<LONG>  >>  result<LONG>\ninputgts<GTS> number<LONG>  >>  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  >>  outputgts<GTS>",tags:["operators"],since:"1.0.0",OPB64name:"EYs"},">>>":{description:"Shifts the bits of a long by a number of positions to the right. The most significant bit after each shift is set to 0, regardless of the sign of \nthe unshifted long.\n\nSince Warp 10™ 2.1, `>>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",signature:"number<LONG> shift<LONG>  >>>  result<LONG>\ninputgts<GTS> number<LONG>  >>>  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  >>>  outputgts<GTS>",tags:["operators"],since:"1.0.0",OPB64name:"EYsy"},ABS:{description:"Computes the absolute value of a number value.\n\nThe `ABS` function consumes a numeric value from the top of the stack and pushes back its absolute value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` A numeric value\n\n@param `result` The absolute value of the given numeric value.\n\n@param `lvalue` A list of numeric values\n\n@param `lresult` A list of the absolute values of the given values.\n\n",signature:"value<LONG>  ABS  result<LONG>\nvalue<COUNTER>  ABS  result<LONG>\nvalue<DOUBLE>  ABS  result<DOUBLE>\nlvalue<LIST<LONG>>  ABS  lresult<LIST<LONG>>\nlvalue<LIST<COUNTER>>  ABS  lresult<LIST<LONG>>\nlvalue<LIST<DOUBLE>>  ABS  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"ABS"},"ACCEL.CACHE":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.CACHE` function will enable accessing the in-memory data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.CACHE"},"ACCEL.NOCACHE":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOCACHE` function will disable accessing the in-memory data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOCACHE"},"ACCEL.NOPERSIST":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOPERSIST` function will disable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOPERSIST"},"ACCEL.PERSIST":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.PERSIST` function will enable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.PERSIST"},"ACCEL.REPORT":{description:"The `ACCEL.REPORT` function will produce a map containing informations related to the Warp 10 Accelerator. The following table describes the various keys present in this map:\n\n| Key | Description |\n|-----|-------------|\n| `accelerated` | Boolean indicating whether or not the last [`FETCH`](/doc/FETCH) accessed the in-memory data managed by the Warp 10 Accelerator. |\n| `status` | Boolean indicating whether or not the Warp 10 Accelerator is enabled. |\n| `cache` | Boolean indicating if the in-memory data will be considered for update, fetch and delete operations. |\n| `persist` | Boolean indicating if the persistent data will be considered for update, fetch and delete operations. |\n| `chunkcount` | Number of chunks managed by the accelerator for its in-memory data. |\n| `chunkspan` | Length of each chunk expressed in platform time units. |\n\n@param `report` Map containing informations related to the Warp 10 Accelerator\n\n",signature:" ACCEL.REPORT  report<MAP>",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.REPORT"},ACOS:{description:"The `ACOS` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arccosine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arccosine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arccosine in radians of the given values.\n\n",signature:"value<NUMBER>  ACOS  result<DOUBLE>\nlvalue<LIST<NUMBER>>  ACOS  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ACOS"},ADDDAYS:{description:'Adds days to a timestamp or a tselements.\n\nThe `ADDDAYS` function consumes from the top of the stack a number (positive or negative) of days, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the days and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `days` The number of days to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',signature:"timestamp<LONG> timezone<STRING> days<LONG>  ADDDAYS  result<LONG>\ntimestamp<LONG> days<LONG>  ADDDAYS  result<LONG>\ntselements<LIST<LONG>> days<LONG>  ADDDAYS  tselementsresult<LIST<LONG>>",tags:["date"],since:"1.2.0",OPB64name:"ADDDAYS"},ADDDURATION:{description:"Adds an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) to a timestamp or a tselements.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `duration` The duration\n\n@param `factor` The number of durations to add. Can be negative. Default to 1 if not set.\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n",signature:"timestamp<LONG> timezone<STRING> duration<STRING>  ADDDURATION  result<LONG>\ntimestamp<LONG> timezone<STRING> duration<STRING> factor<LONG>  ADDDURATION  result<LONG>\ntimestamp<LONG> duration<STRING>  ADDDURATION  result<LONG>\ntimestamp<LONG> duration<STRING> factor<LONG>  ADDDURATION  result<LONG>\ntselements<LIST<LONG>> duration<STRING>  ADDDURATION  tselementsresult<LIST<LONG>>\ntselements<LIST<LONG>> duration<STRING> factor<LONG>  ADDDURATION  tselementsresult<LIST<LONG>>",tags:["date"],since:"2.4.0",OPB64name:"ADDDURATION"},ADDEXACT:{description:"The `ADDEXACT` function consumes two LONGs from the top of the stack and puts back the sum. If the sum overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `sum` The sum of x and y\n\n@param `list` List of numeric values\n\n@param `ssum` The sum of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lsum` List of **LONG** where each value is the sum of y and an element in lx\n\n",signature:"x<NUMBER> y<NUMBER>  ADDEXACT  sum<LONG>\nlist<LIST<NUMBER>>  ADDEXACT  ssum<LONG>\nlx<LIST<NUMBER>> y<NUMBER>  ADDEXACT  lsum<LIST<LONG>>",tags:["math"],since:"1.2.23",OPB64name:"ADDEXACT"},ADDMONTHS:{description:'Adds months to a timestamp or a tselements.\n\nThe `ADDMONTHS` function consumes from the top of the stack a number (positive or negative) of months, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the months and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `months` The number of months to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',signature:"timestamp<LONG> timezone<STRING> months<LONG>  ADDMONTHS  result<LONG>\ntimestamp<LONG> months<LONG>  ADDMONTHS  result<LONG>\ntselements<LIST<LONG>> months<LONG>  ADDMONTHS  tselementsresult<LIST<LONG>>",tags:["date"],since:"1.2.0",OPB64name:"ADDMONTHS"},ADDVALUE:{description:"The `ADDVALUE` function adds a value to a GTS, without checking for tick duplicates. The added data point is appended to the GTS.\nThe [`SETVALUE`](/doc/SETVALUE) overrides an existing value.\n\nThe `ADDVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `ADDVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, for example by using [`GET`](/doc/GET)\nwith value 0 as parameter.\n\nIf latitude or longitude are NaN (not a number), value has only timestamp, elevation, value.\nIf elevation is NaN (not a number), value has only timestamp, latitude, longitude, value.\nIf elevation is NaN and longitude or latitude are NaN, value has only timestamp, value.\n\nWhen adding a Geo Time Series™ or GTS Encoder value, the value will be wrapped (as when using `WRAPRAW`) and added as a binary value.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Series™\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `result` The Geo Time Series™ with the new datapoint added\n\n@param `elevation` Elevation or NaN\n\n",signature:"gts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<STRING>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<BYTES>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<BOOLEAN>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<DOUBLE>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<LONG>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<GTSENCODER>  ADDVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<GTS>  ADDVALUE  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"ADDVALUE"},ADDYEARS:{description:'Adds years to a timestamp or a tselements.\n\nThe `ADDYEARS` function consumes from the top of the stack a number (positive or negative) of years, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the years and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `years` The number of years to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',signature:"timestamp<LONG> timezone<STRING> years<LONG>  ADDYEARS  result<LONG>\ntimestamp<LONG> years<LONG>  ADDYEARS  result<LONG>\ntselements<LIST<LONG>> years<LONG>  ADDYEARS  tselementsresult<LIST<LONG>>",tags:["date"],since:"1.2.0",OPB64name:"ADDYEARS"},AESUNWRAP:{description:'Unwraps a byte array with the [AES WRAP](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") and pushes back the decrypted data into an bytes array.\n\n`AESUNWRAP` removes the a 64bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) added by [`AESWRAP`](/doc/AESWRAP) WarpScript function\n\n@param `data` Encoded Byte array.\n\n@param `key` Byte array, 128, 192 or 256 bits key.\n\n@param `decoded` Decoded Byte array.\n\n',signature:"key<BYTES> data<BYTES>  AESUNWRAP  decoded<BYTES>",tags:["crypto"],since:"1.0.11",OPB64name:"AESUNWRAP"},AESWRAP:{description:'Wraps a byte array or String with the [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt) algorithm and pushes a byte array containing the encrypted data onto the stack.\n\n`AESWRAP` adds a 64 bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) prefix to the input in order to protect the encrypted data against AES block determinism as [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") uses a fixed Initialization Vector.\n\n@param `key` 128, 192 or 256 bits key to use for encryption.\n\n@param `string` String data to encrypt.\n\n@param `bytes` Byte array to encrypt.\n\n@param `encrypted` Encrypted result.\n\n',signature:"string<STRING> key<BYTES>  AESWRAP  encrypted<BYTES>\nbytes<BYTES> key<BYTES>  AESWRAP  encrypted<BYTES>",tags:["crypto"],since:"1.0.11",OPB64name:"AESWRAP"},AGO:{description:"The `AGO` function is a shortcut which enables you to compute timestamps by specifying an offset from the current time.\n\n@param `offset` The numbers of ticks in platform time unit to subtract, truncated if floating-point.\n\n@param `timestamp` The computed timestamp\n\n",signature:"offset<NUMBER>  AGO  timestamp<LONG>",tags:["date"],since:"1.2.0",OPB64name:"AGO"},AND:{description:"The `AND` operator is a synonymous for [`&&`](/doc/8XN).\n\nIt performs a logical **AND** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `AND` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical AND applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with AND between each common tick input values.\n\n",signature:"p1<BOOLEAN> p2<BOOLEAN>  AND  result<BOOLEAN>\nl<LIST>  AND  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  AND  gtsresult<GTS>",tags:["operators","logic"],since:"1.0.0",OPB64name:"AND"},APPEND:{description:"The `APPEND` function consumes two paramters from the top of the stack and appends the LIST, MAP or GTS on top of the stack to the one just below.\nThe augmented LIST, MAP or GTS is then pushed back on the stack.\n\n@param `newitems` items to append to input.\n\n@param `inputlist` LIST to be modified.\n\n@param `outputlist` The LIST that has been modified\n\n@param `inputmap` MAP to be modified.\n\n@param `outputmap` The AP that has been modified \n\n@param `inputGTS` GTS to be modified.\n\n@param `outputGTS` The GTS that has been modified\n\n",signature:"inputlist<LIST> newitems<LIST>  APPEND  outputlist<LIST>\ninputmap<MAP> newitems<MAP>  APPEND  outputmap<MAP>\ninputGTS<GTS> newitems<GTS>  APPEND  outputGTS<MAP>",tags:["lists","maps"],since:"1.0.0",OPB64name:"APPEND"},APPLY:{description:"The `APPLY` framework provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can do. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` List of resulting GTS, one per equivalence class.\n\n@param `op` Operation to perform.\n\n",signature:"[ gts<LIST<GTS>+> labels<LIST> op<OPERATOR> ]  APPLY  result<LIST<GTS>>",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"APPLY"},ASENCODERS:{description:"The `ASENCODERS` function consumes a Geo Time Series™, a wrap or a raw wrap, or a list thereof and convert each one into an encoder.\n\n@param `gts` Geo Time Series™ to be converted.\n\n@param `lgts` List of Geo Time Series™ to be converted.\n\n@param `wrappedgts` Wrapped Geo Time Series™ to be converted.\n\n@param `lwrappedgts` List of wrapped Geo Time Series™ to be converted.\n\n@param `rawwrappedgts` Raw wrapped Geo Time Series™ to be converted.\n\n@param `lrawwrappedgts` List of raw wrapped Geo Time Series™ to be converted.\n\n@param `encoder` Encoder of the given Geo Time Series™.\n\n@param `lencoder` List of encoder, one for each given Geo Time Series™.\n\n",signature:"gts<GTS>  ASENCODERS  encoder<GTSENCODER>\nlgts<LIST<GTS>>  ASENCODERS  lencoder<LIST<GTSENCODER>>\nwrappedgts<STRING>  ASENCODERS  encoder<GTSENCODER>\nlwrappedgts<LIST<STRING>>  ASENCODERS  lencoder<LIST<GTSENCODER>>\nrawwrappedgts<BYTES>  ASENCODERS  encoder<GTSENCODER>\nlrawwrappedgts<LIST<BYTES>>  ASENCODERS  lencoder<LIST<GTSENCODER>>\nencoder<GTSENCODER>  ASENCODERS  encoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>>  ASENCODERS  lencoder<LIST<GTSENCODER>>",tags:["encoder","conversion"],since:"2.2.0",OPB64name:"ASENCODERS"},ASIN:{description:"The `ASIN` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arcsine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arcsine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arcsine in radians of the given values.\n\n",signature:"value<NUMBER>  ASIN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  ASIN  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ASIN"},ASREGS:{description:"Replaces in a macro the uses of the given symbols by the use of registers.\n\nIf there are not enough registers available, replace each of the symbols from the start of the list until all registers are used.\n\nSince 2.6.0, the list of symbols is optional. In that case, `ASREGS` first recursively extracts all the symbols from given the macro and uses that list to do the replacement.\n\n@param `macro` Macro to transform.\n\n@param `vars` List of symbols.\n\n",signature:"macro<MACRO> vars<LIST<STRING>>  ASREGS  macro<MACRO>\nmacro<MACRO>  ASREGS  macro<MACRO>",tags:["stack"],since:"2.0.0",OPB64name:"ASREGS"},ASSERT:{description:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise.\n\nThe `ASSERT` function consumes a **BOOLEAN** parameter from the top of the stack. If the boolean is **true** the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception.\n\n`ASSERT` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n",signature:"condition<BOOLEAN>  ASSERT ",tags:["debug"],since:"1.0.0",OPB64name:"ASSERT"},ASSERTMSG:{description:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise and displays a message.\n\nThe `ASSERTMSG` function consumes a **BOOLEAN** parameter and a **STRING** parameter from the top of the stack. If the boolean is **true**, the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception with a message displaying the **STRING** parameter.\n\n`ASSERTMSG` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n@param `message` The exception message to display if the test fails\n\n",signature:"condition<BOOLEAN> message<STRING>  ASSERTMSG ",tags:["debug"],since:"1.2.13",OPB64name:"ASSERTMSG"},ATAN:{description:"The `ATAN` function consumes a floating point number between -1 et 1 from the top of the stack and pushes back its arctangent in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arctangent in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arctangent in radians of the given values.\n\n",signature:"value<NUMBER>  ATAN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  ATAN  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ATAN"},ATAN2:{description:"ATAN2 function returns the polar angle theta (azimut) from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta). This method computes the phase theta by computing an arc tangent of y/x in the range of `] -pi  pi ]`.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `result` theta in polar coordinates\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `lresult` List of thetas in polar coordinates\n\n",signature:"y<NUMBER> x<NUMBER>  ATAN2  result<DOUBLE>\ny<NUMBER> lx<LIST<NUMBER>>  ATAN2  lresult<LIST<DOUBLE>>\nly<LIST<NUMBER>> x<NUMBER>  ATAN2  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.2.13",OPB64name:"ATAN2"},ATBUCKET:{description:"The `ATBUCKET` function consumes a bucketized GTS from the stack, looks at its `index`-th bucket and puts on the stack a\nlist with the timestamp, latitude, longitude, elevation and value for this bucket.\n\n@param `gts` Bucketized Geo Time Series™\n\n@param `index` Index of the bucket\n\n@param `result` List with the timestamp, latitude, longitude, elevation and value for the index-th bucket of the GTS\n\n",signature:"gts<GTS> index<LONG>  ATBUCKET  result<LIST>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"ATBUCKET"},ATINDEX:{description:"The `ATINDEX` function consumes a Geo Time Series™ or a list thereof from the stack, looks at its index-th point and put on the stack a list with the timestamp, longitude, \nlatitude, elevation and value for the `index`-th point of the GTS.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the GTS.\n\n@param `index` Index of the tick, truncated if floating-point.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",signature:"gts<GTS> index<NUMBER>  ATINDEX  data<LIST>\nlgts<LIST<GTS>> index<NUMBER>  ATINDEX  ldata<LIST<LIST>>",tags:["gts"],since:"1.0.0",OPB64name:"ATINDEX"},ATTICK:{description:"The `ATTICK` function consumes a Geo Time Series™ from the stack, looks at its tick-th tick (the data point with a timestamp tick) and put on the \nstack a list with the timestamp, latitude, longitude, elevation and value for that data point.\n\nIf there is no data point with tick timestamp, it return a list with timestamp, latitude, longitude and elevation at **NaN** and value at **null**.\n\n@param `timestamp` Timestamp at which to take the data, if it is a floating-point value, it is truncated.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",signature:"gts<GTS> timestamp<LONG>  ATTICK  data<LIST>\nlgts<LIST<GTS>> timestamp<LONG>  ATTICK  ldata<LIST<LIST>>\ngts<GTS> timestamp<COUNTER>  ATTICK  data<LIST>\nlgts<LIST<GTS>> timestamp<COUNTER>  ATTICK  ldata<LIST<LIST>>\ngts<GTS> timestamp<DOUBLE>  ATTICK  data<LIST>\nlgts<LIST<GTS>> timestamp<DOUBLE>  ATTICK  ldata<LIST<LIST>>",tags:["gts"],since:"1.0.0",OPB64name:"ATTICK"},ATTRIBUTES:{description:"Retrieves the attributes of a Geo Time Series™.\n\nThe `ATTRIBUTES` function takes a **GTS** on top of the stack and push back a **MAP** including all its attributes.\n\nAn attribute corresponds to a tag for a specific series.\nThe attribute system allows the user to add some information that can change in a series.\n\n@param `gts` The input Geo Time Series™\n\n@param `encoder` The input Geo Time Series™ Encoder\n\n@param `return` The attributes MAP of the input Geo Time Series™\n\n",signature:"gts<GTS>  ATTRIBUTES  return<MAP>\nencoder<GTSENCODER>  ATTRIBUTES  return<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"ATTRIBUTES"},AUTHENTICATE:{description:"The `AUTHENTICATE` function authenticates the current stack with the **read token** on top of the stack. This function removes the token from the stack.\n\nInside a WarpScript, the stack could be authenticated only once. An exception is thrown when the stack is already authenticated.\n\n@param `token` Read token\n\n",signature:"token<STRING>  AUTHENTICATE ",tags:["stack"],since:"1.0.0",OPB64name:"AUTHENTICATE"},"B64->":{description:"Decodes the [base64](http://tools.ietf.org/html/rfc4648#section-4) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",signature:"content<STRING>  B64->  result<BYTES>",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoAIs"},B64TOHEX:{description:"Decodes the  [base64](http://tools.ietf.org/html/rfc4648#section-4) content on top of the stack and immediately re-encode it in hexadecimal.\nThis enables you to convert encoded content which would not be valid UTF-8 encoding from base64 to hexadecimal. \nAs the string are URL encoded, the symbol `+` have to be replaced by `%2B`, otherwise a space will replace the `+` in the string.\n\n@param `content` String to convert\n\n@param `result` Hexadecimal converted string\n\n",signature:"content<STRING>  B64TOHEX  result<STRING>",tags:["strings","conversion"],since:"1.0.0",OPB64name:"B64TOHEX"},"B64URL->":{description:"Decodes the [base64url](http://tools.ietf.org/html/rfc4648#section-5) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",signature:"content<STRING>  B64URL->  result<BYTES>",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoKK8BAIs"},BBOX:{description:"The `BBOX` function computes the bounding box of a Geo Time Series™ or a list thereof. It returns a list with extremas, or a list of list of extremas.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `minlat` Latitude of lower left of bounding box.\n\n@param `minlon` Longitude of lower left of bounding box.\n\n@param `maxlat` Latitude of upper right of bounding box.\n\n@param `maxlon` Longitude of upper right of bounding box.\n\n@param `extremas` List of list containing minlat, minlon, maxlat, maxlon, for every GTS in lgts.\n\n",signature:"gts<GTS>  BBOX  [  minlat<DOUBLE>  minlon<DOUBLE>  maxlat<DOUBLE>  maxlon<DOUBLE>  ]\nlgts<LIST<GTS>>  BBOX  extremas<LIST<LIST<DOUBLE>>>",tags:["geo","gts"],since:"1.0.0",OPB64name:"BBOX"},"BIN->":{description:"The `->BIN` function decodes a binary string representation into a bytes array.\n\n@param `binary` The binary string representation\n\n@param `result` The bytes array\n\n",signature:"binary<STRING>  BIN->  result<BYTES>",tags:["strings","conversion","binary"],since:"1.0.6",OPB64name:"FZ_DAIs"},BINTOHEX:{description:"Converts a string representing a binary number into a string representing a hexadecimal number.\n\nThe `BINTOHEX` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from binary to hexadecimal.\n\n@param `content` The string representing a binary number\n\n@param `result` The string representing a hexadecimal number\n\n",signature:"content<STRING>  BINTOHEX  result<STRING>",tags:["strings","conversion","binary"],since:"1.0.0",OPB64name:"BINTOHEX"},BITCOUNT:{description:"Returns the logical size and the cardinality of a [BitSet](https://docs.oracle.com/javase/8/docs/api/java/util/BitSet.html).\n\nThe `BITCOUNT` function consumes a bitset on the top of the stack and push back its logical size and its cardinality.\n  * The logical size is the index of the highest bit set to true plus one.\n  * The cardinality is the number of bit set to true.\n\n@param `bitset` The BitSet to count\n\n@param `length` The logical size of the BitSet\n\n@param `cardinality` The number of bits set to true\n\n",signature:"bitset<BITSET>  BITCOUNT  cardinality<LONG> length<LONG>",tags:["bitset","binary"],since:"1.0.6",OPB64name:"BITCOUNT"},BITGET:{description:"Returns the value of the bit with the specified index.\n\nThe `BITGET` function consumes a bitset and a long on the top of the stack. It returns the value of the bit with the specified index. The bit index starts at 0 from the right.\n\n@param `index` The bit index\n\n@param `bitset` The bitset\n\n@param `return` The value of the bit with the specified index\n\n",signature:"bitset<BITSET> index<LONG>  BITGET  return<BOOLEAN>",tags:["bitset","binary"],since:"1.0.5",OPB64name:"BITGET"},BITSTOBYTES:{description:"Converts a bitset into a bytes array.\n\n@param `bitset` Bitset\n\n@param `result` Bytes array\n\n",signature:"bitset<BITSET>  BITSTOBYTES  result<BYTES>",tags:["bitset","binary","conversion"],since:"1.0.6",OPB64name:"BITSTOBYTES"},BOOTSTRAP:{description:"This function is executed systematically before the WarpScript stack is available for anything else. By default this function does nothing, it is equivalent \nto [`NOOP`](/doc/NOOP).\n\nIf bootstrap code was specified in the Warp 10 platform configuration, for either or all of `egress`, `mobius` or `runner`, the `BOOTSTRAP` function might\nhave been redefined and actual code could be executed.\n\nThis function is not meant to be used in user provided scripts.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"BOOTSTRAP"},BREAK:{description:"The `BREAK` function breaks out of the current loop. It takes no argument.\n\n> If used outside a loop, an error is thown\n\n",signature:"",tags:["logic","control"],since:"1.0.0",OPB64name:"BREAK"},BUCKETCOUNT:{description:"The function `BUCKETCOUNT` consumes a GTS off the stack and pushes its bucketcount onto the stack.\n\n> Note: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Number of buckets\n\n",signature:"gts<GTS>  BUCKETCOUNT  result<LONG>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETCOUNT"},BUCKETIZE:{description:"The Geo Time Series™ kept in the Warp 10 platform grow over time as more measurements are added. Some series have very regular measurements,\nothers more sporadic ones. But when it comes to manipulating the data, it might be handy to be able to impose some kind of regularity to measurements.\nThis is exactly what the [`BUCKETIZE`](/doc/BUCKETIZE) framework does, it provides the tooling for putting the data of a Geo Time Series™ into regularly spaced\n**buckets**.\n\nA **bucket** is a time interval which spans a certain number of time units called the **bucketspan**, ending at a tick called the **lastbucket**.\n\nAs an example, the bucket spanning 10 time units and ending at time units 20 will contain all measurements taken at the following times:\n\n20, 19, 18, 17, 16, 15, 14, 13, 12, 11\n\nthe previous bucket with the same bucketspan ends at 10 and covers ticks 10 down to 1. The next bucket ends at 30 and covers ticks 21 to 30.\n\nA bucketized Geo Time Series™ is characterized by its **bucketspan**, its **bucketcount** and the **lastbucket**.\nA bucketized Geo Time Series™ has at most one measurement per bucket, there might be buckets with no measurements.\n\nThe `BUCKETIZE` framework is used to convert a non bucketized Geo Time Series™ into a bucketized one. The bucketization process collects\nthe measurements of the original geo time series which fall in each bucket and apply a bucketizer function on those data, thus leading to at most a\nsingle measurement for each bucket.\n\nThe `BUCKETIZE` framework comes with a number of bucketizer which implement very common aggregation functions such as SUM, MIN, MAX, MEAN, etc.\n\nA macro can be used instead of the bucketizer argument. In that case, in each bucket the measurements are collected as a sub Geo Time Series™ which is taken as parameter by the macro.\nThis macro must then push onto the stack its result (see description in signature description below).\n\nIf the bucketizer argument is NULL, then BUCKETIZE do not create any new Geo Time Series™ but instead sets the lastbucket, bucketspan and bucketcount of its inputs without processing their data.\n\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so the first value of the geo time series is at the beginning of the first bucket.\n\n@param `bucketspan` Width in time units of each bucket. If `bucketspan` is 0 but `bucketcount` is set, WarpScript will compute `bucketspan` so `bucketcount` buckets cover the complete set of values from firsttick to lasttick. If this value is set to -1, the number of buckets is computed so the first tick is towards the end of the first bucket.\n\n@param `lastbucket` Specifies the timestamp in time units since the Unix Epoch of the end of the most recent bucket. If you set this value to 0, this timestamp will be computed automatically so it covers the most recent value of the geo time series and falls on a `bucketspan` boundary.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS\n\n",signature:"[ gts<GTS+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>\n[ gts<GTS+> macro<MACRO> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> macro<MACRO> lastbucket<LONG> bucketspan<LONG> bucketcount<LONG> ]  BUCKETIZE  result<LIST<GTS>>",tags:["framework","bucketize","gts","bucketizer"],since:"1.0.0",OPB64name:"BUCKETIZE"},"BUCKETIZE.CALENDAR":{description:"Creates bucketized Geo Time Series with buckets that span a calendar duration that can be irregular (e.g. taking into account leap years and daylight saving time).\n\nInstead of using a bucketspan like the BUCKETIZE framework, it uses a bucketduration: a STRING in [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) format, as `PyYmMwWdDThHmMsS` similarly to that of ADDDURATION function. However, complex bucketdurations that can be non-positive from some ticks are not allowed.\n\nIn the result, the tick of each bucket is its index, which is equal to the number of buckets that are ended since Unix Epoch. In particular, the tick of the bucket that contains Unix Epoch is always 0. The resulting GTS is considered bucketized for further operations. Then, the function UNBUCKETIZE.CALENDAR can be used to replace bucket indices with their timestamp end boundaries.\n\nThis function answers the limitation of BUCKETIZE to regular buckets. For instance, BUCKETIZE.CALENDAR can be used with a duration of one month (`P1M`) or one year (`P1Y`).\n\nThe delta between Unix Epoch and the first timestamp of bucket 0th is called the bucketoffset. The bucketoffset, bucketduration and buckettimezone are stored in the attributes.\n\n@param `timezone` The timezone to consider. Default to UTC\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so every value of the GTS falls in a bucket.\n\n@param `bucketduration` Width in ISO 8601 duration format of each bucket.\n\n@param `lastbucket` Specifies the timestamp in platform time units of the end boundary of the most recent bucket. For coherency with BUCKETIZE, this value can not be set to 0.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS in the new time referential\n\n",signature:"[ gts<GTS+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>\n[ gts<GTS+> macro<MACRO> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>\n[ gts<GTS+> bucketizer<AGGREGATOR> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> timezone<STRING> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>\n[ gts<GTS+> macro<MACRO> lastbucket<LONG> bucketduration<STRING> bucketcount<LONG> timezone<STRING> ]  BUCKETIZE.CALENDAR  result<LIST<GTS>>",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"BUCKETIZE.CALENDAR"},BUCKETSPAN:{description:"The function `BUCKETSPAN` consumes a GTS off the stack and pushes its bucketspan onto the stack.\n\n> when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Bucketspan\n\n",signature:"gts<GTS>  BUCKETSPAN  result<LONG>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETSPAN"},"BYTES->":{description:"Converts a bytes array into a string with given a charset and put the string on top of the stack.\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\n\n@param `charset` Charset to use\n\n@param `bytes` Bytes array to convert\n\n@param `result` String converted byte array\n\n",signature:"bytes<BYTES> charset<STRING>  BYTES->  result<STRING>",tags:["strings","conversion"],since:"1.0.6",OPB64name:"F__JGKBhEV"},BYTESTOBITS:{description:"Converts a byte array into a bitset.\n\n@param `bytesarray` Bytes array\n\n@param `result` Bitset\n\n",signature:"bytesarray<BYTES>  BYTESTOBITS  result<BITSET>",tags:["bitset","conversion","binary"],since:"1.0.6",OPB64name:"BYTESTOBITS"},CALL:{description:'The `CALL` function invokes the external program whose path (relative to the `warpscript.call.directory` directory) is on top of the stack. The calling convention will pass to the external\nprogram the **STRING** object below the path on a line by itself on standard input after having URL encoded the **STRING**. The invoked\nprogram is expected to return a URL encoded **STRING** object if invocation was successful, or a string starting with a space and followed by a URL encoded error message if an error was encoutered.\n\nIf you need to pass complex structures to the invoked program, you can use functions such as [`->JSON`](/doc/AIt9JoxD), [`->PICKLE`](/doc/AItFHJCAI3J)\nand [`->B64`](/doc/AIt1CYF) to encode the input prior to the invocation.\n\nExamples of callable programs are provided in [shell](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/sh/callable.sh)\nand [python](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/python/callable.py).\n\nThe program must be stored in the directory described by the `warpscript.call.directory` configuration parameter.\n\nThe program must first output on the stdout the number of concurrent thread allowed.\n\nExample:\n\n```bash\n#!/bin/bash\necho 5 # 5 threads allowed\nurldecode() {\n  # urldecode <string>\n  local url_encoded="${1//+/ }"\n  printf \'%b\' "${url_encoded//%/\\\\x}"\n}\nwhile true\n\ndo\n  read line\n  line=`urldecode "${line}"` # read the params given by the WarpScript\n  echo $line # Will be pushed on the stack\ndone\n```\n\n@param `program` Program path\n\n@param `params` URL encoded input\n\n@param `result` URL encoded output\n\n',signature:"params<STRING> program<STRING>  CALL  result<STRING>",tags:["platform"],since:"1.0.7",OPB64name:"CALL"},CBRT:{description:"The `CBRT` function consumes a numeric parameter from the top of the stack and pushes back its cubic root.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Cubic root of the given value.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of cubic root of each given value.\n\n",signature:"value<NUMBER>  CBRT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  CBRT  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"CBRT"},CEIL:{description:"The `CEIL` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number bigger than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-up value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-up values, for each given value.\n\n",signature:"value<NUMBER>  CEIL  result<DOUBLE>\nlvalue<LIST<NUMBER>>  CEIL  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"CEIL"},CEVAL:{description:"The `CEVAL` function allows you to execute macros in a concurrent way on a pool of threads.\n\nAll macros will be executed with the maximum parallelism level specified. Each macro is executed on its own stack. The context of the global stack is\nreplicated to each of those stacks so each macro will have access to the existing symbols and the redefined functions. Any modification to the symbol\ntable or redifined functions done in a concurrent macro will not be reflected in the global stack afterwards.\n\nEach macro is invoked with its index in the list on top of the stack.\n\nUpon termination of each macro, the content of their respective stacks is put into a list, with the top of the stack at index 0, and those lists are\nmerged into a global list which is then pushed onto the stack. The resulting list for each macro appears at the index of the macro in the original macro list.\n\nBeware that no synchronization is implicitely performed between the concurrent macros. If you require synchronization between macros, for example because\nyou are modifying a list accessible by all macros via a symbol, you must use the [`SYNC`](/doc/SYNC) function.\n\nIf one of the macros fail, an attempt to interrupt the other running macros will be done and the failure will be propagated to the other macros. For the\ntime being, a call to [`STOP`](/doc/STOP) or [`RETURN`](/doc/RETURN) in one of the macros will stop all of them.\n\nUse of `CEVAL` is not available from within a macro currently executing in a `CEVAL` call.\n\nThe `CEVAL` function is part of the `io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```properties\n// Enable CEVAL and SYNC functions\nwarpscript.extension.concurrent = io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension\n```\n\n@param `poolSize` Parallelism level\n\n@param `macros` List of macros\n\n@param `result` Result list\n\n",signature:"macros<LIST> poolSize<LONG>  CEVAL  result<LIST>",tags:["extensions"],since:"1.0.0",OPB64name:"CEVAL"},CHECKMACRO:{description:"The `CHECKMACRO` function checks if a macro is defined and aborts the execution when it encounters an undefined macro.\n\n@param `name` The macro name\n\n",signature:"name<STRING>  CHECKMACRO ",tags:["logic","control"],since:"2.1.0",OPB64name:"CHECKMACRO"},CHECKSHAPE:{description:"Return a BOOLEAN indicating whether an input list and its nested lists sizes are coherent together to form a tensor (or multidimensional array).\n\n@param `list` The input list.\n\n@param `result` true or false.\n\n",signature:"list<LIST>  CHECKSHAPE  result<LIST>\n{ list<LIST>  } CHECKSHAPE  result<LIST>",tags:["lists","tensors"],since:"2.1.0",OPB64name:"CHECKSHAPE"},CHRONOEND:{description:"The `CHRONOEND` function ends a stopwatch with the given name previously started with [`CHRONOSTART`](/doc/CHRONOSTART). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\nIt is a good practice to put `CHRONOEND` in the finally clause of a [`TRY`](/doc/TRY) for the timing to work even if exceptions are thrown.\n\n@param `name` A name identifying the stopwatch.\n\n",signature:"name<STRING>  CHRONOEND ",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOEND"},CHRONOSTART:{description:"The `CHRONOSTART` function starts a stopwatch with the given name. To stop the stopwatch, call [`CHRONOEND`](/doc/CHRONOEND). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\n@param `name` A name identifying the stopwatch.\n\n",signature:"name<STRING>  CHRONOSTART ",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTART"},CHRONOSTATS:{description:"The `CHRONOSTATS` function \n\n@param `stats` A map with stopwatches names as keys and maps as values. These maps have two keys, `total_calls` and `total_time`. The former gives the number of calls to [`CHRONOSTART`](/doc/CHRONOSTART) and the latter gives the cumulative time between [`CHRONOSTART`](/doc/CHRONOSTART) and [`CHRONOEND`](/doc/CHRONOEND) in **nanoseconds**.\n\n",signature:" CHRONOSTATS  stats<MAP>",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTATS"},CHUNK:{description:"The `CHUNK` is used to split a Geo Time Series™ into partial GTS. The split operation is controlled by multiple parameters.\nThe series will be splitted in chunks, each chunks will form a new GTS, with a label value corresponding to its first tick.\n\n@param `keepempty` If true empty chunks are kept\n\n@param `chunklabel` The label name of the label added by the split operation (with a value corresponding to the first tick of the chunk).\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` An overlap duration (in time units) between chunks, this is useful when chunking a GTS to apply an algorithm which operates on a sliding window.\n\n@param `chunkwidth` The width in time units of each chunk.\n\n@param `lastchunkend` The end timestamp of the most recent split to consider.\n\n@param `gts` A single GTS instance.\n\n@param `gtsList` A GTS list to split, each GTS will be splitted individually.\n\n@param `encoder` A single GTS Encoder instance.\n\n@param `lEncoder` A GTS Encoder list to split, each GTS Encoder will be splitted individually.\n\n@param `result` GTS Chunks, a list formed with its partial GTS.\n\n@param `resultEncoders` GTS Encoders Chunks, a list formed with its partial GTS Encoders.\n\n",signature:"gts<GTS> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  result<LIST<GTS>>\ngtsList<LIST<GTS>> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  result<LIST<GTS>>\nencoder<GTSENCODER> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  resultEncoders<LIST<GTSENCODER>>\nlEncoder<LIST<GTSENCODER>> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNK  resultEncoders<LIST<GTSENCODER>>",tags:["gts"],since:"1.0.0",OPB64name:"CHUNK"},CHUNKENCODER:{description:"The `CHUNKENCODER` function is used to split a [GTSEncoder](/doc/NEWENCODER) into partial GTSEncoder. The user defines some parameters that will \nbe applied to the split operation. The series will be splitted in chunks, each chunks will form a new GTSEncoder, with a label value \ncorresponding to its first tick.\n\nDeprecated since 2.1, use CHUNK instead which behaves the same.\n\n@param `keepempty` If true empty chunk are kept\n\n@param `chunklabel` The label name of the label added by this split operation (add a value corresponding to the first tick of the chunk). Could be a regular expression.\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` A time overlap for each chunks in time units.\n\n@param `chunkwidth` The width in time unit of each chunks in time units.\n\n@param `lastchunkend` The split operation end when it encounters this timestamp.\n\n@param `GTSEncoder` A single GTSEncoder \n\n@param `GTSEncoderList` A GTSEncoder list to split, each GTSEncoder will be splitted individually.\n\n@param `result` GTSEncoder Chunks, a list formed with its partial GTSEncoder\n\n",signature:"GTSEncoder<GTSENCODER> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNKENCODER  result<LIST<GTSENCODER>>\nGTSEncoderList<LIST<GTSENCODER>> lastchunkend<LONG> chunkwidth<LONG> chunkoverlap<LONG> chunkcount<LONG> chunklabel<STRING> keepempty<BOOLEAN>  CHUNKENCODER  result<LIST<LIST<GTSENCODER>>>",tags:["encoder"],since:"1.2.9",OPB64name:"CHUNKENCODER"},CLEAR:{description:"The `CLEAR` function empties the stack.\n\n@param `input` all the input on the stack will be erased from the stack.\n\n",signature:"input<ANY*>  CLEAR ",tags:["stack"],since:"1.0.0",OPB64name:"CLEAR"},CLEARDEFS:{description:"The `CLEARDEFS` function allows you to clear all [redefined WarpScript functions](/doc/DEF).\n\nBy default, all redefined WarpScript function, will not be available anymore. Set the `warpscript.def.unshadow` \nconfiguration property to change this behaviour.\n\nThis configuration parameter determines if undefining a function (via NULL 'XXX' DEF) will unshadow the original statement \nthus making it available again or if it will replace it with a function that will fail with a message saying the function is undefined.\nThe safest behavior is to leave this undefined or set to **false**.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"CLEARDEFS"},CLEARREGS:{description:"Clears all registers, setting their current value to `NULL`.\n\n@param `value` Value from the designated register.\n\n",signature:" CLEARREGS  value<ANY>",tags:["stack"],since:"2.0.0",OPB64name:"CLEARREGS"},CLEARSYMBOLS:{description:"The `CLEARSYMBOLS` function clears all symbols defined with the function [`STORE`](/doc/STORE).\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"CLEARSYMBOLS"},CLEARTOMARK:{description:"Removes elements from the stack up to and including the first mark encountered.\n\n@param `inputs` all the inputs references on the stack will be erased\n\n@param `mark` the mark will also be erased\n\n",signature:"mark<MARK> inputs<ANY*>  CLEARTOMARK ",tags:["stack"],since:"1.0.0",OPB64name:"CLEARTOMARK"},CLIP:{description:"The `CLIP` function clips a Geo Time Series™, encoders or list thereof according to a series of limits. The limits are lists of pair containing the lower and upper \ntimestamps used to clip. Each pair will generate a clipped GTS or encoder for each instance.\n\n@param `bounds` List of timestamp pairs. Each pair is a list of LONG.\n\n@param `gts` GTS to clip\n\n@param `lgts` List of GTSs to clip\n\n@param `encoder` Emcoder to clip\n\n@param `lencoder` List of encoders to clip\n\n@param `result` List of clipped GTS\n\n",signature:"gts<GTS> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<GTS>>\nlgts<LIST<GTS>> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<LIST<GTS>>>\nencoder<GTSENCODER> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<GTSENCODER>>\nlencoder<LIST<GTSENCODER>> bounds<LIST<LIST<LONG>>>  CLIP  result<LIST<LIST<GTS>>>",tags:["gts"],since:"1.2.0",OPB64name:"CLIP"},CLONE:{description:"The `CLONE` function does a shallow copy of a given Geo Time Series™, List, Map or Vector. Since 2.1.1 it can also clone Encoders.\n\nAs it makes a shallow copy, be careful when using CLONE on a List of Geo Time Series™ like those generated by the use of [`FETCH`](/doc/FETCH). Modifying a Geo Time Series™ in any of those list will alter the matching Geo Time Series™ in the other List.\nIf you want to use `CLONE` after a [`FETCH`](/doc/FETCH), you will need to extract the Geo Time Series™ from the list, for example by using [`LIST->`](/doc/I3_IK1oy), [`GET`](/doc/GET) or [`LMAP`](/doc/LMAP).\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `list` The List to clone\n\n@param `map` The Map to clone\n\n@param `set` The Set to clone\n\n@param `vector` The Vector to clone\n\n@param `encoder` The Encoder to clone\n\n@param `clone` The cloned Geo Time Series™, List, Map, Vector or Encoder\n\n@param `original` The original Geo Time Series™, List, Map, Vector or Encoder\n\n",signature:"gts<GTS>  CLONE  original<GTS> clone<GTS>\nlist<LIST>  CLONE  original<LIST> clone<LIST>\nmap<MAP>  CLONE  original<MAP> clone<MAP>\nset<SET>  CLONE  original<SET> clone<SET>\nvector<VECTOR>  CLONE  original<VECTOR> clone<VECTOR>\nencoder<GTSENCODER>  CLONE  original<GTSENCODER> clone<GTSENCODER>",tags:["gts","lists","maps"],since:"1.0.0",OPB64name:"CLONE"},CLONEEMPTY:{description:"Clones a Geo Time Series™, an Encoder or all the instances in a list of Geo Time Series™ or an Encoder, keeping only the metadata and not the values.\n\nThe `CLONEEMPTY` function takes as parameter a Geo Time Series™, an Encoder or a list thereof. It creates an empty clone of the input with only his metadata. The cloned metadata are:\n * Classname\n * Labels\n * Attributes\n * Lastbucket, for Geo Time Series™ only\n * Bucketspan, for Geo Time Series™ only\n * Bucketcount, for Geo Time Series™ only\n * Base timestamp, for Encoders only\n * Wrapping key, for Encoders only\n\nThe input parameter is consumed and the clone or list of clones is left on the stack.\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `gtsList` The list of Geo Time Series™ to clone\n\n@param `result` The cloned Geo Time Series™\n\n@param `resultList` The cloned list of Geo Time Series™\n\n@param `encoder` The encoder to clone\n\n@param `encoderList` The list of encoder to clone\n\n@param `encoderResult` The cloned encoder\n\n@param `encoderResultList` The cloned list of encoders\n\n",signature:"gts<GTS>  CLONEEMPTY  result<GTS>\ngtsList<LIST<GTS>>  CLONEEMPTY  resultList<LIST<GTS>>\nencoder<GTSENCODER>  CLONEEMPTY  encoderResult<GTSENCODER>\nencoderList<LIST<GTSENCODER>>  CLONEEMPTY  encoderResultList<LIST<GTSENCODER>>",tags:["gts"],since:"1.0.0",OPB64name:"CLONEEMPTY"},CLONEREVERSE:{description:"The function CLONEREVERSE clone the input and reverses the order of the elements. \nOutput is a reference to a new object.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n@param `input` reference of the list or string to reverse.\n\n@param `output` reference to a new reversed list or string or byte array.\n\n",signature:"input<LIST>  CLONEREVERSE  output<LIST>\ninput<STRING>  CLONEREVERSE  output<STRING>\ninput<BYTES>  CLONEREVERSE  output<BYTES>",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"CLONEREVERSE"},COMMONTICKS:{description:"Take a list of Geo Time Series™ and output A GTS list with only the set of ticks they have in common compared by timestamp.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with common ticks\n\n",signature:"gtsList<LIST<GTS>>  COMMONTICKS  result<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"COMMONTICKS"},COMPACT:{description:"The `COMPACT` function expects a Geo Time Series™ or a **LIST** of GTS on top of the stack. For each GTS instance it reads, it will \nproduce a GTS whith fewer values, by removing measurements which have the same value, location and elevation as the previous one. The first tick will be the kept, then ticks with value or position change will be kept. The last tick from the original gts will be copied, in order to keep the same LASTTICK.\n\n@param `gts` A GTS to compact\n\n@param `gtsList` A GTS list to compact\n\n@param `result` A compacted GTS\n\n@param `resultList` A compacted GTS list\n\n",signature:"gts<GTS>  COMPACT  result<GTS>\ngtsList<LIST<GTS>>  COMPACT  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"COMPACT"},CONTAINS:{description:"The `CONTAINS` function checks if the element on top of the stack is contained by the list on second position. A boolean is pushed on the stack.\n\nIf the parameters are two STRINGs, `CONTAINS` checks if the second STRING is contained in the first one, leaving a boolean on the stack. This latter usage is available since revision 2.1.0.\n\n@param `item` Depending on list construction, could be a number, a string, a boolean, NULL, a GTS...\n\n@param `presence` true if inputlist contains the item. false otherwise or if inputlist is empty.\n\n@param `list` reference to the LIST to search.\n\n@param `set` reference to the SET to search.\n\n@param `str` STRING in which to find `substr`.\n\n@param `substr` STRING to find in `str`.\n\n",signature:"list<LIST> item<ANY>  CONTAINS  list<LIST> presence<BOOLEAN>\nset<SET> item<ANY>  CONTAINS  set<LIST> presence<BOOLEAN>\nstr<STRING> substr<STRING>  CONTAINS  presence<BOOLEAN>",tags:["lists"],since:"1.0.0",OPB64name:"CONTAINS"},CONTAINSKEY:{description:"The `CONTAINSKEY` function checks if the key element on top of the stack is a key \nof the map on second position. \n\nThe key is consumed, and a boolean is pushed on the stack.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this key. Do not trust presence if key is NULL.\n\n",signature:"inputmap<MAP> key<ANY>  CONTAINSKEY  outputmap<MAP> presence<BOOLEAN>",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSKEY"},CONTAINSVALUE:{description:"The `CONTAINSVALUE` function checks if the value element on top of the stack is a value \nof the map on second position. \n\nThe value is consumed, and a boolean is pushed on the stack.\n\n@param `value` Depending on map construction, could be a number, a string, a boolean, NULL.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this value in at least one pair of its key-value.\n\n",signature:"inputmap<MAP> value<ANY>  CONTAINSVALUE  outputmap<MAP> presence<BOOLEAN>",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSVALUE"},CONTINUE:{description:"Immediately stop executing the current iteration of an ongoing loop and start the next one.\n\n",signature:"",tags:["logic","control"],since:"1.0.0",OPB64name:"CONTINUE"},COPYGEO:{description:"The `COPYGEO` function forces the location elements of a GTS onto others. `COPYGEO` expects two parameters on the stack.\nFirst input is GTS or a gts list: those series(s) will have their location overwritten by the one of the second GTS parameter. Geo information will be copied only if they are present in the second paramaters on the same tick otherwise it keep the existing location. See [`COMMONTICKS`](/doc/COMMONTICKS) to keep only commonticks before calling `COPYGEO`.\n\n@param `gts` A GTS\n\n@param `gtsList` A list of GTS\n\n@param `geogts` A GTS with the geo information you want to copy to other (list of) gts.\n\n@param `result` A GTS with the geo information of the geogts input\n\n@param `resultList` A list of GTS with the geo information of the geogts input\n\n",signature:"gts<GTS> geogts<GTS>  COPYGEO  result<GTS>\ngtsList<LIST<GTS>> geogts<GTS>  COPYGEO  resultList<LIST<GTS>>",tags:["gts","geo"],since:"1.0.0",OPB64name:"COPYGEO"},COPYSIGN:{description:"The `COPYSIGN` function copies the sign of a number on another one and pushes back the value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` Numeric parameter on which sign is applied\n\n@param `p2` Numeric parameter on which sign is extracted\n\n@param `list1` List of numeric parameter on wich sign is applied\n\n@param `list2` List of numeric parameter on wich sign is extracted\n\n@param `result` Value of p1 with the sign of p2 s a DOUBLE\n\n@param `lresult` List of results\n\n",signature:"p1<NUMBER> p2<NUMBER>  COPYSIGN  result<DOUBLE>\np1<NUMBER> list2<LIST<NUMBER>>  COPYSIGN  lresult<LIST<DOUBLE>>\nlist1<LIST<NUMBER>> p2<NUMBER>  COPYSIGN  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"COPYSIGN"},CORRELATE:{description:"The `CORRELATE` function allows you to compute correlation between one base Geo Time Series™ and a set of others. \nBy putting the base GTS in the set of others, cross correlation can be computed.\n\n@param `baseGTS` The base Geo Time Series\n\n@param `gtsList` A list of Geo Time Series against which to compute the correlation\n\n@param `timeOffsets` A list of time offsets for which the correlation will be computed (expressed in time units of the Warp instance)\n\n@param `result` A list of synthetic Geo Time Series™ whose timestamps are the offsets from the initial offset list and the values are the computed correlations. There is one GTS per GTS in the list at TOP-1.\n\n",signature:"baseGTS<GTS> gtsList<LIST> timeOffsets<LIST>  CORRELATE  result<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"CORRELATE"},COS:{description:"The `COS` function consumes a floating point number from the top of the stack and pushes back its cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Cosine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of cosine of the given values.\n\n",signature:"value<NUMBER>  COS  result<DOUBLE>\nlvalue<LIST<NUMBER>>  COS  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COS"},COSH:{description:"The `COSH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic cosine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic cosine of the given values.\n\n",signature:"value<NUMBER>  COSH  result<DOUBLE>\nlvalue<LIST<NUMBER>>  COSH  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COSH"},COUNTER:{description:"The `COUNTER` function pushes a counter (AtomicLong) initialized with the value 0 onto the stack.\n\nThis atomic counter can be safely shared in multiple concurrent macros (see [`CEVAL`](/doc/CEVAL)).\n\n@param `counter` Counter instance.\n\n",signature:" COUNTER  counter<COUNTER>",tags:["counters"],since:"1.0.0",OPB64name:"COUNTER"},COUNTERDELTA:{description:"The `COUNTERDELTA` function increments a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `increment` Counter increment.\n\n",signature:"counter<COUNTER> increment<LONG>  COUNTERDELTA  counter<COUNTER>",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERDELTA"},COUNTERSET:{description:"The `COUNTERSET` function set the value of a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `value` Counter value.\n\n",signature:"counter<COUNTER> value<LONG>  COUNTERSET  counter<COUNTER>",tags:["counters"],since:"1.2.22",OPB64name:"COUNTERSET"},COUNTERVALUE:{description:"The `COUNTERVALUE` function pushes the counter value onto the stack.\n\n@param `counter` The counter instance.\n\n@param `value` The value of the counter.\n\n",signature:"counter<COUNTER>  COUNTERVALUE  value<LONG>",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERVALUE"},COUNTTOMARK:{description:"Counts the number of elements on the stack up to but excluding the first mark encountered. Neither the mark nor the\nelements on top of it are removed from the stack.\n\n@param `result` Stack depth until `MARK`\n\n",signature:" COUNTTOMARK  result<LONG>",tags:["stack"],since:"1.0.0",OPB64name:"COUNTTOMARK"},CPOPR:{description:"Pops a value from the top of the stack and stores it into the designated register if the register is empty (*i.e.* has `NULL` as its current value).\n\nThe `CPOPR` function is really a family of functions named `CPOPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",signature:"value<ANY>  CPOPR ",tags:["stack"],since:"2.0.0",OPB64name:"CPOPR"},CPROB:{description:"The function `CPROB` generates a new Geo Time Series™ from an input Geo Time Series™ by computing a conditional probability.\n\nThe function expects a **STRING** separator on top of the stack and expects the input Geo Time Series™ to have \nvalues of the form given1< SEP >given2< SEP >....< SEP >event. It will then emit P(event|given1,given2,...).\n\nIf the separator is **NULL**, `CPROB` behaves like [`PROB`](/doc/PROB).\n\n@param `separator` Value separator\n\n@param `gts` Geo Time Series™\n\n@param `lgts` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `lresult` List of Geo Time Series™\n\n",signature:"gts<GTS> separator<STRING>  CPROB  result<GTS>\nlgts<LIST<GTS>> separator<STRING>  CPROB  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.6",OPB64name:"CPROB"},CROP:{description:"The `CROP` function works on bucketized Geo Time Series™ instances, if transforms a GTS into another one whose bucketcount, last bucket parameters span the smallest interval with actual values. Bucket span remains the same.\n\nWhen called on a non bucketized GTS instance, `CROP` simply clones it.\n\nThis function expects a list of GTS instances on the top of the stack.\n\n@param `gts` Bucketized GTS\n\n@param `result` ropped version of GTS or a clone thereof if GTS was not bucketized.\n\n@param `gtsList` List of bucketized GTS\n\n@param `resultList` A list of cropped version of GTS or a clone thereof if GTS was not bucketized.\n\n",signature:"gts<GTS>  CROP  result<GTS>\ngtsList<LIST<GTS>>  CROP  resultList<LIST<GTS>>",tags:["bucketize"],since:"1.0.0",OPB64name:"CROP"},CSTORE:{description:"The `CSTORE` function stores a value in a symbol or a register only if that symbol or register is not yet defined. The name of this function stands for Conditional STORE.\n\n@param `symbol` Name of symbol under which to store `value`.\n\n@param `register` Number of the register under which to store `value`.\n\n@param `value` Value to store unde `symbol`.\n\n",signature:"value<ANY> symbol<STRING>  CSTORE \nvalue<ANY> register<LONG>  CSTORE ",tags:["stack"],since:"1.0.0",OPB64name:"CSTORE"},CUDF:{description:"The `CUDF` function invokes a User Defined Function from a Jar as [`UDF`](/doc/UDF) but reuses a cached instance of the function.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",signature:"class<STRING>  CUDF ",tags:["control"],since:"1.0.0",OPB64name:"CUDF"},DEBUGOFF:{description:"Turns off stack debugging which was turned on by [`DEBUGON`](/doc/DEBUGON) or [`NDEBUGON`](/doc/NDEBUGON).\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGOFF"},DEBUGON:{description:"Turns on stack debugging which returns the stack content in case of error. Stack debugging is off by default.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGON"},DECREMENTEXACT:{description:"The `DECREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value decremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be decremented by one\n\n@param `result` The decremented value\n\n@param `lvalue` List of values to be decremented by one\n\n@param `lresult` List of decremented values\n\n",signature:"value<NUMBER>  DECREMENTEXACT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  DECREMENTEXACT  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.2.23",OPB64name:"DECREMENTEXACT"},DEDUP:{description:"Removes duplicate ticks.\n\nThe `DEDUP` function consumes a Geo Time Series™ or a **LIST** thereof from the top of the stack and pushes back the Geo Time Series™ with deduplicated ticks.\n\nSince the 2.7.0 version, this function can be given an optional mapper or macro to combine the duplicate data points.\n\n@param `gts` The Geo Time Series™ to deduplicate\n\n@param `result` The Geo Time Series™ with deduplicated ticks\n\n@param `lgts` The list of Geo Time Series™ to deduplicate\n\n@param `lresult` The list of Geo Time Series™ with deduplicated ticks\n\n@param `mapper` Mapper used to aggregate duplicate values\n\n@param `macro` Macro used to aggregate duplicate values given as a GTS\n\n",signature:"gts<GTS>  DEDUP  result<GTS>\ngts<GTS> mapper<AGGREGATOR>  DEDUP  lresult<GTS>\ngts<GTS> macro<MACRO>  DEDUP  lresult<GTS>\nlgts<LIST<GTS>>  DEDUP  lresult<LIST<GTS>>\nlgts<LIST<GTS>> mapper<AGGREGATOR>  DEDUP  lresult<LIST<GTS>>\nlgts<LIST<GTS>> macro<MACRO>  DEDUP  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"DEDUP"},DEF:{description:"The `DEF` function allows you to define new WarpScript functions or redefine existing ones for the duration of your script execution.\n\nThe function expects on the stack a macro which will be used as the content of the newly defined function, and a name under which to define the new function.\n\nWhen redefining a function, if the function being redefined is used within the macro, the code which will be executed is the current one, \nas the binding of function to code is done at the time when the macro is defined and not when it is executed.\n\nYou may therefore add limits to the use of an existing function by rewrapping it in a macro which will be associated with the original function name.\n\nTo remove redefined functions see [`CLEARDEFS`](/doc/CLEARDEFS).\n\n@param `name` New function name\n\n@param `newDef` Macro which will be used as the content of the newly defined function\n\n",signature:"newDef<MACRO> name<STRING>  DEF ",tags:["stack"],since:"1.0.0",OPB64name:"DEF"},DEFINED:{description:"The `DEFINED` function checks whether or not a symbol is defined.\n\n@param `name` Symbol name\n\n@param `result` Whether or not the symbol is defined\n\n",signature:"name<STRING>  DEFINED  result<BOOLEAN>",tags:["logic","control"],since:"1.0.0",OPB64name:"DEFINED"},DEFINEDMACRO:{description:"The `DEFINEDMACRO` function checks if a macro is defined and pushes true or false on the stack accordingly.\n\n@param `name` The macro name\n\n@param `result` True if the macro is defined, false otherwise\n\n",signature:"name<STRING>  DEFINEDMACRO  result<BOOLEAN>",tags:["logic","control"],since:"1.0.16",OPB64name:"DEFINEDMACRO"},DEFLATE:{description:"The `DEFLATE` function compresses a STRING or a byte array using the [Zlib](https://en.wikipedia.org/wiki/Zlib) library. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",signature:"string<STRING>  DEFLATE  compressed<BYTES>\nbytes<BYTES>  DEFLATE  compressed<BYTES>",tags:["conversion"],since:"2.1.0",OPB64name:"DEFLATE"},DELETE:{description:"The `DELETE` function is used to delete a set of GTS from a Warp 10 platform. A delete endpoint must be set on the Warp 10 configuration.\n\nDelete expects 5 parameters on top of the stack: the write token of the Warp 10 application, a string corresponding to a gts selector, a start \nand a end timestamp and finally the number of GTS expected to be deleted.\n\nFor safety reasons `DELETE` will first perform a dryrun call to the /delete endpoint to retrieve the number of GTS which would be deleted by the call. \nIf this number is above the expected number provided by the user the actual delete will not be performed and instead an error will be raised.\n\nDelete will push as a result the number of GTS really deleted.\n\nIf both end_timestamp and start_timestamp are NULL, Warp 10 will perform a delete all. FETCH won't find anything after a delete all.\n\n```flow\n// Write token\n'TOKEN'\n\n// Gts selector\n'gts.to.delete{}'\n\n// Start Timestamp\n1479372838011043\n\n// End timestamp\nNOW\n\n// DELETE expects a count number (if nb GTS > count, DELETE is stopped)\n1\n\nDELETE \n```\n\n@param `count` Number of GTS expected to be deleted\n\n@param `end_timestamp` End timestamp or NULL\n\n@param `start_timestamp` Start timestamp or NULL\n\n@param `gts_selector` GTS selector\n\n@param `writeToken` Write token\n\n@param `result` Actual deleted GTS count\n\n",signature:"writeToken<STRING> gts_selector<STRING> start_timestamp<LONG> end_timestamp<LONG> count<LONG>  DELETE  result<LONG>",tags:["gts"],since:"1.0.5",OPB64name:"DELETE"},DELETEOFF:{description:"Disables delete operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a delete operation is attempted.\n\n",signature:"message<STRING> secret<STRING>  DELETEOFF ",tags:["platform"],since:"2.0.3",OPB64name:"DELETEOFF"},DELETEON:{description:"Enables delete operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",signature:"secret<STRING>  DELETEON ",tags:["platform"],since:"2.0.3",OPB64name:"DELETEON"},DEPTH:{description:"The `DEPTH` function pushes on top of the stack the depth (i.e. number of levels) of the stack prior to the call.\n\n@param `result` Stack depth\n\n",signature:" DEPTH  result<LONG>",tags:["stack"],since:"1.0.0",OPB64name:"DEPTH"},DEREF:{description:"Replaces in a Macro the occurrences of symbol dereferencing (`$x`) or calls to `LOAD` with a `STRING` argument or calls to `PUSHRx` by the values associated with either the symbol name or register number in a parameter map.\n\nValues are used verbatim except for Macros which are inserted as functions, *i.e.* they are inserted followed by a call to `EVAL` so they are executed in the target macro instead of ending up on the stack. If you wish to replace a symbol dereference by a Macro, you need to write the macro inside of another Macro.\n\n\n@param `macro` Macro to transform.\n\n@param `values` Map of symbol name or register number to replacement value.\n\n",signature:"macro<MACRO> values<MAP>  DEREF  macro<MACRO>",tags:["stack"],since:"2.3.0",OPB64name:"DEREF"},DET:{description:"Computes the [determinant](https://en.wikipedia.org/wiki/Determinant) of a matrix.\n\n@param `matrix` The matrix for which to compute the determinant.\n\n@param `det` The computed determinant.\n\n",signature:"matrix<MATRIX>  DET  det<DOUBLE>",tags:["math"],since:"1.0.6",OPB64name:"DET"},DIFFERENCE:{description:"Computes the difference between two sets.\n\nThe `DIFFERENCE` function consumes two sets from the top of the stack and pushes back its mathematical difference (ie: the elements in *A* but not in *B*).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* - *B*, the set of elements in *A* but not in *B*\n\n",signature:"setA<SET> setB<SET>  DIFFERENCE  output<SET>",tags:["sets"],since:"1.0.0",OPB64name:"DIFFERENCE"},DISCORDS:{description:"The `DISCORDS` function detects discords in a Geo Time Series™. The discord detection algorithm is based on identifying outlier patterns in\nthe Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `DISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0\n\n@param `overlapping` Flag indicating whether or not the `DISCORDS` function should report overlapping discords\n\n@param `maximum` The maximum number of discords to identify\n\n@param `lresult` The list of Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `result` The Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n",signature:"lgts<LIST<GTS>> wsize<LONG> length<LONG> scale<LONG> maximum<LONG> overlapping<BOOLEAN> distance<DOUBLE>  DISCORDS  lresult<LIST<GTS>>\ngts<GTS> wsize<LONG> length<LONG> scale<LONG> maximum<LONG> overlapping<BOOLEAN> distance<DOUBLE>  DISCORDS  result<GTS>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"DISCORDS"},DOC:{description:"Consumes the String on the stack or leave it there and stop the script if the stack is currently in documentation mode ([`DOCMODE`](/doc/DOCMODE)) \n\nYou can use it to document macros.\n\n@param `string` Text to display in [`DOCMODE`](/doc/DOCMODE)\n\n",signature:"string<STRING>  DOC  string<STRING>",tags:["help"],since:"1.0.0",OPB64name:"DOC"},DOCMODE:{description:"Toggle the 'documentation mode' of the stack\n\n",signature:"",tags:["help"],since:"1.0.0",OPB64name:"DOCMODE"},"DOUBLEBITS->":{description:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the **LONG** value as the raw bits of the **DOUBLE**\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",signature:"input<LONG>  DOUBLEBITS->  result<DOUBLE>",tags:["conversion","binary"],since:"1.2.3",OPB64name:"G3xKFZl4FZ_JJmoy"},DOUBLEEXPONENTIALSMOOTHING:{description:"The `DOUBLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Double Exponential Smoothing aka Holt's linear trend method](https://www.otexts.org/fpp/7/2) formula.\n\nIt consumes three parameters from the top of the stack:\n * A trend smoothing factor beta (a numeric parameter between 0 < beta < 1)\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** and levels are pushed onto the stack (in this order in the **LIST**).\n\n@param `beta` The trend smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The list within the smoothed Geo Time Series™ and its levels\n\n",signature:"gts<GTS> alpha<DOUBLE> beta<DOUBLE>  DOUBLEEXPONENTIALSMOOTHING  result<LIST<GTS>>",tags:["gts","statistics"],since:"1.0.0",OPB64name:"DOUBLEEXPONENTIALSMOOTHING"},DROP:{description:"The `DROP` function removes the element at the top of the stack.\n\n@param `input` object reference to drop from the top of the stack.\n\n",signature:"input<ANY>  DROP ",tags:["stack"],since:"1.0.0",OPB64name:"DROP"},DROPN:{description:"The `DROPN` function removes the top N elements of the stack after having consumed N which was on the top of the stack prior to calling `DROPN`.\n\n@param `number` The number of elements to drop\n\n",signature:"number<NUMBER>  DROPN ",tags:["stack"],since:"1.0.0",OPB64name:"DROPN"},DTW:{description:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) or -1 if the threshold was reached.\n\n",signature:"gts1<GTS> gts2<GTS> threshold<DOUBLE>  DTW  dtw<DOUBLE>",tags:["gts","distance"],since:"1.0.0",OPB64name:"DTW"},DUP:{description:"The `DUP` function duplicates the element on the top of the stack, it doesn’t copy the content. If you apply DUP to a GTS you will\nhave two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `input` any parameter on top of the stack\n\n@param `out` a reference copy of input on top of the stack\n\n",signature:"input<ANY>  DUP  input<ANY> out<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"DUP"},DUPN:{description:"The `DUPN` function duplicates the top N elements of the stack after having consumed N which is on the top of the stack when calling `DUPN`.\n\nAs the [`DUP`](/doc/DUP) function, `DUPN` duplicates the references of the N elements on the top of the stack, it doesn’t copy the elements.\nIf you apply `DUPN` to a GTS you will have two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `number` The number of elements to duplicate\n\n",signature:"number<NUMBER>  DUPN ",tags:["stack"],since:"1.0.0",OPB64name:"DUPN"},DURATION:{description:"The `DURATION` function consumes a **STRING** representing an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) and pushes back a **LONG** duration in platform time unit.\n\nThe ISO 8601 duration can be expessed as `PwWdDThHmMsS` with:\n- `w` weeks\n- `d` days\n- `h` hours\n- `m` minutes\n- `s` or `s.ssssss...` seconds\nEach of these values can be either positive or negative. Each value/unit couple can be omitted if the value is zero but at least one value/couple should be defined.\n\nIf the consumed ISO 8601 duration has precision under platform time unit, superfluous digits will be ignored. Prior to revision 2.4, precision below milliseconds were always ignored, independently of platform time unit.\n\n@param `isoDuration` A representation of a ISO 8601 duration with some limitations, see the description.\n\n@param `duration` Number of platform time unit corresponding to the duration.\n\n",signature:"isoDuration<STRING>  DURATION  duration<LONG>",tags:["time"],since:"1.0.0",OPB64name:"DURATION"},DWTSPLIT:{description:"The `DWTSPLIT` function splits a Geo Time Series™ produced by [`FDWT`](/doc/FDWT) into multiple series, one per resolution level of the Wavelet transform.\n\n\n@param `label-name` Label name used in the generated series to indicate the level of each Geo Time Series™\n\n@param `gts` GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `lgts` List of GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `result` Splited GTS\n\n@param `lresult` List of splited GTS\n\n",signature:"gts<GTS> label-name<STRING>  DWTSPLIT  result<GTS>\nlgts<LIST<GTS>> label-name<STRING>  DWTSPLIT  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"DWTSPLIT"},E:{description:"Alias of [e](/doc/OF).\n\nThe `E` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",signature:" E  eValue<DOUBLE>",tags:["math","constants"],since:"1.0.0",OPB64name:"GF"},ECGEN:{description:"The `ECGEN` function generates a public/private key pair parameters suitable for performing [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n\nThe resulting parameters can serve as input to [`ECPRIVATE`](/doc/ECPRIVATE) and [`ECPUBLIC`](/doc/ECPUBLIC) to generate the actual private and public keys.\n\nThe following curves are supported:\n\n`c2pnb272w1`, `c2tnb191v3`, `c2pnb208w1`, `c2tnb191v2`, `c2tnb191v1`, `prime192v3`, `c2tnb359v1`, `prime192v2`, `prime192v1`, `c2tnb239v3`, `c2pnb163v3`, `c2tnb239v2`, `c2pnb163v2`, `c2tnb239v1`, `c2pnb163v1`, `c2pnb176w1`, `prime256v1`, `c2pnb304w1`, `c2pnb368w1`, `c2tnb431r1`, `prime239v3`, `prime239v2`, `prime239v1`, `sect233r1`, `secp112r2`, `secp112r1`, `secp256k1`, `sect113r2`, `secp521r1`, `sect113r1`, `sect409r1`, `secp192r1`, `sect193r2`, `sect131r2`, `sect193r1`, `sect131r1`, `secp160k1`, `sect571r1`, `sect283k1`, `secp384r1`, `sect163k1`, `secp256r1`, `secp128r2`, `secp128r1`, `secp224k1`, `sect233k1`, `secp160r2`, `secp160r1`, `sect409k1`, `sect283r1`, `sect163r2`, `sect163r1`, `secp192k1`, `secp224r1`, `sect239k1`, `sect571k1`, `B-163`, `P-521`, `P-256`, `B-233`, `P-224`, `B-409`, `P-384`, `B-283`, `B-571`, `P-192`, `brainpoolp512r1`, `brainpoolp384t1`, `brainpoolp256r1`, `brainpoolp192r1`, `brainpoolp512t1`, `brainpoolp256t1`, `brainpoolp224r1`, `brainpoolp320r1`, `brainpoolp192t1`, `brainpoolp160r1`, `brainpoolp224t1`, `brainpoolp384r1`, `brainpoolp320t1`, `brainpoolp160t1`\n\n@param `curve` Name of the elliptic curve to use.\n\n@param `public` Map containing the public key parameters.\n\n@param `private` Map containing the private key parameters.\n\n",signature:"curve<STRING>  ECGEN  private<MAP> public<MAP>",tags:["crypto"],since:"2.6.0",OPB64name:"ECGEN"},ECHOOFF:{description:"Turns off the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:" ECHOOFF ",tags:["stack"],since:"2.0.0",OPB64name:"ECHOOFF"},ECHOON:{description:"Turns on the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of topmost stack levels to display after each WarpScript™ line, truncated if floating-point.\n\n",signature:"levels<NUMBER>  ECHOON ",tags:["stack"],since:"2.0.0",OPB64name:"ECHOON"},ECPRIVATE:{description:"The `ECPRIVATE` function generates a private key from private key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `private` Map containing ECC private key parameters.\n\n@param `key` ECC private key.\n\n",signature:"private<MAP>  ECPRIVATE  key<KEY>",tags:["crypto"],since:"2.6.0",OPB64name:"ECPRIVATE"},ECPUBLIC:{description:"The `ECPUBLIC` function generates a public key from public key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `public` Map containing ECC public key parameters.\n\n@param `key` ECC public key.\n\n",signature:"public<MAP>  ECPUBLIC  key<KEY>",tags:["crypto"],since:"2.6.0",OPB64name:"ECPUBLIC"},ECSIGN:{description:"The `ECSIGN` function generates a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) private key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Content to sign.\n\n@param `alg` Signing algorithm to use.\n\n@param `private` Private key to use for signining.\n\n@param `signature` Resulting signature.\n\n",signature:"data<BYTES> alg<STRING> private<KEY>  ECSIGN  signature<BYTES>",tags:["crypto"],since:"2.6.0",OPB64name:"ECSIGN"},ECVERIFY:{description:"The `ECVERIFY` function verifies a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) public key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Signed data.\n\n@param `alg` Signing algorithm to use.\n\n@param `public` Public key to use for verification.\n\n@param `signature` Signature to verify.\n\n@param `result` Validity of the signature.\n\n",signature:"data<BYTES> signature<BYTES> alg<STRING> public<KEY>  ECVERIFY  result<BOOLEAN>",tags:["crypto"],since:"2.6.0",OPB64name:"ECVERIFY"},ELAPSED:{description:"The `ELAPSED` function pushes onto the stack a list containing timing informations. The first element of the list is the timestamp at which \nthe script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution \nof the associated script line.\n\nTiming informations are only collected after a call to [`TIMINGS`](/doc/TIMINGS) (its line included) and before a call to [`NOTIMINGS`](/doc/NOTIMINGS)\n (its line excluded).\n\n@param `result` The first element of the list is the timestamp at which the script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution of the associated script line.\n\n",signature:" ELAPSED  result<LIST<LONG>>",tags:["stack"],since:"1.0.0",OPB64name:"ELAPSED"},ELEVATIONS:{description:"The `ELEVATIONS` function consumes a Geo Time Series™ or a list thereof from the stack, extracts its elevations, puts them in a list and pushes the list onto the stack.      \n\n@param `gts` The Geo Time Series™ from which to extract the elevations\n\n@param `lgts` The list of Geo Time Series™ from which to extract the elevations\n\n@param `elevations` The elevations of the given Geo Time Series™\n\n@param `lelevations` The list of elevations of the given Geo Time Series™\n\n",signature:"gts<GTS>  ELEVATIONS  elevations<LIST<LONG>>\nlgts<LIST<GTS>>  ELEVATIONS  lelevations<LIST<LIST<LONG>>>",tags:["gts","geo"],since:"1.0.0",OPB64name:"ELEVATIONS"},EMPTY:{description:"Reject GTS instances with values.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with empty values\n\n",signature:"gtsList<LIST<GTS>>  EMPTY  result<LIST<GTS>>",tags:["gts"],since:"1.2.5",OPB64name:"EMPTY"},"ENCODER->":{description:"The `ENCODER->` functions convert an encoder into a list of ( timestamp, latitude, longitude, elevation, value ) list. It also pushes attributes, labels and name on the stack.\nFunction also accepts wrapped or raw-wrapped encoders or gts.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedinput` Encoder or GTS after WRAP. \n\n@param `rawwrappedinput` Encoder or GTS after WRAPRAW.\n\n@param `output` List of list of ( timestamp, latitude, longitude, elevation, value ). Missing values in the encoder or GTS are replaced by NaN.\n\n@param `name` Name of encoder or GTS. If no name was defined, will be NULL.\n\n@param `attributes` Attributes of encoder or GTS input. If none defined, will be an empty map.\n\n@param `labels` Labels of encoder or GTS input. If none defined, will be an empty map.\n\n",signature:"encoder<GTSENCODER>  ENCODER->  name<STRING> attributes<MAP> labels<MAP> output<LIST>\nwrappedinput<STRING>  ENCODER->  name<STRING> attributes<MAP> labels<MAP> output<LIST>\nrawwrappedinput<BYTES>  ENCODER->  name<STRING> attributes<MAP> labels<MAP> output<LIST>",tags:["encoder","conversion","gts"],since:"1.2.9",OPB64name:"GJt2IoG4JXoy"},ERROR:{description:"Pushes onto the stack a list containing the current error (as caught by a [`TRY`](/doc/TRY)) and its causes. Each error is a map with the following fields:\n\n| Field | Description |\n| --- | --- |\n| type | Type of the error, the Java class of the underlying exception |\n| message | The message associated with the error |\n| stacktrace | A list of lists, each containing `filename`, `line number`, `class name`, `method name` |      \n\nThe current error is the first element of the list.\n\nIf there is no current error, the returned list will be empty.\n\n@param `error` List of maps describing the current error and its causes.\n\n",signature:" ERROR  error<LIST<MAP>>",tags:["stack"],since:"1.2.11",OPB64name:"ERROR"},ESDTEST:{description:"The `ESDTEST` function detects outliers in a GTS (or a **LIST** of GTS), by applying a [generalized extreme studentized deviate test](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm).\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nA [Grubbs’](/doc/GRUBBSTEST)test is done for one candidate at a time. Then, the candidate is removed from the set and another [Grubbs’](/doc/GRUBBSTEST)test\nis performed. This process is iterated a given number of times. The detected outliers are the removed values and the current candidate of the last successful\ntest.\n\nA **LIST** of ticks (or a **LIST** of **LIST** of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",signature:"gts<GTS> k<LONG> mad<BOOLEAN> alpha<DOUBLE>  ESDTEST  result<LIST<LONG>>\ngts<GTS> k<LONG> mad<BOOLEAN>  ESDTEST  result<LIST<LONG>>\ngtsList<LIST<GTS>> k<LONG> mad<BOOLEAN> alpha<DOUBLE>  ESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> k<LONG> mad<BOOLEAN>  ESDTEST  resultList<LIST<LIST<LONG>>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ESDTEST"},EVAL:{description:"The `EVAL` function evaluates the statements contained in the string at the top of the stack as if they had been entered individually or runs the macro at the top os the stack.\n\n@param `string` String to evaluate\n\n@param `macro` Macro to run\n\n",signature:"macro<MACRO>  EVAL \nstring<STRING>  EVAL ",tags:["control"],since:"1.0.0",OPB64name:"EVAL"},EVALSECURE:{description:"The `EVALSECURE` function executes a secure script. The script must have been created on a platform with the same secure script cryptographic key as the current platform (note that this is not the *secret* set using [`SECUREKEY`](doc/SECUREKEY)).\n\n@param `secure` String containing the secure script to execute.\n\n@param `return` The return values depend on the actual code of the secure script.\n\n",signature:"secure<STRING>  EVALSECURE  return<ANY>",tags:["crypto","stack"],since:"1.0.0",OPB64name:"EVALSECURE"},EVERY:{description:"When called via the `/mobius` endpoint, the `EVERY` function sets the repeat interval for the preceding macro.\n\nWhen called outside of `/mobius`, the `EVERY` function simply executes the macro.\n\n@param `repeat` The repeat interval to enforce, in milliseconds.\n\n@param `macro` The macro to execute.\n\n",signature:"macro<MACRO> repeat<LONG>  EVERY ",tags:["platform"],since:"1.0.0",OPB64name:"EVERY"},EXP:{description:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a floating point value x consumed from the top of the stack,\n i.e. e<sup>x</sup>.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List where each value is e<sup>x</sup>\n\n",signature:"value<NUMBER>  EXP  result<DOUBLE>\nlvalue<LIST<NUMBER>>  EXP  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"EXP"},EXPM1:{description:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a DOUBLE value x consumed from the top of the stack then subtracts one, i.e. e<sup>x</sup>-1.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>-1\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List of e<sup>x</sup>-1\n\n",signature:"value<NUMBER>  EXPM1  result<DOUBLE>\nlvalue<LIST<NUMBER>>  EXPM1  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"EXPM1"},EXPORT:{description:"The `EXPORT` function allows you to set or update a list of symbols which will be dumped upon script termination. This proves handy when \ndebugging a script as you can visualize, even in the case of errors, the value of specific symbols.\n\nThe function expects either a symbol name (a **STRING**) which will be added to the current list of exported symbols, a list of symbol \nname which will replace the current list of exported symbols, an empty list to disable symbol export altogether, or a list with a single\n**NULL** element to instruct the WarpScript engine to export all existing symbols.\n\nWhen symbols should be exported, the debug mode is implied (see [`DEBUGON`](/doc/DEBUGON)).\n\n@param `symbol` Symbol name\n\n@param `symbols` List of symbols\n\n",signature:"symbol<STRING>  EXPORT \nsymbols<LIST>  EXPORT ",tags:["stack","debug"],since:"1.0.2",OPB64name:"EXPORT"},EXTLOADED:{description:"Checks if a WarpScript extension is loaded or not and therefore available.      \n\n@param `ext` Name of extension to check.\n\n@param `loaded` Boolean indicating whether or not the specified extension is loaded in the WarpScript environment.\n\n",signature:"ext<STRING>  EXTLOADED  loaded<BOOLEAN>",tags:["stack"],since:"1.2.13",OPB64name:"EXTLOADED"},F:{description:"`F` stand for `false`. It is a boolean constant.\n\n\n@param `b` false\n\n",signature:" F  b<BOOLEAN>",tags:["logic","constants"],since:"1.0.0",OPB64name:"F"},FAIL:{description:"The `FAIL` function stops the execution of the WarpScript scripts by throwing an exception.\n\n",signature:"",tags:["control"],since:"1.0.0",OPB64name:"FAIL"},FDWT:{description:"The `FDWT` function performs a [Forward Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Fast_wavelet_transform#Forward_DWT) on a Geo Time Series™.\n\nA number of different [Wavelets](https://en.wikipedia.org/wiki/Wavelet) are available, the list is inspired by that available on \nthe [Wavelet Browser](http://wavelets.pybytes.com/).\n\nThe list of Wavelets which can be used is the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\nThe FDWT can only be applied to Geo Time Series™ with a number of values which is a power of 2.\n\nAssuming the input GTS has 2<sup>n</sup> values, the result of the FDWT transformation is a GTS with 2<sup>n</sup> values (the wavelet coefficients) with timestamps from 0 to 2<sup>n</sup>-1.\n\nThe ticks of the `n` levels are contiguous, with the first tick being for level `n`, the next 2 for level `n-1`, the next 4 for level `n-2`, up to the last 2<sup>n-1</sup> for level 1.\n\nLevel 1 has the finest time resolution but the coarsest frequency resolution. Each level has half (coarser) the time resolution and double (finer) the frequency resolution as the previous level.\n\n@param `wavelet` Name of wavelet to use for the transformation.\n\n@param `gts` Geo Time Series™ instance on which to perform the FDWT.\n\n@param `lgts` List of Geo Time Series™ on which to apply the FDWT.\n\n@param `fdwt` Transformed Geo Time Series™.\n\n@param `lfdwt` List of transformed Geo Time Series™.\n\n",signature:"gts<GTS> wavelet<STRING>  FDWT  fdwt<GTS>\nlgts<LIST<GTS>> wavelet<STRING>  FDWT  lfdwt<LIST<GTS>>",tags:["math","gts"],since:"1.0.0",OPB64name:"FDWT"},FETCH:{description:"The `FETCH` function interacts with the Warp 10 Storage Engine to retrieve data according to given criteria.\n\n`FETCH` either accepts a list of 5 parameters or a map with the parameters. Those are defining the **read access rights**, the **concerned Geo Time Series** and the **time window**. Other parameters in the map input are optional. \n\nThe list input is here to keep backward compatibility with old WarpScripts. The map input allows a great flexibility, as described below.\n\n### Access rights\nA valid read token is needed to read data with fetch. If you use a [metaset](/doc/METASET) and also specify a token, the token included in the metaset will be ignored.\n\n### Concerned Geo Time Series\n`FETCH` selects Geo Time Series according to:\n+ The `selectors` parameter, which is a list of selector.\n+ If `selectors` is not found, `FETCH` uses the `selector` parameter which is a single selector.\n+ If `selector` is not found, `FETCH`  uses both `class` and `labels` parameters.  \n\n### Time window\n`FETCH`  begins from the newest value and stop when the oldest value is collected. Thus, `end` must be defined in your request and defines the newest included value in your time window. If `end` is anterior to your oldest value, the result will be empty (no Geo Time Series). The span of the time window ending at `end` is then defined according to:\n+ The `timespan` parameter.\n+ If `timespan` is not defined, `FETCH` collects a maximum of `count` point.\n+ If `count` is not defined, `FETCH` determines `timespan` with `start`. If `start` is more recent than `end`, `end` and `start` are permuted internally. Be careful, this means `end` is included but  **`start` is excluded from the time window**.\n\n### Boundaries\nSince version 2.3.0, you can define *boundaries* around the requested data. When fetching data based on a time range, both a *pre* and *post* boundaries can be specified. When fetching by count, only a *pre* boundary can be requested.\nBoundaries are a number of datapoints which are either before (*pre* boundary) or after (*post* boundary) the fetched data. Fetching boundaries is very useful when storing only the changes of values as they enable you to always fetch datapoints even if the requested time range does not contain any. They can also be used to fetch the first `N` datapoints after a given timestamp.\nNote that fetching *post* boundaries is less efficient than fetching the requested range or a *pre* boundary as the data has to be scanned in reverse order which has an impact on I/Os and ultimately on performance.\n\n### Sampling options\n+ Since version 2.3.0, you can randomly sample points with the `sample` parameter. If `sample` equals 0.1, `FETCH` will randomly return one point out of ten. This implementation is the fastest way to resample data.\n+ Since version 2.3.0, you can `skip` the N newest datapoints in the time window specified.\n\n### Query without looking into directory\nThe fetch time to read one gts among millions of gts recorded with the same classname, the same application and the same owner can take time. Use the `gts` parameter to select if you exactly know the classname and all the labels.\n\nIf you want to read only Geo Time Series attributes or labels, using [FIND](/doc/FIND) is more efficient than fetching the last value.\n\n@param `token` Read token to use to fetch the data.\n\n@param `class` Selector for the GTS classes. Can either be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `labels` Map of labels selectors. The key is the label name, the value a selector which can be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `start` Oldest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `end` Newest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `data` List of fetched Geo Time Series™.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n@param `metaset` A set of Geo Time Series™ produced by the [`METASET`](/doc/METASET) function.\n\n@param `type` Name of type to force for the GTS, either LONG, DOUBLE, BOOLEAN or STRING.\n\n@param `typeattr` Name of label to use for storing the GTS type. This option is incompatible with 'type', when set values of different types are ventilated in separate GTS with the same set of class and labels and an additional *type* label of the given name.\n\n@param `timespan` Depth to consider when fetching the datapoints. If the value is positive then it is interpreted as a duration in time units, if it is negative then as the maximum number of datapoints to fetch. If negative, incompatible with 'count'.\n\n@param `count` Maximum number of datapoints to fetch for each GTS. Incompatible with negative 'timespan'.\n\n@param `extra` List of extraneous classes to fetch. For each GTS matching the selection criteria, GTS with those extra class names will be fetched too (with the *exact* same set of labels).\n\n@param `active.after` Timestamp after which a GTS must have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `quiet.after` Timestamp after which a GTS must not have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `gts` Explicit list of Geo Time Series™ to fetch. The class and labels will be used as is and not serve as selectors.\n\n@param `boundary` Number of datapoints to include in both *pre* and *post* boundaries.\n\n@param `boundary.pre` Number of datapoints in the *pre* boundary.\n\n@param `boundary.post` Number of datapoints in the *post* boundary.\n\n@param `sampling.ratio` A probability between 0 (excluded, no datapoints returned) and 1.0 (all datapoints returned). The random sampling is done by the storage layer, which is the most efficient.\n\n@param `skip.count` Set fetch to ignore the N newest points in the time window you specified.\n\n",signature:"[ token<STRING> class<STRING> labels<MAP> end<LONG> timespan<LONG> ]  FETCH  data<LIST<GTS>>\n[ token<STRING> class<STRING> labels<MAP> start<STRING> end<STRING> ]  FETCH  data<LIST<GTS>>\n{ token<STRING> class<STRING> labels<MAP> end<LONG> start<STRING> timespan<LONG> count<LONG> selector<STRING> selectors<LIST<STRING>> metaset<STRING> type<STRING> typeattr<STRING> extra<LIST<STRING>> active.after<LONG> quiet.after<LONG> gts<LIST<GTS>> boundary.post<LONG> boundary.pre<LONG> boundary<LONG> skip.count<LONG> sampling.ratio<DOUBLE>  } FETCH  data<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FETCH"},FETCHBOOLEAN:{description:"The `FETCHBOOLEAN` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type BOOLEAN.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"linput<LIST>  FETCHBOOLEAN  data<LIST<GTS>>\nminput<MAP>  FETCHBOOLEAN  data<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHBOOLEAN"},FETCHDOUBLE:{description:"The `FETCHDOUBLE` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type DOUBLE.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"linput<LIST>  FETCHDOUBLE  data<LIST<GTS>>\nminput<MAP>  FETCHDOUBLE  data<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHDOUBLE"},FETCHLONG:{description:"The `FETCHLONG` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type LONG.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"linput<LIST>  FETCHLONG  data<LIST<GTS>>\nminput<MAP>  FETCHLONG  data<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHLONG"},FETCHSTRING:{description:"The `FETCHSTRING` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type STRING.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"linput<LIST>  FETCHSTRING  data<LIST<GTS>>\nminput<MAP>  FETCHSTRING  data<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHSTRING"},FFT:{description:"The `FFT` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFT` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe real parts of the `FFT` coefficients, the second the imaginary parts. The scale factor is equal to X/(n * bucketspan) where n is the number\nof elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the number\nof values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFT` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the real parts of the `FFT` coefficients, the second the imaginary parts.\n\n",signature:"gts<GTS>  FFT  result<LIST<GTS>>\ngtsList<LIST<GTS>>  FFT  result<LIST<LIST<GTS>>>",tags:["gts"],since:"1.0.0",OPB64name:"FFT"},FFTAP:{description:"The `FFTAP` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFTAP` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe amplitude of the coefficient at that frequency and the second the associated phase. The scale factor is equal to X/(n * bucketspan) where n is\nthe number of elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the\nnumber of values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFTAP` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the amplitude of the coefficient at that frequency and the second the associated phase.\n\n",signature:"gts<GTS>  FFTAP  result<LIST<GTS>>\ngtsList<LIST<GTS>>  FFTAP  result<LIST<LIST<GTS>>>",tags:["gts"],since:"1.0.0",OPB64name:"FFTAP"},FFTWINDOW:{description:"The `FFTWINDOW` transforms Geo Time Series™ by applying a [window function](https://en.wikipedia.org/wiki/Window_function) to its values. The function supports the following windows:\n\n| Name | Window |\n| --- | --- |\n| `triangular` | [Triangular](https://en.wikipedia.org/wiki/Window_function#Triangular_window) |\n| `parzen` | [Parzen](https://en.wikipedia.org/wiki/Window_function#Parzen_window) |\n| `welch` | [Welch](https://en.wikipedia.org/wiki/Window_function#Welch_window) |\n| `sine` | [Sine](https://en.wikipedia.org/wiki/Window_function#Sine_window) |\n| `hann` | [Hann](https://en.wikipedia.org/wiki/Window_function#Hann_window) |\n| `hamming` | [Hamming](https://en.wikipedia.org/wiki/Window_function#Hamming_window) |\n| `blackman` | [Blackman](https://en.wikipedia.org/wiki/Window_function#Blackman_window) |\n| `nuttall` | [Nuttall](https://en.wikipedia.org/wiki/Window_function#Nuttall_window,_continuous_first_derivative) | \n| `blackman-nuttall` | [Blackman-Nuttall](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Nuttall_window) |\n| `blackman-harris` | [Blackman-Harris](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Harris_window) |\n| `flattop` | [Flat top](https://en.wikipedia.org/wiki/Window_function#Flat_top_window) |\n| `rectangular` | [Rectangular](https://en.wikipedia.org/wiki/Window_function#Rectangular_window) |\n\n@param `window` Name of the window function to apply.\n\n@param `gts` Single Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `windowed` Tranformed Geo Time Series™.\n\n@param `lwindowed` List of transformed Geo Time Series™.\n\n",signature:"gts<GTS> window<STRING>  FFTWINDOW  windowed<GTS>\nlgts<LIST<GTS>> window<STRING>  FFTWINDOW  lwindowed<LIST<GTS>>",tags:["gts"],since:"1.2.13",OPB64name:"FFTWINDOW"},FILL:{description:"The `FILL` function fills missing values in two Geo Time Series™ so they end up with identical ticks.\n\nThe filling is done using a *filler* function which applies a given strategy. Filler functions can be created using macros via the [`MACROFILLER`](/doc/MACROFILLER) function.\n\n@param `gtsa` First Geo Time Series™ to fill.\n\n@param `gtsb` Second Geo Time Series™ to fill.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:"gtsa<GTS> gtsb<GTS> filler<FILLER>  FILL  gtsa<GTS> gtsb<GTS>",tags:["filler"],since:"2.0.0",OPB64name:"FILL"},FILLNEXT:{description:"The `FILLNEXT` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation of the \nnext non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",signature:"gts<GTS>  FILLNEXT  result<GTS>\ngtsList<LIST<GTS>>  FILLNEXT  resultList<LIST<GTS>>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLNEXT"},FILLPREVIOUS:{description:"The `FILLPREVIOUS` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation \nof the previous non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",signature:"gts<GTS>  FILLPREVIOUS  result<GTS>\ngtsList<LIST<GTS>>  FILLPREVIOUS  resultList<LIST<GTS>>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLPREVIOUS"},FILLTICKS:{description:"The `FILLTICKS` function add values to a Geo Time Series™ instance or a list thereof for ticks in the given **LIST**.\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n@param `data` List of (latitude, longitude, elevation, ticks) where ticks is a list of ticks.\n\n",signature:"gts<GTS> data<LIST>  FILLTICKS  result<GTS>\ngtsList<LIST<GTS>> data<LIST>  FILLTICKS  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FILLTICKS"},FILLVALUE:{description:"The `FILLVALUE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with a fixed value/location/elevation.\n\nIt expects a GTS or a list thereof on the top of the stack after having consumed a list of parameters (latitude, longitude, elevation, value)\nsitting on top of the stack prior to the call.\n\nLocation must be floating point numbers (e.g. 0.0 not 0). Elevation must be an integer. If no location or elevation should be set, **NaN** can\nbe used instead of specific value.\n\nThis function has no effect on non bucketized GTS instances.\n\n\n\nThe value is cast to the type of the GTS value\n\n@param `gts` The Geo Time Series™ to fill\n\n@param `gtsList` The list of Geo Time Series™ to fill\n\n@param `result` The filled Geo Time Series™\n\n@param `resultList` The list of filled Geo Time Series™\n\n@param `data` The list of parameters (latitude, longitude, elevation, value)\n\n",signature:"gts<GTS> data<LIST>  FILLVALUE  result<GTS>\ngtsList<LIST<GTS>> data<LIST>  FILLVALUE  resultList<LIST<GTS>>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLVALUE"},FILTER:{description:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `FILTER` framework allows for advanced filtering using N-ary functions\n(functions which accept N parameters).\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A single list containing only the selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `FILTER`.\n\n",signature:"[ gtsList<LIST<GTS>> labels<LIST<STRING>> filter<FILTER> ]  FILTER  result<LIST<GTS>>",tags:["framework","filter"],since:"1.0.0",OPB64name:"FILTER"},FILTERBY:{description:"The `FILTERBY` function selects elements of a list based on the boolean return value of a macro evaluated for each element.\n\n@param `macro` Macro used for filtering. This macro should consume the element of the list pushed on top of the stack and leave a boolean on the stack. If this boolean is `true`, the element will be retained.\n\n@param `list` List of elements to filter.\n\n@param `sublist` List with the selected elements from `list`.\n\n",signature:"list<LIST> macro<MACRO>  FILTERBY  sublist<LIST>",tags:["lists"],since:"1.2.22",OPB64name:"FILTERBY"},FIND:{description:"The `FIND` function finds Geo Time Series™ labels and attributes of GTS, not their values. It is the fastest way to read attributes of GTS. `FIND` ask only `directory` component of Warp&nbsp;10™, while [FETCH](/doc/FETCH) first ask `directory`, then ask `store` to read GTS values. \n\nSyntax is close to [FETCH](/doc/FETCH), without time boundaries or data point count.\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `data` List of fetched Geo Time Series™. These GTS does not contain any value.\n\n@param `uuidattribute` Setting this to true add `.uuid` attribute in the output data. This UUID is a hash of class and label.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n",signature:"[ token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FIND  data<LIST<GTS>>\n[ uuidattribute<BOOLEAN> token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FIND  data<LIST<GTS>>\n{ token<STRING> classSelector<STRING> labelsSelector<MAP>  } FIND  data<LIST<GTS>>\n{ token<STRING> selector<STRING>  } FIND  data<LIST<GTS>>\n{ token<STRING> selectors<LIST<STRING>>  } FIND  data<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FIND"},FINDSETS:{description:"The `FINDSETS` function returns sets of values for the classes, labels and attributes of the Geo Time Series™ which matched the selection criteria.\n\nThose results can be used for example to update a UI with lists of possible values for labels when exploring a corpus of GTS.\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label names to exact match or regular expression (if the value starts with a *~*) for matching labels and attributes.\n\n@param `attributes` Map of attribute names to value list.\n\n@param `labels` Map of label names to value list.\n\n@param `classes` List of class names.\n\n",signature:"[ token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FINDSETS  classes<LIST<STRING>> labels<MAP> attributes<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"FINDSETS"},FINDSTATS:{description:"The `FINDSTATS` function computes statistics on matching Geo Time Series™. The estimations are based on the use of [HyperLogLogPlus](https://en.wikipedia.org/wiki/HyperLogLog) estimators.\n\nThe function returns a map containing information about the matching Geo Time Series. The fields of the map are the following:\n\n| Key | Value |\n|-----|-------|\n| `gts.estimate` | Estimation of the number of matching Geo Time Series™ |\n| `classes.estimate` | Estimation of the number of distinct class names |\n| `labelnames.estimate` | Estimation of the number of distinct label names |\n| `labelvalues.estimate` | Estimation of the number of distinct label values |\n| `per.class.estimate` | If the number of matching classes is below the `directory.stats.class.maxcardinality`, this key will be associated with a map containing per class estimate of number of GTS |\n| `per.label.value.estimate` | If the number of label names in the matching GTS is below `directory.stats.labels.maxcardinality`, this key will be associated with a map containing an estimation of distinct label values per label name |\n| `error.rate` | This is the error rate of the estimators used for computing the estimations |\n| `partial.results` | When accessing a sharded Directory, this will be set to `true` if only partial results were collected |\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `result` Map containing stats such as error rate or whether estimates on classes, gts, or labels.\n\n",signature:"[ token<STRING> classSelector<STRING> labelsSelector<MAP> ]  FINDSTATS  result<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"FINDSTATS"},FIRSTTICK:{description:"The `FIRSTTICK` function pushes on the stack the timestamp of the first tick of the Geo Time Series™ on top of the stack.\n\nWhen applied to a list of GTS, `FIRSTTICK` will return the lowest first tick found across all Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™\n\n@param `gts` Geo Time Series™\n\n@param `result` Timestamp. If the GTS does not have values, **Long.MAX_VALUE** is pushed.\n\n",signature:"gts<GTS>  FIRSTTICK  result<LONG>\nlgts<LIST<GTS>>  FIRSTTICK  result<LONG>",tags:["gts"],since:"1.0.0",OPB64name:"FIRSTTICK"},FLATTEN:{description:"The function `FLATTEN` inspects the top of the stack.\n\nIf it is a LIST of values,\nit inspects each value and replaces each value which was a LIST with its content.\n`FLATTEN` proceed recursively until all LISTs have been flattened.\n\nIf it is not a LIST, the function exits and let the stack in the same state.\n\n@param `input` Input is a list who may contains lists\n\n@param `notAList` An object which is not a list\n\n@param `output` Output list do not contains anymore nested lists\n\n",signature:"input<LIST>  FLATTEN  output<LIST>\nnotAList<ANY>  FLATTEN  notAList<ANY>",tags:["lists"],since:"1.0.0",OPB64name:"FLATTEN"},"FLOATBITS->":{description:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the 32 lower bits of the **LONG** value as the raw bits of a **FLOAT**.\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",signature:"input<LONG>  FLOATBITS->  result<DOUBLE>",tags:["conversion","binary"],since:"1.2.3",OPB64name:"GZlEFKG1HKGIAIs"},FLOOR:{description:"The `FLOOR` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number smaller than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-down value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-down values, for each given value.\n\n",signature:"value<NUMBER>  FLOOR  result<DOUBLE>\nlvalue<LIST<NUMBER>>  FLOOR  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"FLOOR"},FLOORDIV:{description:"The `FLOORDIV` function consumes two NUMBER values, convert them to LONGs and pushes back largest LONG value that is less than or equal to the algebraic quotient.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fDiv` The largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfDiv` List of largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n",signature:"dividend<NUMBER> divisor<NUMBER>  FLOORDIV  fDiv<LONG>\ndividend<NUMBER> ldivisor<LIST<NUMBER>>  FLOORDIV  lfDiv<LIST<LONG>>\nldividend<LIST<NUMBER>> divisor<NUMBER>  FLOORDIV  lfDiv<LIST<LONG>>",tags:["math"],since:"1.2.23",OPB64name:"FLOORDIV"},FLOORMOD:{description:"The `FLOORMOD` function consumes two NUMBER values, convert them to LONGs and pushes back the floor modulus which is x - (floorDiv(x, y) * y).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fMod` The floor modulus x - (floorDiv(x, y) * y)\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfMod` List of floor modulus x - (floorDiv(x, y) * y)\n\n",signature:"dividend<NUMBER> divisor<NUMBER>  FLOORMOD  fMod<LONG>\ndividend<NUMBER> ldivisor<LIST<NUMBER>>  FLOORMOD  lfMod<LIST<LONG>>\nldividend<LIST<NUMBER>> divisor<NUMBER>  FLOORMOD  lfMod<LIST<LONG>>",tags:["math"],since:"1.2.23",OPB64name:"FLOORMOD"},FOR:{description:"The `FOR` function implements a for loop. It takes three arguments from the stack: the initial and the final values of the loop index and a macro to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",signature:"initial<NUMBER> final<NUMBER> macro<MACRO>  FOR \ninitial<NUMBER> final<NUMBER> macro<MACRO> index<BOOLEAN>  FOR ",tags:["control"],since:"1.0.0",OPB64name:"FOR"},FOREACH:{description:"The `FOREACH` function implements a for loop on a list or map.\n\nFor each iteration i on a list, the i-th element on the list is put on top of the stack, and the exec macro is then called.\n\nFor each iteration i on a map, the exec macro is called with the i-th value on top of the stack, and the i-th key just below on the stack.\nYou can start your macro with `'value' STORE 'key' STORE`.\n\nSince release 2.1, `FOREACH` has the ability to iterate over Geo Time Series™ and GTS Encoders. When iterating over a GTS or Encoder, the macro is fed with a list of the form `[ tick lat lon elev value ]` where `lat`, `lon` and `elev` may be `NaN` if unset. In the case of an Encoder, `value` can be a byte array or a `BigDecimal` on top of `LONG`, `DOUBLE`, `STRING` or `BOOLEAN`.\n\nSince release 2.4.0, you can force FOREACH to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `exec` Macro to apply\n\n@param `list` List to iterate on\n\n@param `map` Map to iterate on\n\n@param `set` Set to iterate on\n\n@param `vector` Vector to iterate on\n\n@param `gts` GTS to iterate on\n\n@param `string` String to iterate on\n\n@param `encoder` GTSEncoder to iterate on\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",signature:"list<LIST> exec<MACRO>  FOREACH \nmap<MAP> exec<MACRO>  FOREACH \nset<SET> exec<MACRO>  FOREACH \nvector<VLIST> exec<MACRO>  FOREACH \nstring<STRING> exec<MACRO>  FOREACH \ngts<GTS> exec<MACRO>  FOREACH \nencoder<GTSENCODER> exec<MACRO>  FOREACH \nlist<LIST> exec<MACRO> index<BOOLEAN>  FOREACH \nmap<MAP> exec<MACRO> index<BOOLEAN>  FOREACH \nset<SET> exec<MACRO> index<BOOLEAN>  FOREACH \nvector<VLIST> exec<MACRO> index<BOOLEAN>  FOREACH \nstring<STRING> exec<MACRO> index<BOOLEAN>  FOREACH \ngts<GTS> exec<MACRO> index<BOOLEAN>  FOREACH \nencoder<GTSENCODER> exec<MACRO> index<BOOLEAN>  FOREACH ",tags:["control"],since:"1.0.0",OPB64name:"FOREACH"},FORGET:{description:"Removes a symbol from the symbol table.      \n\n@param `symbol` Name of the symbol to remove.\n\n",signature:"symbol<STRING>  FORGET ",tags:["stack"],since:"1.0.0",OPB64name:"FORGET"},FORSTEP:{description:"The `FORSTEP` function implements for loop with an index step. It takes four arguments from the stack: the initial and the final values of the loop index,\na macro step to evaluate after each iteration and an other one to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `step` Macro step to evaluate after each iteration, typically to compute index\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",signature:"initial<NUMBER> final<NUMBER> step<MACRO> macro<MACRO>  FORSTEP \ninitial<NUMBER> final<NUMBER> step<MACRO> macro<MACRO> index<BOOLEAN>  FORSTEP ",tags:["control"],since:"1.0.0",OPB64name:"FORSTEP"},FROMBIN:{description:"Converts the binary representation on top of the stack into the corresponding long.\n\n@param `input` Binary representation of a signed long, 64 characters max.\n\n@param `output` Signed long of input.\n\n",signature:"input<STRING>  FROMBIN  output<LONG>",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBIN"},FROMBITS:{description:"**This function is deprecated. Replace it in your code by the [`DOUBLEBITS->`](/doc/G3xKFZl4FZ_JJmoy) function.**\n\nConverts the **LONG** on top of the stack into a **DOUBLE** by considering it a raw bit representation.\n\n@param `input` Raw bit representation to convert\n\n@param `result` Converted value\n\n",signature:"input<LONG>  FROMBITS  result<DOUBLE>",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBITS"},FROMHEX:{description:"Converts an hexadecimal representation into a signed long. 64bits max.\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Signed long\n\n",signature:"input<STRING>  FROMHEX  output<LONG>",tags:["conversion"],since:"1.0.0",OPB64name:"FROMHEX"},FUNCTIONS:{description:"FUNCTIONS returns a list of every functions available in your Warp 10 environnment, including native and extension functions.\n\nIt could be useful when coding your own extension to check your new functions are correctly registered.\n\n\nFUNCTIONS allow anyone to discover new extensions you created on the platform, so it is deactivated by default.\n\nYou must add `warpscript.extension.inventory=io.warp10.script.ext.inventory.InventoryWarpScriptExtension` in your configuration file for this function to be available.\n\n@param `functions` List of Warp 10 functions available on this instance\n\n",signature:" FUNCTIONS  functions<LIST<STRING>>",tags:["platform","extensions"],since:"1.2.16",OPB64name:"FUNCTIONS"},FUSE:{description:"Fuses Geo Time Series™ chunks. The fusion process attempts to keep the bucketization parameters if all chunks are bucketized with compatible `bucketspan` and `lastbucket` values.\n\nAll chunks must be of the same type.\n\nThe fused GTS will have the common class name of the chunks or no class name if some chunks have a different class name. The labels will be those common to all chunks, so when fusing chunks created with [`CHUNK`](/doc/CHUNK), the chunk id will be dropped.\n\n@param `chunks` List of Geo Time Series™ to fuse.\n\n@param `gts` Geo Time Series™ resulting from the fusion of `chunk`.\n\n",signature:"chunks<LIST<GTS>>  FUSE  gts<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FUSE"},"GEO.BUFFER":{description:"The `GEO.BUFFER` function allows to create [*buffer*](https://en.wikipedia.org/wiki/Buffer_(GIS)) **GEOSHAPE** objects. The function takes a `MAP` instance as input. This map can contain the following entries:\n\n| Key | Description |\n|-----|-------------|\n| `dist` | Distance of the buffer, as a central angle expressed in degrees. |\n| `mdist` | Distance of the buffer expressed in meters. This key is only taken into account if `dist` is not specified. |\n| `cap` | The end cap style to consider, use `SQUARE`, `FLAT` or `ROUND` (default). |\n| `join` | The join style to use, use `BEVEL`, `MITRE` or `ROUND` (default). |\n| `limit` | The mitre limit to use. Defaults to 5.0. |\n| `segments` | Number of segments to use per quadrant, defaults to 8. |\n| `singlesided` | Set to `true` to compute a single sided buffer. If `true`, positive distance will indicate left-hand side and negative distance right-hand side. End cap is ignored for single sided buffers. |\n| `wkb` | Byte array containing a [WKB](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary) definition of a geographic area. |\n| `wkt` | String containing a [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) definition of a geographic area. |\n| `geojson` | String containing a [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) definition of a geographic area. |\n\nIf a geographic area is defined, only one of `wkb`, `wkt` or `geojson` may be specified. The output of the function is a new definition of a geographic area with the buffer added to the original definition.\n\nIf no geographic area is defined, `GEO.BUFFER` will define a buffer which will be used by the next call to either [`GEO.WKT`](/doc/GEO.WKT), [`GEO.WKB`](/doc/GEO.WKB) or [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `params` Parameter map containing keys as defined above.\n\n@param `wkb` Area definition with the buffer added, if `params` had a value for key `wkb`.\n\n@param `area` Area definition with the buffer added, in WKT or GeoJSON depending on the presence of key `wkt` or `geojson` in `params`.\n\n",signature:"params<MAP>  GEO.BUFFER  wkb<BYTES>\nparams<MAP>  GEO.BUFFER  area<STRING>\nparams<MAP>  GEO.BUFFER ",tags:["geo"],since:"2.7.0",OPB64name:"GEO.BUFFER"},"GEO.COVER":{description:"The `GEO.COVER` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* in which the input Geo Time Series™ or GTS Encoder had datapoints.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",signature:"gts<GTS> resolution<LONG>  GEO.COVER  geoshape<GEOSHAPE>\nencoder<GTSENCODER> resolution<LONG>  GEO.COVER  geoshape<GEOSHAPE>\nlist<LIST> resolution<LONG>  GEO.COVER  geoshapes<LIST<GEOSHAPE>>",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER"},"GEO.COVER.RL":{description:"The `GEO.COVER.RL` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* which cover the path of an input Geo Time Series™ or GTS Encoder. The path is considered to follow [rhumb lines](https://en.wikipedia.org/wiki/Rhumb_line), hence the function suffix `.RL`.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",signature:"gts<GTS> resolution<LONG>  GEO.COVER.RL  geoshape<GEOSHAPE>\nencoder<GTSENCODER> resolution<LONG>  GEO.COVER.RL  geoshape<GEOSHAPE>\nlist<LIST> resolution<LONG>  GEO.COVER.RL  geoshapes<LIST<GEOSHAPE>>",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER.RL"},"GEO.DIFFERENCE":{description:"The `GEO.DIFFERENCE` function computes the difference between two GEOSHAPE. The resulting GEOSHAPE instance contains cells which cover the part of the first GEOSHAPE which is not in the second. If you need to have cells up to a certain resolution, you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the result.\n\n@param `shapeA` GEOSHAPE instance from which to subtract the second shape.\n\n@param `shapeB` GEOSHAPE to subtract from 'shapeA'.\n\n@param `shape` GEOSHAPE containing 'shapeA' minus 'shapeB'.\n\n",signature:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.DIFFERENCE  shape<GEOSHAPE>",tags:["geo"],since:"1.0.0",OPB64name:"GEO.DIFFERENCE"},"GEO.INTERSECTION":{description:"The `GEO.INTERSECTION` function computes the intersection of two GEOSHAPE instances. The intersection process will produce a GEOSHAPE whose cells are common to the two initial shapes. The common cells will be of various resolutions, depending on the resolutions of the cells from the initial shapes. If you need the resulting shape to contain cells up to a specific resolution, you can call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) either on the result or on the initial shapes.\n\n@param `shapeA` First GEOSHAPE instance.\n\n@param `shapeB` Second GEOSHAPE instance.\n\n@param `shapes` GEOSHAPE instances.\n\n@param `shape` Geographical area (GEOSHAPE) resulting from the intersection of the given shapes.\n\n",signature:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.INTERSECTION  shape<GEOSHAPE>\nshapes<LIST<GEOSHAPE>>  GEO.INTERSECTION  shape<GEOSHAPE>",tags:["geo"],since:"1.0.0",OPB64name:"GEO.INTERSECTION"},"GEO.INTERSECTS":{description:"The `GEO.INTERSECTS` function checks if a Geo Time Series or each GTS from a list has at least one data point with a position inside a given geographical area. Since `2.7.1`, the function can also check if two `GEOSHAPE` instances intersect.\n\n@param `shapeA` First `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shapeB` Second `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shape` Instance of GEOSHAPE containing the area which the Geo Time Series must intersect.\n\n@param `gts` Single instance of Geo Time Series.\n\n@param `lgts` List of Geo Time Series.\n\n@param `result` Boolean indicating whether or not the Geo Time Series had at least one datapoint in 'shape' or if the two shapes intersect.\n\n@param `results` List of boolean results indicating whether or not each GTS had at least one datapoint in 'shape'.\n\n",signature:"gts<GTS> shape<GEOSHAPE>  GEO.INTERSECTS  result<BOOLEAN>\nlgts<LIST<GTS>> shape<GEOSHAPE>  GEO.INTERSECTS  results<LIST<BOOLEAN>>\nshapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.INTERSECTS  result<BOOLEAN>",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.INTERSECTS"},"GEO.JSON":{description:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",signature:"GeoJSON<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.JSON  geoshape<GEOSHAPE>\nGeoJSON<STRING> resolution<LONG> inside<BOOLEAN>  GEO.JSON  geoshape<GEOSHAPE>",tags:["geo"],since:"1.2.9",OPB64name:"GEO.JSON"},"GEO.JSON.UNIFORM":{description:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.JSON`](doc/GEO.JSON), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",signature:"GeoJSON<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.JSON.UNIFORM  geoshape<GEOSHAPE>\nGeoJSON<STRING> resolution<LONG> inside<BOOLEAN>  GEO.JSON.UNIFORM  geoshape<GEOSHAPE>",tags:["geo"],since:"1.2.13",OPB64name:"GEO.JSON.UNIFORM"},"GEO.NORMALIZE":{description:"The `GEO.NORMALIZE` function ensures that the intersection of two **GEOSHAPE**s is present in both as an identical set of cells.\n\n@param `shapeA` The first GEOSHAPE to normalize.\n\n@param `shapeB` The second GEOSHAPE to normalize.\n\n@param `normalizedA` A normalized copy of the first GEOSHAPE.\n\n@param `normalizedB` A normalized copy of the second GEOSHAPE.\n\n",signature:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.NORMALIZE  normalizedA<GEOSHAPE> normalizedB<GEOSHAPE>",tags:["geo"],since:"2.5.0",OPB64name:"GEO.NORMALIZE"},"GEO.OPTIMIZE":{description:"The `GEO.OPTIMIZE` function optimizes a GEOSHAPE instance by modifying its cells to either limit the finest resolution present in the shape or reduce the number of cells by merging cells which cover a whole cell at the coarser resolution.\n\n@param `shape` GEOSHAPE instance to optimize.\n\n@param `resolution` Finest resolution acceptable (even number from 2 to 32) or 0 to reduce the number of cells.\n\n@param `optimized` Optimized GEOSHAPE instance\n\n",signature:"shape<GEOSHAPE> resolution<LONG>  GEO.OPTIMIZE  optimized<GEOSHAPE>",tags:["geo"],since:"1.2.13",OPB64name:"GEO.OPTIMIZE"},"GEO.REGEXP":{description:"The `GEO.REGEXP` function converts a GEOSHAPE into a regular expression to select hexadecimal [HHCode](https://en.wikipedia.org/wiki/HHCode) STRINGs which are included in the GEOSHAPE.\n\n@param `shape` An instance of GEOSHAPE.\n\n@param `regexp` A regular expression for matching HHCodes covered by 'shape'.\n\n",signature:"shape<GEOSHAPE>  GEO.REGEXP  regexp<STRING>",tags:["geo"],since:"1.0.11",OPB64name:"GEO.REGEXP"},"GEO.UNION":{description:"The `GEO.UNION` function computes a GEOSHAPE which is the union of two other shapes. The resulting shape will have cells covering the two original shapes. If you need to have cells up to a certain resolution you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the resulting shape.\n\n@param `shapeA` First GEOSHAPE instance to merge.\n\n@param `shapeB` Second GEOSHAPE instance to merge.\n\n@param `shapes` GEOSHAPE instances to merge.\n\n@param `shape` Resulting GEOSHAPE which is the union of the given shapes.\n\n",signature:"shapeA<GEOSHAPE> shapeB<GEOSHAPE>  GEO.UNION  shape<GEOSHAPE>\nshapes<LIST<GEOSHAPE>>  GEO.UNION  shape<GEOSHAPE>",tags:["geo"],since:"1.0.0",OPB64name:"GEO.UNION"},"GEO.WITHIN":{description:"The `GEO.WITHIN` function checks whether a Geo Time Series™ or each GTS from a list have all its datapoints with a location inside a given geographical area.\n\n@param `shape` Instance of GEOSHAPE containing the area inside which the Geo Time Series™ must be contained.\n\n@param `gts` Single instance of Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `result` Boolean indicating whether or not the Geo Time Series™ had all its datapoints with a location inside 'shape'.\n\n@param `results` List of boolean results indicating whether or not each GTS had all its datapoints with a location inside 'shape'.\n\n",signature:"gts<GTS> shape<GEOSHAPE>  GEO.WITHIN  result<BOOLEAN>\nlgts<LIST<GTS>> shape<GEOSHAPE>  GEO.WITHIN  results<LIST<BOOLEAN>>",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.WITHIN"},"GEO.WKB":{description:"The `GEO.WKB` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geoshape object.\n\n",signature:"WKB<BYTES> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKB  geoshape<GEOSHAPE>\nWKB<BYTES> resolution<LONG> inside<BOOLEAN>  GEO.WKB  geoshape<GEOSHAPE>",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB"},"GEO.WKB.UNIFORM":{description:"The `GEO.WKB.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKB`](doc/GEO.WKB), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geographical area output.\n\n",signature:"WKB<BYTES> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKB.UNIFORM  geoshape<GEOSHAPE>\nWKB<BYTES> resolution<LONG> inside<BOOLEAN>  GEO.WKB.UNIFORM  geoshape<GEOSHAPE>",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB.UNIFORM"},"GEO.WKT":{description:"The `GEO.WKT` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geoshape object.\n\n",signature:"WKT<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKT  geoshape<GEOSHAPE>\nWKT<STRING> resolution<LONG> inside<BOOLEAN>  GEO.WKT  geoshape<GEOSHAPE>",tags:["geo"],since:"1.0.0",OPB64name:"GEO.WKT"},"GEO.WKT.UNIFORM":{description:"The `GEO.WKT.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKT`](doc/GEO.WKT), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geographical area output.\n\n",signature:"WKT<STRING> percentage<DOUBLE> inside<BOOLEAN>  GEO.WKT.UNIFORM  geoshape<GEOSHAPE>\nWKT<STRING> resolution<LONG> inside<BOOLEAN>  GEO.WKT.UNIFORM  geoshape<GEOSHAPE>",tags:["geo"],since:"1.2.11",OPB64name:"GEO.WKT.UNIFORM"},"GEOCELL->":{description:"The `GEOCELL->` function converts a **LONG** geocell to a **STRING** HHCode prefix. The resulting string length is half the resolution of the geocell.\n\nThis function cannot convert to **BYTES** because this representation is limited to resolutions multiple of 4.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `geocell` A geocell.\n\n@param `hhPrefix` A HHCode prefix representing the given cell.\n\n",signature:"geocell<LONG>  GEOCELL->  hhPrefix<STRING>",tags:["geo"],since:"2.6.0",OPB64name:"GoKEFoKBI1oy"},"GEOHASH->":{description:"The `GEOHASH->` converts a [Geohash](https://en.wikipedia.org/wiki/Geohash), exposing the latitude and longitude it contains, or transforms a list of Geohashes into a `GEOSHAPE`.\n\n@param `geohash` Geohash to unpack.\n\n@param `geohashes` List of Geohashes defining a geographical area.\n\n@param `lat` Unpacked latitude.\n\n@param `lon` Unpacked longitude.\n\n@param `toHHCodeString` Set to `true` to convert the GeoHash to a HHCode STRING or to `false` to convert it to a LONG HHCode instead of extracting its latitude and longitude.\n\n@param `hhcode` The HHCode for `geohash`, as a LONG or STRING.\n\n@param `shape` Warp 10 `GEOSHAPE` covering the same geographic area as the Geohashes in `geohashes`.\n\n",signature:"geohash<STRING>  GEOHASH->  lat<DOUBLE> lon<DOUBLE>\ngeohash<STRING> toHHCodeString<BOOLEAN>  GEOHASH->  hhcode<ANY>\ngeohashes<LIST<STRING>>  GEOHASH->  shape<GEOSHAPE>",tags:["geo"],since:"1.0.11",OPB64name:"GoKEH34IH1oy"},GEOPACK:{description:"The `GEOPACK` function takes a **GEOSHAPE** and packs it into a String.\n\n@param `shape` The GEOSHAPE instance to pack.\n\n@param `packed` The packed string representation of the GEOSHAPE.\n\n",signature:"shape<GEOSHAPE>  GEOPACK  packed<STRING>",tags:["geo"],since:"1.0.7",OPB64name:"GEOPACK"},"GEOSHAPE->":{description:"The `GEOSHAPE->` function converts **GEOSHAPE** to a list of **LONG** geocells or **STRING** HHCode prefixes. Conversion to list of **BYTES** is not supported, because this representation only supports resolution multiple of 4.\n\n@param `geoshape` The geoshape to get the cells from.\n\n@param `toString` Whether to convert the cells to **STRING** HHCode prefix (true) or geocells (false).\n\n@param `geocells` List of geocells.\n\n@param `geocellsOrHHPrefixes` List of **LONG** geocells or **STRING** HHCode prefixes.\n\n",signature:"geoshape<GEOSHAPE>  GEOSHAPE->  geocells<LIST<LONG>>\ngeoshape<GEOSHAPE> toString<BOOLEAN>  GEOSHAPE->  geocellsOrHHPrefixes<LIST<ANY>>",tags:["geo"],since:"2.6.0",OPB64name:"GoKEJoW0J3JhEV"},GEOSHIFT:{description:"`GEOSHIFT` functions shifts a geoshape on the earth. It is able to safely overlap the poles or the 180th meridian.\n- Longitude shift keeps distances.\n- Latitude shift keeps angles, not distances.\n- When doing latitude shift, you can specify a meridian to shift along this meridian. It means a positive shift became a negative shift behind this meridian +/- 90°.\n\nSet precision parameter to zero for safe shifting operation. See [`GEO.WKT`](/doc/GEO.WKT) for precision encoding.\n\nUse [`->GEOJSON`](/doc/AIt6GJx9JoxD) to visualize shapes and the results. GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `lon` degrees of longitude to shift (-360 to 360).\n\n@param `lat` degrees of latitude to shift (-180 to 180).\n\n@param `precision` even number from 0 to 30. Set to 0 for automatic resolution. Force to another value if you know the input resolution to be finer and you want a coarser resolution.\n\n@param `shape` The input geoshape.\n\n@param `output` The shifted geoshape.\n\n@param `meridian` When doing latitude shift, you can specify a meridian to shift along this meridian. (-180 to 180)\n\n",signature:"shape<GEOSHAPE> lat<DOUBLE> lon<DOUBLE> precision<LONG>  GEOSHIFT  output<GEOSHAPE>\nshape<GEOSHAPE> meridian<DOUBLE> lat<DOUBLE> lon<DOUBLE> precision<LONG>  GEOSHIFT  output<GEOSHAPE>",tags:["geo"],since:"2.5.0",OPB64name:"GEOSHIFT"},GEOSPLIT:{description:"The `GEOSPLIT` function splits a **GEOSHAPE** into a set of **GEOSHAPE**s which have no adjacent cells (each shape is a connected space).\n\nAdjacent cells share part of their side. Adjacency is not provided by corners and cells on each side of the international date line are not considered adjacent either.\n\n@param `shape` The GEOSHAPE instance to split.\n\n@param `subshapes` The shapes whose union form `shape` and which each form a connected space.\n\n",signature:"shape<GEOSHAPE>  GEOSPLIT  subshapes<LIST<GEOSHAPE>>",tags:["geo"],since:"2.5.0",OPB64name:"GEOSPLIT"},GEOUNPACK:{description:"The `GEOUNPACK` function unpacks a GEOSHAPE previously packed using [`GEOPACK`](/doc/GEOPACK).\n\n@param `packed` A packed string representation of a GEOSHAPE.\n\n@param `packedbytes` A byte array representation of a GEOSHAPE.\n\n@param `shape` The decoded instance of GEOSHAPE.\n\n",signature:"packed<STRING>  GEOUNPACK  shape<GEOSHAPE>\npackedbytes<BYTES>  GEOUNPACK  shape<GEOSHAPE>",tags:["geo"],since:"1.0.7",OPB64name:"GEOUNPACK"},GET:{description:"Retreive a value in a **MAP** or a **list**.\n\nThe `GET` function consumes on the top of the stack a list, a byte array, or a map, and the index (or the key), \nthen put the result on the stack. \n\nIf key is not found, it returns NULL on the stack.\n\nIf index is out of bound, `GET` raises an error.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, GET can operate recursively on nested lists. In this case, the index is a list.\n\n@param `map` The input MAP.\n\n@param `key` Depending on map construction, could be a number, a string, a list, another map, a GTS, a boolean.\n\n@param `mapvalue` The value for the requested key. If key do not exists in map, returns NULL\n\n@param `index` The index number in the list. Valid values in [-size; size-1]\n\n@param `list` The input LIST.\n\n@param `value` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `array` Byte array from which to read a byte.\n\n@param `bytevalue` The value of the byte, always unsigned (from 0 to 255).\n\n",signature:"map<MAP> key<ANY>  GET  mapvalue<ANY>\nlist<LIST> index<LONG>  GET  value<ANY>\nlist<LIST> index<LIST>  GET  value<ANY>\narray<BYTES> index<LONG>  GET  bytevalue<LONG>",tags:["lists","maps","binary"],since:"1.0.0",OPB64name:"GET"},GETEXPONENT:{description:"The `GETEXPONENT` function consumes a DOUBLE, a LONG casted as a DOUBLE or a COUNTER caster as DOUBLE and pushes back the unbiased exponent used in the representation of this DOUBLE.\n\n@param `n` The decimal value to get the exponent from, will be converted to DOUBLE if not already the case.\n\n@param `exponent` the unbiased exponent of the argument\n\n",signature:"n<NUMBER>  GETEXPONENT  exponent<LONG>",tags:["math"],since:"1.2.23",OPB64name:"GETEXPONENT"},GETHOOK:{description:"Extracts the macro associated with a token hook and pushes it onto the stack wrapped as a secure script.\n\nIf the token does not contain the given hook, an empty macro will be wrapped.\n\n@param `hook` Name of the hook to extract from the token.\n\n@param `token` Read token from which to extract the hook.\n\n@param `secure` Hook macro wrapped in a secure script.\n\n",signature:"token<STRING> hook<STRING>  GETHOOK  secure<STRING>",tags:["platform"],since:"1.0.8",OPB64name:"GETHOOK"},GETSECTION:{description:"The `GETSECTION` function pushes onto the stack the name of the current section.\n\n@param `section` Name of the current section.\n\n",signature:" GETSECTION  section<STRING>",tags:["stack","debug"],since:"1.2.7",OPB64name:"GETSECTION"},GOLDWRAP:{description:"The `GOLDWRAP` function wraps a Geo Time Series™ or a GTS Encoder in a deterministic way, by sorting on timestamps but also on values, locations and elevations.\n\nThis version of a `WRAP` like function is meant to create a *gold standard* blob from its input. In order to ensure reproducibility of the processs, attributes should be dropped prior to calling `GOLDWRAP`.\n\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `wrap` Wrapped Geo Time Series™ instance to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n@param `list` List of Geo Time Series™ or GTS Encoders to wrap.\n\n",signature:"encoder<GTSENCODER>  GOLDWRAP  wrapped<BYTES>\ngts<GTS>  GOLDWRAP  wrapped<BYTES>\nwrap<BYTES>  GOLDWRAP  wrapped<BYTES>\nlist<LIST<GTS>>  GOLDWRAP  lwrapped<LIST<BYTES>>\nlist<LIST<GTSENCODER>>  GOLDWRAP  lwrapped<LIST<BYTES>>\nlist<LIST<BYTES>>  GOLDWRAP  lwrapped<LIST<BYTES>>",tags:["gts"],since:"2.2.0",OPB64name:"GOLDWRAP"},GROUPBY:{description:"The `GROUPBY` function groups the elements of a list according to the value returned by a macro.\n\n@param `macro` Macro used for grouping, consumes an element off the stack and produces a value on the stack.\n\n@param `list` List of elements to group.\n\n@param `grouped` List of groups, each group is a list whose first element is the group key and whose second element is the sublist of `list` for which `macro` produced the same value.\n\n",signature:"list<LIST> macro<MACRO>  GROUPBY  grouped<LIST>",tags:["lists"],since:"1.2.22",OPB64name:"GROUPBY"},GRUBBSTEST:{description:"The `GRUBBSTEST` function detects an outlier in a GTS (or a LIST of GTS), by applying a \n[Grubbs’](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm) test.\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nIt tests whether there is exactly a single outlier in a GTS or not. For an iterative version which can detect multiple outliers, use instead\n[`ESDTEST`](/doc/ESDTEST).\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> ### Reference \n> Grubbs, Frank (February 1969). “Procedures for Detecting Outlying Observations in Samples”. Technometrics (Technometrics, Vol. 11, No. 1).\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",signature:"gts<GTS> mad<BOOLEAN> alpha<DOUBLE>  GRUBBSTEST  result<LIST<LONG>>\ngts<GTS> mad<BOOLEAN>  GRUBBSTEST  result<LIST<LONG>>\ngtsList<LIST<GTS>> mad<BOOLEAN> alpha<DOUBLE>  GRUBBSTEST  resultList<LIST>\ngtsList<LIST<GTS>> mad<BOOLEAN>  GRUBBSTEST  resultList<LIST<LIST<LONG>>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"GRUBBSTEST"},"GTSHHCODE->":{description:"The `GTSHHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude. This function is very similar to [`HHCODE->`](/doc/H3W2IoG4AIs) except that when given the internal value used by Geo Time Series™ for a missing location it pushes back `NaN NaN`.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",signature:"hhcode<LONG>  GTSHHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<STRING>  GTSHHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<BYTES>  GTSHHCODE->  lat<DOUBLE> lon<DOUBLE>",tags:["geo"],since:"2.2.0",OPB64name:"GpGIH3W2IoG4AIs"},GZIP:{description:"The `GZIP` function compresses a STRING or a byte array using the [gzip](https://en.wikipedia.org/wiki/Gzip) algorithm. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",signature:"string<STRING>  GZIP  compressed<BYTES>\nbytes<BYTES>  GZIP  compressed<BYTES>",tags:["conversion"],since:"1.0.11",OPB64name:"GZIP"},HASH:{description:"Computes a 64 bits hash of the string or byte array on top of the stack.\n\n@param `str` String to hash\n\n@param `bytes` Bytes to hash\n\n@param `result` 64bit hash\n\n",signature:"str<STRING>  HASH  result<LONG>\nbytes<BYTES>  HASH  result<LONG>",tags:["strings"],since:"1.0.0",OPB64name:"HASH"},HAVERSINE:{description:"The `HAVERSINE` function consumes two coordinates and pushes back a **DOUBLE** [great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance) in meters.\n\n@param `p2_longitude` Point 2 longitude.\n\n@param `p2_latitude` Point 2 latitude.\n\n@param `p1_longitude` Point 1 longitude.\n\n@param `p1_latitude` Point 1 latitude.\n\n@param `haversineDistance` Great circle distance using the haversine fonction.\n\n",signature:"p1_latitude<NUMBER> p1_longitude<NUMBER> p2_latitude<NUMBER> p2_longitude<NUMBER>  HAVERSINE  haversineDistance<DOUBLE>",tags:["geo"],since:"1.0.0",OPB64name:"HAVERSINE"},HEADER:{description:"The `HEADER` function allows you to set custom headers which should be returned in the HTTP response. This obviously works only for the `/exec` Warp 10 endpoint.\n\n@param `name` Name of HTTP header to return, MUST start with `X-`, *i.e.* be a custom header.\n\n@param `value` Value to return for the `name` header. If `NULL`, the specified header is removed from the list of headers to return.\n\n",signature:"name<STRING> value<STRING>  HEADER ",tags:["stack"],since:"1.0.14",OPB64name:"HEADER"},"HEX->":{description:"Converts a hexadecimal string representation into a bytes array.\nBytes array cannot be represented on the stack.\n\n@param `input` A valid hexadecimal string.\n\n@param `output` Bytes Array from input. Seen as null on the stack.\n\n",signature:"input<STRING>  HEX->  output<BYTES>",tags:["conversion"],since:"1.0.0",OPB64name:"H3KNAIs"},HEXTOB64:{description:"Decodes the hex encoded content on top of the stack and \nimmediately re-encode it in base64. This enables you to \nconvert encoded content which would not be valid UTF-8 encoding \nfrom hexadecimal to base64.      \n\n@param `input` A valid hexadecimal string\n\n@param `output` Base64 representation of input\n\n",signature:"input<STRING>  HEXTOB64  output<STRING>",tags:["conversion"],since:"1.0.0",OPB64name:"HEXTOB64"},HEXTOBIN:{description:"Converts a string representing a hexadecimal number into a string representing a binary number.\n\nThe `HEXTOBIN` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from hexadecimal to binary.\n\n@param `input` The string representing a hexadecimal number\n\n@param `output` The string representing a binary number\n\n",signature:"input<STRING>  HEXTOBIN  output<STRING>",tags:["conversion","binary"],since:"1.0.0",OPB64name:"HEXTOBIN"},"HHCODE->":{description:"The `HHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",signature:"hhcode<LONG>  HHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<STRING>  HHCODE->  lat<DOUBLE> lon<DOUBLE>\nhhcode<BYTES>  HHCODE->  lat<DOUBLE> lon<DOUBLE>",tags:["geo"],since:"1.0.11",OPB64name:"H3W2IoG4AIs"},"HHCODE.BBOX":{description:"The `HHCODE.BBOX` function returns the bounding box of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the bounding box representing the lat/lon of North-Easth and South-West corners of the bbox.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `latSW` Latitude of the south west corner of the bounding box\n\n@param `lonSW` Longitude of the south west corner of the bounding box\n\n@param `latNE` Latitude of the north east corner of the bounding box\n\n@param `lonNE` Longitude of the north east corner of the bounding box\n\n",signature:"hhCode<STRING> resolution<LONG>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<LONG> resolution<LONG>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<BYTES> resolution<LONG>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<STRING>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>\nhhCode<BYTES>  HHCODE.BBOX  latSW<DOUBLE> lonSW<DOUBLE> latNE<DOUBLE> lonNE<DOUBLE>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.BBOX"},"HHCODE.CENTER":{description:"The `HHCODE.CENTER` function returns the center of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the center and returns its lat/lon.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `lat` Latitude of the center of the given HHCode\n\n@param `lon` Longitude of the center of the given HHCode\n\n",signature:"hhCode<STRING> resolution<LONG>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<LONG> resolution<LONG>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<BYTES> resolution<LONG>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<STRING>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>\nhhCode<BYTES>  HHCODE.CENTER  lat<DOUBLE> lon<DOUBLE>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.CENTER"},"HHCODE.EAST":{description:"The `HHCODE.EAST` function returns the cell east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.EAST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.EAST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.EAST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.EAST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.EAST  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.EAST"},"HHCODE.NORTH":{description:"The `HHCODE.NORTH` function returns the cell north of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.NORTH  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.NORTH  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.NORTH  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.NORTH  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.NORTH  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH"},"HHCODE.NORTH.EAST":{description:"The `HHCODE.NORTH.EAST` function returns the cell north east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.NORTH.EAST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.NORTH.EAST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.NORTH.EAST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.NORTH.EAST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.NORTH.EAST  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.EAST"},"HHCODE.NORTH.WEST":{description:"The `HHCODE.NORTH.WEST` function returns the cell north west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.NORTH.WEST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.NORTH.WEST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.NORTH.WEST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.NORTH.WEST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.NORTH.WEST  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.WEST"},"HHCODE.SOUTH":{description:"The `HHCODE.SOUTH` function returns the cell south of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.SOUTH  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.SOUTH  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.SOUTH  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.SOUTH  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.SOUTH  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH"},"HHCODE.SOUTH.EAST":{description:"The `HHCODE.SOUTH.EAST.EAST` function returns the cell south east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.SOUTH.EAST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.SOUTH.EAST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.SOUTH.EAST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.SOUTH.EAST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.SOUTH.EAST  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.EAST"},"HHCODE.SOUTH.WEST":{description:"The `HHCODE.SOUTH.WEST` function returns the cell south west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.SOUTH.WEST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.SOUTH.WEST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.SOUTH.WEST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.SOUTH.WEST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.SOUTH.WEST  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.WEST"},"HHCODE.WEST":{description:"The `HHCODE.WEST` function returns the cell west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"inputHHCode<STRING> resolution<LONG>  HHCODE.WEST  outputHHCode<STRING>\ninputHHCode<LONG> resolution<LONG>  HHCODE.WEST  outputHHCode<LONG>\ninputHHCode<BYTES> resolution<LONG>  HHCODE.WEST  outputHHCode<BYTES>\ninputHHCode<STRING>  HHCODE.WEST  outputHHCode<STRING>\ninputHHCode<BYTES>  HHCODE.WEST  outputHHCode<BYTES>",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.WEST"},HIDE:{description:"The `HIDE` function hides some levels of the stack to the rest of the executing code. This allows a kind of protection for levels which should not be accessed by a macro call for example. Note that this is not a real protection since a call to [`SHOW`](/doc/SHOW) could reveal the hidden levels.\n\nThe hidden levels are always the deepest. Depending on the `levels` parameter to the call to `HIDE`, the hidden levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there remains at most a certain number ((*abs(`levels`)*) with `levels` < 0).\n\nWhen called with `NULL` as parameter, `HIDE` will hide all the visible levels.\n\nThe number of newly hidden levels is returned.\n\n@param `levels` Number of levels to hide or to remain visible, or `NULL` to hide them all.\n\n@param `hidden` Number of levels actually hidden.\n\n",signature:"levels<LONG>  HIDE  hidden<LONG>",tags:["stack"],since:"2.7.1",OPB64name:"HIDE"},HLOCATE:{description:"The `HLOCATE` function locates the HBase regions containing a list of Geo Time Series™.\n\nThis function only works with the distributed version of Warp 10™.\n\nIt outputs a list of lists containing a GTS selector, the host and port of the RegionServer currently serving the region and the region id of a region containing data for this GTS.\n\n@param `gts` List of Geo Time Series™ to locate.\n\n@param `result` List of GTS, RegionServer, region tuples.\n\n",signature:"gts<LIST<GTS>>  HLOCATE  result<LIST>",tags:["extensions"],since:"1.2.13",OPB64name:"HLOCATE"},HULLSHAPE:{description:"Return the shape of a tensor (or multidimensional array) that would be able to contain all the values of an input nested list. The size of the returned shape is equal to the deepest level of nesting plus one. Its i-th value is equal to the size of the largest list that is nested i levels deep.\n\n@param `list` The input list.\n\n@param `shape` The hull shape of the input list.\n\n",signature:"list<LIST>  HULLSHAPE  shape<LIST>\n{ list<LIST>  } HULLSHAPE  shape<LIST>",tags:["lists","tensors"],since:"2.1.0",OPB64name:"HULLSHAPE"},HUMANDURATION:{description:"The `HUMANDURATION` function consumes a **LONG** duration and push back an easily readable **STRING** representation of this duration.\n\nThe format of the pushed back **STRING** is **[Dd][Hh][Mm]S.XXXXXXs** with D as days, H as hours, M as minutes, S as seconds and XXXXXX the number of ms (3 digits), us (6 digits) or ns (9 digits) depending on the platform configuration. If the duration is less than a day, Dd is omitted, sames goes with Hh and Mm.\n\n@param `duration` Duration expressed in the platform time unit.\n\n@param `humanReadableDuration`  A representation of the duration, easily readable for a human.\n\n",signature:"duration<LONG>  HUMANDURATION  humanReadableDuration<STRING>",tags:["date","time"],since:"1.0.0",OPB64name:"HUMANDURATION"},HYBRIDTEST:{description:"The `HYBRIDTEST` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\nLike [`STLESDTEST`](/doc/STLESDTEST), `HYBRIDTEST` performs an [`ESDTEST`](/doc/ESDTEST) onto a GTS that have been relieved of its seasonal and trend part. \nBut unlike the mentioned test, [`STL`](/doc/STL) and [`ESDTEST`](/doc/ESDTEST) are performed piecewise. Plus, the trend is approximated with the piecewise \nmedian instead of the trend part of the [`STL`](/doc/STL) decomposition.\n\nA LIST of ticks (or a LIST of LIST of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis technique was first developped at [Twitter](https://blog.twitter.com/2015/introducing-practical-and-robust-anomaly-detection-in-a-time-series).\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ## References\n> - Owen Vallis, Jordan Hochenbaum, Arun Kejariwal. “A Novel Technique for Long-Term Anomaly Detection in the Cloud”, Twitter Inc (2014).\n> - Cleveland, Robert B., et al. “STL: A seasonal-trend decomposition procedure based on loess.” Journal of Official Statistics 6.1 (1990): 3-73.\n> - Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n\n@param `parameters` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `lgts` List of [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n",signature:"gts<GTS> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE> parameters<MAP>  HYBRIDTEST  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG> parameters<MAP>  HYBRIDTEST  result<LIST<LONG>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE> parameters<MAP>  HYBRIDTEST  result<LIST<LIST<LONG>>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST  result<LIST<LIST<LONG>>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST  result<LIST<LIST<LONG>>>\nlgts<LIST<GTS>> period<LONG> piece<LONG> k<LONG> parameters<MAP>  HYBRIDTEST  result<LIST<LIST<LONG>>>",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST"},HYBRIDTEST2:{description:"The `HYBRIDTEST2` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\n`HYBRIDTEST2` is almost the same procedure than [`HYBRIDTEST`](/doc/HYBRIDTEST) except that it does not use [`STL`](/doc/STL) decomposition for the \nseasonal extract.\n\nThe seasonal part is approximated by pondering each value with the [entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29) of the \n[modified Z-score](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm) of its seasonal subseries (series with only the values of the \nsame season).\n\nThis test is usually preferred when it is meaningful to think in term of entropy, for example when the GTS represents counters of events. Also as it \ndoes not use [`STL`](/doc/STL) decomposition, it is not prone to border effects, but at the cost of not detecting slight outliers.\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n@param `gtsList` List of GTS\n\n",signature:"gts<GTS> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST2  result<LIST<LONG>>\ngts<GTS> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST2  result<LIST<LONG>>\ngtsList<LIST<GTS>> period<LONG> piece<LONG> k<LONG> alpha<DOUBLE>  HYBRIDTEST2  result<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> period<LONG> piece<LONG> k<LONG>  HYBRIDTEST2  result<LIST<LIST<LONG>>>",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST2"},HYPOT:{description:"HYPOT function returns the radius r from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta), r = sqrt(x²+y²).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `result` radius r in polar coordinates\n\n@param `lresult` List of radiuses r in polar coordinates\n\n",signature:"x<NUMBER> y<NUMBER>  HYPOT  result<DOUBLE>\nx<NUMBER> ly<LIST<NUMBER>>  HYPOT  lresult<LIST<DOUBLE>>\nlx<LIST<NUMBER>> y<NUMBER>  HYPOT  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"HYPOT"},IDENT:{description:"The `IDENT` function pushes onto the stack the value of the system property `warp.ident`.\n\n@param `ident` The value of the `warp.ident` property.\n\n",signature:" IDENT  ident<STRING>",tags:["stack"],since:"1.0.0",OPB64name:"IDENT"},IDWT:{description:"The `IDWT` function computes an Inverse [Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Discrete_wavelet_transform) on a Geo Time Series™.\n\nThe names of the available Wavelet are the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\n\n@param `wavelet` Wavelet to consider\n\n@param `gts` Geo Time Series™ which contains the wavelet coefficients as is returned by [`FDWT`](/doc/FDWT).\n\n@param `result` Reconstructed Geo Time Series™\n\n",signature:"gts<GTS> wavelet<STRING>  IDWT  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"IDWT"},IEEEREMAINDER:{description:"The `IEEEREMAINDER` function consumes two parameters, a dividend f1 and a divisor f2. This function push the remainder onto the stack as\nprescribed by the [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_754-1985).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` Dividend, converted as DOUBLE if not already the case.\n\n@param `divisor` Divisor, converted as DOUBLE if not already the case.\n\n@param `result` Remainder\n\n@param `ldividend` List of dividends, converted as DOUBLE if not already the case.\n\n@param `ldivisor` List of divisors, converted as DOUBLE if not already the case.\n\n@param `lresult` List of remainders\n\n",signature:"dividend<NUMBER> divisor<NUMBER>  IEEEREMAINDER  result<LONG>\ndividend<NUMBER> ldivisor<LIST<NUMBER>>  IEEEREMAINDER  lresult<LIST<LONG>>\nldividend<LIST<NUMBER>> divisor<NUMBER>  IEEEREMAINDER  lresult<LIST<LONG>>",tags:["operators"],since:"1.0.0",OPB64name:"IEEEREMAINDER"},IFFT:{description:"The `IFFT` function computes an Inverse [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) of two Geo Time Series™ \nrepresenting real and imaginary parts of FFT coefficients.\n\nThe result is the reconstructed Geo Time Series™. The ticks of this reconstructed GTS are the coefficient indices. They must be multipled by the original \nbucketspan to space the ticks according to the decomposed Geo Time Series™. The bucketspan is equal to `X / (n * factor)` where `X` is the number of time \nunits in a second, `n` is the number of coefficients and `factor` is the scale factor returned by `FFT`.\n\n@param `im` GTS containing the imaginary part\n\n@param `real` GTS containing the real parts of the `FFT` coefficients\n\n@param `result` Reconstructed Geo Time Series™\n\n",signature:"real<GTS> im<GTS>  IFFT  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"IFFT"},IFT:{description:"The `IFT` function is a conditional construct which will run a macro only if a boolean condition is true. The condition can either be a boolean on the stack or the result of a macro run.\n\n@param `check` Boolean which will be checked as the conditional test.\n\n@param `if` Macro which will be executed to determine the conditional test. This macro must leave a boolean on the stack.\n\n@param `then` Macro which is executed if the conditional test is `true`.\n\n@param `result` State of the stack after the `then` macro is executed.\n\n",signature:"if<MACRO> then<MACRO>  IFT  result<ANY*>\ncheck<BOOLEAN> then<MACRO>  IFT  result<ANY*>",tags:["control"],since:"1.0.0",OPB64name:"IFT"},IFTE:{description:"The `IFTE` function is a conditional construct which evaluates a condition and executes one of two macros depending on the condition (`true` or `false`). The condition can either be a BOOLEAN value on the stack or a macro which will be executed and must leave a BOOLEAN on the stack.\n\n@param `else` Macro executed if the condition is `false`.\n\n@param `then` Macro executed if the condition is `true`.\n\n@param `if` Macro executed to evaluate the condition. Must leave a BOOLEAN on top of the stack.\n\n@param `condition` Boolean value used as the condition.\n\n@param `result` Result of the execution of either the `then` or `else` macro.\n\n",signature:"if<MACRO> then<MACRO> else<MACRO>  IFTE  result<ANY*>\ncondition<BOOLEAN> then<MACRO> else<MACRO>  IFTE  result<ANY*>",tags:["control"],since:"1.0.0",OPB64name:"IFTE"},IMMUTABLE:{description:"Transforms a collection (**LIST**, **MAP**, **VLIST**, **SET**) into an immutable one. Any attempt to modify the immutable collection will fail. The original collection is not modified.\n\n@param `list` List to wrap into an immutable wrapper.\n\n@param `map` Map to wrap into an immutable wrapper.\n\n@param `set` Set to wrap into an immutable wrapper.\n\n@param `vector` Vector to wrap into an immutable wrapper.\n\n@param `immutableList` Immutable version of 'list'.\n\n@param `immutableMap` Immutable version of 'map'.\n\n@param `immutableSet` Immutable version of 'set'.\n\n@param `immutableVector` Immutable version of 'vector'.\n\n",signature:"list<LIST>  IMMUTABLE  immutableList<LIST>\nmap<MAP>  IMMUTABLE  immutableMap<MAP>\nset<SET>  IMMUTABLE  immutableSet<SET>\nvector<VLIST>  IMMUTABLE  immutableVector<VLIST>",tags:["lists","maps","sets"],since:"1.0.0",OPB64name:"IMMUTABLE"},IMPORT:{description:"The `IMPORT` function allows to create aliases for macro name prefixes. This is handy when accessing macros from WarpFleet™ repositories which might have multiple versions and/or long group and artifact ids. When fetching a macro, the *imported* prefixes will be scanned and the longest matching one will be replaced by the associated alias.\n\n@param `prefix` Original prefix to *import*.\n\n@param `as` Name under which `prefix` will be imported.\n\n",signature:"prefix<STRING> as<STRING>  IMPORT ",tags:["stack"],since:"2.0.3",OPB64name:"IMPORT"},INCREMENTEXACT:{description:"The `INCREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value incremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be incremented by one\n\n@param `result` The incremented value\n\n@param `lvalue` List of values to be incremented by one\n\n@param `lresult` List of incremented values\n\n",signature:"value<NUMBER>  INCREMENTEXACT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  INCREMENTEXACT  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.2.23",OPB64name:"INCREMENTEXACT"},INFLATE:{description:"Decompresses a byte array containing data compressed by [`DEFLATE`](doc/DEFLATE).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",signature:"compressed<BYTES>  INFLATE  uncompressed<BYTES>",tags:["conversion"],since:"2.1.0",OPB64name:"INFLATE"},INFO:{description:"Generate documentation of a function or a macro.\n\n@param `conf` String list of related configuration keys existing in the Warp 10 configuration.\n\n@param `examples` String list of WarpScript examples.\n\n@param `related` String list of related functions.\n\n@param `params` Map describing the parameters defined in `sig`.\n\n@param `sig` List of signatures. Each signature is a **LIST** with 2 lists (input and output) which contain parameter definitions: *eg* `param1:STRING` in stack order (top first)\n\n@param `desc` Description of the function or macro.\n\n@param `tags` String list tags (*eg* categories).\n\n@param `version` Version of the Warp 10 distribution on which this funcion is available (`standalone` | `distributed` | `all` | `pkg` | `ext` | `plugin`)\n\n@param `deleted` Version's number of Warp 10 where this function (or macro) was deleted.\n\n@param `deprecated` Version's number of Warp 10 where this function (or macro) was deprecated.\n\n@param `since` Version's number of Warp 10 where this function (or macro) was included.\n\n@param `name` Name of the function or macro.\n\n@param `ext` Fully qualified class name of the WarpScript Extension defining the function.\n\n@param `plugin` Fully qualified class name of the WarpScript Plugin defining the function.\n\n",signature:"{ plugin<STRING> ext<STRING> name<STRING> since<STRING> deprecated<STRING> deleted<STRING> version<STRING> tags<LIST> desc<STRING> sig<LIST> params<MAP> related<LIST> examples<LIST> conf<LIST>  } INFO ",tags:["platform","help"],since:"1.2.14",OPB64name:"INFO"},INFOMODE:{description:"Toggles the info mode ON or OFF depending on its current state. Default is OFF when the stack is created.\n\nWhen info mode is ON, the [`INFO`](/doc/INFO) function pushes its map parameter on the stack and stops the current execution as [`STOP`](/doc/STOP) would do.\n\n",signature:" INFOMODE ",tags:["platform","help"],since:"1.2.14",OPB64name:"INFOMODE"},INTEGRATE:{description:"The `INTEGRATE` function takes a GTS or a list thereof and integrates it/them, considering the value at each tick is a rate of change per second.\n\n@param `initial` Initial value\n\n@param `gts` GTS to integrate\n\n@param `lgts` List of GTS to integrate\n\n@param `result` Integrated GTS\n\n@param `lresult` List of integrated GTS\n\n",signature:"gts<GTS> initial<NUMBER>  INTEGRATE  result<GTS>\nlgts<LIST<GTS>> initial<NUMBER>  INTEGRATE  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"INTEGRATE"},INTERPOLATE:{description:"The `INTERPOLATE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with by interpolating linearly. \n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled bucketized GTS\n\n@param `resultList` list of filled bucketized GTS\n\n",signature:"gts<GTS>  INTERPOLATE  result<GTS>\ngtsList<LIST<GTS>>  INTERPOLATE  resultList<LIST<GTS>>",tags:["bucketize"],since:"1.0.0",OPB64name:"INTERPOLATE"},INTERSECTION:{description:"Computes the intersection &#x2229; of two sets.\n\nThe `INTERSECTION` function consumes two sets from the top of the stack and pushes back its mathematical intersection (ie: the elements in common).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x2229; *B*\n\n",signature:"setA<SET> setB<SET>  INTERSECTION  output<SET>",tags:["sets"],since:"1.0.0",OPB64name:"INTERSECTION"},INV:{description:"Inverts a matrix. The inversion is attempted using the [LU Decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.\n\nIf the matrix is singular or not square an error will be raised.\n\n@param `matrix` Matrix to invert.\n\n@param `inverse` Inverse of the original matrix.\n\n",signature:"matrix<MATRIX>  INV  inverse<MATRIX>",tags:["math"],since:"1.0.6",OPB64name:"INV"},ISAUTHENTICATED:{description:"Returns true or false whether or not the stack is authenticated\n\n@param `result` True if the stack is authenticated, false otherwise\n\n",signature:" ISAUTHENTICATED  result<BOOLEAN>",tags:["stack"],since:"1.2.11",OPB64name:"ISAUTHENTICATED"},ISNULL:{description:"The `ISNULL` function consumes a parameter p from the top of the stack and pushes onto the stack true if p is null, else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p is null\n\n",signature:"p<ANY>  ISNULL  result<BOOLEAN>",tags:["math","logic"],since:"1.0.0",OPB64name:"ISNULL"},ISNaN:{description:"The `ISNaN` function consumes a numeric parameter p from the top of the stack and pushes onto the stack true if p is Not a Number (NaN), else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p a Double and is NaN, false  otherwise\n\n",signature:"p<ANY>  ISNaN  result<BOOLEAN>",tags:["math"],since:"1.0.0",OPB64name:"ISNaN"},ISO8601:{description:"The `ISO8601` function consumes an optional **STRING** timezone and a **LONG** UTC timestamp and pushes back a **STRING** representing the date and time according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\n\nDepending on the platform time unit, the part representing seconds can have 3, 6 or 9 significant figures respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time representation.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `iso8601dateAndTime` Representation of the date and time of the given timestamp for the givent timezone according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard\n\n",signature:"timestamp<LONG>  ISO8601  iso8601dateAndTime<STRING>\ntimestamp<LONG> timezone<STRING>  ISO8601  iso8601dateAndTime<STRING>",tags:["date","time"],since:"1.0.0",OPB64name:"ISO8601"},ISODURATION:{description:"The `ISODURATION` function consumes a **LONG** duration in platform unit and pushes back a **STRING** reresenting an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). Whatever the platform time unit is, the representation maximum resolution is milliseconds.\n\nThe format of the ISO 8601 representation is `PThHmMs.xS` with `h` as hours, `m` as minutes, `s` as seconds and `x` as milliseconds. If any of these value is zero, the value and unit are omitted. The only exception is for a duration of 0 which is represented as `PT0S`. If the duration is negative, `h`, `m` and `s`, if displayed, are negative numbers. \n\n@param `duration` A duration expressed in platform time unit.\n\n@param `iso8601duration` A representation of the consumed duration according to ISO 8601.\n\n",signature:"duration<LONG>  ISODURATION  iso8601duration<STRING>",tags:["time"],since:"1.0.0",OPB64name:"ISODURATION"},ISONORMALIZE:{description:"The `ISONORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between -1 and 1 (i.e. it replaces X by \n(X - mean)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",signature:"gts<GTS>  ISONORMALIZE  result<GTS>\ngtsList<LIST<GTS>>  ISONORMALIZE  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"ISONORMALIZE"},JOIN:{description:"Join N strings with the given separator.\n\n@param `n` Number of elements to join that it needs to take from the top of the stack.\n\n@param `sep` Separator used to join the strings.\n\n@param `string` One or more string on the stack.\n\n@param `objects` List of objects whose string representations are to be joined.\n\n@param `result` Joined string.\n\n",signature:"string<STRING*> sep<STRING> n<LONG>  JOIN  result<STRING>\nobjects<LIST> sep<STRING>  JOIN  result<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"JOIN"},"JSON->":{description:"The `JSON->` function parses a string as [JSON](http://json.org/) from the top of the stack and pushes the result onto the stack.\n\n@param `json` String JSON representation\n\n@param `resultMap` Map JSON representation if it is a JSON object\n\n@param `resultList` List JSON representation if it is a JSON array\n\n",signature:"json<STRING>  JSON->  resultMap<MAP>\njson<STRING>  JSON->  resultList<LIST>",tags:["conversion"],since:"1.0.0",OPB64name:"H_CEIXoy"},JSONLOOSE:{description:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONLOOSE` function configures the stack to send results in a loose [JSON](http://json.org/) format where `NaN` and `Infinite` are valid values.\n\nIf the [JSON](http://json.org/) parser you’re using is strict, you should either configurate the [`JSONSTRICT`](/doc/JSONSTRICT) mode or dealing with \n`NaN` and `Infinite` values outside the parser.\n\n",signature:"",tags:["platform"],since:"1.0.0",OPB64name:"JSONLOOSE"},JSONSTACK:{description:"Select the JSON format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:" JSONSTACK ",tags:["stack"],since:"2.0.0",OPB64name:"JSONSTACK"},JSONSTRICT:{description:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONSTRICT` function configures the stack to send results in strict [JSON](http://json.org/) format.\n\n",signature:"",tags:["platform"],since:"1.0.0",OPB64name:"JSONSTRICT"},KEYLIST:{description:"Gets keys from a **MAP**.\n\nThe function `KEYLIST` extracts the keys of a map on the top of the stack and pushes on the stack a list with those keys. The map is consumed.      \n\n@param `map` Map from which you want to extract keys\n\n@param `result` List of keys\n\n",signature:"map<MAP>  KEYLIST  result<LIST>",tags:["maps"],since:"1.0.0",OPB64name:"KEYLIST"},KURTOSIS:{description:"The `KURTOSIS` function computes the [kurtosis](https://en.wikipedia.org/wiki/Kurtosis) of a Geo Time Series™ or a list thereof.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the kurtosis.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `kurtosis` Computed kurtosis of the Geo Time Series™ instance.\n\n@param `lkurtosis` List of computed kurtosis of the Geo Time Series™ instances.\n\n",signature:"gts<GTS> bessel<BOOLEAN>  KURTOSIS  kurtosis<DOUBLE>\nlgts<LIST<GTS>> bessel<BOOLEAN>  KURTOSIS  lkurtosis<LIST<DOUBLE>>",tags:["gts","statistics"],since:"1.2.13",OPB64name:"KURTOSIS"},LABELS:{description:"The `LABELS` function consumes a GTS from the stack, extracts its labels, puts them in a map and pushes the map onto the stack.\n\n@param `gts` The Geo Time Series™ to get the labels from.\n\n@param `encoder` The Geo Time Series™ Encoder to get the labels from.\n\n@param `return` Labels MAP\n\n",signature:"gts<GTS>  LABELS  return<MAP>\nencoder<GTSENCODER>  LABELS  return<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"LABELS"},LASTACTIVITY:{description:"Extracts the timestamp of last activity recorded in the Geo Time Series™ metadata.\n\nThe timestamp is expressed as platform time units elapsed since the Unix Epoch.\n\n@param `gts` Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `encoder` Geo Time Series™ encoder from which to extract the last activity timestamp.\n\n@param `lgts` List of Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `lencoder` List of Geo Time Series™ encoders from which to extract the last activity timestamp.\n\n@param `lastactivity` Timestamp of last activity.\n\n@param `llastactivity` List of timestamps of last activity.\n\n",signature:"gts<GTS>  LASTACTIVITY  lastactivity<LONG>\nencoder<GTSENCODER>  LASTACTIVITY  lastactivity<LONG>\nlgts<LIST<GTS>>  LASTACTIVITY  llastactivity<LONG>\nlencoder<LIST<GTSENCODER>>  LASTACTIVITY  llastactivity<LONG>",tags:["gts"],since:"2.0.0",OPB64name:"LASTACTIVITY"},LASTBUCKET:{description:"The function `LASTBUCKET` consumes a GTS off the stack and pushes its lastbucket onto the stack.\n\nNote: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Last bucket timestamp\n\n",signature:"gts<GTS>  LASTBUCKET  result<LONG>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"LASTBUCKET"},LASTSORT:{description:"Sorts a list of Geo Time Series™ according to their most recent value. If most recent values are identical, ticks will be compared, the most recent \nappearing first. If the ticks are also identical, then metadata (class and labels) will be compared.\n\nUse this function to compute Top N queries.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Sorted list of Geo Time Series™\n\n",signature:"gtsList<LIST<GTS>>  LASTSORT  result<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"LASTSORT"},LASTTICK:{description:"The `LASTTICK` function pushes on the stack the newest tick of the Geo Time Series™ on top of the stack or, if the GTS is bucketized, its last bucket.\n\nWhen applied to a list of GTS, `LASTTICK` will return the greatest last tick found across all Geo Time Series™.\n\nIf the GTS does not have values, `Long.MIN_VALUE` is pushed.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `gts` Geo Time Series™.\n\n@param `result` Last tick value.\n\n",signature:"gts<GTS>  LASTTICK  result<LONG>\nlgts<LIST<GTS>>  LASTTICK  result<LONG>",tags:["gts"],since:"1.0.0",OPB64name:"LASTTICK"},LBOUNDS:{description:"The `LBOUNDS` function computes bounds which divide a specified interval into `n` intervals of equal length.\n\nThe result of `LBOUNDS` is a list of `n+1` bounds, defining `n` intervals inside the specified range plus the two bounds of this range which define the intervals before and after the range.\n\n@param `n` Number of intervals to generate.\n\n@param `upper` Upper bound of the range to subdivide.\n\n@param `lower` Lower bound of the range to subdivide.\n\n@param `bounds` List of computed bounds.\n\n",signature:"lower<DOUBLE> upper<DOUBLE> n<LONG>  LBOUNDS  bounds<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"LBOUNDS"},LFLATMAP:{description:"The `LFLATMAP` function applies a macro on each element of a list, producing a list \nwith the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the list index on top and the element \nat that particular index below it. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\nDifference with `LMAP`: if the macro returns a list, then LFLATMAP will produce a \nlist with the elements of the macro output list (_i.e._ it will _flatten_ the list). \n\nDifference with `LMAP FLATTEN`: flatten will do the list flattening recursively. \n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count -1) will be on the top of the stack. By default, true.\n\n",signature:"inputlist<LIST> macro<MACRO>  LFLATMAP  results<LIST>\ninputlist<LIST> macro<MACRO> index<BOOLEAN>  LFLATMAP  results<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"LFLATMAP"},LIMIT:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and \na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `LIMIT` function modifies the maximum number of datapoints which can be fetched during a script execution by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call `AUTHENTICATE` with a valid token.\n\n@param `maxDataPoints` Maximal data points retrieved from database in a single FETCH\n\n",signature:"maxDataPoints<LONG>  LIMIT ",tags:["platform"],since:"1.0.0",OPB64name:"LIMIT"},LINEOFF:{description:"The `LINEOFF` function disables the automatic labelling of WarpScript code as enabled by `LINEON`.      \n\n",signature:"",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEOFF"},LINEON:{description:"The `LINEON` function enables the automatic section labelling at the beginning of each line of the input WarpScript code. This handy feature greatly simplifies the debug process as the exact line number where an error happens will appear in the error message embedded as a section name of the form `[Line #xx]`.\n\nThis automatic labelling only works with the `/exec` endpoint of Warp 10.\n\n",signature:"",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEON"},"LIST->":{description:"The `LIST->` function extracts the elements of the **LIST** at the top of the stack\nand pushes them onto the stack one by one. The function then pushes\nonto the stack the number of elements that were in the **LIST**.\n\n@param `input` The input list, will be consumbed\n\n@param `listlength` The length N of input\n\n@param `elements` N elements pushed on the stack\n\n",signature:"input<LIST>  LIST->  elements<ANY*> listlength<LONG>",tags:["lists","conversion"],since:"1.0.0",OPB64name:"I3_IK1oy"},LMAP:{description:"The `LMAP` function applies a macro on each element of a **LIST**, producing a **LIST** with the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **LIST** index on top and the element at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",signature:"inputlist<LIST> macro<MACRO>  LMAP  results<LIST>\ninputlist<LIST> macro<MACRO> index<BOOLEAN>  LMAP  results<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"LMAP"},LOAD:{description:"The `LOAD` function pushes onto the stack the value currently associated with a symbol name.      \n\nIf the symbol is not defined, an error will be raised.\n\n@param `name` Name of symbol whose value should be retrieved.\n\n@param `register` Register number whose value should be retrieved.\n\n@param `value` Retrieved value.\n\n",signature:"name<STRING>  LOAD  value<ANY>\nregister<LONG>  LOAD  value<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"LOAD"},LOCATIONOFFSET:{description:"The `LOCATIONOFFSET` function downsamples a Geo Time Series™ by retaining the first and last datapoints and only those datapoints which are \nmore than a given distance away.\n\n@param `distance` Distance in meters\n\n@param `gts` Geo Time Series™ to downsample\n\n@param `gtsList` List of Geo Time Series™ to downsample\n\n@param `result` Downsampled Geo Time Series™\n\n@param `resultList` List of downsampled Geo Time Series™\n\n",signature:"gts<GTS> distance<NUMBER>  LOCATIONOFFSET  result<GTS>\ngtsList<LIST<GTS>> distance<NUMBER>  LOCATIONOFFSET  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"LOCATIONOFFSET"},LOCATIONS:{description:"The `LOCATIONS` function consumes a Geo Time Series™ from the stack, extracts the locations of a Geo Time Series™, puts them in two lists \n(a list of latitudes and a list of longitudes) and pushes the two lists onto the stack.\n\n@param `gts` GTS\n\n@param `longitudes` List of longitudes\n\n@param `latitudes` List of latitudes\n\n",signature:"gts<GTS>  LOCATIONS  latitudes<LIST<DOUBLE>> longitudes<LIST<DOUBLE>>",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCATIONS"},LOCSTRINGS:{description:"The `LOCSTRINGS` function extract the locations from a Geo Time Series™ and builds a list of the 64 bits hexadecimal representation of their \n[HHCode](https://en.wikipedia.org/wiki/HHCode).\n\n@param `gts` Geo Time Series™\n\n@param `result` List of [HHCode](https://en.wikipedia.org/wiki/HHCode)\n\n",signature:"gts<GTS>  LOCSTRINGS  result<LIST<STRING>>",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCSTRINGS"},LOG:{description:"The `LOG` function consumes a floating point number x from the top of the stack and pushes back its natural logarithm, log<sub>e</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Natural logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of natural logarithms of the given values\n\n",signature:"value<NUMBER>  LOG  result<DOUBLE>\nlvalue<LIST<NUMBER>>  LOG  lresult<LIST<DOUBLE>>",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG"},LOG10:{description:"The `LOG10` function consumes a floating point number x from the top of the stack and pushes back its common logarithm, log<sub>10</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Common logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of common logarithms of the given values\n\n",signature:"value<NUMBER>  LOG10  result<DOUBLE>\nlvalue<LIST<NUMBER>>  LOG10  lresult<LIST<DOUBLE>>",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG10"},LOG1P:{description:"Returns the natural logarithm of the sum of the argument and 1.\n\nThe `LOG1P` function consumes a number from the top of the stack and pushes back the natural logarithm for (arg + 1).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Logarithm of (value + 1)\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of logarithm of (value + 1)\n\n",signature:"value<NUMBER>  LOG1P  result<DOUBLE>\nlvalue<LIST<NUMBER>>  LOG1P  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"LOG1P"},"LOGEVENT->":{description:"Warp&nbsp;10™ runner execution logs are encrypted. See [this documentation](/content/03_Documentation/06_Operations/05_Logs/).\n\nThe easiest way to read logs is to copy the log output and use this function.\n\n\n@param `logline` The opb64 representation of the aes encrypted log line\n\n@param `decodedlog` The decoded logs.\n\n",signature:"logline<STRING>  LOGEVENT->  decodedlog<STRING>",tags:["debug"],since:"1.2.7",OPB64name:"I3x6GKO4I_FhEV"},LOGMSG:{description:"`LOGMSG` function prints millisecond timestamp and input text on the standard output.\n\nThe `LOGMSG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",signature:"msg<STRING>  LOGMSG ",tags:["extensions"],since:"1.0.0",OPB64name:"LOGMSG"},LOWESS:{description:"The `LOWESS` function consumes a bandwidth (a **LONG**) from the top of the stack, then smooths a GTS or a **LIST** of GTS that are below by using \nlocal regression.\n\nTo obtain a good smoothing, it is advised to choose an odd number of at least 5 as the bandwidth parameter.\n\n@param `bandwidth` The bandwitdth parameter is the number of nearest neighbours to consider when applying the local regression.\n\n@param `gts` Geo Time Series™.\n\n@param `gtsList` List of Geo Time Series™.\n\n@param `lresult` List of Geo Time Series™ result.\n\n@param `result` Geo Time Series™ result.\n\n",signature:"gts<GTS> bandwidth<LONG>  LOWESS  result<GTS>\ngtsList<LIST<GTS>> bandwidth<LONG>  LOWESS  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"LOWESS"},LR:{description:"Compute the [simple linear regression](https://en.wikipedia.org/wiki/Linear_regression) parameters `alpha` (y-intercept) and `beta` (line slope) for the given numerical Geo Time Series™.\n\n@param `gts` Geo Time Series™ on which to compute linear regression.\n\n@param `beta` The slope of the line fitted on the GTS values.\n\n@param `alpha` The y-intercept of the lined fitted on the GTS values.\n\n",signature:"gts<GTS>  LR  alpha<DOUBLE> beta<DOUBLE>",tags:["gts","statistics"],since:"1.0.13",OPB64name:"LR"},LSORT:{description:"The `LSORT` function sorts the list on the top of the stack.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `inputlist` The reference of the list to sort\n\n@param `sortedlist` The original list sorted, this is not a new list object\n\n",signature:"inputlist<LIST>  LSORT  sortedlist<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"LSORT"},LTTB:{description:"The `LTTB` function downsamples a Geo Time Series™ or list thereof using the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",signature:"gts<GTS> samples<LONG>  LTTB  downsampled<GTS>\nlgts<LIST<GTS>> samples<LONG>  LTTB  ldownsampled<LIST<GTS>>",tags:["gts"],since:"1.0.11",OPB64name:"LTTB"},MACROBUCKETIZER:{description:"`MACROBUCKETIZER` converts a macro into a bucketizer which can be used with the [`BUCKETIZE`](/doc/BUCKETIZE) framework.\n\nFor each tick in the mapped GTS, the macro will be called with a list containing the following elements on the stack:\n\n```js\n[tick_of_computation,[gts_classes],[label_bucketize],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n@param `macro` Macro used as a bucketizer\n\n@param `result` Bucketizer to apply\n\n",signature:"macro<MACRO>  MACROBUCKETIZER  result<AGGREGATOR>",tags:["bucketize","bucketizer"],since:"1.0.0",OPB64name:"MACROBUCKETIZER"},MACROCONFIG:{description:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration keys looked up are those built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIG`.\n\n`MACROCONFIG` will check if the keys exists, if not it will remove the part of the macro name after the last `/` and will try that new key. It will successively try all names up to the last part of the macro name.\n\nIf none of those keys existed, the call will end in error.\n\nSo for example, if `MACROCONFIG` is called from a macro `my/test/macro` to retrieve the value associated with `mykey`, it will look up the following keys in the configuration:\n\n```\nmykey@my/test/macro\nmykey@my/test\nmykey@my\n```\n\n@param `key` Configuration key to look up.\n\n",signature:"key<STRING>  MACROCONFIG ",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIG"},MACROCONFIGDEFAULT:{description:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration key looked is built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIGDEFAULT`.\n\n`MACROCONFIGDEFAULT` will check if the keys exists, if not it will push the provided default value onto the stack, or fail with an error if the default was `NULL`. If the key is found, the associated value is pushed on the stack.\n\n@param `key` Configuration key to look up.\n\n@param `default` Default value to use if the key was not found, or `NULL` to fail if the key is absent.\n\n",signature:"key<STRING> default<STRING>  MACROCONFIGDEFAULT ",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGDEFAULT"},MACROCONFIGSECRET:{description:"The `MACROCONFIGSECRET` macro consumes 2 elements on the stack, the current and new secret to be set. If no secret has been set, the function will throw an error.\n\nThe secret set by this function is the secret used by [`SETMACROCONFIG`](/doc/SETMACROCONFIG).\n\n@param `newSecret` New secret to override the current one.\n\n@param `oldSecret` Currently set secret.\n\n",signature:"oldSecret<STRING> newSecret<STRING>  MACROCONFIGSECRET ",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGSECRET"},MACROFILLER:{description:"`MACROFILLER` converts a macro into a *filler* which can be used with the [`FILL`](/doc/FILL) function.\n\nThe macro will find the following elements on the stack when it is called:\n\n```\n6: Geo Time Series™ to fill. Both this GTS and the one above are only meant to expose the metadata\n5: Geo Time Series™ of the *other* GTS with a value at the current tick\n4: list of [ tick latitude longitude elevation value ] for the pre window\n3: [ tick latitude longitude elevation value ] of the *other* Geo Time Series™\n2: list of [ tick latitude longitude elevation value ] for the post window\nTOP: tick which is being filled\n```\n\nIt must leave on the stack a list containing the following elements, in this order:\n\n*tick*, *latitude* or `NaN`, *longitude* or `NaN`, *elevation* or `NaN`, *value*\n\n\n@param `macro` Macro to wrap.\n\n@param `prewindow` Number of datapoints needed ahead of the missing datapoint.\n\n@param `postwindow` Number of datapoints needed after the missing datapoint.\n\n@param `filler` Filler instance.\n\n",signature:"macro<MACRO> prewindow<LONG> postwindow<LONG>  MACROFILLER  filler<FILLER>",tags:["filler"],since:"2.0.0",OPB64name:"MACROFILLER"},MACROFILTER:{description:"`MACROFILTER` converts a macro into a filter which can be used with the [`FILTER`](/doc/FILTER) framework\n\nFor each equivalence classes in the filter set of Geo Time Series™, the macro will be called with the following elements on the stack:\n\n```\n[gts], {labels_equivalence_class}\n```\n\nAfter each call the macro is expected to leave a list on the stack.\n\n@param `macro` Macro to apply\n\n@param `result` Filter to apply\n\n",signature:"macro<MACRO>  MACROFILTER  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"MACROFILTER"},MACROMAPPER:{description:"`MACROMAPPER` converts a macro into a mapper which can be used with the [`MAP`](/doc/MAP) framework.\n\nFor each tick in the mapped Geo Time Series™, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROMAPPER` can also create a multivariate mapper, that is, a mapper that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate mapper with MAP, each input GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n\n@param `macro` Macro to convert\n\n@param `result` Mapper to apply\n\n",signature:"macro<MACRO>  MACROMAPPER  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"MACROMAPPER"},MACROREDUCER:{description:"`MACROREDUCER` converts a macro into a reducer which can be used with the [`REDUCE`](/doc/REDUCE) framework\n\nFor each tick in the Geo Time Series™ to reduce, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nEach list have a length of the number of GTSs in the partition. Each missing value are replaced by `null`, each missing tick by the minimum value of long and each missing latitude, longitude or elevation by NaN. The `label_maps` list as one more element at the end compared to the other lists: the common labels for the GTSs of the partition.\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROREDUCER` can also create a multivariate reducer, that is, a reducer that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate reducer with REDUCE, each input List of GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n@param `macro` Macro to apply\n\n@param `result` Reducer to apply\n\n",signature:"macro<MACRO>  MACROREDUCER  result<AGGREGATOR>",tags:["reducer"],since:"1.0.0",OPB64name:"MACROREDUCER"},MACROTTL:{description:"In a file defining a server side macro, the `MACROTTL` function defines the time to live of the macro code. If the macro is accessed after this delay has expired and ondemand loading of macros is enabled, it will unconditionnaly be reloaded from disk.\n\nThis feature is very useful when you have macros generated dynamically on the server side which change frequently. Using `MACROTTL` you can ensure the newest code is loaded regardless of the rescan interval of the macro directory.\n\nIn a the file defining a server side macro, the call to `MACROTTL` should appear before or after the actual macro definition but not within.\n\nThe time after which the macro will no longer be valid is the time of the call to `MACROTTL` plus its parameter.\n\n@param `ttl` The time to live to apply to the macro, in ms.\n\n",signature:"ttl<LONG>  MACROTTL ",tags:["platform"],since:"1.2.13",OPB64name:"MACROTTL"},MAKEGTS:{description:"The `MAKEGTS` function builds a Geo Time Series™ from **LIST**s.\n\nThe timestamp and values lists must be of the exact same size.\nHowever, as latitudes, longitudes and elevations are optional in a Geo Time Series™, these lists can be shorter than the timestamps lists or even empty. If there are missing latitudes, longitudes and elevations, use [`NaN`](/doc/NaN).\n\n@param `values` Values of the GTS\n\n@param `elevations` Elevations of the GTS\n\n@param `longitudes` Longitudes of the GTS\n\n@param `latitudes` Latitudes of the GTS\n\n@param `timestamps` Timestamps of the GTS\n\n@param `result` Geo Time Series™\n\n",signature:"timestamps<LIST> latitudes<LIST> longitudes<LIST> elevations<LIST> values<LIST>  MAKEGTS  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"MAKEGTS"},MAN:{description:"The `MAN` function returns the help link for a function name.\n\nIf the function does not exists, it returns http://www.warp10.io/\n\n\n@param `function` The function name\n\n@param `any` Anything except a function name\n\n@param `url` URL of the online help\n\n",signature:"function<STRING>  MAN  url<STRING>\nany<ANY>  MAN  url<STRING>\n MAN  url<STRING>",tags:["misc","help"],since:"1.2.18",OPB64name:"MAN"},MAP:{description:"The `MAP` framework applies a function on values of a Geo Time Series™ that fall into a sliding window.\n\nThe `MAP` framework is designed to use an existing MAPPER or a custom MACROMAPPER. It could also accept a macro: the current window is passed as a GTS to the macro. See examples below.\n\n@param `result` List of Geo Time Series™, one for each input, whose values are the results of the function application on each sliding window. If the input series is bucketized, the result series will be too unless outputTicks is non null.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `mapper` Mapper function to apply\n\n@param `pre` Width of the sliding window before the current tick. This parameter is interpreted as a number of ticks if its value is positive, and as a number of time units if its value is negative. A value of 0 means the sliding window does not cover the past. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the past. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `post` Width of the sliding window after the current tick. Values have the same semantics as for the `pre` parameter. A value of 0 means the sliding window does not cover the future. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the future. Defaults to 0.\n\n@param `occurrences` Limit the number of computations to that number. If the value is 0, compute a value for each tick of the input Geo Time Series™. If it is non-negative, compute that many values starting from the oldest to the most recent tick. In the other case, do that many computations in the reverse order. This is useful when you are interested in a single result, like the max or sum of all values. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `step` The step size in number of ticks. The mapper beggins at the oldest tick and goes to the tick `step` after the current one and so on. Defaults to 1.\n\n@param `overrideTick` If set to true, the tick value returned by the mapper is used to update the current tick, else it is ignored and the original tick is kept. Defaults to false.\n\n@param `outputTicks` If non null, it sets the list of ticks that is traversed to anchor the sliding windows (instead of the ticks of the input Geo Time Series™). In that case, a tick of the input Geo Time Series™ that would be equal to one of these anchor points is counted by a positive `post` if `occurences` is non-negative, or by a positive `pre` if `occurences` is negative.\n\n",signature:"[ gts<GTS+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> ]  MAP  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> ]  MAP  result<LIST<GTS>>\n[ gts<GTS+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> ]  MAP  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> ]  MAP  result<LIST<GTS>>\n[ gts<GTS+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> ]  MAP  result<LIST<GTS>>\n[ gtsList<LIST<GTS>+> mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> ]  MAP  result<LIST<GTS>>\ngts<GTS+> { mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> outputTicks<LIST<LONG>>  } MAP  result<LIST<GTS>>\ngtsList<LIST<GTS>+> { mapper<AGGREGATOR> pre<LONG> post<LONG> occurrences<LONG> step<LONG> overrideTick<BOOLEAN> outputTicks<LIST<LONG>>  } MAP  result<LIST<GTS>>",tags:["mapper","framework"],since:"1.0.0",OPB64name:"MAP"},"MAP->":{description:"The `MAP->` function expands the **MAP** on top of the stack into pairs of elements followed by the number of elements extracted. If the **MAP** was \ncreated by a call to `->MAP`, the order of the elements will be the same as prior to calling `->MAP`.\n\n@param `map` Map to expand\n\n@param `key` Key of the pair\n\n@param `value` Value of the pair\n\n@param `mapsize` The number of key value pushed on the stack.\n\n",signature:"map<MAP>  MAP->  key<ANY*> value<ANY*> mapsize<LONG>",tags:["maps","conversion"],since:"1.0.0",OPB64name:"IJ4FAIs"},MAPID:{description:"Generates a fingerprint of a map.\n\n@param `input` Input map\n\n@param `result` Fingerprint of the map\n\n",signature:"input<MAP>  MAPID  result<STRING>",tags:["maps"],since:"1.0.0",OPB64name:"MAPID"},MARK:{description:"Pushes a mark onto the stack.\n\n@param `mark` A MARK instance.\n\n",signature:" MARK  mark<MARK>",tags:["stack"],since:"1.0.0",OPB64name:"MARK"},"MAT->":{description:"The `MAT->` function converts a Matrix into nested lists.\n\n\n@param `input` Matrix to convert\n\n@param `result` Nested list of values\n\n",signature:"input<MATRIX>  MAT->  [  result<LIST<LIST<DOUBLE>>>  ]",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"IJ4JAIs"},MATCH:{description:"The `MATCH` function applies a regular expression (regexp) to a string.\n\nIt consumes two parameters from the top of the stack: the regexp pattern and the string to test matching with.\n\nIf the string doesn’t match the regexp, the function return an empty list. If it matches, the function will return a list of every matching group.\n\nInstead of using a regular expression **STRING**, you can also use the result of [`MATCHER`](/doc/MATCHER) for improved performance.\n\n@param `regexp` Regular expression to apply\n\n@param `string` String to evaluate\n\n@param `result` List of every matching group.\n\n",signature:"string<STRING> regexp<STRING>  MATCH  result<LIST<STRING>>\nstring<STRING> regexp<MATCHER>  MATCH  result<LIST<STRING>>",tags:["strings"],since:"1.0.0",OPB64name:"MATCH"},MATCHER:{description:"The `MATCHER` function will compile a regular expression into an efficient object which can be used by [`MATCH`](/doc/MATCH).\n\n@param `regexp` Regular expression to compile\n\n@param `result` Compiled regula expression\n\n",signature:"regexp<STRING>  MATCHER  result<MATCHER>",tags:["strings"],since:"1.0.0",OPB64name:"MATCHER"},MAX:{description:"Returns the greater of two numeric values.\n\nThe `MAX` function consumes two numeric parameters from the top of the stack and pushes back the greatest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The larger of p1 and p2.\n\n@param `sresult` The larger of the elements in the given list.\n\n@param `lresult` A list where each value is the max between the element in the list and the given value.\n\n",signature:"p1<LONG> p2<LONG>  MAX  result<LONG>\np1<LONG> p2<DOUBLE>  MAX  result<DOUBLE>\np1<DOUBLE> p2<LONG>  MAX  result<DOUBLE>\np1<DOUBLE> p2<DOUBLE>  MAX  result<DOUBLE>\np1<COUNTER> p2<COUNTER>  MAX  result<LONG>\np1<COUNTER> p2<DOUBLE>  MAX  result<DOUBLE>\np1<DOUBLE> p2<COUNTER>  MAX  result<DOUBLE>\np1<COUNTER> p2<LONG>  MAX  result<DOUBLE>\np1<LONG> p2<COUNTER>  MAX  result<DOUBLE>\nllist<LIST<LONG>>  MAX  sresult<LONG>\ndlist<LIST<DOUBLE>>  MAX  sresult<DOUBLE>\nclist<LIST<COUNTER>>  MAX  sresult<LONG>\nllist<LIST<LONG>> value<LONG>  MAX  lresult<LIST<LONG>>\nclist<LIST<COUNTER>> value<COUNTER>  MAX  lresult<LIST<LONG>>\ndlist<LIST<DOUBLE>> value<DOUBLE>  MAX  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"MAX"},MAXBUCKETS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXBUCKETS` function modifies the maximum number of buckets which can be created by a call to [`BUCKETIZE`](/doc/BUCKETIZE) by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXBUCKETS ",tags:["platform","bucketize"],since:"1.0.0",OPB64name:"MAXBUCKETS"},MAXDEPTH:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXDEPTH` function modifies the maximum depth (number of levels) of the execution stack by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXDEPTH ",tags:["platform","stack"],since:"1.0.0",OPB64name:"MAXDEPTH"},MAXGEOCELLS:{description:"Modifies the maximum number of cells a **GEOSHAPE** created by [`GEO.WKT`](/doc/GEO.WKT) or [`GEO.JSON`](/doc/GEO.JSON) can have. The limit can be modified up to the configured value for `warpscript.maxgeocells.hard`.\n\n@param `maxcells` New limit to set.\n\n",signature:"maxcells<LONG>  MAXGEOCELLS ",tags:["platform"],since:"1.2.11",OPB64name:"MAXGEOCELLS"},MAXGTS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard limit \nwhich can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXGTS` function modifies the maximum number of Geo Time Series™ which can be fetched by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXGTS ",tags:["platform","gts"],since:"1.0.0",OPB64name:"MAXGTS"},MAXJSON:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to\nthe hard limit value.\n\nThe `MAXJSON` function modifies the maximum number of characters in a json produced by [`->JSON`](/doc/AIt9JoxD).\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXJSON ",tags:["platform"],since:"2.5.0",OPB64name:"MAXJSON"},MAXLONG:{description:"Pushes [Long.MAX_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MAX_VALUE) onto the stack.\n\n@param `result` Long.MAX_LONG\n\n",signature:" MAXLONG  result<LONG>",tags:["math","constants"],since:"1.0.0",OPB64name:"MAXLONG"},MAXLOOP:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard\nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe MAXLOOP function modifies the maximum number of milliseconds which can be spent in a loop setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXLOOP ",tags:["platform"],since:"1.0.0",OPB64name:"MAXLOOP"},MAXOPS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXOPS` function modifies the maximum number of operations which can be performed during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXOPS ",tags:["platform"],since:"1.0.0",OPB64name:"MAXOPS"},MAXPIXELS:{description:"Modifies the maximum size (in pixels) of images which can be created by [`PGraphics`](/doc/PGraphics). The limit can be modified up to the value configured in `warpscript.maxpixels.hard`.\n\n@param `pixels` Maximum size (in pixels).\n\n",signature:"pixels<LONG>  MAXPIXELS ",tags:["platform"],since:"1.0.0",OPB64name:"MAXPIXELS"},MAXRECURSION:{description:"Modifies the maximum nesting depth of macro calls. The limit can be modified up to the value configured in `warpscript.maxrecursion.hard`.\n\n@param `depth` Maximum nesting depth.\n\n",signature:"depth<LONG>  MAXRECURSION ",tags:["platform"],since:"1.2.13",OPB64name:"MAXRECURSION"},MAXSYMBOLS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a \nhard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXSYMBOLS` function modifies the maximum number of simultaneous symbols which can be defined on the stack during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"limit<LONG>  MAXSYMBOLS ",tags:["platform"],since:"1.0.0",OPB64name:"MAXSYMBOLS"},MAXURLFETCHCOUNT:{description:"The `MAXURLFETCHCOUNT` function modifies the maximum number of URLs which can be fetched with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.MAXURLFETCHCOUNT.limit.hard`.\n\n@param `limit` The maximum number of URLs which can be fetched.\n\n",signature:"limit<LONG>  MAXURLFETCHCOUNT ",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHCOUNT"},MAXURLFETCHSIZE:{description:"The `MAXURLFETCHSIZE` function modifies the maximum cumulative size of fetched payloads with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.urlfetch.maxsize.hard` and is expressed as a number of bytes.\n\n@param `limit` The maximum cumulative size of fetched payloads.\n\n",signature:"limit<LONG>  MAXURLFETCHSIZE ",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHSIZE"},MD5:{description:"The `MD5` function digests a byte array on the stack with the cryptographic hash function [`MD5`](https://en.wikipedia.org/wiki/MD5).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",signature:"input<BYTES>  MD5  result<BYTES>",tags:["crypto"],since:"1.2.0",OPB64name:"MD5"},MERGE:{description:"Merge several Geo Time Series™ together.\n\nThe `MERGE` function expects a **LIST** of Geo Time Series™ on the top of the stack. It will consume these GTS and push onto the stack a single GTS instance\nwith all measurements found in the GTS instances present in the **LIST**. The name and labels of the resulting GTS instance are those of the first one of the\n**LIST**.\n\n`MERGE` do not override values on the same timestamp, they are appenned.\n\n@param `gtsList` The list of Geo Time Series™\n\n@param `result` The merged Geo Time Series™\n\n",signature:"gtsList<LIST<GTS>>  MERGE  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"MERGE"},META:{description:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `META` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",signature:"gtsList<LIST<GTS>> writeToken<STRING>  META ",tags:["gts"],since:"1.0.0",OPB64name:"META"},METADIFF:{description:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend in an incremental manner. New attributes are added and already existing attributes are updated or removed if their value is an empty string.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `METADIFF` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",signature:"gtsList<LIST<GTS>> writeToken<STRING>  METADIFF ",tags:["gts"],since:"2.3.0",OPB64name:"METADIFF"},METAOFF:{description:"Disables meta operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a meta operation is attempted.\n\n",signature:"message<STRING> secret<STRING>  METAOFF ",tags:["platform"],since:"2.0.3",OPB64name:"METAOFF"},METAON:{description:"Enables meta operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",signature:"secret<STRING>  METAON ",tags:["platform"],since:"2.0.3",OPB64name:"METAON"},METASET:{description:"Performs a [`FIND`](/doc/FIND), retrieving a list of Geo Time Series™ and builds a *metaset* which can be distributed to allow access to those GTS without having to give away credentials.\n\nMetaset support is only available if a key has been set for `warp.aes.metasets`.\n\n@param `ttl` Time to live of the produces metaset. It will not be usable after that much time has elapsed since the current time. The ttl is specified in time units.\n\n@param `maxduration` The maximum span of data which can be retrieved using this metaset, in time units.\n\n@param `notafter` Most recent timestamp of the data this metaset can retrieve.\n\n@param `notbefore` Most ancient timestamp of the data this meataset can retrieve.\n\n@param `labels` Map of label selectors.\n\n@param `class` Geo Time Series™ class selector.\n\n@param `token` Read token to use for retrieving the GTS.\n\n@param `metaset` Encrypted metaset which can be used with a [`FETCH`](/doc/FETCH).\n\n",signature:"[ token<STRING> class<STRING> labels<MAP> notbefore<LONG> notafter<LONG> maxduration<LONG> ttl<LONG> ]  METASET  metaset<STRING>",tags:["gts"],since:"1.2.5",OPB64name:"METASET"},METASORT:{description:"Sorts a list of Geo Time Series™ according to elements of their metadata. The list of elements to consider for sorting can contain label names or NULL to consider the classname. Elements will be considered in the order in which they appear in the list.\n\n@param `gts` List of Geo Time Series™ to sort.\n\n@param `elements` Metadata elements to consider for sorting.\n\n@param `sorted` Sorted list of GTS.\n\n",signature:"gts<LIST<GTS>> elements<LIST>  METASORT  sorted<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"METASORT"},MIN:{description:"Returns the smaller of two numeric values.\n\nThe `MIN` function consumes two numeric parameters from the top of the stack and pushes back the smallest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The smaller of p1 and p2.\n\n@param `sresult` The smaller of the elements in the given list.\n\n@param `lresult` A list where each value is the min between the element in the list and the given value.\n\n",signature:"p1<LONG> p2<LONG>  MIN  result<LONG>\np1<LONG> p2<DOUBLE>  MIN  result<DOUBLE>\np1<DOUBLE> p2<LONG>  MIN  result<DOUBLE>\np1<DOUBLE> p2<DOUBLE>  MIN  result<DOUBLE>\np1<COUNTER> p2<COUNTER>  MIN  result<LONG>\np1<COUNTER> p2<DOUBLE>  MIN  result<DOUBLE>\np1<DOUBLE> p2<COUNTER>  MIN  result<DOUBLE>\np1<COUNTER> p2<LONG>  MIN  result<DOUBLE>\np1<LONG> p2<COUNTER>  MIN  result<DOUBLE>\nllist<LIST<LONG>>  MIN  sresult<LONG>\ndlist<LIST<DOUBLE>>  MIN  sresult<DOUBLE>\nclist<LIST<COUNTER>>  MIN  sresult<LONG>\nllist<LIST<LONG>> value<LONG>  MIN  lresult<LIST<LONG>>\nclist<LIST<COUNTER>> value<COUNTER>  MIN  lresult<LIST<LONG>>\ndlist<LIST<DOUBLE>> value<DOUBLE>  MIN  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"MIN"},MINLONG:{description:"Pushes [Long.MIN_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MIN_VALUE) onto the stack.\n\n@param `result` Long.MIN_VALUE\n\n",signature:" MINLONG  result<LONG>",tags:["math","constants"],since:"1.0.0",OPB64name:"MINLONG"},MINREV:{description:"The `MINREV` function consumes a string representing a revision on the stack and puts back a boolean indicating if the revision of the current Warp 10™ platform is newer or equal.\n\n@param `revision` A string representing a revision (semantic versioning). Given a version number MAJOR.MINOR.PATCH, .MINOR or .MINOR.PATCH can be omitted.\n\n@param `newer` A boolean indicating wether the revision of the current Warp 10™ platform is newer or equal to the given revision.\n\n",signature:"revision<STRING>  MINREV  newer<BOOLEAN>",tags:["platform"],since:"1.2.23",OPB64name:"MINREV"},MMAP:{description:"The `MMAP` function applies a macro on each key/value pair of a **MAP**, producing a **MAP** with the two elements on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **MAP** index on top and the key/value pair at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each entry in inputmap.\n\n@param `inputmap` Map to iterate on.\n\n@param `results` Map of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",signature:"inputmap<MAP> macro<MACRO>  MMAP  results<MAP>\ninputmap<MAP> macro<MACRO> index<BOOLEAN>  MMAP  results<MAP>",tags:["maps"],since:"2.7.0",OPB64name:"MMAP"},MODE:{description:"The `MODE` function computes the mode(s) for a given Geo Time Series™ or a GTS **LIST**. Foreach Geo Time Series™ pushes back on the stack a list containing \ntheir mode(s).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Mode of the list (the items that occurs most often)\n\n",signature:"gts<GTS>  MODE  result<LIST>\ngtsList<LIST<GTS>>  MODE  [  result<LIST<LIST>>  ]",tags:["gts"],since:"1.0.11",OPB64name:"MODE"},MONOTONIC:{description:"Produces a new Geo Time Series™ from an input by modifying the value so the result is monotonous. This is technically applying a ratchet effect on values.\n\nThe `MONOTONIC` function expects a boolean on top of the stack and a Geo Time Series™ or list thereof below the boolean. The boolean indicates whether the\nresult should be monotonically increasing (false) or decreasing (true).\n\n@param `trend` Whether the result should be monotonically increasing (false) or decreasing (true)\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` New Geo Time Series™\n\n@param `resultList` List of new Geo Time Series™\n\n",signature:"gts<GTS> trend<BOOLEAN>  MONOTONIC  result<GTS>\ngtsList<LIST<GTS>> trend<BOOLEAN>  MONOTONIC  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"MONOTONIC"},MOTIONSPLIT:{description:'The `MOTIONSPLIT` function splits Geo Time Series™ instances based on several possible motion criteria. Split parameters can be combined to split on multiple criteria.\n\n`MOTIONSPLIT` can split on:\n- stopped state detection\n- moving to stopped transition\n- time difference between two ticks (just as [`TIMESPLIT`](/doc/TIMESPLIT) does).\n- maximal distance between two consecutive positions.\n\n`MOTIONSPLIT` parameters:\n- **timesplit**: LONG value, time in platform time unit. Splits if the time difference between two consecutive ticks is strictly greater than this parameter. If defined, the split type label will be "timesplit".\n- **distance.split**: DOUBLE value, distance in meter. Splits if the orthodromic distance between two consecutive locations is strictly greater than this parameter. If defined, the split type label will be "distancesplit".\n- **stopped.min.time**: LONG value, time in platform time unit. This is the minimum time the consecutive locations should stay in the stopped zone radius to consider a stop state. If defined, the split type label will be "stopped".\n- **stopped.max.radius**: DOUBLE value, distance in meter. As long as consecutive positions remains in the radius during stopped.min.time, `MOTIONSPLIT` detect a stopped state.\n- **stopped.max.speed**: DOUBLE value, speed in m/s. If the speed is greater than this value while in stopped state, `MOTIONSPLIT` exits the stopped state.\n- **stopped.max.mean.speed**: DOUBLE value, speed in m/s. Maximum mean speed in the proximity zone that prevent the split. `MOTIONSPLIT` will split only if there is a full stop during the given time and radius, and if the mean speed in the proximity zone is less than this parameter.\n- **stopped.split**: BOOLEAN value. If true, `MOTIONSPLIT` also splits between stopped and moving sequences. If defined, the split type label will be "stopped" or "moving".\n- **label.stopped.time**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the time in stopped state. If the split source is not a stop detection, this label won\'t be set.\n- **label.split.number**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the split number, starting from 1.\n- **label.split.type**: STRING value. If defined, `MOTIONSPLIT` will add an extra label that contains the split reason. It could be "timesplit", "distancesplit", "end", "stopped" or "moving".\n\n`MOTIONSPLIT` split type priorities:\n- If stopped.min.time and stopped.max.radius are set, the stop detection has the first priority.\n- If `MOTIONSPLIT` does not detect a stopped state, it looks for a distance split.\n- If `MOTIONSPLIT` does not detect a stopped state or a distance split, it looks for a time split.\n\n\n@param `parameters` List of splitting parameters. See the function description.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n',signature:"gts<GTS> parameters<MAP>  MOTIONSPLIT  splits<LIST<GTS>>\nlgts<LIST<GTS>> parameters<MAP>  MOTIONSPLIT  lsplits<LIST<LIST<GTS>>>",tags:["gts"],since:"2.3.0",OPB64name:"MOTIONSPLIT"},MSGFAIL:{description:"The `MSGFAIL` function stops the execution of WarpScript code by throwing an exception. \n\n@param `message` The exception message\n\n",signature:"message<STRING>  MSGFAIL ",tags:["control"],since:"1.0.0",OPB64name:"MSGFAIL"},MSORT:{description:"The function `MSORT` inspects the top of the stack. If it is a **MAP**, it sorts the **MAP** according to its keys. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\n@param `map` Map to sort\n\n@param `result` Sorted map\n\n",signature:"map<MAP>  MSORT  result<MAP>",tags:["maps"],since:"1.0.0",OPB64name:"MSORT"},MSTU:{description:"The `MSTU` function pushes onto the stack the number of platform time units in one millisecond. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one millisecond.\n\n",signature:" MSTU  numberTimeUnits<LONG>",tags:["date","time","platform"],since:"1.0.0",OPB64name:"MSTU"},MULTIPLYEXACT:{description:"The `MULTIPLYEXACT` function consumes two LONGs from the top of the stack and puts back the product. If the product overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `prod` The product of x and y\n\n@param `list` List of numeric values\n\n@param `sprod` The product of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lprod` List of **LONG** where each value is the product of y and an element in lx\n\n",signature:"x<NUMBER> y<NUMBER>  MULTIPLYEXACT  prod<LONG>\nlist<LIST<NUMBER>>  MULTIPLYEXACT  sprod<LONG>\nlx<LIST<NUMBER>> y<NUMBER>  MULTIPLYEXACT  lprod<LIST<LONG>>",tags:["math"],since:"1.2.23",OPB64name:"MULTIPLYEXACT"},MUSIGMA:{description:"The `MUSIGMA` function calculates the mean and the standard deviation of a Geo Time Series. It consumes two parameters from the top of the stack: a boolean \n(to choose if [Bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction) should be applied on the standard deviation) and a numeric GTS, and \nit pushes onto the stack its mean (mu) and its standard deviation (sigma).\n\n@param `bessel` True if apply a [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `sigma` Standard deviation\n\n@param `mu` Mean\n\n@param `gts` A single Geo Time Series\n\n",signature:"gts<GTS> bessel<BOOLEAN>  MUSIGMA  mu<DOUBLE> sigma<DOUBLE>",tags:["gts"],since:"1.0.0",OPB64name:"MUSIGMA"},MUTEX:{description:"Attempts to hold a named lock, creating it if needed, and execute a macro while holding the lock. When the macro execution terminates, either normally or with an error, the lock is released.\n\n@param `mutex` Name of lock to hold.\n\n@param `macro` Macro to execute while holding the lock.\n\n",signature:"macro<MACRO> mutex<STRING>  MUTEX ",tags:["extensions","stack"],since:"2.0.0",OPB64name:"MUTEX"},MVELEVATIONS:{description:"The `MVELEVATIONS` function extracts elevations from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVELEVATIONS` function will emit a list with two elements (a pair), the first element will be the elevation associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the elevations of the Multivariate value itself.\n\nIf a tick has no associated elevation, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted elevations.\n\n",signature:"input<GTSENCODER>  MVELEVATIONS  output<LIST>\ninput<GTS>  MVELEVATIONS  output<LIST>\nlinput<LIST>  MVELEVATIONS  output<LIST>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVELEVATIONS"},MVHHCODES:{description:"The `MVHHCODES` function extracts [`HHCodes`](https://en.wikipedia.org/wiki/HHCode) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVHHCODES` function will emit a list with two elements (a pair), the first element will be the HHCode associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the HHCodes of the Multivariate value itself.\n\nIf a tick has no associated location, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted HHCodes.\n\n",signature:"input<GTSENCODER>  MVHHCODES  output<LIST>\ninput<GTS>  MVHHCODES  output<LIST>\nlinput<LIST>  MVHHCODES  output<LIST>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVHHCODES"},MVINDEXSPLIT:{description:"The `MVINDEXSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVINDEXSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element index (first element being at index 0).\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:INDEX` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of indices or indices ranges can be specified to only produce encoders for the indices which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `indices` List of indices or indices ranges (list of two indices), used to restrict which indices to consider.\n\n@param `renaming` Map of index (LONG) to parameter to `RENAME`. If no entry is present for an index, `+:INDEX` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",signature:"input<GTSENCODER>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> indices<LIST>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> indices<LIST> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> indices<LIST>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> indices<LIST> renaming<MAP>  MVINDEXSPLIT  output<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTSENCODER>> indices<LIST>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTSENCODER>> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTSENCODER>> indices<LIST> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>> indices<LIST>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>\nlinput<LIST<GTS>> indices<LIST> renaming<MAP>  MVINDEXSPLIT  loutput<LIST<LIST<GTSENCODER>>>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVINDEXSPLIT"},MVLOCATIONS:{description:"The `MVLOCATIONS` function extracts location (latitude, longitude) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVLOCATIONS` function will emit a list with two elements (a pair), the first element will be the latitude and longitude (a list) associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the latitudes and longitudes of the Multivariate value itself.\n\nIf a tick has no associated location, `[ NaN NaN ]` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted locations.\n\n",signature:"input<GTSENCODER>  MVLOCATIONS  output<LIST>\ninput<GTS>  MVLOCATIONS  output<LIST>\nlinput<LIST>  MVLOCATIONS  output<LIST>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVLOCATIONS"},MVTICKS:{description:"The `MVTICKS` function extracts ticks from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVTICKS` function will emit a list with two elements (a pair), the first element will be the tick at which the Multivariate value was encountered, the second element will be a list containing the ticks of the Multivariate value itself.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted ticks.\n\n",signature:"input<GTSENCODER>  MVTICKS  output<LIST>\ninput<GTS>  MVTICKS  output<LIST>\nlinput<LIST>  MVTICKS  output<LIST>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKS"},MVTICKSPLIT:{description:"The `MVTICKSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVTICKSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element timestamp.\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:TIMESTAMP` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of timestamps or timestamp ranges can be specified to only produce encoders for the timestamps which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `timestamps` List of timestamps or timestamps ranges (list of two timestamps), used to restrict which timestamps to consider.\n\n@param `renaming` Map of timestamp (LONG) to parameter to `RENAME`. If no entry is present for a timestamp, `+:TIMESTAMP` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",signature:"input<GTSENCODER>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> timestamps<LIST>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTSENCODER> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> timestamps<LIST>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\ninput<GTS> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  output<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>> timestamps<LIST>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTSENCODER>> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>> timestamps<LIST>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>\nlinput<LIST<GTS>> timestamps<LIST> renaming<MAP>  MVTICKSPLIT  loutput<LIST<GTSENCODER>>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKSPLIT"},MVVALUES:{description:"The `MVVALUES` function extracts values from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted values.\n\n",signature:"input<GTSENCODER>  MVVALUES  output<LIST>\ninput<GTS>  MVVALUES  output<LIST>\nlinput<LIST>  MVVALUES  output<LIST>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVVALUES"},NAME:{description:"The `NAME` function consumes a Geo Time Series™ from the stack, extracts its class name, and pushes it onto the stack.\n\n@param `gts` Geo Time Series™\n\n@param `encoder` Geo Time Series™ Encoder\n\n@param `result` Class name\n\n",signature:"gts<GTS>  NAME  result<STRING>\nencoder<GTSENCODER>  NAME  result<STRING>",tags:["gts"],since:"1.0.0",OPB64name:"NAME"},NBOUNDS:{description:"The `NBOUNDS` function computes bounds defining a specified number of intervals which have the same area under the curve of a normal distribution with a given mean and standard deviation.\n\n@param `n` Number of desired intervals.\n\n@param `sigma` Positive standard deviation to use for the normal distribution.\n\n@param `mu` Mean to use for the normal distribution.\n\n@param `bounds` List of `n`-1 bounds defining the `n` intervals.\n\n",signature:"mu<NUMBER> sigma<NUMBER> n<LONG>  NBOUNDS  bounds<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"NBOUNDS"},NDEBUGON:{description:"Turns on stack debugging so up to the given number of stack levels will be returned in case of error. Stack debugging is off by default.\n\n@param `n` Maximum number of stack levels to return in case of error.\n\n",signature:"n<NUMBER>  NDEBUGON ",tags:["stack"],since:"1.0.0",OPB64name:"NDEBUGON"},NEGATEEXACT:{description:"The `NEGATEEXACT` function consumes one LONG from the top of the stack and puts back the negated value. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be negated\n\n@param `result` The negated value\n\n@param `lvalue` List of values to be negated\n\n@param `lresult` List of negated values\n\n",signature:"value<NUMBER>  NEGATEEXACT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  NEGATEEXACT  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.2.23",OPB64name:"NEGATEEXACT"},NEWENCODER:{description:"The `NEWENCODER` function creates an empty encoder and pushes it onto the stack. An encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` A newly created empty encoder instance.\n\n",signature:" NEWENCODER  encoder<GTSENCODER>",tags:["encoder","multivariate"],since:"1.2.9",OPB64name:"NEWENCODER"},NEWGTS:{description:"The `NEWGTS` function pushes onto the stack an empty Geo Time Series™ instance.\n\n@param `gts` A newly created empty GTS instance.\n\n",signature:" NEWGTS  gts<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"NEWGTS"},NEXTAFTER:{description:"The `NEXTAFTER` function consumes two numeric parameter from the top of the stack and pushes back the **DOUBLE** adjacent to the first argument in the direction of the second argument. In other words, the result is between *from* and *to* and adjacent to *from*.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `from` Starting value\n\n@param `to` Direction used to calculate the adjacent value\n\n@param `result` Next **DOUBLE** from *from* to *to*\n\n@param `lfrom` List of starting values\n\n@param `lto` List of directions used to calculate the adjacent value\n\n@param `lresult` List of next **DOUBLE** from *from* to *to*\n\n",signature:"from<NUMBER> to<NUMBER>  NEXTAFTER  result<DOUBLE>\nfrom<NUMBER> lto<LIST<NUMBER>>  NEXTAFTER  lresult<LIST<DOUBLE>>\nlfrom<LIST<NUMBER>> to<NUMBER>  NEXTAFTER  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"NEXTAFTER"},NEXTDOWN:{description:"The `NEXTDOWN` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of negative infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of negative infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of negative infinity\n\n",signature:"value<NUMBER>  NEXTDOWN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  NEXTDOWN  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.2.23",OPB64name:"NEXTDOWN"},NEXTUP:{description:"The `NEXTUP` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of positive infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of positive infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of positive infinity\n\n",signature:"value<NUMBER>  NEXTUP  result<DOUBLE>\nlvalue<LIST<NUMBER>>  NEXTUP  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"NEXTUP"},NOLOG:{description:"The `NOLOG` function resets java.util.logging.LogManager.\n\nIt can be useful to do this during developments and tests of an extension.\n\nThe `NOLOG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n",signature:" NOLOG ",tags:["extensions"],since:"1.2.19",OPB64name:"NOLOG"},NONEMPTY:{description:"Filter a list of Geo Time Series™ in order to retain only those that have at least one value.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `results` Filtered list of Geo Time Series™\n\n",signature:"gtsList<LIST<GTS>>  NONEMPTY  results<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"NONEMPTY"},NONNULL:{description:"The `NONNULL` function consumes a list and produces a list containing only the non NULL elements of the argument list.\n\n@param `list` The argument list to filter\n\n@param `nonnulls` A new list with only those elements from `list` which are not NULL\n\n",signature:"list<LIST>  NONNULL  nonnulls<LIST>",tags:["math","logic"],since:"1.2.7",OPB64name:"NONNULL"},NOOP:{description:"It does nothing.\n\nWhile it does not have a usefulness of its own, it can be used when generating code from within WarpScript code prior to executing it with [`EVAL`](/doc/EVAL).\n\n",signature:"",tags:["platform"],since:"1.0.0",OPB64name:"NOOP"},NORMALIZE:{description:"The `NORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between 0 and 1 (i.e. it replaces X by \n(X - min)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",signature:"gts<GTS>  NORMALIZE  result<GTS>\ngtsList<LIST<GTS>>  NORMALIZE  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"NORMALIZE"},NOT:{description:"Negates a boolean.\n\nThe `NOT` function is synonymous for [`!`](/doc/7F). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gts` A boolean Geo Time Series™\n\n@param `negatedgts` A boolean Geo Time Series™\n\n",signature:"input<BOOLEAN>  NOT  result<BOOLEAN>\ngts<GTS>  NOT  negatedgts<GTS>",tags:["logic"],since:"1.0.0",OPB64name:"NOT"},NOTAFTER:{description:"Checks that the current time is not after the provided timestamp.\n\nThe `NOTAFTER` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not after the provided timestamp.\nIf it is not after the WarpScript execution continues, otherwise it throws an exception.\n\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",signature:"timestamp<LONG>  NOTAFTER \ndate<STRING>  NOTAFTER ",tags:["date"],since:"1.0.0",OPB64name:"NOTAFTER"},NOTBEFORE:{description:"Checks that the current time is not before the provided timestamp.\n\nThe `NOTBEFORE` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not before the provided timestamp.\nIf it is not before the WarpScript execution continues, otherwise it throws an exception.\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",signature:"timestamp<LONG>  NOTBEFORE \ndate<STRING>  NOTBEFORE ",tags:["date"],since:"1.0.0",OPB64name:"NOTBEFORE"},NOTIMINGS:{description:"Use of the `NOTIMINGS` function disables the collection of timing information for each line of the input script. Use [`TIMINGS`](/doc/TIMINGS) to enable it again.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"NOTIMINGS"},NOW:{description:"The `NOW` function pushes onto the stack the current **LONG** timestamp expressed in the platform time unit. This timestamp is the number of platform time unit elapsed since 00:00:00 on 1 January 1970 UTC minus the number of leap seconds, see [Unix time](https://en.wikipedia.org/wiki/Unix_time).\n\nThis function is mostly linear with time but this property is violated when the OS resynchronises its clock (ie consecutive calls to `NOW` may 'jump' or 'go backward').\n\n@param `timestamp` The current timestamp in platform time unit.\n\n",signature:" NOW  timestamp<LONG>",tags:["date","time"],since:"1.0.0",OPB64name:"NOW"},NPDF:{description:"The `NPDF` function builds a function which outputs the probability of occurrence of a given value under a specified normal distribution.\n\nThe normal distribution is defined by its mean and standard deviation. The result of the `NPDF` function is itself a function which can be invoked via [`EVAL`](doc/EVAL).\n\n*NPDF* stands for Normal (Gaussian) distribution Probability Density Function.\n\n@param `sigma` Standard deviation of the normal distribution to consider.\n\n@param `mu` Mean of the normal distribution to consider.\n\n@param `npdf` Function which given an input number outputs the probability of its occurence under the given normal distribution.\n\n",signature:"mu<NUMBER> sigma<NUMBER>  NPDF  npdf<FUNCTION>",tags:["math"],since:"1.0.0",OPB64name:"NPDF"},NPEEK:{description:"Displays a given number of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of stack levels to display.\n\n",signature:"levels<NUMBER>  NPEEK ",tags:["stack"],since:"2.0.0",OPB64name:"NPEEK"},NRETURN:{description:"Immediately exit a certain number of macros being executed. The `NRETURN` function expects a number of levels on top of the stack.\n\n@param `levelnumber` Number of levels of macro to exit.\n\n",signature:"levelnumber<LONG>  NRETURN ",tags:["control"],since:"1.0.0",OPB64name:"NRETURN"},NSUMSUMSQ:{description:"Computes the cardinality, sum of values and sum of squared values of a Geo Time Series™. Pushes those results on the stack in the order they were mentioned.\n\nOnly numeric series are allowed.\n\n@param `square` Sum of squared values\n\n@param `sum` Sum of values\n\n@param `cardinality` Values count\n\n@param `gts` Geo Time Series™\n\n",signature:"gts<GTS>  NSUMSUMSQ  cardinality<LONG> sum<DOUBLE> square<DOUBLE>",tags:["gts"],since:"1.0.0",OPB64name:"NSUMSUMSQ"},NULL:{description:"The `NULL` function pushes the symbolic value *null* onto the stack.\n\n@param `result` Symbolic value *null*\n\n",signature:" NULL  result<NULL>",tags:["constants"],since:"1.0.0",OPB64name:"NULL"},NaN:{description:"Pushes the double value *NaN* (Not a Number) onto the stack.\n\n@param `result` Value *NaN*\n\n",signature:" NaN  result<DOUBLE>",tags:["constants"],since:"1.0.0",OPB64name:"NaN"},ONLYBUCKETS:{description:"Only retains ticks from Geo Time Series™ with timestamps which are bucket ends. If an input GTS is not bucketized, a clone of the GTS will be returned.\n\nThe `ONLYBUCKETS` function does not remove duplicate ticks, please consider using [`DEDUP`](/doc/DEDUP) for that purpose.\n\n@param `gts` Single instance of Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `result` Transformed GTS.\n\n@param `lresult` List of transformed GTS.\n\n",signature:"gts<GTS>  ONLYBUCKETS  result<GTS>\nlgts<LIST<GTS>>  ONLYBUCKETS  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"ONLYBUCKETS"},"OPB64->":{description:"Decode a String in order preserving base64 into a byte array.\n\nBytes array cannot be represented on the stack.\n\n@param `input` Any valid opbbase64 string.\n\n@param `output` Byte array of the input decoded input.\n\n",signature:"input<STRING>  OPB64->  output<BYTES>",tags:["conversion"],since:"1.0.7",OPB64name:"Ip01CYFhEV"},OPB64TOHEX:{description:"The OPB64TOHEX function decodes the order preserving base64 string on top of the stack and immediately re-encode it in hex string.\n\n\n@param `input` OPBase64 encoded string\n\n@param `output` hexadecimal representation\n\n",signature:"input<STRING>  OPB64TOHEX  output<STRING>",tags:["conversion"],since:"1.0.2",OPB64name:"OPB64TOHEX"},OPS:{description:"Pushes onto the stack the current number of operations which were performed by the WarpScript code execution.\n\n@param `ops` number of operations\n\n",signature:" OPS  ops<LONG>",tags:["platform"],since:"1.0.0",OPB64name:"OPS"},OPTDTW:{description:"The `OPTDTW` function finds the top subsequence matches in a sequence for a given query sequence. The function uses [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping)\nto assess the subsequence similarity with the query.\n\n@param `match` Number of top matches. Use 0 as the number of matches to return to return them all.\n\n@param `query` Query numerical sequence, thr shortest\n\n@param `data` Data sequence in which to find matches\n\n@param `result` List of matches, each match being a pair of (index, distance).\n\n",signature:"data<LIST> query<LIST> match<LONG>  OPTDTW  result<LIST>",tags:["math","distance"],since:"1.0.0",OPB64name:"OPTDTW"},OPTIMIZE:{description:"Optimizes the memory footprint of Geo Time Series™ and GTS Encoder instances.\n\n@param `ratio` Ratio of memory footprint to number of values, if this ratio is not exceeded, no optimization will take place. As a result, optimization is always done when ratio <= 1 or ratio is NaN.\n\n@param `gts` Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `encoder` Instance of GTS Encoder to optimize.\n\n@param `optencoder` Optimized version of the encoder, or the original instance if no optimization occurred.\n\n@param `lgts` List of Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `lencoder` List of instances of GTS Encoder to optimize.\n\n@param `loptencoder` List of optimized version of the encoders or the original instances if no optimization occurred.\n\n",signature:"gts<GTS> ratio<NUMBER>  OPTIMIZE  gts<GTS>\nencoder<GTSENCODER> ratio<NUMBER>  OPTIMIZE  optencoder<GTSENCODER>\nlgts<LIST<GTS>> ratio<NUMBER>  OPTIMIZE  lgts<LIST<GTS>>\nlencoder<LIST<GTSENCODER>> ratio<NUMBER>  OPTIMIZE  loptencoder<LIST<GTSENCODER>>",tags:["gts"],since:"1.2.9",OPB64name:"OPTIMIZE"},OR:{description:"The `OR` operator is a synonymous for [`||`](/doc/U6k).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `OR` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",signature:"p1<BOOLEAN> p2<BOOLEAN>  OR  result<BOOLEAN>\nl<LIST>  OR  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  OR  gtsresult<GTS>",tags:["operators","logic"],since:"1.0.0",OPB64name:"OR"},PACK:{description:"The `PACK` function packs a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n@param `input` List to pack\n\n@param `format` Format used to pack\n\n@param `result` Bytes array\n\n",signature:"input<LIST> format<STRING>  PACK  result<BYTES>",tags:["lists"],since:"1.0.7",OPB64name:"PACK"},PAPPLY:{description:"The `PAPPLY` function performs operations in a way identical to the [`APPLY`](/doc/APPLY) framework but produces a map of results keyed by the label map of each equivalence class.\n\nAs [`APPLY`](/doc/APPLY), `PAPPLY` provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can due. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` Map of resulting GTS, one per equivalence class, keyed with the equivalence class labels.\n\n@param `op` Operation to perform.\n\n",signature:"[ op<OPERATOR> labels<LIST> gts<LIST<GTS>+> ]  PAPPLY  result<MAP>",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"PAPPLY"},PARSE:{description:"The `PARSE` function parses an input **STRING** containing datapoints in the [Geo Time Series™ input format](/content/03_Documentation/03_Interacting_with_Warp_10/03_Ingesting_data/02_GTS_input_format) and pushes onto the stack the parsed Geo Time Series™.\n\n@param `data` Datapoints in the Geo Time Series™ input format\n\n@param `result` List of parsed Geo Time Series™\n\n",signature:"data<STRING>  PARSE  result<LIST<GTS>>",tags:["gts","strings"],since:"1.0.11",OPB64name:"PARSE"},PARSESELECTOR:{description:"The `PARSESELECTOR` function parses a GTS Selector (STRING) returnss the class selector and labels selectors.\n\nIn order for `PARSESELECTOR` to parse correctly a selector, the following characters MUST appear percent-encoded in the `STRING` to parse, the equal sign (`=`, `%3D`), the comma (`,` `%2C`) and closing curly brace (`}` `%7D`). Due to the way WarpScript parses `STRING` constants, the `%` sign MUST be percent-encoded (`%25`) in the `STRING` if it appears in WarpScript code:\n\nThe `STRING` `class{label=comm%2Cequal%3Dsign}` must appear in WarpScript as:\n\n```\n'class{label=comm%252Cequal%253Dsign'\n```\n\nCombined with `TOSELECTOR`, it can be used to build a selector from a subset of GTS.\n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature'\n  { 'sensorId' '=01' }\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\nFETCH\n\n```\nThis can be used to simplify the syntax of a FETCH or FIND request. \n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature{sensorId=01}' PARSESELECTOR\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\n\nFETCH\n```\n\n\n\n@param `selector` String selector.\n\n@param `labelselector` MAP of label selectors.\n\n@param `classselector` Class name selector.\n\n",signature:"selector<STRING>  PARSESELECTOR  classselector<STRING> labelselector<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"PARSESELECTOR"},PARSEVALUE:{description:"The `PARSEVALUE` function parses a STRING representing a valid value in the Geo Time Series™ input format.\n\nThe underlying implementation being the internal WarpScript function, some of the returned types might not be easily handled in the rest of the calling script. Most notably, some floating point representations might lead to BigDecimal instances being produced.\n\n@param `input` String representation of the value to parse.\n\n@param `value` Parsed value, could be a STRING, LONG, DOUBLE, BIGDECIMAL, BOOLEAN or BYTES elements.\n\n",signature:"input<STRING>  PARSEVALUE  value<ANY>",tags:["gts"],since:"2.1.0",OPB64name:"PARSEVALUE"},PARTITION:{description:"The `PARTITION` function splits a Geo Time Series™ list in equivalence classes based on label values.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels` plus all labels with common values among the GTS in the equivalence class.\n\n",signature:"lgts<LIST<GTS>> labels<LIST<STRING>>  PARTITION  result<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"PARTITION"},PATTERNDETECTION:{description:"The `PATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it\n\n@param `lresult` The list of result GTS\n\n",signature:"gts<GTS> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNDETECTION  result<GTS>\nlgts<LIST<GTS>> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNDETECTION  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNDETECTION"},PATTERNS:{description:"The `PATTERNS` function extracts symbolic patterns (or motifs) from a Geo Time Series™. Those patterns are similar to [iSAX](http://www.cs.ucr.edu/~eamonn/iSAX/iSAX.html) symbols.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNS` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",signature:"gts<GTS> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNS  result<GTS>\nlgts<LIST<GTS>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  PATTERNS  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNS"},PEEK:{description:"Displays the top of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:" PEEK ",tags:["stack"],since:"2.0.0",OPB64name:"PEEK"},PEEKN:{description:"Displays the content of the level of the stack at the given distance from the top.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `distance` Distance (in stack levels) between the top of the stack and the level to display.\n\n",signature:"distance<NUMBER>  PEEKN ",tags:["stack"],since:"2.0.0",OPB64name:"PEEKN"},PERMUTE:{description:"Permute the dimensions of a nested LIST as if it were a tensor or a multidimensional array.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent before operating. Default to false.\n\n@param `pattern` The permutation pattern (a LIST of LONG).\n\n@param `tensor` The resulting nested LIST.\n\n",signature:"tensor<LIST> pattern<LIST>  PERMUTE  tensor<LIST>\n{ tensor<LIST> pattern<LIST> fast<BOOLEAN>  } PERMUTE  tensor<LIST>",tags:["lists","tensors"],since:"2.1.0",OPB64name:"PERMUTE"},PFILTER:{description:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `PFILTER framework allows for advanced filtering using N-ary functions \n(functions which accept N parameters). Returned GTS are grouped by equivalence classes.\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A map keyed by the label set of each equivalence class whose values are lists of selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `PFILTER`.\n\n",signature:"[ gtsList<LIST<GTS>> labels<LIST<STRING>> filter<FILTER> ]  PFILTER  result<MAP>",tags:["framework","filter"],since:"1.0.0",OPB64name:"PFILTER"},PGraphics:{description:'Warp 10 includes a large subset of the [Processing](http://www.processing.org) drawing library. You can create and manipulate images, then push a base64 encoded png onto the stack.\n\n+ Step 1: create a processing graphic object with `PGraphics` function.\n+ Step 2: manipulate this object with Processing functions.\n+ Step 3: render the processing graphic with `Pencode` function.\n\nDocumentation of every function has a link to original Processing website. Original website includes more examples for each function.\n\nProcessing functions offers a lot of different signatures for colors. The most efficient is to keep the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n\nUp to Warp 10 1.2.18, antialiasing was not available. It is now available, by appending a digit to the **imgtype** string argument. The maximum anti-aliasing level is determined by the hardware of the machine that is running the software, so 2D4 and 2D8 mode will not work with every computer.\n\n+ "2D": no antialiasing\n+ "2D2": bilinear smoothing\n+ "2D3": bicubic smoothing\n+ "2D4": 4x antialiasing\n+ "2D8": 8x antialiasing\n\n\nYou can adjust the maximal number of pixel allowed in Warp 10 configuration file.\n\n@param `imgtype` \'2D\', \'3D\', or \'2Dx\', where x is the level of anti aliasing (2, 3, 4, or 8).\n\n@param `width` Pixel width of the image.\n\n@param `height` Pixel height of the image.\n\n@param `pg` Processing graphic object.\n\n',signature:"width<LONG> height<LONG> imgtype<STRING>  PGraphics  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PGraphics"},PI:{description:"Alias of [pi](/doc/R5Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",signature:" PI  pi<DOUBLE>",tags:["math","constants"],since:"1.0.0",OPB64name:"J3Z"},PICK:{description:"The `PICK` function copies on top of the stack the element at level N. Parameter N is consumed off the top of the stack when `PICK` is called.\n\n@param `level` Level of the stack\n\n@param `result` What is on stack at *level*\n\n",signature:"level<NUMBER>  PICK  result<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"PICK"},"PICKLE->":{description:"The `PICKLE->` function decodes some Pickle encoded content contained in a byte array.\nThe conversion is done using [Pyrolite v4](https://github.com/irmen/pickle).\n\nIt can read all pickle protocol versions (0 to 4, so this includes\nthe latest additions made in Python 3.4).\n\n```python\n>>> myobject={ 'apple':3.5,'banana':18 }\n>>> pickle.dumps(myobject).encode(\"hex\")\n'286470300a53276170706c65270a70310a46332e350a73532762616e616e61270a70320a4931380a732e'\n```\n\n@param `input` Byte array of a pickle encoded content\n\n@param `output` Warp 10 object\n\n",signature:"input<BYTES>  PICKLE->  output<ANY>",tags:["platform"],since:"1.0.7",OPB64name:"J3_2Hol4AIs"},PIGSCHEMA:{description:"The `PIGSCHEMA` function produces on top of the stack a STRING representing the [Pig](https://en.wikipedia.org/wiki/Pig_(programming_tool)) schema definition for the current stack content.\n\n@param `elt` Stack content.\n\n@param `schema` Schema for the current stack, usable when working with WarpScript in Pig.\n\n",signature:"elt<ANY*>  PIGSCHEMA  elt<ANY*> schema<STRING>",tags:["pig","stack"],since:"1.2.5",OPB64name:"PIGSCHEMA"},PIVOT:{description:"The `PIVOT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick of GTS from the first list, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n1// C3{C1=C} 2\n2// C4{C2=F} 30\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n4// C3{} 5\n4// C4{} 50\n```\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",signature:"input<LIST<GTS>> pivot<LIST<GTS>>  PIVOT  result<LIST<GTS>>",tags:["gts"],since:"2.2.0",OPB64name:"PIVOT"},PIVOTSTRICT:{description:"The `PIVOTSTRICT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™ in a way similar to what [`PIVOT`](/doc/PIVOT) does.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick common to Geo Time Series™ of both lists, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOTSTRICT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n```\n\nOnly ticks 0 and 3 appear in the result as those are the only ticks present in both `C1` and `C2`.\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",signature:"input<LIST<GTS>> pivot<LIST<GTS>>  PIVOTSTRICT  result<LIST<GTS>>",tags:["gts"],since:"2.2.0",OPB64name:"PIVOTSTRICT"},POPR:{description:"Pops a value from the top of the stack and stores it into the designated register.\n\nThe `POPR` function is really a family of functions named `POPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",signature:"value<ANY>  POPR ",tags:["stack"],since:"2.0.0",OPB64name:"POPR"},PREDUCE:{description:"Behaves as [`REDUCE`](/doc/REDUCE) but produces a map of results keyed by the label map of each equivalence class.\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` Map keyed by the label map of each equivalence class and whose values are the Geo Time Series™ produced for each class.\n\n",signature:"[ gts<LIST<GTS>+> labels<LIST<STRING>> reducer<AGGREGATOR> ]  PREDUCE  result<MAP>",tags:["reducer","framework"],since:"1.0.5",OPB64name:"PREDUCE"},PRNG:{description:"The `PRNG` function initializes the stack's seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator). This PRNG can later be used by the [`SRAND`](/doc/SRAND) function to produce random numbers in a deterministic way (!).\n\n@param `seed` The seed to use for initializing the PRNG.\n\n",signature:"seed<LONG>  PRNG ",tags:["math"],since:"1.2.9",OPB64name:"PRNG"},PROB:{description:"Computes probability for each value of the input Geo Time Series™.\n\nThe function `PROB` consumes a GTS or a list of the GTS from the top of the stack. It pushes back the probability for each value.\n\nThe probabilities are computed using the value histogram.\n\n@param `gts` The input Geo Time Series™\n\n@param `gtslist` The input list of Geo Time Series™\n\n@param `result` The Geo Time Series™ wit probability for each value\n\n@param `resultList` The List of Geo Time Series™ with probability for each value\n\n",signature:"gts<GTS>  PROB  result<GTS>\ngtslist<LIST<GTS>>  PROB  resultList<LIST<GTS>>",tags:["gts","statistics"],since:"1.0.6",OPB64name:"PROB"},PROBABILITY:{description:"Pushes on the stack a function which computes probabilities according to a provided value histogram.\n\nTo use the function pushed by `PROBABILITY` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function expects a value on top of the stack and will output the probability of occurrence of this value.\n\n",signature:"valueHistogram<MAP>  PROBABILITY  result<STRING>",tags:["math","statistics"],since:"1.0.0",OPB64name:"PROBABILITY"},PSTACK:{description:"When in interactive (REPL) mode, prints the content of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"",tags:["stack"],since:"2.0.0",OPB64name:"PSTACK"},PUSHR:{description:"Pushes onto the stack the value currently contained in the designated register.\n\nThe `PUSHR` function is really a family of functions named `PUSHRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value from the designated register.\n\n",signature:" PUSHR  value<ANY>",tags:["stack"],since:"2.0.0",OPB64name:"PUSHR"},PUT:{description:"The `PUT` function inserts a new key-value pair in a map.\nIf the key already exists in the input MAP, the value is replaced by the new one.\n\n`PUT` function puts the reference of the MAP on top of the stack.\n\n@param `newkey` Depending on map construction, could be a number, a string, a boolean\n\n@param `newvalue` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `inputmap` reference to the map to be modified\n\n@param `outputmap` copy of input map reference. Useful to chain other instructions on the same map.\n\n",signature:"inputmap<MAP> newvalue<ANY> newkey<ANY>  PUT  outputmap<MAP>",tags:["maps"],since:"1.0.0",OPB64name:"PUT"},Palpha:{description:"Extracts the alpha value from a color.\n\nThe `Palpha` function is easy to use and understand, but it is slower than bit shifting... \n\n\n[Link to original Processing doc](https://processing.org/reference/alpha_.html)\n\n@param `color` Any value of the color datatype\n\n@param `alpha` Alpha component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> color<NUMBER>  Palpha  pg<PGRAPHICS> alpha<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Palpha"},Parc:{description:"Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse defined by the **a**, **b**, **c**, and **d** parameters. The origin of the arc's ellipse may be changed with the [`PellipseMode`](/doc/PellipseMode) function. Use the **start** and **stop** parameters to specify the angles (in radians) at which to draw the arc.\n\n\n\nThere are three ways to draw an arc; the rendering technique used is defined by the optional seventh parameter. The three options, depicted in the examples, are PIE, OPEN, and CHORD. The default mode is the OPEN stroke with a PIE fill.\n\n\n\nIn some cases, the `Parc` function isn't accurate enough for smooth drawing. For example, the shape may jitter on screen when rotating slowly. If you're having an issue with how arcs are rendered, you'll need to draw the arc yourself with [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) or a **PShape**.\n\n\n[Link to original Processing doc](https://processing.org/reference/arc_.html)\n\n@param `b` y-coordinate of the arc's ellipse\n\n@param `a` x-coordinate of the arc's ellipse\n\n@param `c` width of the arc's ellipse by default\n\n@param `d` height of the arc's ellipse by default\n\n@param `start` angle to start the arc, specified in radians\n\n@param `stop` angle to stop the arc, specified in radians\n\n@param `mode` closing mode. either PIE, OPEN, or CHORD\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> start<DOUBLE> stop<DOUBLE>  Parc  pg<PGRAPHICS>\npg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> start<DOUBLE> stop<DOUBLE> mode<STRING>  Parc  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Parc"},Pbackground:{description:"The `Pbackground` function sets the color used for the background of the processing graphics object. \n\nAn image object can also be used as the background for a sketch, although the image's width and height must match that of the processing object. Images used with `Pbackground` will ignore the current [`Ptint`](/doc/Ptint) setting. \n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pbackground` calls internally [`Pcolor`](/doc/Pcolor).\n\n\n[Link to original Processing doc](https://processing.org/reference/background_.html)\n\n@param `argb` any argb color value.\n\n@param `rgb` any rgb color value.\n\n@param `alpha` opacity of the background. 0 = transparent, 255 = opaque.\n\n@param `gray` a value between white (255) and black (0)\n\n@param `image` PImage to set as background (must be same size as pg)\n\n@param `v1` red or hue value (depending on the current color mode)\n\n@param `v2` green or saturation value (depending on the current color mode)\n\n@param `v3` blue or brightness value (depending on the current color mode)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> argb<LONG>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> image<PIMAGE>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> rgb<LONG> alpha<NUMBER>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE> alpha<NUMBER>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Pbackground  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Pbackground  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pbackground"},PbeginContour:{description:"Use the `PbeginContour` and [`PendContour`](/doc/PendContour) function to create negative shapes within shapes such as the center of the letter 'O'. `PbeginContour` begins recording vertices for the shape and [`PendContour`](/doc/PendContour) stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\n\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a `PbeginContour`/[`PendContour`](/doc/PendContour) pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginContour_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PbeginContour  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PbeginContour"},PbeginShape:{description:"Using the `PbeginShape` and [`PendShape`](/doc/PendShape) functions allow creating more complex forms. `PbeginShape` begins recording vertices for a shape and [`PendShape`](/doc/PendShape) stops recording. \n\nThe value of the **kind** parameter tells it which types of shapes to create from the provided vertices. The parameters available for beginShape() are POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the `PbeginShape` function, a series of [`Pvertex`](/doc/Pvertex) commands must follow. To stop drawing the shape, call [`PendShape`](/doc/PendShape). The [`Pvertex`](/doc/Pvertex) function with two parameters specifies a position in 2D. Each shape will be outlined with the current stroke color and filled with the fill color. \n\n\nTransformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within `PbeginShape`. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within `PbeginShape`. \n\n\nThe P2D and P3D renderers allow [`Pstroke`](/doc/Pstroke) and [`Pfill`](/doc/Pfill) to be altered on a per-vertex group basis. Settings such as [`PstrokeWeight`](/doc/PstrokeWeight), [`PstrokeCap`](/doc/PstrokeCap), and [`PstrokeJoin`](/doc/PstrokeJoin) cannot be changed while inside a `PbeginShape`/[`PendShape`](/doc/PendShape) block with any renderer.\n\nUp to Warp 10 1.2.18, `PbeginShape` could be called without the **kind** parameter. It defaults to POLYGON.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginShape_.html)\n\n@param `kind` Either POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> kind<STRING>  PbeginShape  pg<PGRAPHICS>\npg<PGRAPHICS>  PbeginShape  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PbeginShape"},Pbezier:{description:"Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezier_.html)\n\n@param `x1` coordinates for the first anchor point\n\n@param `y1` coordinates for the first anchor point\n\n@param `z1` coordinates for the first anchor point\n\n@param `x2` coordinates for the first control point\n\n@param `y2` coordinates for the first control point\n\n@param `z2` coordinates for the first control point\n\n@param `x3` coordinates for the second control point\n\n@param `y3` coordinates for the second control point\n\n@param `z3` coordinates for the second control point\n\n@param `x4` coordinates for the second anchor point\n\n@param `y4` coordinates for the second anchor point\n\n@param `z4` coordinates for the second anchor point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  Pbezier  pg<PGRAPHICS>\npg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> z1<DOUBLE> x2<DOUBLE> y2<DOUBLE> z2<DOUBLE> x3<DOUBLE> y3<DOUBLE> z3<DOUBLE> x4<DOUBLE> y4<DOUBLE> z4<DOUBLE>  Pbezier  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pbezier"},PbezierDetail:{description:"Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the **P3D** renderer; the default **P2D** renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierDetail_.html)\n\n@param `detail` resolution of the curves\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> detail<NUMBER>  PbezierDetail  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PbezierDetail"},PbezierPoint:{description:"Evaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierPoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PbezierPoint  pg<PGRAPHICS> out<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PbezierPoint"},PbezierTangent:{description:"Calculates the tangent of a point on a Bezier curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PbezierTangent  pg<PGRAPHICS> out<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PbezierTangent"},PbezierVertex:{description:"Specifies vertex coordinates for Bezier curves. Each call to `PbezierVertex` defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PbezierVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only with POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/bezierVertex_.html)\n\n@param `x2` The x-coordinate of the 1st control point\n\n@param `y2` The y-coordinate of the 1st control point\n\n@param `x3` The x-coordinate of the 2nd control point\n\n@param `y3` The y-coordinate of the 2nd control point\n\n@param `x4` The x-coordinate of the anchor point\n\n@param `y4` The y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  PbezierVertex  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PbezierVertex"},Pblend:{description:"Blends a region of pixels from one image into another (or in itself again) with full alpha channel support.\n\nHere are the available modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n\n+ BLEND - linear interpolation of colours: C = A*factor + B\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - Multiply the colors, result will always be darker.\n+ SCREEN - Opposite multiply, uses inverse values of the colors.\n+ OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values,and screens light values.\n+ HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n+ SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n+ DODGE - Lightens light tones and increases contrast, ignores darks.Called \"Color Dodge\" in Illustrator and Photoshop.\n+ BURN - Darker areas are applied, increasing contrast, ignores lights.Called \"Color Burn\" in Illustrator and Photoshop.\n\nAll modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the **src** parameter is not used, the display window is used as the source image.\n\n[Link to original Processing doc](https://processing.org/reference/blend_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `mode` Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> src<PIMAGE> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG> mode<STRING>  Pblend  pg<PGRAPHICS>\npg<PGRAPHICS> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG> mode<STRING>  Pblend  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pblend"},PblendMode:{description:"Blends the pixels in the display window according to a defined mode. \n\nHere are the available modes to blend the source pixels (A) with the ones of pixels already in the display window (B). \n\n+ BLEND - linear interpolation of colours: C = A*factor + B. This is the default blending mode.\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - multiply the colors, result will always be darker.\n+ SCREEN - opposite multiply, uses inverse values of the colors.\n+ REPLACE - the pixels entirely replace the others and don't utilize alpha (transparency) values\n\nA pixel's final color is the result of applying one of the above blend modes with each channel of (A) and (B) independently. For example, red is compared with red, green with green, and blue with blue.\n\nWe recommend using `PblendMode` and not the previous [`Pblend`](/doc/Pblend) function. However, unlike [`Pblend`](/doc/Pblend), the `PblendMode` function does not support the following: HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN. On older hardware, the LIGHTEST, DARKEST, and DIFFERENCE modes might not be available as well. \n\n[Link to original Processing doc](https://processing.org/reference/blendMode_.html)\n\n@param `mode` The blending mode to use\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PblendMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PblendMode"},Pblue:{description:"Extracts the blue value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pblue` function is easy to use and understand, but it is slower than bit masking. \n\n\n[Link to original Processing doc](https://processing.org/reference/blue_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `blue` Blue component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> rgb<NUMBER>  Pblue  pg<PGRAPHICS> blue<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pblue"},Pbox:{description:"A box is an extruded rectangle. A box with equal dimensions on all sides is a cube.\n\n\n[Link to original Processing doc](https://processing.org/reference/box_.html)\n\n@param `size` dimension of the box in all dimensions (creates a cube)\n\n@param `w` dimension of the box in the x-dimension\n\n@param `h` dimension of the box in the y-dimension\n\n@param `d` dimension of the box in the z-dimension\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> size<NUMBER>  Pbox  pg<PGRAPHICS>\npg<PGRAPHICS> w<NUMBER> h<NUMBER> d<NUMBER>  Pbox  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pbox"},Pbrightness:{description:"Extracts the brightness value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/brightness_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `brightness` Brightness component of input color\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> rgb<NUMBER>  Pbrightness  pg<PGRAPHICS> brightness<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pbrightness"},Pclear:{description:"Clears the pixels. This function clears everything in a **PGraphics** object to make all of the pixels 100% transparent.\n\n\n[Link to original Processing doc](https://processing.org/reference/clear_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  Pclear  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pclear"},Pclip:{description:"Limits the rendering to the boundaries of a rectangle defined by the parameters. The boundaries are drawn based on the state of the [`PimageMode`](/doc/PimageMode) function, either CORNER, CORNERS, or CENTER. \n\n\n[Link to original Processing doc](https://processing.org/reference/clip_.html)\n\n@param `a` x-coordinate of the rectangle, by default\n\n@param `b` y-coordinate of the rectangle, by default\n\n@param `c` width of the rectangle, by default\n\n@param `d` height of the rectangle, by default\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Pclip  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pclip"},Pcolor:{description:"`Pcolor` creates colors for storing in ARGB LONG datatype.\n\n+ RGB: The most efficient is to skip Pcolor function, using the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n+ HSB: For Hue Saturation Brightness to RGB conversion, use [`PcolorMode`](/doc/PcolorMode) to specify HSB, then use Pcolor to convert to ARGB.\n\nThe parameters are interpreted as RGB or HSB values depending on the current [`PcolorMode`](/doc/PcolorMode). The default mode is RGB values from 0 to 255.\n\nNote that if only one value is provided to `Pcolor`, it will be interpreted as a grayscale value. Add a second value, and it will be used for alpha transparency. When three values are specified, they are interpreted as either RGB or HSB values. Adding a fourth value applies alpha transparency.\n\n\n[Link to original Processing doc](https://processing.org/reference/color_.html)\n\n@param `gray` int: number specifying value between white and black\n\n@param `alpha` float, or int: relative to current color range\n\n@param `v1` float, or int: red or hue values relative to the current color range\n\n@param `v2` float, or int: green or saturation values relative to the current color range\n\n@param `v3` float, or int: blue or brightness values relative to the current color range\n\n@param `color` ARGB color.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> gray<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> gray<NUMBER> alpha<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Pcolor  pg<PGRAPHICS> color<LONG>",tags:["processing"],since:"1.0.0",OPB64name:"Pcolor"},PcolorMode:{description:"Changes the way Processing interprets color data. By default, the parameters for [`Pfill`](/doc/Pfill), [`Pstroke`](/doc/Pstroke), [`Pbackground`](/doc/Pbackground), and [`Pcolor`](/doc/Pcolor) are defined by values between 0 and 255 using the RGB color model. The `PcolorMode` function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling **colorMode(RGB, 1.0)** will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters **max**, **max1**, **max2**, **max3**, and **maxA**.\n\nWhen using max different from default values, do not work with grayscale.\n\nAfter changing the range of values for colors with code like **colorMode(HSB, 360, 100, 100)**, those ranges remain in use until they are explicitly changed again. For example, after running **colorMode(HSB, 360, 100, 100)** and then changing back to **colorMode(RGB)**, the range for R will be 0 to 360 and the range for G and B will be 0 to 100. To avoid this, be explicit about the ranges when changing the color mode. For instance, instead of **colorMode(RGB)**, write **colorMode(RGB, 255, 255, 255)**. \n\n\n[Link to original Processing doc](https://processing.org/reference/colorMode_.html)\n\n@param `mode` Either 'RGB' or 'HSB', corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n\n@param `max` range for all color elements\n\n@param `max1` range for the red or hue depending on the current color mode\n\n@param `max2` range for the green or saturation depending on the current color mode\n\n@param `max3` range for the blue or brightness depending on the current color mode\n\n@param `maxA` range for the alpha\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PcolorMode  pg<PGRAPHICS>\npg<PGRAPHICS> mode<STRING> max<DOUBLE>  PcolorMode  pg<PGRAPHICS>\npg<PGRAPHICS> mode<STRING> max1<DOUBLE> max2<DOUBLE> max3<DOUBLE>  PcolorMode  pg<PGRAPHICS>\npg<PGRAPHICS> mode<STRING> max1<DOUBLE> max2<DOUBLE> max3<DOUBLE> maxA<DOUBLE>  PcolorMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PcolorMode"},Pconstrain:{description:"Constrains a value to not exceed a maximum and minimum value. Also known as clamping a value. \n\nIt could be done with warpscript MIN MAX functions, see example.\n\n[Link to original Processing doc](https://processing.org/reference/constrain_.html)\n\n@param `x` The value to clamp.\n\n@param `low` Minimum limit.\n\n@param `high` Maximum limit.\n\n@param `clamped` Clamped value of x in [low high] range.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x<DOUBLE> low<DOUBLE> high<DOUBLE>  Pconstrain  pg<PGRAPHICS> clamped<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pconstrain"},Pcopy:{description:"Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an image used as the **src** parameter into the display window. If the source and destination regions are not the same size, it will automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/copy_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `img` PIMAGE object, copy of pg\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> src<PIMAGE> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG>  Pcopy  pg<PGRAPHICS>\npg<PGRAPHICS> sx<LONG> sy<LONG> sw<LONG> sh<LONG> dx<LONG> dy<LONG> dw<LONG> dh<LONG>  Pcopy  pg<PGRAPHICS>\npg<PGRAPHICS>  Pcopy  pg<PGRAPHICS> img<PIMAGE>",tags:["processing"],since:"1.0.0",OPB64name:"Pcopy"},PcreateFont:{description:"Dynamically converts a font to the format used by Processing from a font that is installed on the computer.  Not all fonts can be used and some might work with one operating system and not others.\n\nThe **size** parameter states the font size you want to generate. The **smooth** parameter specifies if the font should be antialiased or not.\n\nSince the 2.5.0 version, the name of the font can be a URI to a OpenType or Type1 font which will be resolved by a macro defined by the `processing.font.resolver` configuration.\n\n[Link to original Processing doc](https://processing.org/reference/createFont_.html)\n\n@param `name` Name of the font to load or URI from where to load the font.\n\n@param `size` Point size of the font\n\n@param `smooth` True for an antialiased font, false for aliased\n\n@param `charset` subset of ascii characters to be generated.\n\n@param `font` Processing font object compatible with PtextFont.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> name<STRING>  PcreateFont  pg<PGRAPHICS> font<PFONT>\npg<PGRAPHICS> name<STRING> size<NUMBER>  PcreateFont  pg<PGRAPHICS> font<PFONT>\npg<PGRAPHICS> name<STRING> size<NUMBER> smooth<BOOLEAN>  PcreateFont  pg<PGRAPHICS> font<PFONT>\npg<PGRAPHICS> name<STRING> size<NUMBER> smooth<BOOLEAN> charset<STRING>  PcreateFont  pg<PGRAPHICS> font<PFONT>",tags:["processing"],since:"1.0.0",OPB64name:"PcreateFont"},Pcurve:{description:"Draws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of `Pcurve` functions together or using [`PcurveVertex`](/doc/PcurveVertex). An additional function called [`PcurveTightness`](/doc/PcurveTightness) provides control for the visual quality of the curve. The `Pcurve` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n[Link to original Processing doc](https://processing.org/reference/curve_.html)\n\n@param `x1` float: coordinates for the beginning control point\n\n@param `y1` float: coordinates for the beginning control point\n\n@param `x2` float: coordinates for the first point\n\n@param `y2` float: coordinates for the first point\n\n@param `x3` float: coordinates for the second point\n\n@param `y3` float: coordinates for the second point\n\n@param `x4` float: coordinates for the ending control point\n\n@param `y4` float: coordinates for the ending control point\n\n@param `z1` float: coordinates for the beginning control point\n\n@param `z2` float: coordinates for the first point\n\n@param `z3` float: coordinates for the second point\n\n@param `z4` float: coordinates for the ending control point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  Pcurve  pg<PGRAPHICS>\npg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> z1<DOUBLE> x2<DOUBLE> y2<DOUBLE> z2<DOUBLE> x3<DOUBLE> y3<DOUBLE> z3<DOUBLE> x4<DOUBLE> y4<DOUBLE> z4<DOUBLE>  Pcurve  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pcurve"},PcurveDetail:{description:"Sets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveDetail_.html)\n\n@param `detail` Resolution of the curves\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> detail<NUMBER>  PcurveDetail  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PcurveDetail"},PcurvePoint:{description:"Evaluates the curve at point **t** for points **a**, **b**, **c**, **d**. The parameter **t** may range from 0 (the start of the curve) and 1 (the end of the curve). **a** and **d** are points on the curve, and **b** and **c** are the control points. This can be used once with the **x** coordinates and a second time with the **y** coordinates to get the location of a curve at **t**.\n\n\n[Link to original Processing doc](https://processing.org/reference/curvePoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of second point on the curve\n\n@param `c` coordinate of third point on the curve\n\n@param `d` coordinate of fourth point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PcurvePoint  pg<PGRAPHICS> out<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PcurvePoint"},PcurveTangent:{description:"Calculates the tangent of a point on a curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE> t<DOUBLE>  PcurveTangent  pg<PGRAPHICS> out<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTangent"},PcurveTightness:{description:"Modifies the quality of forms created with [`Pcurve`](/doc/Pcurve) and [`PcurveVertex`](/doc/PcurveVertex). The parameter **tightness** determines how the curve fits to the vertex points. The value 0.0 is the default value for **tightness** (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTightness_.html)\n\n@param `tightness` Amount of deformation from the original vertices\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> tightness<NUMBER>  PcurveTightness  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTightness"},PcurveVertex:{description:"Specifies vertex coordinates for curves. This function may only be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). The first and last points in a series of `PcurveVertex` lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with `PcurveVertex` will draw the curve between the second, third, and fourth points. The `PcurveVertex` function is an implementation of Catmull-Rom splines. \n\n[Link to original Processing doc](https://processing.org/reference/curveVertex_.html)\n\n@param `x` The x-coordinate of the vertex\n\n@param `y` The y-coordinate of the vertex\n\n@param `z` The z-coordinate of the vertex\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  PcurveVertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  PcurveVertex  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PcurveVertex"},Pdecode:{description:"`Pdecode` takes the image representation on the stack and pushes a Pimage object on the stack. This object can only be used as an input for [`Pset`](/doc/Pset), [`Pimage`](/doc/Pimage), [`Pbackground`](/doc/Pbackground).\n\nInput string must start with the header `data:image/png;base64,`.\n\nSupported input types: PNG, GIF, JPG.\n\n@param `img` Processing Pimage object.\n\n@param `rawimg` Image bytes.\n\n@param `b64img` Base64 encoded image string\n\n",signature:"b64img<STRING>  Pdecode  img<PIMAGE>\nrawimg<BYTES>  Pdecode  img<PIMAGE>",tags:["processing"],since:"1.0.0",OPB64name:"Pdecode"},Pdist:{description:"Calculates the distance between two points, in 2D or 3D space.\n\n\n[Link to original Processing doc](https://processing.org/reference/dist_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `z1` z-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> z1<DOUBLE> x2<DOUBLE> y2<DOUBLE> z2<DOUBLE>  Pdist  pg<PGRAPHICS>\npg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE>  Pdist  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pdist"},Pellipse:{description:"Draws an ellipse (oval) to the screen. An ellipse with equal width and height is a circle. By default, the first two parameters set the location, and the third and fourth parameters set the shape's width and height. The origin may be changed with the [`PellipseMode`](/doc/PellipseMode) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/ellipse_.html)\n\n@param `a` float: x-coordinate of the ellipse\n\n@param `b` float: y-coordinate of the ellipse\n\n@param `c` float: width of the ellipse by default\n\n@param `d` float: height of the ellipse by default\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Pellipse  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pellipse"},PellipseMode:{description:"Modifies the location from which ellipses are drawn by changing the way in which parameters given to [`Pellipse`](/doc/Pellipse) are intepreted.\n\nThe default mode is **ellipseMode(CENTER)**, which interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**ellipseMode(RADIUS)** also uses the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, but uses the third and fourth parameters to specify half of the shapes's width and height.\n\n**ellipseMode(CORNER)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**ellipseMode(CORNERS)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the location of one corner of the ellipse's bounding box, and the third and fourth parameters as the location of the opposite corner.\n\n[Link to original Processing doc](https://processing.org/reference/ellipseMode_.html)\n\n@param `mode` Either CENTER, RADIUS, CORNER, or CORNERS\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PellipseMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PellipseMode"},Pencode:{description:"`Pencode` function takes a processing graphic object on the top of the stack, render it to a png file, encode it in base64, prefix the result with the standard png header \"data:image/png;base64,\".\n\nThe resulting string is ready to use in an html document.\n\n@param `pg` Processing graphic object.\n\n@param `b64img` Base64 encoded image string, ready to use in an html page.\n\n@param `metadata` Map of metadata to add to the PNG. Accepted keys are 'tEXt', 'zTXt' and 'iTXt', while values are lists of maps with 'keyword' and 'text' keys.\n\n",signature:"pg<PGRAPHICS>  Pencode  b64img<STRING>\npg<PGRAPHICS> metadata<MAP>  Pencode  b64img<STRING>",tags:["processing"],since:"1.0.0",OPB64name:"Pencode"},PendContour:{description:"Use the [`PbeginContour`](/doc/PbeginContour) and `PendContour` function to create negative shapes within shapes such as the center of the letter 'O'. [`PbeginContour`](/doc/PbeginContour) begins recording vertices for the shape and `PendContour` stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a [`PbeginContour`](/doc/PbeginContour)/`PendContour` pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n[Link to original Processing doc](https://processing.org/reference/endContour_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PendContour  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PendContour"},PendShape:{description:"The `PendShape` function is the companion to [`PbeginShape`](/doc/PbeginShape) and may only be called after [`PbeginShape`](/doc/PbeginShape). When `Pendshape` is called, all of image data defined since the previous call to [`PbeginShape`](/doc/PbeginShape) is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end). \n\nUp to Warp 10 1.2.18, `PendShape` could be called without the **mode** parameter. It defaults to OPEN.\n\n[Link to original Processing doc](https://processing.org/reference/endShape_.html)\n\n@param `mode` Use CLOSE to close the shape, OPEN otherwise.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PendShape  pg<PGRAPHICS>\npg<PGRAPHICS>  PendShape  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PendShape"},Pfill:{description:'Sets the color used to fill shapes. For example, if you run **fill(204, 102, 0)**, all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current [`PcolorMode`](/doc/PcolorMode). The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\nThe value for the "gray" parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\nTo change the color of an image or a texture, use [`Ptint`](/doc/Ptint).\n\n[Link to original Processing doc](https://processing.org/reference/fill_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n',signature:"pg<PGRAPHICS> argb<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> gray<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> argb<LONG> alpha<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> v1<LONG> v2<LONG> v3<LONG>  Pfill  pg<PGRAPHICS>\npg<PGRAPHICS> v1<LONG> v2<LONG> v3<LONG> alpha<LONG>  Pfill  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pfill"},Pfilter:{description:"Filters the display window using a preset filter or with a custom shader. Using a shader with `Pfilter` is much faster than without. Shaders require the P2D or P3D renderer in size().\n\n\nThe presets options are:\n\n+ **THRESHOLD** Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The parameter must be between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n+ **GRAY** Converts any colors in the image to grayscale equivalents. No parameter is used.\n+ **OPAQUE** Sets the alpha channel to entirely opaque. No parameter is used.\n+ **INVERT** Sets each pixel to its inverse value. No parameter is used.\n+ **POSTERIZE** Limits each channel of the image to the number of colors specified as the parameter. The parameter can be set to values between 2 and 255, but results are most noticeable in the lower ranges.\n+ **BLUR** Executes a Guassian blur with the level parameter specifying the extent of the blurring. If no parameter is used, the blur is equivalent to Guassian blur of radius 1. Larger values increase the blur.\n+ **ERODE** Reduces the light areas. No parameter is used.\n+ **DILATE** Increases the light areas. No parameter is used.\n\n\n[Link to original Processing doc](https://processing.org/reference/filter_.html)\n\n@param `kind` Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE\n\n@param `param` unique for each, see above\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> kind<STRING>  Pfilter  pg<PGRAPHICS>\npg<PGRAPHICS> kind<STRING> param<DOUBLE>  Pfilter  pg<PGRAPHICS>",tags:["processing"],since:"1.2.17",OPB64name:"J5OdQ6G_RV"},Pget:{description:"Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned (same as `Pcopy`). Use the **x** and **y** parameters to get the value of one pixel. Get a section of the display window by specifying additional **w** and **h** parameters. When getting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\nIf the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with **colorMode(HSB)**, the numbers returned will be in RGB format.\n\nGetting the color of a single pixel with **get(x, y)** is easy, but not as fast as grabbing the data directly from [`Ppixels`](/doc/Ppixels).\n\n[Link to original Processing doc](https://processing.org/reference/get_.html)\n\n@param `x` int: x-coordinate of the pixel\n\n@param `y` int: y-coordinate of the pixel\n\n@param `w` int: width of pixel rectangle to get\n\n@param `h` int: height of pixel rectangle to get\n\n@param `img` PIMAGE object\n\n@param `color` Color of the pixel, 32bits ARGB format.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  Pget  pg<PGRAPHICS> img<PIMAGE>\npg<PGRAPHICS> x<NUMBER> y<NUMBER>  Pget  pg<PGRAPHICS> color<LONG>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> w<NUMBER> h<NUMBER>  Pget  pg<PGRAPHICS> img<PIMAGE>",tags:["processing"],since:"1.0.0",OPB64name:"Pget"},Pgreen:{description:"Extracts the green value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pgreen` function is easy to use and understand, but it is slower than bit shifting. \n\n\n[Link to original Processing doc](https://processing.org/reference/green_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `green` Green component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> rgb<NUMBER>  Pgreen  pg<PGRAPHICS> green<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pgreen"},Phue:{description:"Extracts the hue value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/hue_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `hue` Hue component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> rgb<NUMBER>  Phue  pg<PGRAPHICS> hue<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Phue"},Pimage:{description:"The `Pimage` function draws a Pimage (see [`Pdecode`](/doc/Pdecode)) on a PGraphic object.\n\nThe **img** parameter specifies the image to display and by default the **a** and **b** parameters define the location of its upper-left corner. The image is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PimageMode`](/doc/PimageMode) function can be used to change the way these parameters draw the image.\n\nThe color of an image may be modified with the [`Ptint`](/doc/Ptint) function. This function will maintain transparency for GIF and PNG images.\n\n[Link to original Processing doc](https://processing.org/reference/image_.html)\n\n@param `img` PImage: the image to display\n\n@param `a` float: x-coordinate of the image by default\n\n@param `b` float: y-coordinate of the image by default\n\n@param `c` float: width to display the image by default\n\n@param `d` float: height to display the image by default\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> img<PIMAGE> a<NUMBER> b<NUMBER>  Pimage  pg<PGRAPHICS>\npg<PGRAPHICS> img<PIMAGE> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Pimage  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pimage"},PimageMode:{description:"Modifies the location from which images are drawn by changing the way in which parameters given to [`Pimage`](/doc/Pimage) are intepreted.\n\nThe default mode is **imageMode(CORNER)**, which interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the upper-left corner of the image. If two additional parameters are specified, they are used to set the image's width and height.\n\n**imageMode(CENTER)** interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the image's center point. If two additional parameters are specified, they are used to set the image's width and height.\n\n\n[Link to original Processing doc](https://processing.org/reference/imageMode_.html)\n\n@param `mode` could be CORNER or CENTER\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PimageMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PimageMode"},Plerp:{description:"Calculates a number between two numbers at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for creating motion along a straight path and for drawing dotted lines, or any linear interpolation.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerp_.html)\n\n@param `start` first value\n\n@param `stop` second value\n\n@param `amt` float between 0.0 and 1.0\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> start<NUMBER> stop<NUMBER> amt<NUMBER>  Plerp  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Plerp"},PlerpColor:{description:"Calculates a color between two colors at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 is equal to the first point, 0.1 is very near the first point, 0.5 is halfway in between, etc. \n\nAn amount below 0 will be treated as 0. Likewise, amounts above 1 will be capped at 1. This is different from the behavior of `Plerp`, but necessary because otherwise numbers outside the range will produce strange and unexpected colors.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerpColor_.html)\n\n@param `c1` interpolate from this color\n\n@param `c2` interpolate to this color\n\n@param `amt` between 0.0 and 1.0\n\n@param `outcolor` the interpolated result\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> c1<NUMBER> c2<NUMBER> amt<NUMBER>  PlerpColor  pg<PGRAPHICS> outcolor<LONG>",tags:["processing"],since:"1.0.0",OPB64name:"PlerpColor"},Pline:{description:"Draws a line (a direct path between two points) to the screen. The version of `Pline` with four parameters draws the line in 2D.  To color a line, use the [`Pstroke`](/doc/Pstroke) function. A line cannot be filled, therefore the [`Pfill`](/doc/Pfill) function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the [`PstrokeWeight`](/doc/PstrokeWeight) function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the **z** parameter requires the P3D parameter.\n\n\n[Link to original Processing doc](https://processing.org/reference/line_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z1` z-coordinate of the first point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x1<NUMBER> y1<NUMBER> x2<NUMBER> y2<NUMBER>  Pline  pg<PGRAPHICS>\npg<PGRAPHICS> x1<NUMBER> y1<NUMBER> z1<NUMBER> x2<NUMBER> y2<NUMBER> z2<NUMBER>  Pline  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pline"},PloadShape:{description:"`PloadShape` can load a [SVG image](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) and return a PSHAPE object. WarpScript does not support [OBJ files](https://en.wikipedia.org/wiki/Wavefront_.obj_file) yet. \n\nThis feature is experimental, some files may render empty. \n\n@param `svg` A one line or a multiline SVG string.\n\n@param `Pshape` A PSHAPE object which can be used with Pshape.\n\n",signature:"svg<STRING>  PloadShape  Pshape<PSHAPE>",tags:["processing"],since:"1.2.18",OPB64name:"PloadShape"},Pmag:{description:'Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly used in computer graphics and linear algebra. Because it has no "start" position, the magnitude of a vector can be thought of as the distance from the coordinate 0,0 to its x,y value. Therefore, `Pmag` is a shortcut for writing **0 0 x y Pdist**. It is exactly the same as warpscript function [`HYPOT`](/doc/HYPOT).\n\n3D is not yet supported.\n\n[Link to original Processing doc](https://processing.org/reference/mag_.html)\n\n@param `a` first value\n\n@param `b` second value\n\n@param `mag` result\n\n@param `pg` Processing graphic object\n\n',signature:"pg<PGRAPHICS> a<NUMBER> b<NUMBER>  Pmag  pg<PGRAPHICS> mag<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pmag"},Pmap:{description:"Re-maps a number from one range to another.\n\nIn the first example, the number 25 is converted from a value in the range of 0 to 100 into a value that ranges from the left edge of the window (0) to the right edge (width).\n\n\nAs shown in the second example, numbers outside of the range are not clamped to the minimum and maximum parameters values, because out-of-range values are often intentional and useful.\n\n\n[Link to original Processing doc](https://processing.org/reference/map_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start1` lower bound of the value's current range\n\n@param `stop1` upper bound of the value's current range\n\n@param `start2` lower bound of the value's target range\n\n@param `stop2` upper bound of the value's target range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> value<DOUBLE> start1<DOUBLE> stop1<DOUBLE> start2<DOUBLE> stop2<DOUBLE>  Pmap  pg<PGRAPHICS> output<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pmap"},Pmask:{description:"The `Pmask` function copies the blue channel of an image to the alpha channel of an other.\n\nAs **PGRAPHICS** intances are alse **PIMAGE** instances, you can use this fonction with **PGRAPHICS**.\n\n@param `orginal_img` PImage to be masked\n\n@param `mask_image` Pimage to serve as mask\n\n@param `masked_image` Masked Pimage\n\n@param `orginal_grp` PGraphics to be masked\n\n@param `mask_grp` PGraphics to serve as mask\n\n@param `masked_grp` Masked PGraphics\n\n",signature:"mask_image<PIMAGE> orginal_img<PIMAGE>  Pmask  masked_image<PIMAGE>\nmask_image<PIMAGE> orginal_grp<PGRAPHICS>  Pmask  masked_grp<PGRAPHICS>\nmask_grp<PGRAPHICS> orginal_img<PIMAGE>  Pmask  masked_image<PIMAGE>\nmask_grp<PGRAPHICS> orginal_grp<PGRAPHICS>  Pmask  masked_grp<PGRAPHICS>",tags:["processing"],since:"2.7.0",OPB64name:"Pmask"},PnoClip:{description:"Disables the clipping previously started by the [`Pclip`](/doc/Pclip) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/noClip_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PnoClip  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PnoClip"},PnoFill:{description:"Disables filling geometry. If both [`PnoStroke`](/doc/PnoStroke) and `PnoFill` are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noFill_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PnoFill  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PnoFill"},PnoStroke:{description:"Disables drawing the stroke (outline). If both `PnoStroke` and [`PnoFill`](/doc/PnoFill) are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noStroke_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PnoStroke  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PnoStroke"},PnoTint:{description:"Removes the current fill value for displaying images and reverts to displaying images with their original hues.\n\n\n[Link to original Processing doc](https://processing.org/reference/noTint_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PnoTint  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PnoTint"},Pnorm:{description:"Normalizes a number from another range into a value between 0 and 1. Identical to `value low high 0 1 Pmap`.\n\nNumbers outside of the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. \n\n\n[Link to original Processing doc](https://processing.org/reference/norm_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start` lower bound of the value's current range\n\n@param `stop` upper bound of the value's current range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> value<NUMBER> start<NUMBER> stop<NUMBER>  Pnorm  pg<PGRAPHICS> output<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pnorm"},Ppixels:{description:"Returns an array containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. After **pixels** has been modified, the [`PupdatePixels`](/doc/PupdatePixels) function must be run to update the content of the display window.\n\n\n[Link to original Processing doc](https://processing.org/reference/pixels.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",signature:"pg<PGRAPHICS>  Ppixels  pg<PGRAPHICS> pixels<LIST<LONG>>\nimg<PIMAGE>  Ppixels  img<PIMAGE> pixels<LIST<LONG>>",tags:["processing"],since:"1.0.0",OPB64name:"Ppixels"},Ppoint:{description:"Draws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point.\n\nUse [`Pstroke`](/doc/Pstroke) to set the color of a `Ppoint`.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight.\n\n\n[Link to original Processing doc](https://processing.org/reference/point_.html)\n\n@param `x` x-coordinate of the point\n\n@param `y` y-coordinate of the point\n\n@param `z` z-coordinate of the point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  Ppoint  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  Ppoint  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Ppoint"},PpopMatrix:{description:"Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The [`PpushMatrix`](/doc/PpushMatrix) function saves the current coordinate system to the stack and `PpopMatrix` restores the prior coordinate system. [`PpushMatrix`](/doc/PpushMatrix) and `PpopMatrix` are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/popMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PpopMatrix  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PpopMatrix"},PpopStyle:{description:"The [`PpushStyle`](/doc/PpushStyle) function saves the current style settings and `PpopStyle` restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with [`PpushStyle`](/doc/PpushStyle), it builds on the current style information. The [`PpushStyle`](/doc/PpushStyle) and `PpopStyle` functions can be nested to provide more control (see example for a demonstration.)\n\n\n[Link to original Processing doc](https://processing.org/reference/popStyle_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PpopStyle  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PpopStyle"},PpushMatrix:{description:"Pushes the current transformation matrix onto the matrix stack. Understanding `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) requires understanding the concept of a matrix stack. The `PpushMatrix` function saves the current coordinate system to the stack and [`PpopMatrix`](/doc/PpopMatrix) restores the prior coordinate system. `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PpushMatrix  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PpushMatrix"},PpushStyle:{description:"The `PpushStyle` function saves the current style settings and [`PpopStyle`](/doc/PpopStyle) restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `PpushStyle`, it builds on the current style information. The `PpushStyle` and [`PpopStyle`](/doc/PpopStyle) functions can be nested to provide more control. (See example for a demonstration.)\n\n\nThe style information controlled by the following functions are included in the style:fill, stroke, tint, strokeWeight, strokeCap, strokeJoin, imageMode, rectMode, ellipseMode, shapeMode, colorMode, textAlign, textFont, textMode, textSize, textLeading, emissive, specular, shininess, ambient.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushStyle_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PpushStyle  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PpushStyle"},Pquad:{description:"A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n\n\n[Link to original Processing doc](https://processing.org/reference/quad_.html)\n\n@param `x1` float: x-coordinate of the first corner\n\n@param `y1` float: y-coordinate of the first corner\n\n@param `x2` float: x-coordinate of the second corner\n\n@param `y2` float: y-coordinate of the second corner\n\n@param `x3` float: x-coordinate of the third corner\n\n@param `y3` float: y-coordinate of the third corner\n\n@param `x4` float: x-coordinate of the fourth corner\n\n@param `y4` float: y-coordinate of the fourth corner\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE> x4<DOUBLE> y4<DOUBLE>  Pquad  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pquad"},PquadraticVertex:{description:"Specifies vertex coordinates for quadratic Bezier curves. Each call to `PquadraticVertex` defines the position of one control point and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PquadraticVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when there is no MODE parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/quadraticVertex_.html)\n\n@param `cx` the x-coordinate of the control point\n\n@param `cy` the y-coordinate of the control point\n\n@param `x3` the x-coordinate of the anchor point\n\n@param `y3` the y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> cx<DOUBLE> cy<DOUBLE> x3<DOUBLE> y3<DOUBLE>  PquadraticVertex  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PquadraticVertex"},Prect:{description:"Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. The way these parameters are interpreted, however, may be changed with the [`PrectMode`](/doc/PrectMode) function.\n\n\n\nTo draw a rounded rectangle, add a fifth parameter, which is used as the radius value for all four corners.\n\n\n\nTo use a different radius value for each corner, include eight parameters. When using eight parameters, the latter four set the radius of the arc at each corner separately, starting with the top-left corner and moving clockwise around the rectangle.\n\n\n[Link to original Processing doc](https://processing.org/reference/rect_.html)\n\n@param `a` float: x-coordinate of the rectangle by default\n\n@param `b` float: y-coordinate of the rectangle by default\n\n@param `c` float: width of the rectangle by default\n\n@param `d` float: height of the rectangle by default\n\n@param `r` float: radii for all four corners\n\n@param `tl` float: radius for top-left corner\n\n@param `tr` float: radius for top-right corner\n\n@param `br` float: radius for bottom-right corner\n\n@param `bl` float: radius for bottom-left corner\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER>  Prect  pg<PGRAPHICS>\npg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER> r<NUMBER>  Prect  pg<PGRAPHICS>\npg<PGRAPHICS> a<NUMBER> b<NUMBER> c<NUMBER> d<NUMBER> tl<NUMBER> tr<NUMBER> br<NUMBER> bl<NUMBER>  Prect  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Prect"},PrectMode:{description:"Modifies the location from which rectangles are drawn by changing the way in which parameters given to [`Prect`](/doc/Prect) are intepreted.\n\nThe default mode is **CORNER**, which interprets the first two parameters of [`Prect`](/doc/Prect) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**CORNERS** interprets the first two parameters of [`Prect`](/doc/Prect) as the location of one corner, and the third and fourth parameters as the location of the opposite corner.\n\n**CENTER** interprets the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**RADIUS** also uses the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, but uses the third and fourth parameters to specify half of the shape's width and height.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n\n[Link to original Processing doc](https://processing.org/reference/rectMode_.html)\n\n@param `mode` either CORNER, CORNERS, CENTER, or RADIUS\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PrectMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PrectMode"},Pred:{description:"Extracts the red value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pred` function is easy to use and understand, but it is slower than bit shifting. \n\n[Link to original Processing doc](https://processing.org/reference/red_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `red` Red component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> rgb<NUMBER>  Pred  pg<PGRAPHICS> red<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Pred"},PresetMatrix:{description:"Replaces the current matrix with the identity matrix. \n\n\n[Link to original Processing doc](https://processing.org/reference/resetMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PresetMatrix  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PresetMatrix"},Protate:{description:"Rotates the amount specified by the **angle** parameter. Angles must be specified in radians (values from **0** to **2 PI**). \n\nThe coordinates are always rotated around their relative position to the origin. Positive numbers rotate objects in a clockwise direction and negative numbers rotate in the couterclockwise direction. Transformations apply to everything that happens afterward, and subsequent calls to the function compound the effect. For example, calling `pi 2.0 / Protate` once and then calling `pi 2.0 / Protate` a second time is the same as a single `pi Protate`. \n \n\nTechnically, `Protate` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/rotate_.html)\n\n@param `angle` angle of rotation specified in radians\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> angle<NUMBER>  Protate  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Protate"},Psaturation:{description:"Extracts the saturation value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/saturation_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `saturation` Saturation component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> rgb<NUMBER>  Psaturation  pg<PGRAPHICS> saturation<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"Psaturation"},Pscale:{description:"Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call `2.0 Pscale` increases the dimension of a shape by 200%.\n\n\n\nTransformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling `2.0 Pscale` and then `1.5 Pscale` is the same as `3.0 Pscale`. This function can be further controlled with [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/scale_.html)\n\n@param `s` percentage to scale the object\n\n@param `x` percentage to scale the object in the x-axis\n\n@param `y` percentage to scale the object in the y-axis\n\n@param `z` percentage to scale the object in the z-axis\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> s<NUMBER>  Pscale  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER>  Pscale  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  Pscale  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pscale"},Pset:{description:"Changes the color of any pixel, or writes an image directly to the display window.\n\n\n\nThe **x** and **y** parameters specify the pixel to change and the **c** parameter specifies the color value. The **c** parameter is interpreted according to the current color mode.  (The default color mode is RGB values from 0 to 255.)  When setting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\n\n\nSetting the color of a single pixel with **set(x, y)** is easy, but not as fast as putting the data directly into the list of pixels returned by  [`Ppixels`](/doc/Ppixels).\n\n\n[Link to original Processing doc](https://processing.org/reference/set_.html)\n\n@param `x` X-coordinate of the pixel\n\n@param `y` Y-coordinate of the pixel\n\n@param `c` Any value of the color datatype\n\n@param `img` Image to copy into the original image\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x<NUMBER> y<NUMBER> c<NUMBER>  Pset  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> img<PIMAGE>  Pset  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pset"},Pshape:{description:"Draws shapes to the display window. Shapes must be loaded with [`PloadShape`](/doc/PloadShape). Processing currently works with SVG, OBJ, and custom-created shapes. WrapScript only support SVG. The **shape** parameter specifies the shape to display and the coordinate parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PshapeMode`](/doc/PshapeMode) function can be used to change the way these parameters are interpreted.\n\n\n[Link to original Processing doc](https://processing.org/reference/shape_.html)\n\n@param `shape` the shape to display\n\n@param `x` x-coordinate of the shape\n\n@param `y` y-coordinate of the shape\n\n@param `a` x-coordinate of the shape\n\n@param `b` y-coordinate of the shape\n\n@param `c` width to display the shape\n\n@param `d` height to display the shape\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> shape<PSHAPE>  Pshape  pg<PGRAPHICS>\npg<PGRAPHICS> shape<PSHAPE> x<DOUBLE> y<DOUBLE>  Pshape  pg<PGRAPHICS>\npg<PGRAPHICS> shape<PSHAPE> a<DOUBLE> b<DOUBLE> c<DOUBLE> d<DOUBLE>  Pshape  pg<PGRAPHICS>",tags:["processing"],since:"1.2.18",OPB64name:"Pshape"},PshapeMode:{description:"Modifies the location from which shapes draw. The default mode is **shapeMode(CORNER)**, which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. The syntax **shapeMode(CORNERS)** uses the first and second parameters of [`Pshape`](/doc/Pshape) to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax **shapeMode(CENTER)** draws the shape from its center point and uses the third and forth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. \n\n\n[Link to original Processing doc](https://processing.org/reference/shapeMode_.html)\n\n@param `mode` int: either CORNER, CORNERS, CENTER\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PshapeMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PshapeMode"},PshearX:{description:"Shears a shape around the x-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearX` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearX_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> angle<NUMBER>  PshearX  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PshearX"},PshearY:{description:"Shears a shape around the y-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearY` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearY_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> angle<NUMBER>  PshearY  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PshearY"},Psize:{description:"The `Psize` function returns the pixel `width` and `height` of a Pimage or PGraphics object.\n\n@param `img` PImage instance to measure.\n\n@param `pg` PGraphics instance to measure.\n\n@param `height` Object height in pixels.\n\n@param `width` Object height in pixels.\n\n",signature:"img<PIMAGE>  Psize  width<LONG> height<LONG>\npg<PGRAPHICS>  Psize  width<LONG> height<LONG>",tags:["processing"],since:"2.6.0",OPB64name:"Psize"},Psphere:{description:"A sphere is a hollow ball made from tessellated triangles.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphere_.html)\n\n@param `r` the radius of the sphere\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> r<NUMBER>  Psphere  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Psphere"},PsphereDetail:{description:"Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you are going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until `PsphereDetail` is called again with a new parameter and so should **not** be called prior to every [`Psphere`](/doc/Psphere) statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphereDetail_.html)\n\n@param `res` int: number of segments (minimum 3) used per full circle revolution\n\n@param `ures` int: number of segments used longitudinally per full circle revolutoin\n\n@param `vres` int: number of segments used latitudinally from top to bottom\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> res<NUMBER>  PsphereDetail  pg<PGRAPHICS>\npg<PGRAPHICS> ures<NUMBER> vres<NUMBER>  PsphereDetail  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PsphereDetail"},Pstroke:{description:"Sets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current **colorMode** The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n[Link to original Processing doc](https://processing.org/reference/stroke_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> argb<LONG>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> argb<LONG> alpha<DOUBLE>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> gray<DOUBLE> alpha<DOUBLE>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Pstroke  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Pstroke  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pstroke"},PstrokeCap:{description:"Sets the style for rendering line endings. These ends are either squared, extended, or rounded, each of which specified with the corresponding parameters: SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n\n\n[Link to original Processing doc](https://processing.org/reference/strokeCap_.html)\n\n@param `cap` Either SQUARE, PROJECT, or ROUND\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> cap<STRING>  PstrokeCap  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeCap"},PstrokeJoin:{description:"Sets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER. \n\n\n[Link to original Processing doc](https://processing.org/reference/strokeJoin_.html)\n\n@param `join` Either MITER, BEVEL, ROUND\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> join<STRING>  PstrokeJoin  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeJoin"},PstrokeWeight:{description:"Sets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight. See [`Ppoint`](/doc/Ppoint) example.\n\n[Link to original Processing doc](https://processing.org/reference/strokeWeight_.html)\n\n@param `weight` The weight (in pixels) of the stroke.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> weight<NUMBER>  PstrokeWeight  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeWeight"},Ptext:{description:"Draws text to the screen. Displays the information specified in the first parameter on the screen in the position specified by the additional parameters. A default font will be used unless a font is set with the [`PtextFont`](/doc/PtextFont) function and a default size will be used unless a font is set with [`PtextSize`](/doc/PtextSize). Change the color of the text with the [`Pfill`](/doc/Pfill) function. The text displays in relation to the [`PtextAlign`](/doc/PtextAlign) function, which gives the option to draw to the left, right, and center of the coordinates.\n\n\n\nThe **x2** and **y2** parameters define a rectangular area to display within and may only be used with string data. When these parameters are specified, they are interpreted based on the current [`PrectMode`](/doc/PrectMode) setting. Text that does not fit completely within the rectangle specified will not be drawn to the screen.\n\n\n\nNote that Processing now lets you call `Ptext` without first specifying a PFont with [`PtextFont`](/doc/PtextFont). In that case, a generic sans-serif font will be used instead.\n\n\n[Link to original Processing doc](https://processing.org/reference/text_.html)\n\n@param `s` the string to be displayed\n\n@param `x` by default, x-coordinate of text\n\n@param `y` by default, y-coordinate of text\n\n@param `x1` by default, the x-coordinate of text, see PrectMode for more info\n\n@param `y1` by default, the y-coordinate of text, see PrectMode for more info\n\n@param `x2` by default, the width of the text box, see PrectMode for more info\n\n@param `y2` by default, the height of the text box, see PrectMode for more info\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> s<STRING> x<DOUBLE> y<DOUBLE>  Ptext  pg<PGRAPHICS>\npg<PGRAPHICS> s<STRING> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE>  Ptext  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Ptext"},PtextAlign:{description:"Sets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the **x** and **y** parameters of the [`Ptext`](/doc/Ptext) function.\n\n\n\nAn optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current [`PtextDescent`](/doc/PtextDescent). For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.\n\n\n\nWhen using [`Ptext`](/doc/Ptext) with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)\n\n\n\nThe vertical alignment is based on the value of [`PtextAscent`](/doc/PtextAscent), which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of [`PtextAscent`](/doc/PtextAscent) or [`PtextDescent`](/doc/PtextDescent) so that the hack works even if you change the size of the font.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAlign_.html)\n\n@param `alignX` Horizontal alignment, either LEFT, CENTER, or RIGHT\n\n@param `alignY` Vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> alignX<STRING>  PtextAlign  pg<PGRAPHICS>\npg<PGRAPHICS> alignX<STRING> alignY<STRING>  PtextAlign  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PtextAlign"},PtextAscent:{description:"Returns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the `PtextAscent` and [`PtextDescent`](/doc/PtextDescent) values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAscent_.html)\n\n@param `ascent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PtextAscent  pg<PGRAPHICS> ascent<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PtextAscent"},PtextDescent:{description:"Returns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the [`PtextAscent`](/doc/PtextAscent) and `PtextDescent` values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textDescent_.html)\n\n@param `descent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS>  PtextDescent  pg<PGRAPHICS> descent<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PtextDescent"},PtextFont:{description:"Sets the current font that will be drawn with the [`Ptext`](/doc/Ptext) function. Fonts must be created for Processing with [`PcreateFont`](/doc/PcreateFont) before they can be used. The font set through `PtextFont` will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/textFont_.html)\n\n@param `font` Any variable of the type PFont\n\n@param `size` the size of the letters in pixel.\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> font<PFONT>  PtextFont  pg<PGRAPHICS>\npg<PGRAPHICS> font<PFONT> size<NUMBER>  PtextFont  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PtextFont"},PtextLeading:{description:"Sets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.  Note, however, that the leading is reset by [`PtextSize`](/doc/PtextSize). For example, if the leading is set to 20 with `20 PtextLeading`, then if `48 PtextSize` is run at a later point, the leading will be reset to the default for the text size of 48.\n\n\n[Link to original Processing doc](https://processing.org/reference/textLeading_.html)\n\n@param `leading` The size in pixels for spacing between lines\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> leading<NUMBER>  PtextLeading  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PtextLeading"},PtextMode:{description:"Sets the way text draws to the screen, either as texture maps or as vector geometry. The default **textMode(MODEL)**, uses textures to render the fonts. The **textMode(SHAPE)** mode draws text using the glyph outlines of individual characters rather than as textures. This mode is only supported with the **PDF** and **P3D** renderer settings. With the **PDF** renderer, you must call **textMode(SHAPE)** before any other drawing occurs. If the outlines are not available, then **textMode(SHAPE)** will be ignored and **textMode(MODEL)** will be used instead.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/textMode_.html)\n\n@param `mode` int: either MODEL or SHAPE\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> mode<STRING>  PtextMode  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PtextMode"},PtextSize:{description:"Sets the current font size. This size will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function. Font size is measured in units of pixels.\n\n\n[Link to original Processing doc](https://processing.org/reference/textSize_.html)\n\n@param `size` float: the size of the letters in units of pixels\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> size<NUMBER>  PtextSize  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"PtextSize"},PtextWidth:{description:"Calculates and returns the width of any character or text string.\n\n\n[Link to original Processing doc](https://processing.org/reference/textWidth_.html)\n\n@param `str` The String of characters to measure\n\n@param `w` The width of the input string\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> str<STRING>  PtextWidth  pg<PGRAPHICS> w<DOUBLE>",tags:["processing"],since:"1.0.0",OPB64name:"PtextWidth"},Ptint:{description:"Sets the fill value for displaying images. Images can be tinted to specified colors or made transparent by including an alpha value.\n\n\n\nTo apply transparency to an image without affecting its color, use white as the tint color and specify an alpha value. For instance, **tint(255, 128)** will make an image 50pc transparent (assuming the default alpha range of 0-255, which can be changed with [`PcolorMode`](/doc/PcolorMode)).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/tint_.html)\n\n@param `argb` any argb color value.\n\n@param `alpha` opacity of the image\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> argb<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> gray<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> argb<NUMBER> alpha<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER>  Ptint  pg<PGRAPHICS>\npg<PGRAPHICS> v1<NUMBER> v2<NUMBER> v3<NUMBER> alpha<NUMBER>  Ptint  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Ptint"},PtoImage:{description:"The `PtoImage` function transforms a `PGRAPHICS` to a `PIMAGE`.\n\nThe `PGRAPHICS` can still be used after the transformation as this function copies the pixel values. This is equivalent to `Pencode Pdecode` but it is a lot faster.\n\n@param `pg` Processing graphic object.\n\n@param `img` Processing Pimage object.\n\n",signature:"pg<PGRAPHICS>  PtoImage  img<PIMAGE>",tags:["processing"],since:"2.1.0",OPB64name:"PtoImage"},Ptranslate:{description:"Specifies an amount to displace objects within the display window. The **x** parameter specifies left/right translation, the **y** parameter specifies up/down translation.\n\n\n\nTransformations are cumulative and apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling **50 0 Ptranslate** and then **20 0 Ptranslate** is the same as **70 0 Ptranslate**. This function can be further controlled by using [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/translate_.html)\n\n@param `x` left/right translation\n\n@param `y` up/down translation\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  Ptranslate  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Ptranslate"},Ptriangle:{description:"A triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point. \n\n\n[Link to original Processing doc](https://processing.org/reference/triangle_.html)\n\n@param `x1` float: x-coordinate of the first point\n\n@param `y1` float: y-coordinate of the first point\n\n@param `x2` float: x-coordinate of the second point\n\n@param `y2` float: y-coordinate of the second point\n\n@param `x3` float: x-coordinate of the third point\n\n@param `y3` float: y-coordinate of the third point\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x1<DOUBLE> y1<DOUBLE> x2<DOUBLE> y2<DOUBLE> x3<DOUBLE> y3<DOUBLE>  Ptriangle  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Ptriangle"},PupdatePixels:{description:"Updates the display window with the data in the **pixels[]** array. Use in conjunction with [`Ppixels`](/doc/Ppixels). If you are only reading pixels from the array, there's no need to call `PupdatePixels` - updating is only necessary to apply changes.\n\n[Link to original Processing doc](https://processing.org/reference/updatePixels_.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",signature:"pg<PGRAPHICS> pixels<LIST<LONG>>  PupdatePixels  pg<PGRAPHICS>\nimg<PIMAGE> pixels<LIST<LONG>>  PupdatePixels  img<PIMAGE>",tags:["processing"],since:"1.0.0",OPB64name:"PupdatePixels"},Pvertex:{description:"All shapes are constructed by connecting a series of vertices. `Pvertex` is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons. It is used exclusively within the [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/vertex_.html)\n\n@param `x` x-coordinate of the vertex\n\n@param `y` y-coordinate of the vertex\n\n@param `z` float: z-coordinate of the vertex\n\n@param `u` float: horizontal coordinate for the texture mapping\n\n@param `v` float: vertical coordinate for the texture mapping\n\n@param `pg` Processing graphic object\n\n",signature:"pg<PGRAPHICS> x<NUMBER> y<NUMBER>  Pvertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER>  Pvertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> u<NUMBER> v<NUMBER>  Pvertex  pg<PGRAPHICS>\npg<PGRAPHICS> x<NUMBER> y<NUMBER> z<NUMBER> u<NUMBER> v<NUMBER>  Pvertex  pg<PGRAPHICS>",tags:["processing"],since:"1.0.0",OPB64name:"Pvertex"},"Q->":{description:"The `Q->` function consumes on the stack a [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long and push back the quaternion into\n4 doubles (w, x, y, z, with z being on top).\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `input` Quaternion representation\n\n",signature:"input<LONG>  Q->  w<DOUBLE> x<DOUBLE> y<DOUBLE> z<DOUBLE>",tags:["quaternions"],since:"1.0.0",OPB64name:"JHoy"},QCONJUGATE:{description:"The `QCONJUGATE` function performs a [conjugation](https://en.wikipedia.org/wiki/Quaternion#Conjugation,_the_norm,_and_reciprocal) of a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the quaternion conjugate into a long.\n\n@param `quaternion` The input quaternion\n\n@param `result` The conjugated quaternion\n\n",signature:"quaternion<LONG>  QCONJUGATE  result<LONG>",tags:["quaternions"],since:"1.0.0",OPB64name:"QCONJUGATE"},QDIVIDE:{description:"The `QDIVIDE` function divides a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of dividing them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from division *q* by *r*\n\n",signature:"q<LONG> r<LONG>  QDIVIDE  result<LONG>",tags:["quaternions"],since:"1.0.0",OPB64name:"QDIVIDE"},QMULTIPLY:{description:"The `QMULTIPLY` function multiplies a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of multiplying them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from multiplication *q* by *r*\n\n",signature:"q<LONG> r<LONG>  QMULTIPLY  result<LONG>",tags:["quaternions"],since:"1.0.0",OPB64name:"QMULTIPLY"},QROTATE:{description:"Rotates a vector by a [quaternion](https://en.wikipedia.org/wiki/Quaternion).\n\nThe `QROTATE` function consumes on the top of the stack three doubles representing a vector(x, y, z) and a long representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the vector rotated into 3 doubles (x, y, z with z being on top).\n\n@param `quaternion` The quaternion used to rotate the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",signature:"x<DOUBLE> y<DOUBLE> z<DOUBLE> quaternion<LONG>  QROTATE  x<DOUBLE> y<DOUBLE> z<DOUBLE>",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATE"},QROTATION:{description:"The `QROTATION` extracts the axis and angle of the rotation represented by the [quaternion](https://en.wikipedia.org/wiki/Quaternion) on the stack.\n\n@param `quaternion` The input quaternion\n\n@param `angle` The angle of rotation\n\n@param `x` The X axis\n\n@param `y` The Y axis\n\n@param `z` The Z axis\n\n",signature:"quaternion<LONG>  QROTATION  x<DOUBLE> y<DOUBLE> z<DOUBLE> angle<DOUBLE>",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATION"},QUANTIZE:{description:'The `QUANTIZE` function produces a quantized version of a Geo Time Series™ by replacing each value with a value from a finite list according to the interval the original value falls in. This function only works on numeric Geo Time Series™.\nThis function can help to "discretify" data before calling [`VALUEHISTOGRAM`](/doc/VALUEHISTOGRAM).\nThe list of intervals is defined as: [-∞,bounds<sub>0</sub>], (bounds<sub>0</sub>,bounds_<sub>1</sub>], (bounds<sub>1</sub>,bounds<sub>2</sub>], ..., (bounds<sub>n-1</sub>,+∞]\n\n@param `values` List of `n+1` values, one for each interval defined by `bounds`. If empty, the list `[ `0` `1` ... `n+1` ]` will be used.\n\n@param `bounds` Sorted list of `n` finite bounds defining `n+1` intervals.\n\n@param `gts` Geo Time Series™ to quantize.\n\n@param `qgts` Quantized GTS.\n\n@param `lgts` List of Geo Time Series™ to quantize.\n\n@param `lqgts` List of quantized GTS.\n\n',signature:"gts<GTS> bounds<LIST<DOUBLE>> values<LIST>  QUANTIZE  qgts<GTS>\nlgts<LIST<GTS>> bounds<LIST<DOUBLE>> values<LIST>  QUANTIZE  lqgts<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"QUANTIZE"},RAND:{description:"The `RAND` function pushes onto the stack a random floating point number between 0.0 (inclusive) and 1.0 (exlusive) generated by the default random generator.\n\nThis generation is cryptographically secure.\n\n@param `num` Generated random number between 0 and 1.\n\n",signature:" RAND  num<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"RAND"},RANDOM:{description:"The `RANDOM` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThis function is very similar to [SRAND](/doc/SRAND) except the seed is choosen pseudorandomly when the function is first called. Subsequent calls use the same generator.\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",signature:" RANDOM  num<DOUBLE>",tags:["math"],since:"1.2.23",OPB64name:"RANDOM"},RANDPDF:{description:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe result if a function pushed onto the stack. This function does not have any arguments.\n\nTo use the function pushed by `RANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",signature:"valueHistogram<MAP>  RANDPDF  result<STRING>",tags:["math","statistics"],since:"1.0.7",OPB64name:"RANDPDF"},RANGE:{description:"`RANGE` pushes onto the stack a list of integers in the given range [start included, end excluded[. If start is not in the parameter list, start=0.\n\n`RANGE` also accepts a step parameter in the parameter list.\n\n\n@param `start` The start of range, default is 0\n\n@param `end` The end of range\n\n@param `step` The step between integers, default is 1\n\n@param `output` The list of every integers in the range [start end[\n\n",signature:"[ end<LONG> ]  RANGE  output<LIST<LONG>>\n[ start<LONG> end<LONG> ]  RANGE  output<LIST<LONG>>\n[ start<LONG> end<LONG> step<LONG> ]  RANGE  output<LIST<LONG>>",tags:["counters"],since:"1.0.0",OPB64name:"RANGE"},RANGECOMPACT:{description:"The `RANGECOMPACT` simplifies a Geo Time Series™ by simplifying ranges of identical values (with identical latitude, longitude and elevation), retaining only the first and last ticks of each range.\n\n@param `gts` Geo Time Series™ to compact.\n\n@param `compacted` Compacted GTS.\n\n@param `lgts` List of Geo Time Series™ to compact.\n\n@param `lcompacted` List of compacted GTS.\n\n",signature:"gts<GTS>  RANGECOMPACT  compacted<GTS>\nlgts<LIST<GTS>>  RANGECOMPACT  lcompacted<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"RANGECOMPACT"},RAWDTW:{description:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe computation is performed on the raw Geo Time Series™, no transformation is applied to them.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",signature:"gts1<GTS> gts2<GTS> threshold<DOUBLE>  RAWDTW  dtw<DOUBLE>",tags:["gts","distance"],since:"1.2.11",OPB64name:"RAWDTW"},REDEFS:{description:"The `REDEFS` function allows or disallows execution of redefined functions.\n\n@param `flag` Shall we allow or disallow the execution of redefined functions.\n\n",signature:"flag<BOOLEAN>  REDEFS ",tags:["stack"],since:"1.2.5",OPB64name:"REDEFS"},REDUCE:{description:"The `REDUCE` framework groups Geo Time Series™ by equivalence classes based on label values and applies a function on each equivalence class of Geo Time Series™, considering the values of each tick and producing one GTS per equivalence class.\n\nAs the selected reducer function is applied tick by tick, it is usually wise to [`BUCKETIZE`](/doc/BUCKETIZE) the GTS first with a common value of `lastbucket`.\n\nThe labels whose values are common to all the GTS in an equivalence class will be retained.\n\nSince 2.1 you can make REDUCE override the GTSs ticks. This usage in mainly to be used in conjuction with [`MACROREDUCER`](/doc/MACROREDUCER).\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` List of resulting Geo Time Series™.\n\n@param `overrideTick` Boolean, if true allows the reducer to modify the ticks of the GTSs. If not set, the reducer cannot modify the ticks.\n\n",signature:"[ gts<LIST<GTS>+> labels<LIST<STRING>> reducer<AGGREGATOR> ]  REDUCE  result<LIST<GTS>>\n[ gts<LIST<GTS>+> labels<LIST<STRING>> reducer<AGGREGATOR> overrideTick<BOOLEAN> ]  REDUCE  result<LIST<GTS>>",tags:["reducer","framework"],since:"1.0.0",OPB64name:"REDUCE"},RELABEL:{description:"Modifies the labels of a Geo Time Series™. The `RELABEL` function expects a parameter MAP whose entries are labels to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `RELABEL` function will use the rest of the MAP as the actual labels to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing labels.\n\nAn entry with an empty STRING value or a NULL value will have the effect of removing the label from the GTS' labels.        \n\n@param `labels` Parameter map of label names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `encoder` Encoder to relabel\n\n@param `lencoder` List of encoders to relabel\n\n",signature:"gts<GTS> labels<MAP>  RELABEL  gts<GTS>\nlgts<LIST<GTS>> labels<MAP>  RELABEL  lgts<LIST<GTS>>\nencoder<GTSENCODER> labels<MAP>  RELABEL  encoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> labels<MAP>  RELABEL  lencoder<LIST<GTSENCODER>>",tags:["gts"],since:"1.0.0",OPB64name:"RELABEL"},REMOVE:{description:"Removes an entry from a MAP or from a LIST.\n\nThe `REMOVE` function consumes a list (or a map) and a index (or a key), then remove the entry.\nIt lets the input on the stack and puts the removed item on top of the stack. \nAs a result, the input map or list is modified and the map or list left on top of the stack is *not* a copy. \n\nIf the index is out of bound, the returned value is `NULL` and the list or array is unmodified.\nIf the key does not exist in the map, it returns null as the removed entry.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **GTS**.\n\nSince 2.7, `REMOVE` can be called on a **GTS**.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean\n\n@param `inputmap` The reference to the map to be modified\n\n@param `index` The index of the list, 0 for the first item\n\n@param `inputlist` The reference to the list to be modified\n\n@param `removeditem` Depending on map or list content, could be any type\n\n@param `outputmap` The input map modified\n\n@param `outputlist` The input list modified\n\n@param `pointindex` Index of the point in the GTS, 0-indexed, handles negative indexing.\n\n@param `inputgts` The GTS to remove the point from.\n\n@param `removedpoint` The removed point. List of timestamp, latitude, longitude, elevation and value.\n\n@param `outputgts` The acopy of the original GTS with the requested point removed.\n\n",signature:"inputlist<LIST> index<LONG>  REMOVE  outputlist<LIST> removeditem<ANY>\ninputmap<MAP> key<ANY>  REMOVE  outputmap<MAP> removeditem<ANY>\ninputgts<GTS> pointindex<LONG>  REMOVE  outputgts<GTS> removedpoint<LIST>",tags:["maps","lists"],since:"1.0.0",OPB64name:"REMOVE"},REMOVETICK:{description:"The `REMOVETICK` function transforms a Geo Time Series™ by removing all occurrences of a tick or ticks.\n\n@param `tick` Tick (timestamp) to remove.\n\n@param `lticks` List or Set of ticks to remove.\n\n@param `gts` Geo Time Series™ to transform.\n\n@param `pruned` Tranformed Geo Time Series™.\n\n",signature:"gts<GTS> tick<LONG>  REMOVETICK  pruned<GTS>\ngts<GTS> lticks<LIST<LONG>>  REMOVETICK  pruned<GTS>\ngts<GTS> lticks<SET<LONG>>  REMOVETICK  pruned<GTS>",tags:["gts"],since:"1.2.19",OPB64name:"REMOVETICK"},RENAME:{description:"The `RENAME` function changes the name of a Geo Time Series™, an Encoder or a list thereof. This operation may be required prior to using some functions. If the name starts with '+', the specified name will be appended to the current name of the GTS or Encoder.\n\nIf you want to rename a Geo Time Series™ or an Encoder so its name starts with a '+', you must first set its name to the empty string then use rename with the desired name prefixed with an additional '+'.\n\n@param `gts` Geo Time Series™ instance to rename.\n\n@param `lgts` List of Geo Time Series™ instances to rename.\n\n@param `encoder` Encoder to rename.\n\n@param `lencoder` Encoder to rename.\n\n@param `name` New name to give to the GTS.\n\n",signature:"gts<GTS> name<STRING>  RENAME  gts<GTS>\nlgts<LIST<GTS>> name<STRING>  RENAME  lgts<LIST<GTS>>\nencoder<GTSENCODER> name<STRING>  RENAME  encoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> name<STRING>  RENAME  lencoder<LIST<GTSENCODER>>",tags:["gts","encoder"],since:"1.0.0",OPB64name:"RENAME"},REOPTALT:{description:"Produces a **R**egular **E**xpression **OPT**imized for **ALT**ernation from a list of STRINGs. Large alternations in regular expressions can lead to excessive backtracking and poor matching performance. In order to mitigate this, the `REOPTALT` function will produce a regular expression from a list of STRINGs which reduces the backtracking thus leading to better matching performance.\n\n@param `alternatives` List of STRINGs which should be used in the alternation.\n\n@param `regexp` Regular expression\n\n",signature:"alternatives<LIST<STRING>>  REOPTALT  regexp<STRING>",tags:["strings"],since:"1.2.16",OPB64name:"REOPTALT"},REPLACE:{description:"Replaces the first occurrence of a pattern by its substitution.\n\nThe `REPLACE` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with the replaced value if it was found\n\n",signature:"original<ANY> pattern<ANY> replacement<ANY>  REPLACE  result<STRING>",tags:["strings"],since:"1.1.0",OPB64name:"REPLACE"},REPLACEALL:{description:"Replaces all occurrence of a pattern by its substitution.\n\nThe `REPLACEALL` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with all occurrences of pattern replaced by its value\n\n",signature:"original<ANY> pattern<ANY> replacement<ANY>  REPLACEALL  result<STRING>",tags:["strings"],since:"1.1.0",OPB64name:"REPLACEALL"},REPORT:{description:"The `REPORT` function pushes onto the stack a STRING containing configuration and usage informations which can be useful when investigating issues.\n\n@param `secret` Secret configured for using the `REPORT` function.\n\n@param `report` Actual report.\n\n",signature:"secret<STRING>  REPORT  report<STRING>",tags:["stack"],since:"2.0.3",OPB64name:"REPORT"},RESET:{description:"The `RESET` function resets the stack to the given depth, discarding any items above those 'depth' items.\n\n@param `depth` Depth at which the stack should be reset.\n\n",signature:"depth<LONG>  RESET ",tags:["stack"],since:"1.0.0",OPB64name:"RESET"},RESETS:{description:"The `RESETS` functions transforms a numerical Geo Time Series™, shifting values so no offset (*i.e.* a decrease or increase of values) appears after the operation.\n\nThe parameter to `RESETS` determines if the Geo Time Series should be considered as decreasing instead of increasing.\n\n@param `decreasingGTS` Flag set to `true` to indicate the GTS is decreasing.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `lgts` List of Geo Time Series™ or list thereof to transform.\n\n@param `result` GTS with resets compensated.\n\n@param `lresult` List of GTS with resets compensated.\n\n",signature:"gts<GTS> decreasingGTS<BOOLEAN>  RESETS  result<GTS>\nlgts<LIST<GTS>> decreasingGTS<BOOLEAN>  RESETS  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"RESETS"},RESHAPE:{description:"The `RESHAPE` function modifies the shape of a list.\n\nThe new shape is specified using a list of dimensions, the first being the outer dimension. Such a shape can be produced by `SHAPE`.\n\nNote that the number of elements in the array must be compatible with the requested shape, i.e. the product of the dimensions must match the number of elements in the input list.\n\n@param `input` List to reshape.\n\n@param `shape` Shape specification, list of dimensions, the first element being the outer list.\n\n@param `output` Reshaped list.\n\n",signature:"input<LIST> shape<LIST<LONG>>  RESHAPE  output<LIST>",tags:["lists","tensors"],since:"2.1.0",OPB64name:"RESHAPE"},RESTORE:{description:"The `RESTORE` function resets the stack's symbol table to the state recorded in the context passed as parameter.\n\n@param `context` Stack context produced by [`SAVE`](doc/SAVE).\n\n",signature:"context<CONTEXT>  RESTORE ",tags:["stack"],since:"1.0.0",OPB64name:"RESTORE"},RETHROW:{description:"Inside the *catch* or *finally* macro of a [`TRY`](/doc/TRY), rethrows the last thrown error. If no error was previously thrown, `RETHROW` does nothing.\n\n",signature:" RETHROW ",tags:["control"],since:"1.2.11",OPB64name:"RETHROW"},RETURN:{description:"Returns immediately from the currently executing macro. If called outside a macro, `RETURN` will stop the execution of the current script, behaving like [`STOP`](/doc/STOP).\n\n",signature:" RETURN ",tags:["control"],since:"1.0.0",OPB64name:"RETURN"},REV:{description:"The `REV` function pushes onto the stack the revision of the Warp 10 instance.`\n\n@param `revision` Revision of the Warp 10 platform.\n\n",signature:" REV  revision<STRING>",tags:["platform"],since:"1.0.0",OPB64name:"REV"},REVBITS:{description:"Reverses the order of the bits of a LONG value.\n\n@param `long` LONG value from which to revert the bits.\n\n@param `gnol` LONG value whose bits are in reverse order compared to those of `long`.\n\n",signature:"long<LONG>  REVBITS  gnol<LONG>",tags:["math"],since:"1.0.0",OPB64name:"REVBITS"},REVERSE:{description:"Reverses the order of the elements of the list or the string.\n\nThe `REVERSE` function inverts the order of the elements of the list or the string on the top of the stack.\nBeware, `REVERSE` do not create a new object. Use [`CLONEREVERSE`](/doc/CLONEREVERSE) if you want to keep input.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n\n@param `originalList` The list to reverse\n\n@param `originalString` The string to reverse\n\n@param `reversedObj` The original object with the elements in reverse order\n\n",signature:"originalList<LIST>  REVERSE  reversedObj<LIST>\noriginalString<STRING>  REVERSE  reversedObj<STRING>\noriginalString<BYTES>  REVERSE  reversedObj<BYTES>",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"REVERSE"},REXEC:{description:"The `REXEC` function executes some WarpScript code on a remote Warp 10 instance. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",signature:"warpscript<STRING> endpoint<STRING>  REXEC  stack<ANY*>",tags:["extensions","stack"],since:"1.0.8",OPB64name:"REXEC"},REXECZ:{description:"The `REXECZ` function executes some WarpScript code on a remote Warp 10 instance just like [`REXEC`](/doc/REXEC) does, but compresses the WarpScript code prior to sending it. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",signature:"warpscript<STRING> endpoint<STRING>  REXECZ  stack<ANY*>",tags:["extensions","stack"],since:"1.2.5",OPB64name:"REXECZ"},RINT:{description:"The `RINT` function consumes a numeric parameter from the top of the stack and pushes back the DOUBLE the closest to the parameter and equal to a mathematical integer.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `result` Closest floating-point value to a that is equal to a mathematical integer.\n\n@param `lvalue` List of Numeric values.\n\n@param `lresult` List of closest floating-point values to a that is equal to a mathematical integer.\n\n",signature:"value<NUMBER>  RINT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  RINT  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"RINT"},RLOWESS:{description:"The `RLOWESS` function applies an iterative smoothing program on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is done via locally weighted regression, and is robust to outliers.\n\n> ### REFERENCE\n>\n> **Cleveland, W. S.** (1979) Robust locally weighted regression and smoothing scatterplots. J. American Statistical Association 74, 829–836.\n> **Cleveland, W. S.** (1981) LOWESS: A program for smoothing scatterplots by robust locally weighted regression. The American Statistician 35, 54.\n\n@param `p` The degree for the polynomial fit of the regression\n\n@param `d` The delta radius (in time units) whithin which the local regression is computed only once (other points are interpolated). For very large datasets, it can be wise to set `d` > 0 to speed up the computations.\n\n@param `r` The number of robustifying iterations. The higher the value of `r`, the better the program is robust to outliers.\n\n@param `q` The bandwidth of the local regression. To obtain a good smoothing, it is advised to choose an odd number of at least 5.\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",signature:"gts<GTS> q<LONG> r<LONG> d<LONG> p<LONG>  RLOWESS  result<GTS>\ngtsList<LIST<GTS>> q<LONG> r<LONG> d<LONG> p<LONG>  RLOWESS  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"RLOWESS"},ROLL:{description:"`ROLL` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element at level *N* to the top of the stack and moving the other elements up one level.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",signature:"eltN<ANY> elt2<ANY> elt1<ANY> N<LONG>  ROLL  elt2<ANY> elt1<ANY> eltN<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"ROLL"},ROLLD:{description:"`ROLLD` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element on top of the stack to level *N* and moving the other *N-1* elements down the stack.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",signature:"eltN<ANY> elt2<ANY> elt1<ANY> N<LONG>  ROLLD  elt1<ANY> eltN<ANY> elt2<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"ROLLD"},ROT:{description:"`ROT` cycles through the 3 topmost elements of the stack by moving the element at level 3 to the top of the stack and pushing the other 2 elements up the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n@param `level3` The element at the third level of the stack prior to the function execution\n\n",signature:"level3<ANY> level2<ANY> top<ANY>  ROT  level2<ANY> top<ANY> level3<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"ROT"},ROTATIONQ:{description:"The `ROTATIONQ` function consumes on the stack 4 doubles representing a rotation vector and pushes back [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long.\n\n@param `quaternion` The quaternion representation\n\n@param `angle` The angle of the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",signature:"x<DOUBLE> y<DOUBLE> z<DOUBLE> angle<DOUBLE>  ROTATIONQ  quaternion<QUATERNION>",tags:["quaternions"],since:"1.0.0",OPB64name:"ROTATIONQ"},ROUND:{description:"The `ROUND` function consumes a numeric parameter from the top of the stack and pushes back the long number the closest to the parameter.\n\n@param `input` Input to round.\n\n@param `output` Input rounded to the nearest Long.\n\n",signature:"input<NUMBER>  ROUND  output<LONG>",tags:["math"],since:"1.0.0",OPB64name:"ROUND"},RSADECRYPT:{description:"Decrypts content encrypted with an RSA key.\n\n@param `key` RSA key to use for decryption (a public key if content was encrypted with a private key, a private key otherwise).\n\n@param `cipher` Encrypted data.\n\n@param `data` Cleartext data.\n\n",signature:"cipher<BYTES> key<KEY>  RSADECRYPT  data<BYTES>",tags:["crypto"],since:"1.0.11",OPB64name:"RSADECRYPT"},RSAENCRYPT:{description:"Encrypts a byte array using an RSA key (either public or private).\n\n@param `key` Instance of the RSA private or public key to use for encryption.\n\n@param `data` Data to encrypt.\n\n@param `encrypted` Ciphered version of `data`.\n\n",signature:"data<BYTES> key<KEY>  RSAENCRYPT  encrypted<BYTES>",tags:["crypto"],since:"1.0.11",OPB64name:"RSAENCRYPT"},RSAGEN:{description:"Generates an RSA public key pair.\n\n@param `keylen` Key length in bits.\n\n@param `publicExponent` RSA public exponent, typically 65537.\n\n@param `pubkeyparams` Parameters of the generated RSA public key. Can be converted to a public key using [`RSAPUBLIC`](/doc/RSAPUBLIC).\n\n@param `privkeyparams` Parameters of the generated RSA privsate key. Can be converted to a private key using [`RSAPRIVATE`](/doc/RSAPRIVATE)\n\n",signature:"publicExponent<LONG> keylen<LONG>  RSAGEN  privkeyparams<MAP> pubkeyparams<MAP>",tags:["crypto"],since:"1.0.11",OPB64name:"RSAGEN"},RSAPRIVATE:{description:"Creates an RSA private key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `privkeyparams` Map of private key parameters.\n\n@param `privkey` RSA private key instance.\n\n",signature:"privkeyparams<MAP>  RSAPRIVATE  privkey<KEY>",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPRIVATE"},RSAPUBLIC:{description:"Creates an RSA public key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `pubkeyparams` Map of public key parameters.\n\n@param `pubkey` RSA public key instance.\n\n",signature:"pubkeyparams<MAP>  RSAPUBLIC  pubkey<KEY>",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPUBLIC"},RSASIGN:{description:"Signs a byte array with an RSA private key.\n\n@param `privkey` RSA private key to use for signing.\n\n@param `alg` Name of algorithm to use for computing the data fingerprint. Supported algorithms are those provided by [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `data` Data to sign.\n\n@param `signature` Computed signature.\n\n",signature:"data<BYTES> alg<STRING> privkey<KEY>  RSASIGN  signature<BYTES>",tags:["crypto"],since:"1.0.11",OPB64name:"RSASIGN"},RSAVERIFY:{description:"The `RSAVERIFY` function verify a signature generated with [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) cryptosystem and a hash algorithm.\n\nAlgorithms are those supported by [BouncyCastle](http://stackoverflow.com/questions/8778531/bouncycastle-does-not-find-algorithms-that-it-provides).\n\n@param `pubkey` RSA public key to use for verifying the signature.\n\n@param `alg` Algorithm used for generating the signature. See [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `signature` Signature to verify.\n\n@param `content` Signed content.\n\n@param `verified` Status of the signature verification.\n\n",signature:"content<BYTES> signature<BYTES> alg<STRING> pubkey<KEY>  RSAVERIFY  verified<BOOLEAN>",tags:["crypto"],since:"1.0.11",OPB64name:"RSAVERIFY"},RSORT:{description:"Sort Geo Time Series™ values (and associated locations/elevations) by reverse order of their ticks (i.e. most recent ticks first).\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",signature:"gts<GTS>  RSORT  result<GTS>\ngtsList<LIST<GTS>>  RSORT  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"RSORT"},RTFM:{description:"The `RTFM` function pushes onto the stack the URL of the Warp 10 documentation, so whenever you are lost you can rapidly retrieve the URL you need to get back on track!\n\n@param `url` URL of the Warp 10 documentation.\n\n",signature:" RTFM  url<STRING>",tags:["misc","help"],since:"1.0.7",OPB64name:"RTFM"},RUN:{description:"The `RUN` function attempts to execute the macro whose name is on top of the stack. It is equivalent to `@macro` if called with `macro` on top of the stack.\n\n@param `macroName` Name of macro to execute, without a leading '@'\n\n@param `macroRegister` Register number in which the macro is stored, without a leading '@'\n\n",signature:"macroName<STRING>  RUN \nmacroRegister<LONG>  RUN ",tags:["platform"],since:"1.0.0",OPB64name:"RUN"},RUNNERNONCE:{description:"The `RUNNERNONCE` function decrypts the content of a runner *nonce* as generated when a script is executed by a Warp 10 runner instance.\n\nWhen a script is executed by a runner instance, the following symbols are defined when the script is invoked:\n\n| Symbol | Description |\n| --- | --- |\n| `runner.periodicity` | Periodicity at which the script is supposed to run, in ms. |\n| `runner.path` | Path of the script. |\n| `runner.scheduledat` | Time at which the current execution was scheduled, in ms since the [UNIX Epoch](). |\n| `runner.nonce` | Encrypted time of execution, in time units since the [UNIX Epoch](). |\n\nNote that if the runner pre-shared key is not configured via `runner.psk`, the `RUNNERNONCE` function will push `NULL` onto the stack. Note that in this case, the `runner.nonce` symbol will not be defined.\n\n@param `nonce` Runner *nonce* as stored in `runner.nonce`.\n\n@param `time` Time retrieved from the *nonce*.\n\n",signature:"nonce<STRING>  RUNNERNONCE  time<LONG>",tags:["stack"],since:"1.2.7",OPB64name:"RUNNERNONCE"},RUNR:{description:"Run the macro currently contained in the designated register.\n\nThe `RUNR` function is really a family of functions named `RUNRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n",signature:" RUNR ",tags:["maps"],since:"2.7.0",OPB64name:"RUNR"},RVALUESORT:{description:"Sort Geo Time Series™ values (and associated locations/elevations) by by reverse order of their values.\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",signature:"gts<GTS>  RVALUESORT  result<GTS>\ngtsList<LIST<GTS>>  RVALUESORT  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"RVALUESORT"},SAVE:{description:"The `SAVE` function pushes onto the stack a *context* object which contains all the symbols currently defined in the current stack. This context can be passed as a parameter to the [`RESTORE`](doc/RESTORE) function to later reset the symbol table to the state store in the context. Any symbol created after the context was saved and before it is restored will be discarded when `RESTORE` is called.\n\n@param `context` Stack context, suitable as a parameter to [`RESTORE`](doc/RESTORE).\n\n",signature:" SAVE  context<CONTEXT>",tags:["stack"],since:"1.0.0",OPB64name:"SAVE"},SCALB:{description:'The `SCALB` function consumes a scale factor *scaleFactor* and a numeric parameter *d* and pushes back <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo>&#xD7;</mo><msup><mn>2</mn><mi>scaleFactor</mi></msup></math>. The scale factor must fit into an INT.\n\n@param `scaleFactor` The scaling factor, must fit into an INT\n\n@param `d` The value to be scaled\n\n@param `result` The scaled value\n\n',signature:"d<NUMBER> scaleFactor<LONG>  SCALB  result<TYPE>",tags:["math"],since:"1.2.23",OPB64name:"SCALB"},SECTION:{description:"The `SECTION` function modifies the value of the *section* attribute of the stack. This value appears in the error messages and can therefore help you debug your WarpScript code. Typically, the `SECTION` function is used to separate your code in different logical units.\n\n@param `section` Name to assign to the *section* attribute.\n\n",signature:"section<STRING>  SECTION ",tags:["stack","debug"],since:"1.2.7",OPB64name:"SECTION"},SECURE:{description:"The `SECURE` function encrypts a STRING representing a WarpScript code fragment using the platform's secure script cryptographic key and the current secret set via [`SECUREKEY`](doc/SECUREKEY).\n\nSecure scripts can also be created using the `<S .... S>` syntax.\n\n@param `script` Cleartext version of the WarpScript fragment to encrypt.\n\n@param `encrypted` Encrypted secure script.\n\n",signature:"script<STRING>  SECURE  encrypted<STRING>",tags:["crypto","stack"],since:"1.2.11",OPB64name:"SECURE"},SECUREKEY:{description:"The `SECUREKEY` function sets the secret which will be used to decrypt further secure scripts.\n\nSecure scripts are WarpScript fragments which are encrypted with a cryptographic key specific to the platform they were created on. They can be executed on a platform configured with the same cryptographic key.\n\n@param `key` Secret to use for unlocking the cleartext versions of future secure scripts.\n\n",signature:"key<STRING>  SECUREKEY ",tags:["crypto","stack"],since:"1.0.0",OPB64name:"SECUREKEY"},"SENSISION.DUMP":{description:"The `SENSISION.DUMP` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) metrics in the JVM.\n\nThe STRING produced by `SENSISION.DUMP` can be parsed using `PARSE`.\n\n@param `valueTimestamp` Flag indicating whether to dump the Geo Time Series™ with the timestamp of last updates or the timestamp at which the value is read.\n\n@param `dump` Latest values of all Geo Time Series™ known to Sensision in Geo Time Series™ output input.\n\n",signature:"valueTimestamp<BOOLEAN>  SENSISION.DUMP  dump<STRING>",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMP"},"SENSISION.DUMPEVENTS":{description:"The `SENSISION.DUMPEVENTS` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) events in the events history.\n\nThe STRING produced by `SENSISION.DUMPEVENTS` can be parsed using `PARSE`.\n\nNote that if the system property `sensision.events.history` is not set to a value greater than 0, the function will always return an empty STRING.\n\nThe Sensision event history is a circular buffer.\n\n@param `dump` Latest values of all events in the Sensision event history.\n\n",signature:" SENSISION.DUMPEVENTS  dump<STRING>",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMPEVENTS"},"SENSISION.EVENT":{description:"The `SENSISION.EVENT` function creates a [Sensision](https://github.com/senx/sensision) event.\n\n@param `class` Name of the class of the Sensision event to emit.\n\n@param `labels` Map of label names to values, both STRINGs of the Sensision event.\n\n@param `value` Value associated with the event.\n\n@param `ts` Optional timestamp for the event (in Sensision time units), if omitted, the current timestamp will be used.\n\n",signature:"[ value<LONG> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<STRING> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<BOOLEAN> labels<MAP> class<STRING> ]  SENSISION.EVENT \n[ value<LONG> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT \n[ value<DOUBLE> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT \n[ value<STRING> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT \n[ value<BOOLEAN> labels<MAP> class<STRING> ts<LONG> ]  SENSISION.EVENT ",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.EVENT"},"SENSISION.GET":{description:"The `SENSISION.GET` function reads the current value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to read.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to read.\n\n@param `selector` Geo Time Series™ selector (`class{labels}`) of the Sensision metric to read.\n\n@param `gts` A Geo Time Series™ containing the current value of the Sensision metric. If the metric does not exist, the resulting GTS will be empty.\n\n",signature:"selector<STRING>  SENSISION.GET  gts<GTS>\nclass<STRING> labels<MAP>  SENSISION.GET  gts<GTS>",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.GET"},"SENSISION.SET":{description:"The `SENSISION.SET` function sets a value for a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `value` Value to assign to the Sensision metric.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",signature:"[ value<LONG> labels<MAP> class<STRING> ]  SENSISION.SET \n[ value<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.SET \n[ value<STRING> labels<MAP> class<STRING> ]  SENSISION.SET \n[ value<BOOLEAN> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<LONG> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<STRING> labels<MAP> class<STRING> ]  SENSISION.SET \n[ ttl<LONG> value<BOOLEAN> labels<MAP> class<STRING> ]  SENSISION.SET ",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.SET"},"SENSISION.UPDATE":{description:"The `SENSISION.UPDATE` function updates the numerical value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `delta` Delta to add to the current value of the Sensision metric. If the metric does not exist it will be created with this value.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",signature:"[ delta<LONG> labels<MAP> class<STRING> ]  SENSISION.UPDATE \n[ delta<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.UPDATE \n[ ttl<LONG> delta<LONG> labels<MAP> class<STRING> ]  SENSISION.UPDATE \n[ ttl<LONG> delta<DOUBLE> labels<MAP> class<STRING> ]  SENSISION.UPDATE ",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.UPDATE"},SET:{description:"The `SET` function replaces item at specified index in a list.\nIf the index is greater than the size of the list, it will raise an error.\n\nWhen used on a **BYTE ARRAY**, SET replaces the byte by the byte value. The byte value, signed or not, must be in the range of [-128,255].\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, SET can set an element in a nested list. In this case, the index is a list.\n\n@param `index` The index in the list, 0 for the first item.\n\n@param `inputlist` The input list to modified.\n\n@param `outputlist` The input list modified,  this is not a new list object.\n\n@param `item` The item to update in the inputlist at index, could be any type.\n\n@param `array` Byte array to which write a byte.\n\n@param `bytevalue` The value of the byte, signed or unsigned (from -128 to 255).\n\n@param `outputarray` The input byte array modified, this is not a new byte array.\n\n",signature:"inputlist<LIST> item<ANY> index<LONG>  SET  outputlist<LIST>\ninputlist<LIST> item<ANY> index<LIST>  SET  outputlist<LIST>\narray<BYTES> bytevalue<LONG> index<LONG>  SET  outputarray<LIST>",tags:["lists","binary"],since:"1.0.0",OPB64name:"SET"},"SET->":{description:"The `SET->` function converts the set on top of the stack into a **LIST**.\n\n@param `input` Input set.\n\n@param `output` A list containing input elements.\n\n",signature:"input<SET>  SET->  output<LIST>",tags:["sets"],since:"1.0.0",OPB64name:"JoKJAIs"},SETATTRIBUTES:{description:"Modifies the attributes of a Geo Time Series™, an encoder or a list thereof. The `SETATTRIBUTES` function expects a parameter MAP whose entries are attributes to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `SETATTRIBUTES` function will use the rest of the MAP as the actual attributes to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing attributes.\n\nAn entry with an empty STRING value will have the effect of removing the attribute from the attributes of the GTSs or encoders.   \n\n@param `attributes` Parameter map of attributes names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lencoder` List of Encoders.\n\n@param `encoder` Encoder to relabel\n\n",signature:"gts<GTS> attributes<MAP>  SETATTRIBUTES  gts<GTS>\nlgts<LIST<GTS>> attributes<MAP>  SETATTRIBUTES  lgts<LIST<GTS>>\nencoder<GTSENCODER> attributes<MAP>  SETATTRIBUTES  encoder<GTSENCODER>\nlencoder<LIST<GTS>> attributes<MAP>  SETATTRIBUTES  lencoder<LIST<GTS>>",tags:["gts","encoder"],since:"1.0.0",OPB64name:"SETATTRIBUTES"},SETMACROCONFIG:{description:"The `SETMACROCONFIG` function allows you to set or modify the value of a configuration key accessible via the [`MACROCONFIG`](/doc/MACROCONFIG) or [`MACROCONFIGDEFAULT`](/doc/MACROCONFIGDEFAULT) functions or via the runner script variable expansion.\n\nThis function can only be used if the `warpscript.macroconfig.secret` is set in the Warp 10™ configuration.\n\nThe configuration keys which can be set using `SETMACROCONFIG` must have the format `key@path/tomacro` or `key@/path/to/runner/script`.\n\nSetting the value of a configuration key to `NULL` has the effect of removing the configuration key altogether.\n\n@param `key` Configuration key to set.\n\n@param `secret` Macro config secret.\n\n@param `value` String value to set for the key or `NULL`.\n\n",signature:"value<STRING> key<STRING> secret<STRING>  SETMACROCONFIG ",tags:["platform"],since:"2.1.0",OPB64name:"SETMACROCONFIG"},SETVALUE:{description:"The `SETVALUE` function adds a value to a GTS or override an existing value. If the tick already exists, this function will overwrite the first one it encounters in the GTS. If the tick does not exist, it is appended. \nThe [`ADDVALUE`](/doc/ADDVALUE) function adds a value to a GTS but do not override an existing value.\n\nThe `SETVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `SETVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, using [`GET`](/doc/GET) for instance.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Serie\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `elevation` Elevation or NaN\n\n@param `result` modified Geo Time Series™\n\n",signature:"gts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<STRING>  SETVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<BOOLEAN>  SETVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<DOUBLE>  SETVALUE  result<GTS>\ngts<GTS> tick<LONG> latitude<DOUBLE> longitude<DOUBLE> elevation<LONG> value<LONG>  SETVALUE  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"SETVALUE"},SHA1:{description:"The `SHA1` function digests a byte array on the stack with the cryptographic hash function [SHA-1](https://en.wikipedia.org/wiki/SHA-1).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",signature:"input<BYTES>  SHA1  result<BYTES>",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1"},SHA1HMAC:{description:"The `SHA1HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-1](https://en.wikipedia.org/wiki/SHA-1) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",signature:"message<BYTES> secret<BYTES>  SHA1HMAC  result<BYTES>",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1HMAC"},SHA256:{description:"The `SHA256` function digests a byte array on the stack with the cryptographic hash function [SHA-256](https://en.wikipedia.org/wiki/SHA-2).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",signature:"input<BYTES>  SHA256  result<BYTES>",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256"},SHA256HMAC:{description:"The `SHA256HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-256](https://en.wikipedia.org/wiki/SHA-2) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",signature:"message<BYTES> secret<BYTES>  SHA256HMAC  result<BYTES>",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256HMAC"},SHAPE:{description:"Return the shape of an input list if it could be a tensor (or multidimensional array), or raise an Exception.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent and it returns a shape based on the first nested lists at each level. Default to false.\n\n@param `list` The input list.\n\n@param `shape` The shape of the input list.\n\n",signature:"list<LIST>  SHAPE  shape<LIST>\n{ list<LIST> fast<BOOLEAN>  } SHAPE  shape<LIST>",tags:["lists","tensors"],since:"2.1.0",OPB64name:"SHAPE"},SHMLOAD:{description:"The `SHMLOAD` function loads data previously stored by [`SHMSTORE`](/doc/SHMSTORE) in shared memory, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the requested shared symbol is not known or if the calling script does not currently hold the mutex associated with the symbol.\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to retrieve.\n\n@param `object` Object currently stored under `symbol`.\n\n",signature:"symbol<STRING>  SHMLOAD  object<ANY>",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMLOAD"},SHMSTORE:{description:"The `SHMSTORE` function stores an object in a named shared memory location, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the calling script is not currently holding a mutex (in a call to [`MUTEX`](/doc/MUTEX)). The call will have no effect if the named memory location was already set by a previous call to `SHMSTORE`.\n\nIn order to overwrite a shared memory location, its content must first be cleared by storing [`NULL`](/doc/NULL).\n\n\nIf the calling script currently holds a mutex, this mutex will be associated with the shared memory location, the same mutex will have to be held when retrieving the content of the memory location via [`SHMLOAD`](/doc/SHMLOAD).\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to store.\n\n@param `object` Object to store under `symbol` or `NULL` to clear its content.\n\n",signature:"object<ANY> symbol<STRING>  SHMSTORE ",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMSTORE"},SHOW:{description:"The `SHOW` function makes visible some levels of the stack which were previously hidden by a call to [`HIDE`](/doc/HIDE).\n\nThe levels made visible are the ones closest to the top of the stack. Depending on the `levels` parameter to the call to `SHOW`, the revealed levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there are at most a certain number ((*abs(`levels`)*) with `levels` < 0) of visible levels after the call.\n\nWhen called with `NULL` as parameter, `SHOW` wil reveal all levels currently hidden.\n\n@param `levels` Number of levels to reveal, or `NULL` to reveal them all.\n\n",signature:"levels<LONG>  SHOW ",tags:["stack"],since:"2.7.1",OPB64name:"SHOW"},SHRINK:{description:"Shrink the number of values of a Geo Time Series™ to `size`. The oldest values are kept if `size` is non negative. The earliest ones are kept in the other case.\n\nThis function has the side effect of sorting the Geo Time Series™. If the Geo Time Series™ has fewer than `size` values the function raises an error.\n\n@param `size` Size used to shrink the Geo Time Series™\n\n@param `gts` A Geo Time Series™\n\n@param `result` A shrinked Geo Time Series™\n\n",signature:"gts<GTS> size<LONG>  SHRINK  result<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"SHRINK"},SHUFFLE:{description:"The `SHUFFLE` function shuffles a list.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `input` The reference of the list to shuffle\n\n@param `shuffled` The original list shuffled, this is not a new list object\n\n",signature:"input<LIST>  SHUFFLE  shuffled<LIST>",tags:["lists"],since:"2.1.0",OPB64name:"SHUFFLE"},SIGNUM:{description:"The `SIGNUM` function consumes a numeric parameter from the top of the stack and pushes back its signum.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Signum, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of signum for each given value, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n",signature:"value<NUMBER>  SIGNUM  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SIGNUM  lresult<LIST<DOUBLE>>",tags:["operators","math"],since:"1.0.0",OPB64name:"SIGNUM"},SIN:{description:"The `SIN` function consumes a floating point number from the top of the stack and pushes back its sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Sine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of sine of the given values.\n\n",signature:"value<NUMBER>  SIN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SIN  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SIN"},SINGLEEXPONENTIALSMOOTHING:{description:"The `SINGLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Simple Exponential Smoothing](https://www.otexts.org/fpp/7/1) formula.\n\nIt consumes two parameters from the top of the stack:\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** is pushed onto the stack.\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The smoothed Geo Time Series™\n\n",signature:"gts<GTS> alpha<DOUBLE>  SINGLEEXPONENTIALSMOOTHING  result<GTS>",tags:["gts","statistics"],since:"1.0.0",OPB64name:"SINGLEEXPONENTIALSMOOTHING"},SINH:{description:"The `SINH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic sine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic sine of the given values.\n\n",signature:"value<NUMBER>  SINH  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SINH  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SINH"},SIZE:{description:"Returns the size of the input parameter.\n\nThe `SIZE` function computes the size of a LIST, MAP, GTS or ENCODER (number of values), STRING, byte array of GEOSHAPE (number of cells).\n\n@param `input` The input parameter\n\n@param `size` The size of the input parameter\n\n",signature:"input<LIST>  SIZE  size<LONG>\ninput<MAP>  SIZE  size<LONG>\ninput<GTS>  SIZE  size<LONG>\ninput<STRING>  SIZE  size<LONG>\ninput<BYTES>  SIZE  size<LONG>\ninput<GEOSHAPE>  SIZE  size<LONG>\ninput<GTSENCODER>  SIZE  size<LONG>\ninput<SET>  SIZE  size<LONG>",tags:["strings","lists","maps","gts","geo"],since:"1.0.0",OPB64name:"SIZE"},SKEWNESS:{description:"The `SKEWNESS` function computes the [skewness](https://en.wikipedia.org/wiki/Skewness) of a Geo Time Series™.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the skewness.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `skewness` Computed skewness of the Geo Time Series™ instance.\n\n@param `lskewness` List of computed skewness of the Geo Time Series™ instances.\n\n",signature:"gts<GTS> bessel<BOOLEAN>  SKEWNESS  skewness<DOUBLE>\nlgts<LIST<GTS>> bessel<BOOLEAN>  SKEWNESS  lskewness<LIST<DOUBLE>>",tags:["statistics","gts"],since:"1.2.13",OPB64name:"SKEWNESS"},SMARTPARSE:{description:"The `SMARTPARSE` function parses STRING values, either from a single STRING parameter or from STRING Geo Time Series™, and produces a number of GTS from the parsed data.\n\nThe parsing is done according to a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) which contains [named capturing groups](https://www.regular-expressions.info/named.html) with the Java/.NET syntax, *i.e.* `(?<name>...)`.\n\nThe captured group is interpreted differently based on the syntax of the name.\n\n| Syntax | Interpretation |\n| --- | --- |\n| Lxxx | Captured content is used as the value of label `xxx` |\n| TU | Captured group is interpreted as a timestamp in unit `U` from the [UNIX Epoch](https://en.wikipedia.org/wiki/Unix_time) origin. Valid values for U are `s`, `ms`, `us`, `ns` |\n| lat | Captured group is interpreted as the latitude if another group named `lon` is also present |\n| lon | Captured group is interpreted as the longitude if another group named `lat` is also present |\n| elevU | Captured group is interpreted as the elevation in unit `U`, where `U` can be `m`, `cm`, `mm`, `ft`, `km`, `mi`, `nm` (Nautical Mile). The value is parsed as a DOUBLE and converted to a LONG in `mm` |\n| VTxxx | Captured group is interpreted as a value for a GTS with class `xxx`. The type of the value is determined by the value of `T` which can be `B`(oolean) `S`(tring) `L`(ong) or `D`(ouble) |\n\nThis function is ideally suited for parsing log messages and producing Geo Time Series™ from their content.\n\n@param `regexp` Regular expression to use for parsing. See the function description for the syntax to use.\n\n@param `string` String to parse\n\n@param `results` List of Geo Time Series™ created from the parsed data.\n\n@param `lresults` List of list of GTS created from the parsed data.\n\n@param `gts` STRING valued Geo Time Series™ whose values are to be parsed.\n\n@param `lgts` List of STRING valued GTS whose values are to be parsed.\n\n",signature:"string<STRING> regexp<STRING>  SMARTPARSE  results<LIST<GTS>>\ngts<GTS> regexp<STRING>  SMARTPARSE  results<LIST<GTS>>\nlgts<LIST<GTS>> regexp<STRING>  SMARTPARSE  lresults<LIST<LIST<GTS>>>",tags:["gts","strings"],since:"1.2.13",OPB64name:"SMARTPARSE"},SNAPSHOT:{description:"The `SNAPSHOT` functions produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOT` was called.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*>  SNAPSHOT  snapshot<STRING>",tags:["stack"],since:"1.0.6",OPB64name:"SNAPSHOT"},SNAPSHOTALL:{description:"The `SNAPSHOTALL` functions acts similarly as [`SNAPSHOT`](/doc/SNAPSHOT) and produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOTALL` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*>  SNAPSHOTALL  snapshot<STRING>",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALL"},SNAPSHOTALLTOMARK:{description:"The `SNAPSHOTALLTOMARK` functions acts similarly as [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) and produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTALLTOMARK` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"mark<MARK> stack<ANY*>  SNAPSHOTALLTOMARK  snapshot<STRING>",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALLTOMARK"},SNAPSHOTCOPY:{description:"The `SNAPSHOTCOPY` function behaves like [`SNAPSHOT`](/doc/SNAPSHOT) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPY` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*>  SNAPSHOTCOPY  snapshot<STRING>",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPY"},SNAPSHOTCOPYALL:{description:"The `SNAPSHOTCOPYALL` function behaves like [`SNAPSHOTALL`](/doc/SNAPSHOTALL) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*>  SNAPSHOTCOPYALL  snapshot<STRING>",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALL"},SNAPSHOTCOPYALLTOMARK:{description:"The `SNAPSHOTCOPYALLTOMARK` function behaves like [`SNAPSHOTALLTOMARK`](/doc/SNAPSHOTALLTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*>  SNAPSHOTCOPYALLTOMARK  snapshot<STRING>",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALLTOMARK"},SNAPSHOTCOPYN:{description:"Performs a [`SNAPSHOTCOPY`](/doc/SNAPSHOTCOPY) on the top *N* elements of the stack.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*> n<LONG>  SNAPSHOTCOPYN  snapshot<STRING>",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTCOPYN"},SNAPSHOTCOPYTOMARK:{description:"The `SNAPSHOTCOPYTOMARK` function behaves like [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*>  SNAPSHOTCOPYTOMARK  snapshot<STRING>",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYTOMARK"},SNAPSHOTN:{description:"Produces a WarpScript code fragment which will regenerate the *N* top levels of the stack. The content of those levels is consumed off the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"stack<ANY*> n<LONG>  SNAPSHOTN  snapshot<STRING>",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTN"},SNAPSHOTTOMARK:{description:"The `SNAPSHOTTOMARK` functions produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTTOMARK` was called.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"mark<MARK> stack<ANY*>  SNAPSHOTTOMARK  snapshot<STRING>",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTTOMARK"},SORT:{description:"Sorts a Geo Time Series™ or each GTS of a list of GTS in ascending tick order.\n\n@param `gts` Single Geo Time Series™ instance to sort.\n\n@param `sgts` Sorted Geo Time Series™, this is the same instance as `gts`.\n\n@param `lgts` List of Geo Time Series™ instances to sort.\n\n@param `slist` List of sorted Geo Time Series™. Each instance is the same as the input one.\n\n",signature:"gts<GTS>  SORT  sgts<GTS>\nlgts<LIST<GTS>>  SORT  slist<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"SORT"},SORTBY:{description:"The `SORTBY` function sorts a **LIST** or a **MAP** according to a value returned by a macro. The macro must return a value of the same type (LONG, DOUBLE or STRING) for each element.\n\nOnly **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nBefore release `1.2.22`, the `SORTBY` function could only sort lists of Geo Time Series™.\n\nBefore release `2.7.0`, the `SORTBY` function could only sort lists but not maps.\n\n@param `macro` Macro used for sorting, consumes a list element off the stack and produces a LONG, DOUBLE or STRING value.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",signature:"list<LIST> macro<MACRO>  SORTBY  lsorted<LIST>\nmap<MAP> macro<MACRO>  SORTBY  msorted<MAP>",tags:["lists","gts"],since:"1.0.11",OPB64name:"SORTBY"},SORTWITH:{description:"The `SORTWITH` function sorts a **LIST** or a **MAP** according to a value returned by a comparison macro. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nIn used a on **LIST**, the comparison macro is given 2 elements of the **LIST** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest element in the stack is respectively strictly less than, equal to or strictly more than than the element on the stack.\n\nIn used a on **MAP**, the comparison macro is given 2 entries (key deepest, value shallowest) of the **MAP** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest entry in the stack is respectively strictly less than, equal to or strictly more than than the shallowest entry on the stack.\n\nBefore release `2.7.0`, the `SORTWITH` function could only sort lists but not maps.\n\n@param `macro` Macro used for comparison, must consume two elements of the stack and produces a LONG.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",signature:"list<LIST> macro<MACRO>  SORTWITH  lsorted<LIST>\nmap<MAP> macro<MACRO>  SORTWITH  msorted<MAP>",tags:["lists","gts"],since:"2.2.0",OPB64name:"SORTWITH"},SPLIT:{description:"The SPLIT function split a string in segments given a delimiter.\n\n\nIt consumes two parameters from the top of the stack: the delimiter and the string to test matching with. The delimiter must be a string of length 1, i.e. only one character.\n\n\nThe function will return a list with all the segments. If delimiter is not found, the output list contains the input string.\n\n@param `delimiter` One character delimiter.\n\n@param `s` The string to split\n\n@param `result` List of strings.\n\n",signature:"s<STRING> delimiter<STRING>  SPLIT  result<LIST<STRING>>",tags:["strings"],since:"1.0.0",OPB64name:"SPLIT"},SQRT:{description:"The `SQRT` function consumes a numeric parameter from the top of the stack and pushes back its square root.\n\nFor negative numbers, SQRT returns NaN.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Square root of the given value, NaN if it is negative.\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of square root of each given value, NaN if it is negative.\n\n",signature:"value<NUMBER>  SQRT  result<DOUBLE>\nlvalue<LIST<NUMBER>>  SQRT  lresult<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"SQRT"},SRAND:{description:"The `SRAND` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThe seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",signature:" SRAND  num<DOUBLE>",tags:["math"],since:"1.2.9",OPB64name:"SRAND"},SRANDPDF:{description:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe randomization is seeded. The seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThe result is a function. This function does not have any arguments.\n\nTo use the function pushed by `SRANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",signature:"valueHistogram<MAP>  SRANDPDF  result<STRING>",tags:["math","statistics"],since:"2.2.1",OPB64name:"SRANDPDF"},STACKATTRIBUTE:{description:"Retrieves the value of a stack attribute.\n\n@param `name` Name of the stack attribute to retrieve.\n\n@param `value` Associated value or null if attribute is not set.\n\n",signature:"name<STRING>  STACKATTRIBUTE  value<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"STACKATTRIBUTE"},STACKPSSECRET:{description:"Modifies the secret needed for using functions such as `WSPS`, `WSSTOP` and `WSKILL`.\n\nThis function is only useable if a secret was configured using `stackps.secret`.\n\n@param `secret` Current secret for process status operations, initially the value configured via `stackps.secret`.\n\n@param `newsecret` New secret to set for process status operations.\n\n",signature:"newsecret<STRING> secret<STRING>  STACKPSSECRET ",tags:["extensions","platform"],since:"2.5.0",OPB64name:"STACKPSSECRET"},STACKTOLIST:{description:"Converts the whole stack into a list and pushes this list on top of the stack. The elements are consumed off the stack in the way [`->LIST`](/doc/AItBHKCJ) does it.\n\n@param `stack` Content of the stack.\n\n@param `list` List containing the elements of the stack.\n\n",signature:"stack<ANY*>  STACKTOLIST  list<LIST>",tags:["stack"],since:"1.0.14",OPB64name:"STACKTOLIST"},STANDARDIZE:{description:"Standardizes a single (or a list of) numeric Geo Time Series™ (i.e. it replaces X by (X-mu)/sd).\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n",signature:"gts<GTS>  STANDARDIZE  result<GTS>\ngtsList<LIST<GTS>>  STANDARDIZE  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"STANDARDIZE"},STDERR:{description:"The `STDERR` function prints text to the standard error stream.\n\nThe `STDERR` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",signature:"msg<STRING>  STDERR ",tags:["extensions"],since:"1.0.0",OPB64name:"STDERR"},STDOUT:{description:"The `STDOUT` function prints text to the standard output stream.\n\nThe `STDOUT` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `obj` The object to print. Its `.toString()` method is used to generate the outputed String.\n\n",signature:"obj<ANY>  STDOUT ",tags:["extensions"],since:"1.0.0",OPB64name:"STDOUT"},STL:{description:'The `STL` function applies a Seasonal Trend decomposition on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is based on multiple calls of [`RLOWESS`](/doc/RLOWESS).\n\nThese Geo Time Series™ are the seasonal part and the trend part of the input Geo Time Series™. Their classnames are suffixed with "_seasonal" and "_trend".\n\nThis function can only be applied to [bucketized](/doc/BUCKETIZE) Geo Time Series™ of numeric type.\n\nThe **MAP** parameter must have at least the field `PERIOD`. You can provide additional optional parameters:\n\n## Optional parameters\n### Global\n- `ROBUST` if TRUE, set defaults of number of inner and outer loops to 1 and 15 instead of 2 and 0. Default is FALSE\n- `PRECISION` number of inner loops (a LONG). Default is 2 or 1\n- `ROBUSTNESS` number of outer loops (a LONG). Default is 0 or 15\n\n### Seasonal extract\n- `BANDWIDTH_S` the bandwidth (a LONG) of the local regression. Default is 7\n- `DEGREE_S` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_S` the number of values interpolated instead of estimated. Default is BANDWIDTH_S/10\n\n### Low frequency filtering\n- `BANDWIDTH_L` the bandwidth (a LONG) of the local regression. Default is nextOdd(PERIOD)\n- `DEGREE_L` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_L` the number of values interpolated instead of estimated. Default is BANDWIDTH_L/10\n\n### Trend extract\n- `BANDWIDTH_T` the bandwidth (a LONG) of the local regression. Default is nextOdd(ceiling(1.5*PERIOD/(1-(1.5/BANDWIDTH_S))))\n- `DEGREE_T` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_T` the number of values interpolated instead of estimated. Default is BANDWIDTH_T/10\n\n### Post seasonal smoothing\n- `BANDWIDTH_P` the bandwidth (a LONG) of the local regression. Default is 0 (i.e. no post smoothing)\n- `DEGREE_P` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_P` the number of values interpolated instead of estimated. Default is BANDWIDTH_P/10\n\n### Additional fields\n- `BANDWIDT` value of all BANDWIDTH_X fields that are not set\n- `DEGREE` value of all DEGREE_X fields that are not set\n- `SPEED` value of all SPEED_X fields that are not set\n\n> ### REFERENCE\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `p` The number of buckets that compose a period\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n',signature:"gts<GTS> { p<LONG>  } STL  result<GTS>\ngtsList<LIST<GTS>> { p<LONG>  } STL  resultList<LIST<GTS>>",tags:["gts","bucketize"],since:"1.0.0",OPB64name:"STL"},STLESDTEST:{description:'The \'STLESDTEST\' function detects outliers in a Geo Time Series™ (or a **LIST** of Geo Time Series™) which has a seasonal part.\n\nThe seasonal part and the trend part of the Geo Time Series™ are extracted using [`STL`](/doc/STL) decomposition, then an [`ESDTEST`](/doc/ESDTEST) is performed on the remainder.\n\nThis function only applies to [bucketized](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ### References\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n> **Rosner, Bernard (May 1983)**, "Percentage Points for a Generalized ESD Many-Outlier Procedure",Technometrics, 25(2), pp. 165-172.\n\n@param `STLOption` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `p` The number of buckets that compose a period\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `resultList` A **LIST** of ticks corresponding to the outliers\n\n@param `result` A **LIST** of LIST of ticks corresponding to the outliers\n\n',signature:"gts<GTS> p<LONG> k<LONG> alpha<DOUBLE> STLOption<MAP>  STLESDTEST  result<LIST<LONG>>\ngts<GTS> p<LONG> k<LONG> alpha<DOUBLE>  STLESDTEST  result<LIST<LONG>>\ngts<GTS> p<LONG> k<LONG> STLOption<MAP>  STLESDTEST  result<LIST<LONG>>\ngts<GTS> p<LONG> k<LONG>  STLESDTEST  result<LIST<LONG>>\ngtsList<LIST<GTS>> p<LONG> k<LONG> alpha<DOUBLE> STLOption<MAP>  STLESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> p<LONG> k<LONG> alpha<DOUBLE>  STLESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> p<LONG> k<LONG> STLOption<MAP>  STLESDTEST  resultList<LIST<LIST<LONG>>>\ngtsList<LIST<GTS>> p<LONG> k<LONG>  STLESDTEST  resultList<LIST<LIST<LONG>>>",tags:["outlier","gts"],since:"1.0.0",OPB64name:"STLESDTEST"},STOP:{description:"The `STOP` function stops the current execution by throwing a `WarpScriptStopException`. This means that the current script execution will be aborted unless the call to `STOP` was in a macro invoked via [`TRY`](/doc/TRY).\n\n",signature:"",tags:["stack","debug"],since:"1.0.0",OPB64name:"STOP"},STORE:{description:"The `STORE` function stores a value in a symbol.\n\nSince 2.7, when the list of symbols contains duplicates only the last occurence in the list is assigned to its corresponding value.\n\n@param `symbol` Name of the symbol to modify.\n\n@param `register` Index of the register to modify.\n\n@param `symbols` List of symbols or registers to modify. The last element of the list will contain the top of the stack.\n\n@param `value` Value to store under `symbol`.\n\n@param `values` Multiple values to store in `symbols`.\n\n",signature:"value<ANY> symbol<STRING>  STORE \nvalue<ANY> register<LONG>  STORE \nvalues<ANY*> symbols<LIST<STRING>>  STORE ",tags:["stack"],since:"1.0.0",OPB64name:"STORE"},STRICTMAPPER:{description:"Wraps a *mapper* in such a way that the mapper will only be called if the number of ticks in the window is in the specified range.\n\nSince 2.1 STRICTMAPPER can also take a timespan definition by inputing negative numbers. Number of ticks and timespan can also be mixed to specify, for instance, more than 2 points but less than 5 seconds.\n\n@param `max` If positive, maximum number of ticks in the window. If negative, maximum timespan of the window.\n\n@param `min` If positive, minimum number of ticks in the window. If negative, minimum timespan of the window.\n\n@param `mapper` Mapper to wrap.\n\n@param `wrapped` Wrapped mapper.\n\n",signature:"mapper<AGGREGATOR> min<NUMBER> max<NUMBER>  STRICTMAPPER  wrapped<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"STRICTMAPPER"},STRICTPARTITION:{description:"The `STRICTPARTITION` splits a Geo Time Series™ list in equivalence classes based on label values just like [`PARTITION`](/doc/PARTITION) but only retains in each equivalence class key the labels on which the partitioning was done.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels`.\n\n",signature:"lgts<LIST<GTS>> labels<LIST<STRING>>  STRICTPARTITION  result<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"STRICTPARTITION"},STRICTREDUCER:{description:"Wraps a *reducer* so it is only applied if there are values for all the Geo Time Series™ being reduced.\n\n@param `reducer` Reducer to wrap.\n\n@param `wrapped` Wrapped version of the reducer.\n\n",signature:"reducer<AGGREGATOR>  STRICTREDUCER  wrapped<AGGREGATOR>",tags:["reducer"],since:"1.0.6",OPB64name:"STRICTREDUCER"},STRINGFORMAT:{description:"The STRINGFORMAT function format a String in the same ways as Java [String.format](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.util.Locale-java.lang.String-java.lang.Object...-) does.\n\nThis fonction consumes an optional locale in [ISO 639](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry), a list of Objects to be used in the format string and a [format string](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax).\n\nIf no locale is specified, it defaults to the default JVM locale.\n\n@param `format` A format string.\n\n@param `args` Arguments referenced by the format specifiers in the format string.\n\n@param `locale` The locale to apply during formatting.\n\n@param `formattedString` A formatted string.\n\n",signature:"format<STRING> args<LIST>  STRINGFORMAT  formattedString<STRING>\nformat<STRING> args<LIST> locale<STRING>  STRINGFORMAT  formattedString<STRING>",tags:["strings"],since:"2.2.0",OPB64name:"STRINGFORMAT"},STU:{description:"The `STU` function pushes onto the stack the number of platform time units in one second. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one second.\n\n",signature:" STU  numberTimeUnits<LONG>",tags:["date","time","platform"],since:"1.0.0",OPB64name:"STU"},SUBLIST:{description:"It creates a new list with the elements of the base list whose indices are in the argument list.\n\nIf the argument list contains two indices [a,b] then `SUBLIST` returns the list of elements from index a to index b (included). If the argument list contains more than two indices, the result of `SUBLIST` contains all the elements at the specified indices, with possible duplicates.\n\nNegative indexing is allowed, with negative index effectively refering to index + size.\n\nSince 2.1 a new signature allowing the step to be defined has been introduced. Instead of specifying a list has range, you can put the start, end (optional) and step (optional) as **LONG** values.\n\n@param `arguments` List of indices. Negative indices are considered to be calculated from the end of the list.\n\n@param `base` Base list\n\n@param `result` Filtred list\n\n@param `start` The first index to consider, will be included.\n\n@param `end` The last index to consider, will be included. If not specified, defaults to -1.\n\n@param `step` The delta between two consecutive indexes to consider. If end is after start in the list, step must be strictly positive. If start is after end in the list, step must be strictly negative. If not specified, defaults to 1 or -1 depending on start and end.\n\n",signature:"base<LIST<ANY>> arguments<LIST<LONG>>  SUBLIST  result<LIST<ANY>>\nbase<LIST<ANY>> start<NUMBER>  SUBLIST  result<LIST<ANY>>\nbase<LIST<ANY>> start<NUMBER> end<NUMBER>  SUBLIST  result<LIST<ANY>>\nbase<LIST<ANY>> start<NUMBER> end<NUMBER> step<NUMBER>  SUBLIST  result<LIST<ANY>>",tags:["lists"],since:"1.0.0",OPB64name:"SUBLIST"},SUBMAP:{description:"It creates a new map with the key-value pairs from the base map whose keys are in the argument list.\n\n@param `arguments` List of indices.\n\n@param `base` Base map\n\n@param `result` Filtred map\n\n",signature:"base<MAP> arguments<LIST<STRING>>  SUBMAP  result<MAP>",tags:["maps"],since:"1.0.0",OPB64name:"SUBMAP"},SUBSTRING:{description:"Extract a substring from a **STRING** input, or a subarray from a **BYTE ARRAY** input.  \nIf the length is ommitted, it extracts until the end of the string or byte array. If length is greater than max length, extract stops at the input end.\n\nIf the start is greater than the input size, `SUBSTRING` raises an error.\n\nSince 2.1, the start index can be negative. In this case the effective index is index + size of the **STRING**.\n\n@param `len` Length of substring to extract.\n\n@param `start` First character to include in the substring (0 based).\n\n@param `str` String from which to extract a substring.\n\n@param `substr` Extracted substring.\n\n@param `array` Byte array from which to extract a sub array.\n\n@param `subarray` Extracted sub array.\n\n",signature:"str<STRING> start<LONG> len<LONG>  SUBSTRING  substr<STRING>\nstr<STRING> start<LONG>  SUBSTRING  substr<STRING>\narray<BYTES> start<LONG> len<LONG>  SUBSTRING  subarray<BYTES>\narray<BYTES> start<LONG>  SUBSTRING  subarray<BYTES>",tags:["strings","binary"],since:"1.0.0",OPB64name:"SUBSTRING"},SUBTRACTEXACT:{description:"The `SUBTRACTEXACT` function consumes two LONGs from the top of the stack and puts back the difference between them. If the difference overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `diff` The difference of x and y\n\n@param `list` List of numeric values\n\n@param `sdiff` The first element of the list minus all the others\n\n@param `lx` List of numeric values\n\n@param `ldiff` List of **LONG** where each value is the difference of y and an element in lx\n\n",signature:"x<NUMBER> y<NUMBER>  SUBTRACTEXACT  diff<LONG>\nlist<LIST<NUMBER>>  SUBTRACTEXACT  sdiff<LONG>\nlx<LIST<NUMBER>> y<NUMBER>  SUBTRACTEXACT  ldiff<LIST<LONG>>",tags:["math"],since:"1.2.23",OPB64name:"SUBTRACTEXACT"},SWAP:{description:"Exchanges the positions of the top two elements of the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n",signature:"level2<ANY> top<ANY>  SWAP  top<ANY> level2<ANY>",tags:["stack"],since:"1.0.0",OPB64name:"SWAP"},SWITCH:{description:"Performs a [switch statement](https://en.wikipedia.org/wiki/Switch_statement) allowing to select a macro execution based on a series of condition macros or to fallback on to the execution of a default macro.\n\n@param `n` Number of cases to consider. The `SWITCH` function will expect `n` pairs of condition/execution macros plus a default macro on the stack.\n\n@param `default` Macro which will be executed if all condition macros returned false.\n\n@param `cond1` First condition macro. All condition macros are expected to push a boolean on the stack.\n\n@param `condn` `n`th condition macro.\n\n@param `exec1` First execution macro, this macro will be executed if `cond1` left `true` on the stack.\n\n@param `execn` `n`th execution macro.\n\n",signature:"cond1<MACRO> exec1<MACRO> condn<MACRO> execn<MACRO> default<MACRO> n<LONG>  SWITCH ",tags:["control"],since:"1.0.0",OPB64name:"SWITCH"},SYMBOLS:{description:"The `SYMBOLS` function outputs the list of all defined symbols.\n\n@param `symbols` The list of the names of all defined symbols.\n\n",signature:" SYMBOLS  symbols<LIST>",tags:["stack"],since:"2.2.1",OPB64name:"SYMBOLS"},SYNC:{description:"Executes a macro in a synchronized way while in a parallel execution triggered by a call to [`CEVAL`](/doc/CEVAL). If `SYNC` is called outside of a parallel execution, it simply executes the macro.\n\nWhen called within a `CEVAL` execution, the use of `SYNC` guarantees that only one of the concurrently executing threads will execute the specified macro at any given time.\n\n@param `macro` Macro to execute in a synchronized way.\n\n",signature:"macro<MACRO>  SYNC ",tags:["extensions"],since:"1.0.0",OPB64name:"SYNC"},T:{description:"`T` stand for `true`. It is a boolean constant.\n\n\n@param `b` true\n\n",signature:" T  b<BOOLEAN>",tags:["logic","constants"],since:"1.0.0",OPB64name:"T"},TAN:{description:"The `TAN` function consumes a floating point number from the top of the stack and pushes back its tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Tangent of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of tangent of the given values.\n\n",signature:"value<NUMBER>  TAN  result<DOUBLE>\nlvalue<LIST<NUMBER>>  TAN  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TAN"},TANH:{description:"The `TANH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic tangent of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic tangent of the given values.\n\n",signature:"value<NUMBER>  TANH  result<DOUBLE>\nlvalue<LIST<NUMBER>>  TANH  lresult<LIST<DOUBLE>>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TANH"},TDESCRIBE:{description:"The `TDESCRIBE` function is a recursive [`TYPEOF`](/doc/TYPEOF).\n\nWhen `TDESCRIBE` finds a LIST, it takes the first element of the list to look for his type. When `TDESCRIBE` finds a MAP, it takes a random key in the map to look for the type of the key and the type of the value.\n\n**By design, TDESCRIBE cannot describe heterogeneous lists or maps.**\n\nTDESCRIBE output is subject to change in the future. Do not try to parse it. This function is here to help you during Warpscript development.\n\n\nThe `TDESCRIBE` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `object` Any kind of reference\n\n@param `description` The description of the object\n\n",signature:"object<ANY>  TDESCRIBE  description<STRING>",tags:["extensions","debug"],since:"1.2.19",OPB64name:"TDESCRIBE"},TEMPLATE:{description:"`TEMPLATE` fills a template with values contained in a map. See example for syntax help.\n\nThe `TEMPLATE` function expects the map of values on top of the stack and will operate on the string template below it.\n\nValues speficied with `{{key}}` will be url-escaped. If you do not want that behavior, use `{{{key}}}`.\n\n@param `dictionnary` Each key will be replaced in a {{key}} template. Value could be string long, double, boolean, or a list of maps. If Value is a list of maps, each subkey/value will be replaced in a {{#key}}{{subkey}}{{/key}} template. \n\n@param `listofmaps` Contains a list of subkey/value map. Will be replaced in a {{#key}}{{subkey}}{{/key}} template.\n\n@param `template` Input template.\n\n@param `output` Result of substitution.\n\n",signature:"template<STRING> dictionnary<MAP>  TEMPLATE  output<STRING>\ntemplate<STRING> listofmaps<LIST<MAP>>  TEMPLATE  output<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"TEMPLATE"},THRESHOLDTEST:{description:"Analyzes Geo Time Series™, identifying ticks where values are outliers above the given threshold.\n\n@param `threshold` Threshold above which values are considered outliers.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `ticks` List of ticks where outliers were found.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lticks` List of lists of ticks where outliers were found.\n\n",signature:"gts<GTS> threshold<DOUBLE>  THRESHOLDTEST  ticks<LIST<LONG>>\nlgts<LIST<GTS>> threshold<DOUBLE>  THRESHOLDTEST  lticks<LIST<LIST<LONG>>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"THRESHOLDTEST"},TICKINDEX:{description:"Creates a clone of a Geo Time Series™, replacing each tick with the index (0 based) at which it appears at the moment of the call.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `encoder` Geo Time Series™ Encoder instance to transform.\n\n@param `indexed` Transformed GTS.\n\n@param `indexedenc` Transformed GTS Encoder.\n\n@param `lgts` List of Geo Time Series™ instances to transform.\n\n@param `lencoder` List of Geo Time Series™ Encoder instances to transform.\n\n@param `lindexed` List of indexed Geo Time Series™.\n\n@param `lindexedenc` List of indexed Geo Time Series™ Encoder.\n\n",signature:"gts<GTS>  TICKINDEX  indexed<GTS>\nlgts<LIST<GTS>>  TICKINDEX  lindexed<LIST<GTS>>\nencoder<GTSENCODER>  TICKINDEX  indexedenc<GTSENCODER>\nlencoder<LIST<GTSENCODER>>  TICKINDEX  lindexedenc<LIST<GTSENCODER>>",tags:["gts"],since:"1.0.0",OPB64name:"TICKINDEX"},TICKLIST:{description:"Pushes onto the stack the list of ticks of a Geo Time Series™ or encoder. The ticks appear in the order in which they are found.\n\nIf a list of Geo Time Series™ is given, the result is a list of list of ticks as if the TICKLIST function was applied to each Geo Time Series™ separately.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n@param `encoder` Instance of encoder from which to extract the ticks.\n\n@param `lencoder` List of encoders.\n\n@param `ticks` List of extracted ticks.\n\n@param `lticks` List of lists of ticks.\n\n",signature:"gts<GTS>  TICKLIST  ticks<LIST<LONG>>\nlgts<LIST<GTS>>  TICKLIST  lticks<LIST<LIST<LONG>>>\nencoder<GTSENCODER>  TICKLIST  ticks<LIST<LONG>>\nlencoder<LIST<GTSENCODER>>  TICKLIST  lticks<LIST<LIST<LONG>>>",tags:["gts"],since:"1.0.0",OPB64name:"TICKLIST"},TICKS:{description:"Pushes onto the stack the sorted list of **distinct** ticks of a Geo Time Series™. If a list of Geo Time Series™ is given, all the **distinct** ticks are returned in a single sorted list as if all Geo Time Series™ were merged.\n\nThis function is not to be confused with [`TICKLIST`](/doc/TICKLIST) as this function returns **distinct** ticks and acts as it merges Geo Time Series™.\n\n@param `ticks` List of extracted ticks.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n",signature:"gts<GTS>  TICKS  ticks<LIST<LONG>>\nlgts<LIST<GTS>>  TICKS  ticks<LIST<LONG>>",tags:["gts"],since:"1.0.0",OPB64name:"TICKS"},TIMEBOX:{description:"The `TIMEBOX` executes a macro with a maximum execution time. If the maximum time is reached, an exception will be thrown which can be caught using [`TRY`](/doc/TRY).\n\n@param `maxtime` Maximum execution time, in platform time units.\n\n@param `macro` Macro to execute.\n\n",signature:"macro<MACRO> maxtime<LONG>  TIMEBOX ",tags:["platform"],since:"2.0.3",OPB64name:"TIMEBOX"},TIMECLIP:{description:"Clips Geo Time Series™ instances by restricting their ticks to those within a time interval.      \n\n@param `duration` Width of the time interval to retain, in time units.\n\n@param `end` Most recent timestamp to retain.\n\n@param `start` Start timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `stop` End timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `clipped` Clipped Geo Time Series™.\n\n@param `lclipped` List of clipped GTS.\n\n@param `encoder` Single GTS Encoder instance.\n\n@param `lencoder` List of GTS Encoder instances.\n\n@param `clippedEncoder` Clipped GST encoder.\n\n@param `lclippedEncoders` List of clipped GTS encoders.\n\n",signature:"gts<GTS> end<LONG> duration<LONG>  TIMECLIP  clipped<GTS>\nlgts<LIST<GTS>> end<LONG> duration<LONG>  TIMECLIP  lclipped<LIST<GTS>>\ngts<GTS> stop<STRING> start<STRING>  TIMECLIP  clipped<GTS>\nlgts<LIST<GTS>> stop<STRING> start<STRING>  TIMECLIP  lclipped<LIST<GTS>>\nencoder<GTSENCODER> end<LONG> duration<LONG>  TIMECLIP  clippedEncoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> end<LONG> duration<LONG>  TIMECLIP  lclippedEncoders<LIST<GTSENCODER>>\nencoder<GTSENCODER> stop<STRING> start<STRING>  TIMECLIP  clippedEncoder<GTSENCODER>\nlencoder<LIST<GTSENCODER>> stop<STRING> start<STRING>  TIMECLIP  lclippedEncoders<LIST<GTSENCODER>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMECLIP"},TIMED:{description:"The `TIMED` function converts a macro to a timed macro, recording its execution time and its number of calls.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\n@param `name` A name identifying the macro.\n\n@param `macro` The macro you want to monitor.\n\n@param `timedMacro` A macro which, when called, will update the statitics associated with the given name.\n\n",signature:"macro<MACRO> name<STRING>  TIMED  timedMacro<MACRO>",tags:["debug"],since:"2.1.0",OPB64name:"TIMED"},TIMEMODULO:{description:"Splits Geo Time Series™ into sub-GTS whose timestamps are the original timestamp modulo a given modulus value. Each sub-GTS will bear a label with the quotient of the original timestamps divided by the modulus. The output list order is not guaranteed, use [`SORTBY`](/doc/SORTBY) if you want to order the output by label.\n\nThis function can be used to generate for example one Geo Time Series™ per day with ticks from 0 to 86400 s (excluded).\n\n@param `label` Name of the label which will have the quotient value.\n\n@param `modulus` Value by which to divide the original timestamps.\n\n@param `gts` Geo Time Series™ to split.\n\n@param `splits` Resulting splits.\n\n@param `lgts` List of GTS to split.\n\n@param `lsplits` List of lists of resulting splits.\n\n",signature:"gts<GTS> modulus<LONG> label<STRING>  TIMEMODULO  splits<LIST<GTS>>\nlgts<LIST<GTS>> modulus<LONG> label<STRING>  TIMEMODULO  lsplits<LIST<LIST<GTS>>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMEMODULO"},TIMEOFF:{description:"Turns off the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:" TIMEOFF ",tags:["stack"],since:"2.0.0",OPB64name:"TIMEOFF"},TIMEON:{description:"Turns on the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:" TIMEON ",tags:["stack"],since:"2.0.0",OPB64name:"TIMEON"},TIMESCALE:{description:"Modifies the ticks of Geo Time Series™ instances by multiplying each tick by a provided scale.      \n\nThe resulting tick will be converted to a LONG after multiplication by the scale.\n\nIf the Geo Time Series™ instance is bucketized, the `lastbucket` and `bucketspan` parameters will also be scaled. If the scale would incur a `bucketspan` of 0, the call will end with an error.\n\n@param `scale` Scale by which to multiply each tick.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `scaled` Geo Time Series™ result.\n\n@param `lscaled` List of Geo Time Series™ result.\n\n",signature:"gts<GTS> scale<DOUBLE>  TIMESCALE  scaled<GTS>\ngts<GTS> scale<LONG>  TIMESCALE  scaled<GTS>\nlgts<LIST<GTS>> scale<DOUBLE>  TIMESCALE  lscaled<LIST<GTS>>\nlgts<LIST<GTS>> scale<LONG>  TIMESCALE  lscaled<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMESCALE"},TIMESHIFT:{description:"Shifts the ticks of Geo Time Series™ instances by a given amount.\n\n@param `offset` Offset to apply to the ticks, in time units.\n\n@param `gts` Single Geo Time Series™ instance to shift.\n\n@param `lgts` List of GTS to shift.\n\n@param `shifted` Shifted Geo Time Series™.\n\n@param `lshifted` List of shifted Geo Time Series™.\n\n",signature:"gts<GTS> offset<LONG>  TIMESHIFT  shifted<GTS>\nlgts<LIST<GTS>> offset<LONG>  TIMESHIFT  lshifted<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMESHIFT"},TIMESPLIT:{description:"The `TIMESPLIT` functions splits Geo Time Series™ instances based on *quiet periods*, *i.e.* periods during which the GTS has no values.\n\nWhenever a quiet period longer than a minimum duration is encountered, the Geo Time Series™ is split.\n\nIf input gts has no values or if 'label' is already part of the labels of 'gts', then the resulting list of GTS will only contain a clone of 'gts'. **Make sure to test your GTS split size if needed.**\n\n@param `label` Name of label in which to store the sequence number.\n\n@param `minvalues` Minimum number of values a split should contain. Splits with less than that many values will be discarded.\n\n@param `quietperiod` Minimum duration of the silent period (*i.e.* with no values) between splits.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n",signature:"gts<GTS> quietperiod<LONG> minvalues<LONG> label<STRING>  TIMESPLIT  splits<LIST<GTS>>\nlgts<LIST<GTS>> quietperiod<LONG> minvalues<LONG> label<STRING>  TIMESPLIT  lsplits<LIST<LIST<GTS>>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMESPLIT"},TIMINGS:{description:"Turns on the collection of timing information for each line of the script. The collected timings can be put onto the stack by using [`ELAPSED`](/doc/ELAPSED).\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"TIMINGS"},TLTTB:{description:"The `TLTTB` function performs downsampling of Geo Time Series™ by applying the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data. It differs from the [`LTTB`](doc/LTTB) function by the fact that it considers time based buckets instead of buckets based on a number of values.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",signature:"gts<GTS> samples<LONG>  TLTTB  downsampled<GTS>\nlgts<LIST<GTS>> samples<LONG>  TLTTB  ldownsampled<LIST<GTS>>",tags:["gts"],since:"1.0.11",OPB64name:"TLTTB"},TOBIN:{description:"Converts the long on top of the stack to its 64 bits binary representation.\n\n@param `param` value to convert\n\n@param `result` String converted binary representation of param\n\n",signature:"param<LONG>  TOBIN  result<STRING>",tags:["conversion","strings","binary"],since:"1.0.0",OPB64name:"TOBIN"},TOBITS:{description:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n**Deprecation notice** the `TOBITS` function will be removed, please use `->DOUBLEBITS` or `->FLOATBITS`.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",signature:"number<NUMBER>  TOBITS  bits<LONG>\ngts<GTS>  TOBITS  longgts<GTS>",tags:["math","gts"],since:"1.0.0",OPB64name:"TOBITS"},TOBOOLEAN:{description:"Converts a value of primitive type into a boolean value.\n\nThe `TOBOOLEAN` function consumes a parameter from the top of the stack and pushes back its conversion to boolean.\nNumbers will be false if they are equal to 0 and true otherwise.\nStrings will be false if they are equals to '' and true otherwise.\n\n@param `value` The value of primitive type\n\n@param `result` The boolean conversion of the value\n\n",signature:"value<BOOLEAN>  TOBOOLEAN  result<BOOLEAN>\nvalue<NUMBER>  TOBOOLEAN  result<BOOLEAN>\nvalue<STRING>  TOBOOLEAN  result<BOOLEAN>",tags:["conversion"],since:"1.0.5",OPB64name:"TOBOOLEAN"},TODEGREES:{description:"Converts an angle measured in radians to its equivalent in degrees.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from radians to degrees.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in radian to convert in degree\n\n@param `result` Result of the conversion from radians to degrees\n\n@param `langle` List of angles in radian to convert in degree\n\n@param `lresult` List of results of the conversion from radians to degrees\n\n",signature:"angle<NUMBER>  TODEGREES  result<DOUBLE>\nlangle<LIST<NUMBER>>  TODEGREES  lresult<LIST<DOUBLE>>",tags:["conversion"],since:"1.0.0",OPB64name:"TODEGREES"},TODOUBLE:{description:"Converts a value of primitive type into a double value.\n\nThe `TODOUBLE` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to double.\n\n@param `value` The value of primitive type\n\n@param `result` The double conversion of the value\n\n",signature:"value<BOOLEAN>  TODOUBLE  result<DOUBLE>\nvalue<NUMBER>  TODOUBLE  result<DOUBLE>\nvalue<STRING>  TODOUBLE  result<DOUBLE>",tags:["conversion"],since:"1.0.0",OPB64name:"TODOUBLE"},TOHEX:{description:"Converts a long to its 64 bits hexadecimal representation.\n\n@param `input` Signed long integer.\n\n@param `output` Hexadecimal string representation of input.\n\n",signature:"input<LONG>  TOHEX  output<STRING>",tags:["conversion"],since:"1.0.0",OPB64name:"TOHEX"},TOINTEXACT:{description:"The `TOINTEXACT` function consumes one LONG from the top of the stack and puts back the value. If the result overflows an INT, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be checked not to overflow an INT\n\n@param `result` The given value, converted to Long\n\n@param `lvalue` List of values to be checked not to overflow an INT\n\n@param `lresult` List of given values, converted to Long\n\n",signature:"value<NUMBER>  TOINTEXACT  result<LONG>\nlvalue<LIST<NUMBER>>  TOINTEXACT  lresult<LIST<LONG>>",tags:["math"],since:"1.2.23",OPB64name:"TOINTEXACT"},TOKENDUMP:{description:"Deciphers a token and outputs a map describing the various elements of the token.\n\nThe map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Original token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| params | MAP | Map of token parameters, can be used as input to [`TOKENGEN`](/doc/TOKENGEN) |\n\nThe `params` map contains the following entries for both `READ` and `WRITE` tokens:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| type  | STRING | `READ` or `WRITE` depending on the type of token |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in ms since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in ms since the Unix Epoch |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nAdditionally, for `READ` tokens, the map contains those entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, those will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nNote that the `TOKENDUMP` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration key was not set.\n\n\n@param `token` Token to decode.\n\n@param `map` Map with the extracted parameters, the original token and its *ident*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENDUMP` from Worf.\n\n",signature:"token<STRING>  TOKENDUMP  map<MAP>\ntoken<STRING> secret<STRING>  TOKENDUMP  map<MAP>",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENDUMP"},TOKENGEN:{description:"Generates a token given a map of parameters. The `TOKENGEN` function outputs a map.\n\nThe input parameter map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| id | STRING | Optional identifier that will be put verbatim in the result map |\n| type  | STRING | `READ` or `WRITE` depending on the type of token to generate |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in **milliseconds** since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in **milliseconds** since the Unix Epoch |\n| ttl | LONG | If `expiry` is not specified, a time to live can be set with this key. The TTL is expressed in **milliseconds**, the computed expiry timestamp will be the issuance timestamp plus the ttl |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nWhen generating a `READ` token, the following parameters are needed to ensure data isolation:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, they will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nIf one of these parameter key is not set or set to an empty list, then the generated `READ` token will be granted access to all the scope associated with the parameter key. For example, if `owners` is not set, data from all owners will be accessible to this token.\n\nThe `TOKENGEN` function outputs a map with the following keys:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Generated token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| id | STRING | Optional identifier if the `id` key was specified in the parameter map |\n\nNote that the `TOKENGEN` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration was not set.\n\n@param `params` Map of parameters used to generate the token.\n\n@param `result` Map containing the token, its *ident* and an optional *id*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENGEN` from Worf.\n\n",signature:"params<MAP>  TOKENGEN  result<MAP>\nparams<MAP> secret<STRING>  TOKENGEN  result<MAP>",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENGEN"},TOKENINFO:{description:"Retrieves information from token.\n\nThe `TOKENINFO` function consumes a token from the top of the stack and pushes back a map containing the token information:\n* type: type of token 'Read' or 'Write'\n* issuance: timestamp of token creation, in **milliseconds** since the Unix Epoch \n* expiry: timestamp of token expiration, in **milliseconds** since the Unix Epoch \n* application: name of the application accessing the data\n* apps: list of applications whose data can be accessed (usually limited to a single application)\n\n@param `token` Token to extract informations\n\n@param `infos` Token informations extract from the tokens\n\n",signature:"token<STRING>  TOKENINFO  infos<MAP>",tags:["platform"],since:"1.0.0",OPB64name:"TOKENINFO"},TOKENSECRET:{description:"Modifies the secret needed for using `TOKENGEN` or `TOKENDUMP`.\n\nThis function is only useable if a secret was configured using `token.secret`.\n\n@param `secret` Current secret for token operations, initially the value configured via `token.secret`.\n\n@param `newsecret` New secret to set for token operations.\n\n",signature:"newsecret<STRING> secret<STRING>  TOKENSECRET ",tags:["extensions","platform"],since:"2.0.3",OPB64name:"TOKENSECRET"},TOLONG:{description:"Converts a value of primitive type or a **BYTE ARRAY** into a long value.\n\nThe `TOLONG` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to long.\n\n@param `value` The value of primitive type\n\n@param `result` The long conversion of the value\n\n@param `array` Maximum 8 bytes to convert to a LONG. Sign is kept.\n\n",signature:"value<BOOLEAN>  TOLONG  result<LONG>\nvalue<NUMBER>  TOLONG  result<LONG>\nvalue<STRING>  TOLONG  result<LONG>\narray<BYTES>  TOLONG  result<LONG>",tags:["conversion","binary"],since:"1.0.0",OPB64name:"TOLONG"},TOLOWER:{description:"Converts the **STRING** on top of the stack to lower case.\n\n@param `input` input string\n\n@param `output` Lower case string\n\n",signature:"input<STRING>  TOLOWER  output<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"TOLOWER"},TORADIANS:{description:"Converts an angle measured in degrees to its equivalent in radians.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from degrees to radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in degree to convert in radian\n\n@param `result` Result of the conversion from degree to radian\n\n@param `langle` List of angles in degree to convert in radian\n\n@param `lresult` List of results of the conversion from degree to radian\n\n",signature:"angle<NUMBER>  TORADIANS  result<DOUBLE>\nlangle<LIST<NUMBER>>  TORADIANS  lresult<LIST<DOUBLE>>",tags:["conversion"],since:"1.0.0",OPB64name:"TORADIANS"},TOSELECTOR:{description:"The `TOSELECTOR` function takes a Geo Time Series™ or Geo Time Series™ LIST from the top of the stack and, for each encountered GTS, replace it with a selector which would select it.\n\nThis selector can be used as input of [`PARSESELECTOR`](/doc/PARSESELECTOR) for a [`FETCH`](/doc/FETCH).\n\n@param `gts` The input Geo Time Series™.\n\n@param `gtslist` The input list of Geo Time Series™.\n\n@param `encoder` The input encoder.\n\n@param `encoderlist` The input list of encoders.\n\n@param `selector` The selector string.\n\n@param `selectorlist` The list of selector strings, one per GTS in gtslist.\n\n",signature:"gts<GTS>  TOSELECTOR  selector<STRING>\ngtslist<LIST<GTS>>  TOSELECTOR  selectorlist<LIST<STRING>>\nencoder<GTSENCODER>  TOSELECTOR  selector<STRING>\nencoderlist<LIST<GTSENCODER>>  TOSELECTOR  selectorlist<LIST<STRING>>",tags:["gts"],since:"1.0.0",OPB64name:"TOSELECTOR"},TOSTRING:{description:"Converts a value of primitive type into a string value.\n\nThe `TOSTRING` function consumes a parameter from the top of the stack and pushes back its conversion to string.\n\nNote that GTS are converted to input format and that the string ends with CRLF to follow HTTP recommendations.\n\n@param `value` The value of primitive type\n\n@param `result` The string conversion of the value\n\n",signature:"value<NUMBER>  TOSTRING  result<STRING>\nvalue<BOOLEAN>  TOSTRING  result<STRING>\nvalue<STRING>  TOSTRING  result<STRING>\nvalue<GTS>  TOSTRING  result<STRING>",tags:["strings","conversion"],since:"1.0.0",OPB64name:"TOSTRING"},TOTIMESTAMP:{description:"Converts a date in format ISO8601 into a timestamp in the platform's time unit.\n\nThe `TOTIMESTAMP` function consumes a string parameter (date + time + time zone) from the top of the stack and pushes back its conversion to a number of time units since the Unix Epoch.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nThe supported format is ISO8601 and are:\n* yyyy-mm-dddThh:mm:ss.ssssssZ\n* yyyy-mm-dddThh:mm:ss+hh:mm\n\nAs the string are URL encoded, the symbol + have to be replaced by %2B, otherwise a space will replace the + in the string.\n\n@param `input` ISO8601 string.\n\n@param `result` timestamp in the platform unit.\n\n",signature:"input<STRING>  TOTIMESTAMP  result<LONG>",tags:["conversion","date"],since:"1.0.0",OPB64name:"TOTIMESTAMP"},TOUPPER:{description:"Converts the **STRING** on top of the stack to upper case.\n\n@param `input` input string\n\n@param `output` Upper case string\n\n",signature:"input<STRING>  TOUPPER  output<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"TOUPPER"},TR:{description:"Computes the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a square matrix. If the input matrix is not square, an error is raised.\n\n@param `matrix` The square matrix for which to compute the trace.\n\n@param `trace` The computed trace.\n\n",signature:"matrix<MATRIX>  TR  trace<DOUBLE>",tags:["math"],since:"1.0.6",OPB64name:"TR"},TRANSPOSE:{description:"Computes the [transpose](https://en.wikipedia.org/wiki/Transpose) of a matrix.\n\n@param `matrix` Matrix to transpose.\n\n@param `transpose` The transpose of the original matrix.\n\n",signature:"matrix<MATRIX>  TRANSPOSE  transpose<MATRIX>",tags:["math"],since:"1.0.6",OPB64name:"TRANSPOSE"},TRIM:{description:"Trims whitespaces from both ends of the string on top of the stack.\n\n@param `str` String to trim\n\n@param `trimmedstr` String trimmed\n\n",signature:"str<STRING>  TRIM  trimmedstr<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"TRIM"},TRY:{description:"The `TRY` function provides a way to execute a macro in a safety harness with [Exception handling](https://en.wikipedia.org/wiki/Exception_handling).\n\nIf an error is thrown, it is recorded and will be available via [`ERROR`](/doc/ERROR).\n\n@param `try` Macro whose execution is *attempted*.\n\n@param `catch` Macro which will be executed if an error is encountered while executing the `try` macro.\n\n@param `finally` Macro which will be executed unconditionally after either the `try` or `try`/`catch` execution.\n\n",signature:"try<MACRO> catch<MACRO> finally<MACRO>  TRY ",tags:["control"],since:"1.2.11",OPB64name:"TRY"},TSELEMENTS:{description:"Alias of [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nThe `TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",signature:"timestamp<LONG>  TSELEMENTS  dateAndTimeElements<LIST<LONG>>\ntimestamp<LONG> timezone<STRING>  TSELEMENTS  dateAndTimeElements<LIST<LONG>>",tags:["date","time"],since:"1.0.0",OPB64name:"TSELEMENTS"},"TSELEMENTS->":{description:"The `TSELEMENTS->` function consumes an optional **STRING** timezone and a **LIST** of **LONG** describing a time and date and pushes back the **LONG** timestamp. The **LIST** of **LONG** follows the format given by [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",signature:"dateAndTimeElements<LIST<LONG>>  TSELEMENTS->  timestamp<LONG>\ndateAndTimeElements<LIST<LONG>> timezone<STRING>  TSELEMENTS->  timestamp<LONG>",tags:["date","time"],since:"1.2.0",OPB64name:"K4C4I3KCGJtJJmoy"},TYPEOF:{description:"Gets the type of an element.\n\nThe `TYPEOF` function consumes the top element on the stack and pushes back a string containing the type. The output could be:\n+ AGGREGATOR\n+ BITSET\n+ BOOLEAN\n+ BYTES\n+ CONTEXT\n+ COUNTER\n+ DOUBLE\n+ FILLER\n+ FILTER\n+ GEOSHAPE\n+ GTS\n+ GTSENCODER\n+ KEY\n+ LIST\n+ LONG\n+ MACRO\n+ MAP\n+ MARK\n+ MATCHER\n+ MATRIX\n+ NULL\n+ OPERATOR\n+ PFONT\n+ PGRAPHICS\n+ PIMAGE\n+ PSHAPE\n+ REDUCER\n+ SET\n+ STRING\n+ VECTOR\n+ VLIST\n\nFor any object introduced by a WarpScript extension whose output of TYPEOF is not in the list thereof, the output would be preceded by \"X-\".\n\nNote: since revision 2.5.0, the TYPEOF output of bucketizers, mappers, reducers is changed from 'MAPPER' to 'AGGREGATOR'.\n\n\n@param `object` Any kind of reference\n\n@param `type` The type of the object\n\n",signature:"object<ANY>  TYPEOF  type<STRING>",tags:["stack","debug"],since:"1.0.0",OPB64name:"TYPEOF"},UDF:{description:"The `UDF` function invokes a User Defined Function from a Jar. A new function instance is loaded at each invocation.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",signature:"class<STRING>  UDF ",tags:["control"],since:"1.0.0",OPB64name:"UDF"},ULP:{description:"Returns the size of the [ULP (Unit in the Last Place)](https://en.wikipedia.org/wiki/Unit_in_the_last_place) for the argument. The ulp for a DOUBLE is the positive distance between this floating-point value and the DOUBLE value next larger in magnitude.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `ulp` Computed ULP.\n\n@param `lvalue` List of numeric values.\n\n@param `lulp` List of computed ULPs.\n\n",signature:"value<NUMBER>  ULP  ulp<DOUBLE>\nlvalue<LIST<NUMBER>>  ULP  lulp<LIST<DOUBLE>>",tags:["math"],since:"1.0.0",OPB64name:"ULP"},UNBUCKETIZE:{description:"Transforms a bucketized Geo Time Series™ into a non bucketized one. Note that this function transforms the original GTS, it does not clone it.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™ instances.\n\n",signature:"gts<GTS>  UNBUCKETIZE  gts<GTS>\nlgts<LIST<GTS>>  UNBUCKETIZE  lgts<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"UNBUCKETIZE"},"UNBUCKETIZE.CALENDAR":{description:"On a GTS that is calendar-bucketized, this function replaces the ticks with the timestamp end boundaries of each bucket, and unbucketize it.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `lgts` One or more lists of Geo Time Series™\n\n",signature:"gts<GTS>  UNBUCKETIZE.CALENDAR  gts<GTS>\nlgts<LIST<GTS>>  UNBUCKETIZE.CALENDAR  lgts<LIST<GTS>>",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"UNBUCKETIZE.CALENDAR"},UNGZIP:{description:"Decompresses a byte array containing data compressed by [`GZIP`](doc/GZIP).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",signature:"compressed<BYTES>  UNGZIP  uncompressed<BYTES>",tags:["conversion"],since:"1.0.11",OPB64name:"UNGZIP"},UNION:{description:"Computes the union &#x222a; of two sets.\n\nThe `UNION` function consumes two sets from the top of the stack and pushes back its mathematical union.\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x222a; *B*\n\n",signature:"setA<SET> setB<SET>  UNION  output<SET>",tags:["sets"],since:"1.0.0",OPB64name:"UNION"},UNIQUE:{description:"The `UNIQUE` function eliminates duplicate elements on the LIST on the top of the stack.\nThe order of the resulting LIST is not the same than the original one.\n\nIt makes elements of a list unique by converting it to a set temporarily. See [()](/doc/91Z) for more informations.\n\n@param `input` The list to parse\n\n@param `output` The new list object, without any duplicates\n\n",signature:"input<LIST>  UNIQUE  output<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"UNIQUE"},UNLIST:{description:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`]`](/doc/MF).\n\n@param `list` List to expand.\n\n@param `elts` Elements of `list`.\n\n@param `mark` Instance of MARK.\n\n",signature:"list<LIST>  UNLIST  mark<MARK> elts<ANY*>",tags:["lists"],since:"1.0.11",OPB64name:"UNLIST"},UNMAP:{description:"Unpacks a map, pushing its keys and values onto the stack along a mark as the deepest stack element such that one can use [`}`](/doc/UF) to rebuild the map.\n\n@param `k1` First map key.\n\n@param `v1` First map value.\n\n@param `kN` Nth map key.\n\n@param `vN` Nth map value.\n\n@param `map` Map to unpack.\n\n@param `mark` Mark indicating the deepest level to consider when building the map.\n\n",signature:"map<MAP>  UNMAP  mark<MARK> k1<ANY> v1<ANY> kN<ANY> vN<ANY>",tags:["maps"],since:"1.0.11",OPB64name:"UNMAP"},UNPACK:{description:"The `UNPACK` function unpacks a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n* **<**: No bigendian\n* **>**: Bigendian\n* **L**: Long\n* **B**: Boolean\n* **D**: Double length always equals 64.\n* **<L32**: No bigendian 32 bits Long\n\n@param `list` Pqcked list to unpack\n\n@param `format` Format used to unpack\n\n@param `result` Unpacked list\n\n",signature:"list<BYTES> format<STRING>  UNPACK  result<LIST<ANY>>",tags:["lists"],since:"1.0.7",OPB64name:"UNPACK"},UNSECURE:{description:"The `UNSECURE` function decrypts a secure script. The correct secret MUST have been set unsing [`SECUREKEY`](doc/SECUREKEY) prior to calling this function.\n\n@param `secure` STRING with the secure script to decode.\n\n@param `script` Decoded scripted.\n\n",signature:"secure<STRING>  UNSECURE  script<STRING>",tags:["crypto","stack"],since:"1.0.0",OPB64name:"UNSECURE"},UNSET:{description:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`)`](/doc/9F).\n\n@param `set` Set to expand.\n\n@param `elts` Elements of `set`.\n\n@param `mark` Instance of MARK.\n\n",signature:"set<SET>  UNSET  mark<MARK> elts<ANY*>",tags:["sets"],since:"2.6.0",OPB64name:"UNSET"},UNTIL:{description:"The `UNTIL` function implements an until loop. It takes two macros as arguments from the stack: the code to execute until the condition is true and the condition to evaluate after every iteration.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force UNTIL to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `code` Macro executed on each loop\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",signature:"code<MACRO> condition<MACRO>  UNTIL \ncode<MACRO> condition<MACRO> index<BOOLEAN>  UNTIL ",tags:["control"],since:"1.0.0",OPB64name:"UNTIL"},UNWRAP:{description:"Unwraps packed Geo Time Series™ instances.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",signature:"wrapped<STRING>  UNWRAP  gts<GTS>\nwrappedbytes<BYTES>  UNWRAP  gts<GTS>\nlwrapped<LIST<STRING>>  UNWRAP  lgts<LIST<GTS>>\nlwrapped<LIST<BYTES>>  UNWRAP  lgts<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"UNWRAP"},UNWRAPEMPTY:{description:"Unwraps wrapped Geo Time Series™ instances without unpacking the actual datapoints. This is handy to extract the metadata (class, labels, attributes) from a set of wrapped GTS.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",signature:"wrapped<STRING>  UNWRAPEMPTY  gts<GTS>\nwrappedbytes<BYTES>  UNWRAPEMPTY  gts<GTS>\nlwrapped<LIST<STRING>>  UNWRAPEMPTY  lgts<LIST<GTS>>\nlwrapped<LIST<BYTES>>  UNWRAPEMPTY  lgts<LIST<GTS>>",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPEMPTY"},UNWRAPENCODER:{description:"Unwraps packed Geo Time Series™ into encoders.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `encoder` Encoder with decoded Geo Time Series™ datapoints.\n\n@param `lencoder` List of encoders with decoded Geo Time Series™.\n\n",signature:"wrapped<STRING>  UNWRAPENCODER  encoder<GTSENCODER>\nwrappedbytes<BYTES>  UNWRAPENCODER  encoder<GTSENCODER>\nlwrapped<LIST<STRING>>  UNWRAPENCODER  lencoder<LIST<GTSENCODER>>\nlwrapped<LIST<BYTES>>  UNWRAPENCODER  lencoder<LIST<GTSENCODER>>",tags:["gts"],since:"1.2.9",OPB64name:"UNWRAPENCODER"},UNWRAPSIZE:{description:"Extracts the size (number of datapoints) of wrapped Geo Time Series™ instances.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `size` Decoded Geo Time Series™ size.\n\n@param `lsize` List of decoded Geo Time Series™ sizes.\n\n",signature:"wrapped<STRING>  UNWRAPSIZE  size<LONG>\nwrappedbytes<BYTES>  UNWRAPSIZE  size<LONG>\nlwrapped<LIST<STRING>>  UNWRAPSIZE  lsize<LIST<LONG>>\nlwrapped<LIST<BYTES>>  UNWRAPSIZE  lsize<LIST<LONG>>",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPSIZE"},UPDATE:{description:"Pushes Geo Time Series™ data to the Warp 10 instance.\n\nThe `UPDATE` function allows you to push data directly from your WarpScript code without having to retrieve the data and use the `/update` endpoint.\n\nThe GTS or Encoder instances to push *MUST* have a non empty name and in the case of Geo Time Series™ *MUST* have been renamed (to avoid pushing data by mistake which could override existing data you just retrieved).\n\n@param `token` Write token to use for pushing the data.\n\n@param `gts` Geo Time Series™ to push.\n\n@param `encoder` GTS Encoder to push.\n\n@param `list` List containing Geo Time Series™ and/or GTS Encoder instances to push.\n\n",signature:"gts<GTS> token<STRING>  UPDATE \nencoder<GTSENCODER> token<STRING>  UPDATE \nlist<LIST<GTS>> token<STRING>  UPDATE \nlist<LIST<GTSENCODER>> token<STRING>  UPDATE ",tags:["gts","platform"],since:"1.0.0",OPB64name:"UPDATE"},UPDATEOFF:{description:"Disables update operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when an update operation is attempted.\n\n",signature:"message<STRING> secret<STRING>  UPDATEOFF ",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEOFF"},UPDATEON:{description:"Enables update operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",signature:"secret<STRING>  UPDATEON ",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEON"},URLDECODE:{description:"Decodes a [URL encoded](https://en.wikipedia.org/wiki/Percent-encoding) STRING.\n\n@param `encoded` Encoded STRING to decode.\n\n@param `decoded` Decoded STRING.\n\n",signature:"encoded<STRING>  URLDECODE  decoded<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"URLDECODE"},URLENCODE:{description:"Encodes a STRING using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and replacing occurrences of '+' with '%20'.\n\nThe character set used is [UTF-8](https://en.wikipedia.org/wiki/UTF-8).\n\n@param `string` Input STRING to encode.\n\n@param `encoded` Encoded version of 'string' using the UTF-8 character set.\n\n",signature:"string<STRING>  URLENCODE  encoded<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"URLENCODE"},URLFETCH:{description:"The `URLFETCH` function sends HTTP(S) GET requests, waits for the responses and puts them on the stack.\n\nFor security reasons, the stack must be authenticated for this function to work, see [`AUTHENTICATE`](/doc/AUTHENTICATE).\n\nSince 2.7.0, this function also accepts a MAP of headers.\n\n@param `url` The URL to send the GET request to. Must begin with `http://` or `https://`.\n\n@param `urls` The list of URLs to send the GET requests to. Each URL must begin with `http://` or `https://`. \n\n@param `result` A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\n\n@param `headers` \n\n",signature:"url<STRING>  URLFETCH  result<LIST<LIST>>\nurl<STRING> headers<MAP>  URLFETCH  result<LIST<LIST>>\nurls<LIST<STRING>>  URLFETCH  result<LIST<LIST>>\nurls<LIST<STRING>> headers<MAP>  URLFETCH  result<LIST<LIST>>",tags:["extensions","web"],since:"1.0.2",OPB64name:"URLFETCH"},UUID:{description:"Pushes onto the stack a randomly generated [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n@param `uuid` Generated UUID string\n\n",signature:" UUID  uuid<STRING>",tags:["misc"],since:"1.0.0",OPB64name:"UUID"},"V->":{description:"The `V->` function converts a Vector (VLIST) on top of the stack into a list.\n\n@param `list` Input Vector.\n\n@param `result` Result list.\n\n",signature:"list<VLIST>  V->  result<LIST>",tags:["lists","conversion","pig"],since:"1.0.11",OPB64name:"KXoy"},VALUEDEDUP:{description:"Deletes duplicated values of the Geo Time Series™.\n\nThe `VALUEDEDUP` function takes as parameter a **GTS** or a **LIST** of **GTS** and it removes its duplicate values.\n\nExpects a boolean indicating whether we keep the oldest or most recent datapoint for a given value.\n\n@param `order` Boolean value, true for keeping the oldest datapoint for a given value, false otherwise.\n\n@param `gts` Geo Time Series™ for which to remove the duplicated values.\n\n@param `lgts` List of Geo Time Series™ for which to remove the duplicated values.\n\n@param `dedupgts` Geo Time Series™ with unique values.\n\n@param `ldedupgts` List of Geo Time Series™ with unique values.\n\n",signature:"gts<GTS> order<BOOLEAN>  VALUEDEDUP  dedupgts<GTS>\nlgts<LIST<GTS>> order<BOOLEAN>  VALUEDEDUP  ldedupgts<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"VALUEDEDUP"},VALUEHISTOGRAM:{description:"Produces the value histogram of a Geo Time Series™ or (since 2.2.0) of a GTS Encoder.\n\nThe histogram is a map with an entry for each value (used as the map key), with an associated value equal to the number of occurrences of the value in the series.\n\nIf the input is a bucketized Geo Time Series™, the `NULL` key will have an associated value which is the number of buckets without values (assuming no datapoints were added at timestamps other than those of buckets).\n\nWhen the input is a GTS Encoder, keys may be BigDecimal, LONG, DOUBLE, BOOLEAN or STRING, binary values are not used as keys, their STRING representation (in ISO-8859-1) is used.\n\n@param `gts` Geo Time Series™ for which to compute the histogram\n\n@param `encoder` GTS Encoder for which to compute the histogram\n\n@param `histogram` The value histogram for the input Geo Time Series™ or GTS Encoder\n\n@param `list` List of Geo Time Series™ or GTS Encoders\n\n@param `lhistogram` The list of value histogram maps\n\n",signature:"gts<GTS>  VALUEHISTOGRAM  histogram<MAP>\nencoder<GTSENCODER>  VALUEHISTOGRAM  histogram<MAP>\nlist<LIST<GTS>>  VALUEHISTOGRAM  lhistogram<LIST<MAP>>",tags:["gts"],since:"1.0.0",OPB64name:"VALUEHISTOGRAM"},VALUELIST:{description:"Gets values from a **MAP**.\n\nThe function `VALUELIST` extracts the values of a **MAP** on the top of the stack and pushes on the stack a list with those values. The **MAP** is consumed.\n\n\n@param `map` Map for which to get the values.\n\n@param `values` List of values for the input MAP.\n\n",signature:"map<MAP>  VALUELIST  values<LIST>",tags:["maps"],since:"1.0.0",OPB64name:"VALUELIST"},VALUES:{description:"Gets the values of Geo Time Series™ or encoders.\n\nThe `VALUES` function consumes a Geo Time Series™, an encoder or a list thereof from the stack, and it replaces each instance of Geo Time Series™ or encoder by a list of its values.\n\n@param `gts` Geo Time Series™ for which to get the values.\n\n@param `lgts` List of Geo Time Series™ for which to get the values.\n\n@param `encoder` Encoder for which to get the values.\n\n@param `lencoder` List of encoders for which to get the values.\n\n@param `values` List of values from the input Geo Time Series™.\n\n@param `lvalues` List of list of values from the input Geo Time Series™ list.\n\n",signature:"gts<GTS>  VALUES  values<LIST>\nlgts<LIST<GTS>>  VALUES  lvalues<LIST<LIST>>\nencoder<GTSENCODER>  VALUES  values<LIST>\nlencoder<LIST<GTSENCODER>>  VALUES  lvalues<LIST<LIST>>",tags:["gts"],since:"1.0.0",OPB64name:"VALUES"},VALUESORT:{description:"Sorts values of the Geo Time Series™ in ascending order.\n\nThe function `VALUESORT` takes the **GTS** on top of the stack and sort its values (and associated locations/elevations) in ascending order.\n\n@param `gts` Geo Time Series™ for which to sort the values.\n\n@param `sortedgts` Geo Time Series™ with sorted values.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lsortedgts` List of Geo Time Series™ with sorted values.\n\n",signature:"gts<GTS>  VALUESORT  sortedgts<GTS>\nlgts<LIST<GTS>>  VALUESORT  lsortedgts<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"VALUESORT"},VALUESPLIT:{description:"Splits Geo Time Series™ by values.\n\nThe function `VALUESPLIT` takes one **STRING** on top of the stack plus one **GTS** or a list of **GTS**. It splits **GTS** by values and creates a **GTS** for each different value. For each new **GTS**, the label specified in parameter will be added.\n\nThe new **GTS** will be sorted by value with `VALUESORT`.\n\n@param `label` Label to add to the new Geo Time Series™.\n\n@param `gts` Geo Time Series™ to split by value.\n\n@param `splitedgts` List of Geo Time Series™ splited by value.\n\n@param `lgts` List of Geo Time Series™ to split by value.\n\n@param `lsplitedgts` List of Geo Time Series™ splited by value.\n\n",signature:"gts<GTS> label<STRING>  VALUESPLIT  splitedgts<LIST<GTS>>\nlgts<LIST<GTS>> label<STRING>  VALUESPLIT  lsplitedgts<LIST<LIST<GTS>>>",tags:["gts"],since:"1.0.0",OPB64name:"VALUESPLIT"},"VARINT->":{description:"The `VARINT` function decodes [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoded numbers.\n\n@param `numbers` List of decoded numbers.\n\n@param `encoded` Byte array containing the encoded number(s) to decode.\n\n@param `count` Maximum number of `LONG`s to decode.\n\n@param `processed` Number of bytes which were processed to decode the numbers.\n\n",signature:"encoded<BYTES>  VARINT->  numbers<LIST<LONG>>\nencoded<BYTES> count<LONG>  VARINT->  numbers<LIST<LONG>> processed<LONG>",tags:["conversion","binary"],since:"2.6.0",OPB64name:"KZ4HHJtJAIs"},VARS:{description:"Extracts all variables used in a macro. The `VARS` function scans the macro for occurrences of `LOAD`, `STORE` or `CSTORE` functions and inspects the associated variable name. If such a name is not an explicit STRING, the call to `VARS` will fail with an error.\n\nThe list of symbols is sorted according to the number of occurrences encountered, decreasing.\n\n@param `macro` Macro to inspect.\n\n@param `vars` List of encountered symbols.\n\n@param `onlyPoprAndStore` Returns only variables used by POPR, CPOPR and STORE. Defaults to false.\n\n",signature:"macro<MACRO>  VARS  vars<LIST<STRING>>\nmacro<MACRO> onlyPoprAndStore<BOOLEAN>  VARS  vars<LIST<STRING>>",tags:["stack"],since:"2.0.0",OPB64name:"VARS"},"VEC->":{description:"The `VEC->` function converts a Vector into a list.\n\n\n@param `input` Vector to convert\n\n@param `result` list\n\n",signature:"input<VECTOR>  VEC->  result<LIST>",tags:["lists","conversion","math"],since:"1.0.6",OPB64name:"KZK2AIs"},WEBCALL:{description:"Makes an outbound HTTP call.\n\nNote that the hosts which may be reached via `WEBCALL` might have been restricted through the use of the `webcall.host.patterns` Warp&nbsp;10 configuration parameter.\n\nThe write token is here to check you have the right to send a webcall. If the write token is valid, then the request is sent. It will never be sent in the request.\n\nThe call to `WEBCALL` returns a UUID on the stack. The actual request is performed asynchronously, the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`.\n\n@param `body` body of the request.\n\n@param `headers` map of additionnal http headers.\n\n@param `url` supported schemes are http and https.\n\n@param `method` `GET` or `POST` string.\n\n@param `token` valid write token\n\n@param `uuid` the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`\n\n",signature:"token<STRING> method<STRING> url<STRING> headers<MAP> body<STRING>  WEBCALL  uuid<STRING>",tags:["web"],since:"1.0.0",OPB64name:"WEBCALL"},"WF.ADDREPO":{description:"The `WF.ADDREPO` function allows you to add a repository to the list of repositories taken into account by the WarpFleet™ macro resolver.\n\nIf the URL is valid (syntaxically), then it will be added at the end of the current list of repositories scanned by the resolver. All repository URLs will then be validated by the `validator` macro defined in the configuration (`warpfleet.macros.validator`). Those URLs for which the `validator` macro returned true will be retained.\n\nNote that the repository is only added in the scope of the current stack.\n\n@param `url` URL to add to the list of repositories.\n\n",signature:"url<STRING>  WF.ADDREPO ",tags:["stack"],since:"2.0.3",OPB64name:"WF.ADDREPO"},"WF.GETREPOS":{description:"Retrieves the current list of repositories used by the WarpFleet™ resolver.\n\nNote that if the configuration disabled the use of this function (via `warpfleet.getrepos.disable`), the returned list will be empty even though it contains repositories.\n\n@param `repos` Current list of repository URLs.\n\n",signature:" WF.GETREPOS  repos<LIST<STRING>>",tags:["stack"],since:"2.0.3",OPB64name:"WF.GETREPOS"},"WF.SETREPOS":{description:"Sets the list of repositories used by the WarpFleet™ resolver to the given value (list of valid URLs).\n\nEach URL is tested against WarpFleet™ validator macro to check if it is allowed. Non-valid ones are discarded.\n\nNote that this changes the list only for the scope of the current WarpScript execution.\n\n@param `repos` List of URLs to use for the WarpFleet™ resolver.\n\n",signature:"repos<LIST<STRING>>  WF.SETREPOS ",tags:["stack"],since:"2.0.3",OPB64name:"WF.SETREPOS"},WFOFF:{description:"The `WFOFF` function disables the WarpFleet™ Resolver. It can be re-enabled using `WFON`.\n\nThis is useful when you want to ensure that a macro call only looks it up locally.\n\n",signature:" WFOFF ",tags:["stack"],since:"2.1.0",OPB64name:"WFOFF"},WFON:{description:"The `WFON` function enables the WarpFleet™ Resolver after it has been disabled by `WFOFF`.\n\n",signature:" WFON ",tags:["stack"],since:"2.1.0",OPB64name:"WFON"},WHILE:{description:"The `WHILE` function implements a while loop. It takes two macros as arguments from the stack: the condition macro to evaluate and the macro to execute while the condition is true.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force WHILE to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `code` Macro executed on each loop\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",signature:"condition<MACRO> code<MACRO>  WHILE \ncondition<MACRO> code<MACRO> index<BOOLEAN>  WHILE ",tags:["control"],since:"1.0.0",OPB64name:"WHILE"},WRAP:{description:"The `WRAP` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a STRING.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAP  wrapped<STRING>\nlencoder<GTSENCODER>  WRAP  lwrapped<LIST<STRING>>\ngts<GTS>  WRAP  wrapped<STRING>\nlgts<LIST<GTS>>  WRAP  lwrapped<LIST<STRING>>",tags:["gts","encoder"],since:"1.0.0",OPB64name:"WRAP"},WRAPFAST:{description:"The `WRAPFAST` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a byte array. For fast execution, the content of the GTS is not compressed, so the resulting byte array will be larger than that produced by `WRAPRAW`.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAPFAST  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPFAST  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPFAST  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPFAST  lwrapped<LIST<BYTES>>",tags:["gts","encoder"],since:"2.1.0",OPB64name:"WRAPFAST"},WRAPMV:{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPRAWOPT`, `WRAPMV` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAPMV  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPMV  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPMV  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPMV  lwrapped<LIST<BYTES>>",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"WRAPMV"},"WRAPMV!":{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPMV`, `WRAPMV!` attempts to optimize the representation of DOUBLE values for Geo Time Series™ but unlike `WARPMV`, it does not increase the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAPMV!  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPMV!  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPMV!  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPMV!  lwrapped<LIST<BYTES>>",tags:["gts","encoder","multivariate"],since:"2.6.0",OPB64name:"Kp80J3pL7F"},WRAPOPT:{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a STRING. The packing performed by `WRAPOPT` differs from that of [`WRAP`](/doc/WRAP) only by the fact that `WRAPOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAPOPT  wrapped<STRING>\nlencoder<GTSENCODER>  WRAPOPT  lwrapped<LIST<STRING>>\ngts<GTS>  WRAPOPT  wrapped<STRING>\nlgts<LIST<GTS>>  WRAPOPT  lwrapped<LIST<STRING>>",tags:["gts"],since:"1.2.3",OPB64name:"WRAPOPT"},WRAPRAW:{description:"The `WRAPRAW` function packs a Geo Time Series™ into a byte array.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAPRAW  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPRAW  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPRAW  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPRAW  lwrapped<LIST<BYTES>>",tags:["gts","encoder"],since:"1.0.7",OPB64name:"WRAPRAW"},WRAPRAWOPT:{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES. The packing performed by `WRAPRAWOPT` differs from that of [`WRAPRAW`](/doc/WRAPRAW) only by the fact that `WRAPRAWOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"encoder<GTSENCODER>  WRAPRAWOPT  wrapped<BYTES>\nlencoder<GTSENCODER>  WRAPRAWOPT  lwrapped<LIST<BYTES>>\ngts<GTS>  WRAPRAWOPT  wrapped<BYTES>\nlgts<LIST<GTS>>  WRAPRAWOPT  lwrapped<LIST<BYTES>>",tags:["gts","encoder"],since:"1.2.3",OPB64name:"WRAPRAWOPT"},WSINFO:{description:"Displays informations about WarpScript environments with a given session id. The informations are returned as a map identical to that returned by [`WSPS`](/doc/WSPS):\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `session` Session of the environments to inspect.\n\n@param `infos` List of informations about each WarpScript execution environment with 'session' as their session name.\n\n",signature:"session<STRING>  WSINFO  infos<LIST<MAP>>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSINFO"},WSKILL:{description:"Kills the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP) and marking the environment as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to kill.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",signature:"uuid<STRING> secret<STRING>  WSKILL  status<BOOLEAN>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILL"},WSKILLSESSION:{description:"Kills the execution WarpScript programs by forcing a call to [`STOP`](/doc/STOP) and marking the environments as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `session` Session id of the WarpScript execution environments to kill.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",signature:"session<STRING>  WSKILLSESSION  count<LONG>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILLSESSION"},WSNAME:{description:"Modifies the name associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stack.name` in the attributes map.\n\nName size is limited to 128 characters.\n\n@param `name` Name to assign to the calling execution environment, or `NULL` to simply read the current name.\n\n@param `current` Name assigned to the execution environment.\n\n",signature:"name<STRING>  WSNAME  current<STRING>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSNAME"},WSPS:{description:"Lists all the registers WarpScript execution environments. For each environment a map is returned with the following fields:\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `secret` Secret for process status operations.\n\n@param `procs` List of informations about each registered WarpScript execution environment.\n\n",signature:"secret<STRING>  WSPS  procs<LIST<MAP>>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSPS"},WSSESSION:{description:"Modifies the session id associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stackps.session` in the attributes map.\n\nSession id size is limited to 128 characters.\n\nSession can also be set by setting the `X-Warp10-WarpScriptSession` header.\n\nOnce the session has been set it cannot be modified.\n\n@param `session` Session id to assign to the calling execution environment, or NULL to simply read the current session id.\n\n@param `current` The session id assigned to the execution environment.\n\n",signature:"session<STRING>  WSSESSION  current<STRING>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSESSION"},WSSTACK:{description:"Select the WarpScript™ (*i.e.* SNAPSHOT) format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:" WSSTACK ",tags:["stack"],since:"2.0.0",OPB64name:"WSSTACK"},WSSTOP:{description:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to stop.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",signature:"uuid<STRING> secret<STRING>  WSSTOP  status<BOOLEAN>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOP"},WSSTOPSESSION:{description:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\nThe environments to stop are identified by a session id.\n\n@param `session` Session of the WarpScript execution environments to stop.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",signature:"session<STRING>  WSSTOPSESSION  count<LONG>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOPSESSION"},"Z->":{description:"Unpacks LONG values from a [Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) stored in a byte array.\n\n@param `bitwidth` Size in bits of the LONG values to extract, from 1 to 63.\n\n@param `n` Number of LONG values to extract.\n\n@param `z` Byte array containing the Morton Code to unpack.\n\n@param `longs` List of extracted LONG values.\n\n",signature:"z<BYTES> n<LONG> bitwidth<LONG>  Z->  longs<LIST<LONG>>",tags:["conversion"],since:"1.0.6",OPB64name:"LXoy"},ZDISCORDS:{description:"The `ZDISCORDS` function detects discords in a standardized ([`STANDARDIZE`](/doc/STANDARDIZE) Geo Time Series™. The discord detection\n algorithm is based on identifying outlier patterns in the Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `ZDISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\nGiven the `ZDISCORDS` expects the Geo Time Series™ it operates on to be standardized ([`STANDARDIZE`](/doc/STANDARDIZE), the discord detection \nalgorithm is more sensitive than that of [`DISCORDS`](/doc/DISCORDS).\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0.\n\n@param `overlapping` Flag indicating whether or not the `ZDISCORDS` function should report overlapping discords.\n\n@param `maximum` The maximum number of discords to identify.\n\n@param `window_size` Window size which is the width of each interval on which the pattern extraction should be performed, a pattern length which will determine how the window is segmented, and lastly a quantization scale which will determine how many different buckets will be used to ventilate the series values. (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `result` Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™.\n\n",signature:"window_size<LONG> maximum<LONG> overlapping<BOOLEAN> distance<DOUBLE>  ZDISCORDS  result<GTS>",tags:["gts","outlier"],since:"1.0.13",OPB64name:"ZDISCORDS"},ZDTW:{description:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be Z-normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",signature:"gts1<GTS> gts2<GTS> threshold<DOUBLE>  ZDTW  dtw<DOUBLE>",tags:["gts","distance"],since:"1.2.11",OPB64name:"ZDTW"},ZIP:{description:"The function ZIP takes a list of lists as parameters. Each list which are not singletons must be of same size.\n\nIt returns a list of lists where the i-th list contains the i-th elements of each input list in the same order.\n\nAlso, it considers singletons as a list of the same size with a duplicated value.\n\n@param `input` List of lists\n\n@param `output` List of lists\n\n",signature:"input<LIST<LIST>>  ZIP  output<LIST<LIST>>",tags:["lists"],since:"1.0.0",OPB64name:"ZIP"},ZPATTERNDETECTION:{description:"The `ZPATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`ZPATTERNS`](/doc/ZPATTERNS) or [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe `ZPATTERNDETECTION` does not standardize the datapoints in the sliding window, assuming (wrongly) they already are.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `ZPATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform.\n\n@param `gts` The single GTS to transform.\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it.\n\n@param `lresult` The list of result GTS.\n\n",signature:"gts<GTS> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNDETECTION  result<GTS>\nlgts<LIST<GTS>> patterns<LIST<STRING>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNDETECTION  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNDETECTION"},ZPATTERNS:{description:"Extracts symbolic patterns from Geo Time Series™ as [`PATTERNS`](/doc/PATTERNS) does, but does not standardize each window, assuming (wrongly) the GTS windows are already standardized.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",signature:"gts<GTS> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNS  result<GTS>\nlgts<LIST<GTS>> wsize<NUMBER> length<NUMBER> scale<NUMBER>  ZPATTERNS  lresult<LIST<GTS>>",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNS"},ZSCORE:{description:"The 'ZSCORE' function consumes a flag, then normalizes a Geo Time Series™ or a **LIST** of Geo Time Series™ that are below by replacing their values by their [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe flag indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median).\n\nIf the GTS isn’t of type **DOUBLE** or if the deviation equals 0, an exception is raised.\n\n@param `flag` Indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",signature:"gts<GTS> flag<BOOLEAN>  ZSCORE  result<GTS>\ngtsList<LIST<GTS>> flag<BOOLEAN>  ZSCORE  resultList<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"ZSCORE"},ZSCORETEST:{description:"The ZSCORETEST function detects outliers in a GTS by comparing the Z-score of its values with a given threshold.\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median). If this value is greater than the given threshold, it is flagged as an outlier.\n\nA LIST of ticks, corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n@param `gts` The Geo Time Series™ to test\n\n@param `result` List of the detected outliers timestamps\n\n@param `lgts` The list of Geo Time Series™ to test\n\n@param `lresult` List of list of the detected outliers timestamps\n\n@param `mad` False: use the mean/sigma, true: use the median/mad to calculate the Z-score\n\n@param `trigger` Optional threshold. Default value is 3.5\n\n",signature:"gts<GTS> mad<BOOLEAN>  ZSCORETEST  result<LIST<LONG>>\nlgts<LIST<GTS>> mad<BOOLEAN>  ZSCORETEST  lresult<LIST<LIST<LONG>>>\ngts<GTS> mad<BOOLEAN> trigger<DOUBLE>  ZSCORETEST  result<LIST<LONG>>\nlgts<LIST<GTS>> mad<BOOLEAN> trigger<DOUBLE>  ZSCORETEST  lresult<LIST<LIST<LONG>>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ZSCORETEST"},"[":{description:"Starts a list creation.\n\nThe `[` function creates a list by pushing a mark onto the stack. This is a syntactic help to better present list constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",signature:" [  mark<MARK>",tags:["lists","stack"],since:"1.0.0",OPB64name:"Lk"},"[[":{description:"Pushes a MARK on the stack. This is a syntaxic help to better present Vector (VLIST) constructions.\n \n\n@param `mark` A MARK instance.\n\n",signature:" [[  mark<MARK>",tags:["pig"],since:"1.2.13",OPB64name:"Lpg"},"[[]]":{description:"Pushes an empty Vector onto the stack.\n\n@param `vector` Empty Vector.\n\n",signature:" [[]]  vector<VLIST>",tags:["lists"],since:"1.2.13",OPB64name:"LphSMF"},"[]":{description:"The [] function creates an empty LIST on the top of the stack.\n\n\n@param `content` 0 to n elements.\n\n@param `newlist` list instance, initialized with content.\n\n",signature:"content<ANY>  []  newlist<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"Lpo"},"]":{description:"Closes a currently open list and pushes it onto the stack.\n\n  The `]` function pops from the stack the elements of the list up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",signature:"mark<MARK> v1<ANY> vN<ANY>  ]  list<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"MF"},"]]":{description:"Closes a currently open Vector (VLIST) and pushes it onto the stack. The elements on the stack are those up to the first mark encountered. The mark is discarded.\n\nVLIST are represented as lists on the stack.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",signature:"mark<MARK> v1<ANY> vN<ANY>  ]]  list<VLIST>",tags:["pig"],since:"1.2.13",OPB64name:"MKo"},"^":{description:"Performs a bitwise **XOR** operation.\n\nThe `^` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **XOR**.\n\nSince Warp 10™ 2.1, `^` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be XOR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with XOR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts XOR with mask\n\n",signature:"p1<LONG> p2<LONG>  ^  result<LONG>\ninputgts<GTS> mask<LONG>  ^  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  ^  outputgts<GTS>",tags:["binary","operators"],since:"1.0.0",OPB64name:"MV"},"bucketizer.and":{description:"The `bucketizer.and` function applies the logical operator **AND** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.and  bucketizer<AGGREGATOR>",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.and"},"bucketizer.count":{description:"The `bucketizer.count` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.count  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count"},"bucketizer.count.exclude-nulls":{description:"**Deprecated**: `bucketizer.count.exclude-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.exclude-nulls` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.count.exclude-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.exclude-nulls"},"bucketizer.count.include-nulls":{description:"**Deprecated**: `bucketizer.count.include-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.include-nulls function computes the number of values, including null values, found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.count.include-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.include-nulls"},"bucketizer.count.nonnull":{description:"The `bucketizer.count.nonnull` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.count.nonnull  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.nonnull"},"bucketizer.first":{description:"The `bucketizer.first` function returns the first value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.first` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.first  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.first"},"bucketizer.join":{description:"The `bucketizer.join` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"separator<STRING>  bucketizer.join  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join"},"bucketizer.join.forbid-nulls":{description:"**Deprecated**: `bucketizer.join.forbid-nulls` has the same behavior as `bucketizer.join`, use `bucketizer.join` instead.\n\nThe `bucketizer.join.forbid-nulls` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"separator<STRING>  bucketizer.join.forbid-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join.forbid-nulls"},"bucketizer.last":{description:"The `bucketizer.last` function returns the last value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.last` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.last  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.last"},"bucketizer.mad":{description:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) of each bucket.\n\nThe returned location is the median of all the locations in the bucket, and the returned elevation is the median of all the elevations in the bucket.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.mad  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.2.0",OPB64name:"bucketizer.mad"},"bucketizer.max":{description:"The `bucketizer.max` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.max  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max"},"bucketizer.max.forbid-nulls":{description:"**Deprecated**: `bucketizer.max.forbid-nulls` has the same behavior as `bucketizer.max`, use `bucketizer.max` instead.\n\nThe `bucketizer.max.forbid-nulls` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\nThe `bucketizer.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.max.forbid-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max.forbid-nulls"},"bucketizer.mean":{description:"The `bucketizer.mean` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.mean  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean"},"bucketizer.mean.circular":{description:"The `bucketizer.mean.circular` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`bucketizer.mean.circular.exclude-nulls`](/doc/bucketizer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `bucketizer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"modulo<NUMBER>  bucketizer.mean.circular  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular"},"bucketizer.mean.circular.exclude-nulls":{description:"**Deprecated**: `bucketizer.mean.circular.exclude-nulls` has the same behavior as `bucketizer.mean.circular`, use `bucketizer.mean.circular` instead.\n        \nThe `bucketizer.mean.circular.exclude-nulls` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned.\n\nThe `bucketizer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"modulo<NUMBER>  bucketizer.mean.circular.exclude-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular.exclude-nulls"},"bucketizer.mean.exclude-nulls":{description:"**Deprecated**: `bucketizer.mean.exclude-nulls` has the same behavior as `bucketizer.mean`, use `bucketizer.mean` instead.\n \nThe `bucketizer.mean.exclude-nulls` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.mean.exclude-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.exclude-nulls"},"bucketizer.median":{description:"The `bucketizer.median` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.median  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.median"},"bucketizer.median.forbid-nulls":{description:"**Deprecated**: `bucketizer.median.forbid-nulls` has the same behavior as `bucketizer.median`, use `bucketizer.median` instead.\n\nThe `bucketizer.median.forbid-nulls` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.median.forbid-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"2.4.0",OPB64name:"bucketizer.median.forbid-nulls"},"bucketizer.min":{description:"The `bucketizer.min` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.min  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min"},"bucketizer.min.forbid-nulls":{description:"**Deprecated**: `bucketizer.min.forbid-nulls` has the same behavior as `bucketizer.min`, use `bucketizer.min` instead.\n\nThe `bucketizer.min.forbid-nulls` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.min.forbid-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min.forbid-nulls"},"bucketizer.or":{description:"The `bucketizer.or` function applies the logical operator **OR** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.or  bucketizer<AGGREGATOR>",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.or"},"bucketizer.percentile":{description:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the bucket.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `percentile` Percentile to consider\n\n",signature:"percentile<NUMBER>  bucketizer.percentile  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.percentile"},"bucketizer.rms":{description:"The `bucketizer.rms` function returns the root mean square of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are the last one encountered for each bucket.\n\nThe `bucketizer.rms` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.rms  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.2.18",OPB64name:"bucketizer.rms"},"bucketizer.sd":{description:"This bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Bucketizer to apply\n\n",signature:"bessel<BOOLEAN>  bucketizer.sd  result<AGGREGATOR>",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd"},"bucketizer.sd.forbid-nulls":{description:"**Deprecated**: `bucketizer.sd.forbid-nulls` has the same behavior as `bucketizer.sd`, use `bucketizer.sd` instead.\n\nThis bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"bessel<BOOLEAN>  bucketizer.sd.forbid-nulls  result<AGGREGATOR>",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd.forbid-nulls"},"bucketizer.sum":{description:"The `bucketizer.sum` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.sum  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum"},"bucketizer.sum.forbid-nulls":{description:"**Deprecated**: `bucketizer.sum.forbid-nulls` has the same behavior as `bucketizer.sum`, use `bucketizer.sum` instead.\n\nThe `bucketizer.sum.forbid-nulls` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:" bucketizer.sum.forbid-nulls  bucketizer<AGGREGATOR>",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum.forbid-nulls"},d:{description:"Converts a number of days (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of days from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of days to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of days\n\n",signature:"input<NUMBER>  d  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"d"},e:{description:"Alias of [E](/doc/GF).\n\nThe `e` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",signature:" e  eValue<DOUBLE>",tags:["math","constants"],since:"1.0.0",OPB64name:"OF"},"filler.interpolate":{description:"Pushes onto the stack a *filler* function which fills missing values with a linear interpolation of enclosing values in a Geo Time Series™.\n\nNote that this function will not fill missing leading or trailing ticks as there is no possible interpolation.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:" filler.interpolate  filler<FILLER>",tags:["filler"],since:"2.0.0",OPB64name:"filler.interpolate"},"filler.next":{description:"Pushes onto the stack a *filler* function which fills missing values with the next value in a Geo Time Series™.\n\nNote that this function will not fill missing trailing ticks as there is no next value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:" filler.next  filler<FILLER>",tags:["filler"],since:"2.0.0",OPB64name:"filler.next"},"filler.previous":{description:"Pushes onto the stack a *filler* function which fills missing values with the previous value in a Geo Time Series™.\n\nNote that this function will not fill missing leading ticks as there is no previous value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:" filler.previous  filler<FILLER>",tags:["filler"],since:"2.0.0",OPB64name:"filler.previous"},"filler.trend":{description:"Pushes onto the stack a *filler* function which fills missing values with the centroid of the points computed by projecting trends from both sides of the missing point.\n\nNote that this function will fill all missing points.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:" filler.trend  filler<FILLER>",tags:["filler"],since:"2.0.0",OPB64name:"filler.trend"},"filter.all.eq":{description:"This filter function only selects the Geo Time Series™ whose every value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.all.eq  result<FILTER>\nfilter-value<DOUBLE>  filter.all.eq  result<FILTER>\nfilter-value<BOOLEAN>  filter.all.eq  result<FILTER>\nfilter-value<STRING>  filter.all.eq  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.eq"},"filter.all.ge":{description:"This filter function only selects the Geo Time Series™ whose every value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.all.ge  result<FILTER>\nfilter-value<DOUBLE>  filter.all.ge  result<FILTER>\nfilter-value<STRING>  filter.all.ge  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ge"},"filter.all.gt":{description:"This filter function only selects the Geo Time Series™ whose every value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.all.gt  result<FILTER>\nfilter-value<DOUBLE>  filter.all.gt  result<FILTER>\nfilter-value<STRING>  filter.all.gt  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.gt"},"filter.all.le":{description:"This filter function only selects the Geo Time Series™ whose every value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.all.le  result<FILTER>\nfilter-value<DOUBLE>  filter.all.le  result<FILTER>\nfilter-value<STRING>  filter.all.le  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.le"},"filter.all.lt":{description:"This filter function only selects the Geo Time Series™ whose every value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.all.lt  result<FILTER>\nfilter-value<DOUBLE>  filter.all.lt  result<FILTER>\nfilter-value<STRING>  filter.all.lt  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.lt"},"filter.all.ne":{description:"This filter function only selects the Geo Time Series™ whose every value does not equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.all.ne  result<FILTER>\nfilter-value<DOUBLE>  filter.all.ne  result<FILTER>\nfilter-value<BOOLEAN>  filter.all.ne  result<FILTER>\nfilter-value<STRING>  filter.all.ne  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ne"},"filter.any.eq":{description:"This filter function only selects the Geo Time Series™ whose at least one value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.any.eq  result<FILTER>\nfilter-value<DOUBLE>  filter.any.eq  result<FILTER>\nfilter-value<BOOLEAN>  filter.any.eq  result<FILTER>\nfilter-value<STRING>  filter.any.eq  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.eq"},"filter.any.ge":{description:"This filter function only selects the Geo Time Series™ whose at least one value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.any.ge  result<FILTER>\nfilter-value<DOUBLE>  filter.any.ge  result<FILTER>\nfilter-value<STRING>  filter.any.ge  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ge"},"filter.any.gt":{description:"This filter function only selects the Geo Time Series™ whose at least one value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.any.gt  result<FILTER>\nfilter-value<DOUBLE>  filter.any.gt  result<FILTER>\nfilter-value<STRING>  filter.any.gt  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.gt"},"filter.any.le":{description:"This filter function only selects the Geo Time Series™ whose at least one value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.any.le  result<FILTER>\nfilter-value<DOUBLE>  filter.any.le  result<FILTER>\nfilter-value<STRING>  filter.any.le  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.le"},"filter.any.lt":{description:"This filter function only selects the Geo Time Series™ whose at least one value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.any.lt  result<FILTER>\nfilter-value<DOUBLE>  filter.any.lt  result<FILTER>\nfilter-value<STRING>  filter.any.lt  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.lt"},"filter.any.ne":{description:"This filter function only selects the Geo Time Series™ whose at least one value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.any.ne  result<FILTER>\nfilter-value<DOUBLE>  filter.any.ne  result<FILTER>\nfilter-value<BOOLEAN>  filter.any.ne  result<FILTER>\nfilter-value<STRING>  filter.any.ne  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ne"},"filter.byattr":{description:"This filter function only selects the Geo Time Series™ whose attributes match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter<MAP>  filter.byattr  result<FILTER>",tags:["filter"],since:"1.0.11",OPB64name:"filter.byattr"},"filter.byclass":{description:"This filter function only selects the Geo Time Series™ whose class name matches the filter parameter.\n\n@param `filter` The filter parameter is a **STRING**, if it starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter<STRING>  filter.byclass  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.byclass"},"filter.bylabels":{description:"This filter function only selects the Geo Time Series™ whose labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter<MAP>  filter.bylabels  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.bylabels"},"filter.bylabelsattr":{description:"This filter function only selects the Geo Time Series™ whose attributes or labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes or labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter<MAP>  filter.bylabelsattr  result<FILTER>",tags:["filter"],since:"1.0.11",OPB64name:"filter.bylabelsattr"},"filter.bymetadata":{description:"Filter GTSs by retaining those whose metadata **exactly** match at least one metadata from the given GTS list. \n\nThe metadata consists of the classname and labels.\n\n@param `lgts` List of GTSs to extract the metadata from.\n\n@param `filter` Filter to apply which will keep only GTSs with exact metadata matching.\n\n",signature:"lgts<LIST<GTS>>  filter.bymetadata  filter<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.bymetadata"},"filter.byselector":{description:"This filter allow to select GTS with a standard or an extended selector.\n###### Standard selector: `classname{labelOrAttribute=x}`\n- If classname match, `filter.byselector` looks into input labels to check if labelOrAttribute exists and equals x. If labelOrAttribute is not found among input labels, it looks into input attributes if the label exists and equals x.\n###### Extended selector: `classname{labelname=x}{attributename=y}` matches if:\n- classname matches\n- input have labelname in its labels, and label value matches\n- input have attributename in its labels, and attribute value matches\n\n###### Selectors example:\n- `~.*{}` matches everything.\n- `={}` matches only emtpy classnames, whatever the labels and attributes.\n- `~.*{label=value}{} filter.byselector` is equivalent to `{ 'label' 'value' } filter.bylabels`.\n- `~.*{}{attribute~value} filter.byselector` is equivalent to `{ 'attribute' '~value' } filter.byattr`.\n\n\n@param `selector` The selector parameter. It could be a standard or an extended selector.\n\n@param `result` The filter to apply\n\n",signature:"selector<STRING>  filter.byselector  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.byselector"},"filter.bysize":{description:"Filter GTSs by retaining those whose size is contained between specified bounds (inclusive).\n\n@param `min` The minimum size\n\n@param `max` The maximum size\n\n@param `result` The filter to apply\n\n",signature:"min<LONG> max<LONG>  filter.bysize  result<FILTER>",tags:["filter"],since:"2.4.0",OPB64name:"filter.bysize"},"filter.last.eq":{description:"This filter function only selects the Geo Time Series™ whose last value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.last.eq  result<FILTER>\nfilter-value<DOUBLE>  filter.last.eq  result<FILTER>\nfilter-value<BOOLEAN>  filter.last.eq  result<FILTER>\nfilter-value<STRING>  filter.last.eq  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.eq"},"filter.last.ge":{description:"This filter function only selects the Geo Time Series™ whose last value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.last.ge  result<FILTER>\nfilter-value<DOUBLE>  filter.last.ge  result<FILTER>\nfilter-value<STRING>  filter.last.ge  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ge"},"filter.last.gt":{description:"This filter function only selects the Geo Time Series™ whose last value is greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.last.gt  result<FILTER>\nfilter-value<DOUBLE>  filter.last.gt  result<FILTER>\nfilter-value<STRING>  filter.last.gt  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.gt"},"filter.last.le":{description:"This filter function only selects the Geo Time Series™ whose last value is less or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.last.le  result<FILTER>\nfilter-value<DOUBLE>  filter.last.le  result<FILTER>\nfilter-value<STRING>  filter.last.le  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.le"},"filter.last.lt":{description:"This filter function only selects the Geo Time Series™ whose last value is less than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.last.lt  result<FILTER>\nfilter-value<DOUBLE>  filter.last.lt  result<FILTER>\nfilter-value<STRING>  filter.last.lt  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.lt"},"filter.last.ne":{description:"This filter function only selects the Geo Time Series™ whose last value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter-value<LONG>  filter.last.ne  result<FILTER>\nfilter-value<DOUBLE>  filter.last.ne  result<FILTER>\nfilter-value<BOOLEAN>  filter.last.ne  result<FILTER>\nfilter-value<STRING>  filter.last.ne  result<FILTER>",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ne"},"filter.latencies":{description:"Pushes onto the stack a *pseudo* FILTER which computes latencies in a network. It uses the [`FILTER`](/doc/FILTER) framework for conveniency but really returns new GTS.\n\nThe input Geo Time Series™ are assumed to have values which are fingerprints of packet payloads. The first GTS is assumed to be the *uplink* and all the other GTS the *downlinks*.\n\nThe ticks are the time at which a packet with the given fingerprint was observed.\n\nThe generated Geo Time Series™ will have the same ticks as the uplink one, except the values will be latencies instead of packet fingerprints.\n\nThe `filter.latencies` function accepts a number of options:\n\n| Option | Description |\n|--------|-------------|\n| uplink.latency.min | Compute minimum latency on the uplink. |\n| uplink.latency.max | Compute maximum latency on the uplink. |\n| downlink.latency.min | Compute minimum latency on each downlink. |\n| downlink.latency.max | Compute maximum latency on each downlink. |\n| downlink.matches | Compute the number of matches for each downlink. |\n| downlinks.totalmatches | Computes the total number of matches across downlinks. |\n| downlinks.bitsets | Computes a bitset of downlinks which saw the packet (limited to 64 downlinks). |\n| downlinks.withmatches | Computes the number of downlinks with matches for the given packet. |\n\nThis pseudo FILTER is very specific to a networking use case, but it is a good demonstration of the power of WarpScript and its frameworks.\n\n@param `options` List of options, see above for their description.\n\n@param `maxLatency` Maximum allowable latency, packets with latency above this threshold are ignored.\n\n@param `minLatency` Minimum latency, packets with a latency below this threshold are ignored.\n\n@param `filter` Instance of `filter.latencies`.\n\n",signature:"minLatency<LONG> maxLatency<LONG> options<LIST<STRING>>  filter.latencies  filter<FILTER>",tags:["filter","gts"],since:"1.0.0",OPB64name:"filter.latencies"},h:{description:"Converts a number of hours (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of hours from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of hours to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of hours\n\n",signature:"input<NUMBER>  h  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"h"},m:{description:"Converts a number of minutes (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of minutes from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of minutes to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of minutes\n\n",signature:"input<NUMBER>  m  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"m"},"mapper.abs":{description:"This mapper function returns the absolute value of single value in a sliding window.\n\nThe `mapper.abs` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.abs  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.abs"},"mapper.add":{description:"This mapper function adds a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.add` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.add` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Value to add\n\n@param `result` Mapper to apply\n\n",signature:"constant<DOUBLE>  mapper.add  result<AGGREGATOR>\nconstant<LONG>  mapper.add  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.add"},"mapper.and":{description:"This mapper function applies the logical operator **AND** on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.and  result<AGGREGATOR>",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.and"},"mapper.ceil":{description:"This mapper function rounds the single value in a sliding window to the closests greater **LONG**.\n\nThe `mapper.ceil` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.ceil  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.ceil"},"mapper.count":{description:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.count  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count"},"mapper.count.exclude-nulls":{description:"**Deprecated**: `mapper.count.exclude-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.count.exclude-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.exclude-nulls"},"mapper.count.include-nulls":{description:"**Deprecated**: `mapper.count.include-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.count.include-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.include-nulls"},"mapper.count.nonnull":{description:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.count.nonnull  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.nonnull"},"mapper.day":{description:"This mapper function returns the day of the tick for which it is computed.\n\nThe `mapper.day` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n@param `timezone` Timezone to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"timezone<STRING>  mapper.day  result<AGGREGATOR>\noffset<NUMBER>  mapper.day  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.day"},"mapper.delta":{description:"This mapper function computes the delta between the last and first values (delta = last - first) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.delta` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does \nnot return any value.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.delta  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.delta"},"mapper.dotproduct":{description:"The `mapper.dotproduct` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"vector<LIST>  mapper.dotproduct  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct"},"mapper.dotproduct.positive":{description:"The `mapper.dotproduct.positive` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it sets all negative results to 0.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"vector<LIST>  mapper.dotproduct.positive  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.positive"},"mapper.dotproduct.sigmoid":{description:"The `mapper.dotproduct.sigmoid` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the sigmoid of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"vector<LIST>  mapper.dotproduct.sigmoid  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.sigmoid"},"mapper.dotproduct.tanh":{description:"The `mapper.dotproduct.tanh` function consumes a vector as parameter (a **LIST* of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the \n[hyperbolic tangent](https://en.wikipedia.org/wiki/Hyperbolic_function) of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"vector<LIST>  mapper.dotproduct.tanh  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.tanh"},"mapper.eq":{description:"This mapper function returns the first value in a sliding window which is equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.eq` function can be applied to data of any type.\n\nThe `mapper.eq` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.eq  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.eq  result<AGGREGATOR>\nparameter<BOOLEAN>  mapper.eq  result<AGGREGATOR>\nparameter<STRING>  mapper.eq  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.eq"},"mapper.eq.elev":{description:"This mapper function returns the first elevation in a sliding window which is equal to a given value.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.eq.elev` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.eq.elev  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.elev"},"mapper.eq.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is equal to a given value.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.eq.hhcode` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.eq.hhcode  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.hhcode"},"mapper.eq.lat":{description:"This mapper function returns the first latitude in a sliding window which is equal to a given value.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.eq.lat` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.eq.lat  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.eq.lat  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lat"},"mapper.eq.lon":{description:"This mapper function returns the first longitude in a sliding window which is equal to a given value.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.eq.lon` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.eq.lon  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.eq.lon  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lon"},"mapper.eq.tick":{description:"This mapper function returns the first tick in a sliding window which is equal to a given value.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.eq.tick` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.eq.tick  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.tick"},"mapper.exp":{description:"This mapper function raises a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.exp` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.exp` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\n> ## Note\n> The `mapper.exp` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n>\n> So you are looking for a way to apply the exponential function, ex, to a series of Geo Time Series™. It’s very easy to do it using `mapper.exp` and the\n> [`e`](/doc/OF) constant.\n\n@param `result` Mapper to apply\n\n@param `constant` Constant to use\n\n",signature:"constant<LONG>  mapper.exp  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.exp  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.exp"},"mapper.finite":{description:"Pushes onto the stack an AGGREGATOR which returns its input value only if it is finite (*i.e.* a non DOUBLE or a DOUBLE which is neither NaN nor Infinity).\n\n@param `result` Instance of mapper.finite.\n\n",signature:" mapper.finite  result<AGGREGATOR>",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.finite"},"mapper.first":{description:"This mapper function returns the first value of each sliding window with its associated location and elevation.\n\nThe `mapper.first` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.first  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.first"},"mapper.floor":{description:"This mapper function rounds the *single value* in a sliding window to the closests lower **LONG**.\n\nThe `mapper.floor` function can be applied to data of type **LONG** or **DOUBLE**.      \n\n@param `result` Mapper to apply\n\n",signature:" mapper.floor  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.floor"},"mapper.ge":{description:"This mapper function returns the first value in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ge` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.ge` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ge  result<AGGREGATOR>\nthreshold<STRING>  mapper.ge  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ge  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ge"},"mapper.ge.elev":{description:"This mapper function returns the first elevation in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ge.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ge.elev  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.elev"},"mapper.ge.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ge.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ge.hhcode  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.hhcode"},"mapper.ge.lat":{description:"This mapper function returns the first latitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ge.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ge.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ge.lat  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lat"},"mapper.ge.lon":{description:"This mapper function returns the first longitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ge.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ge.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ge.lon  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lon"},"mapper.ge.tick":{description:"This mapper function returns the first tick in a sliding window which is greater or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ge.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ge.tick  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.tick"},"mapper.geo.approximate":{description:"Pushes onto the stack a mapper instance which will transform the input Geo Time Series™ by approximating the location to the givnen resolution.\n\nApproximation is done by clearing lower bits of the location [HHCode](https://en.wikipedia.org/wiki/HHCode). At resolution `R`, the lower `64 - 2R` bits are cleared.\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\n\n\n@param `resolution` HHCode resolution at which to approximate the locations. Resoluion is an even number between 2 (coarsest) and 32 (finest).\n\n@param `result` Instance of mapper.\n\n",signature:"resolution<LONG>  mapper.geo.approximate  result<AGGREGATOR>",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.approximate"},"mapper.geo.clear":{description:"Pushes onto the stack a mapper which will discard location and elevation information when applied to a Geo Time Series™.\n\nThis mapper can only be applied to single values\n\n@param `result` Instance of the `mapper.geo.clear` mapper.\n\n",signature:" mapper.geo.clear  result<AGGREGATOR>",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.geo.clear"},"mapper.geo.fence":{description:"This function produces a `mapper` which outputs a `BOOLEAN` for each point with an associated location. The value of the output is `true` if the location is inside the provided `GEOSHAPE` and `false` otherwise.\nThe geo zone can be defined in [WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using [`GEO.WKT`](/doc/GEO.WKT) or in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) using [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `zone` Geographical zone.\n\n@param `result` Mapper to apply\n\n",signature:"zone<GEOSHAPE>  mapper.geo.fence  result<AGGREGATOR>",tags:["mapper","geo"],since:"2.7.1",OPB64name:"mapper.geo.fence"},"mapper.geo.outside":{description:"This mapper filters the Geo Time Series™, keeping only the points outside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",signature:"geoZone<GEOSHAPE>  mapper.geo.outside  result<AGGREGATOR>",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.outside"},"mapper.geo.within":{description:"This mapper filters the Geo Time Series™, keeping only the points inside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",signature:"geoZone<GEOSHAPE>  mapper.geo.within  result<AGGREGATOR>",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.within"},"mapper.gt":{description:"This mapper function returns the first value in a sliding window which is greater than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.gt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.gt` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.gt  result<AGGREGATOR>\nthreshold<STRING>  mapper.gt  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.gt  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.gt"},"mapper.gt.elev":{description:"This mapper function returns the first elevation in a sliding window which is greater than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.gt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.gt.elev  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.elev"},"mapper.gt.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.gt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.gt.hhcode  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.hhcode"},"mapper.gt.lat":{description:"This mapper function returns the first latitude in a sliding window which is greater than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.gt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.gt.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.gt.lat  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lat"},"mapper.gt.lon":{description:"This mapper function returns the first longitude in a sliding window which is greater than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.gt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.gt.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.gt.lon  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lon"},"mapper.gt.tick":{description:"This mapper function returns the first tick in a sliding window which is greater than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.gt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.gt.tick  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.tick"},"mapper.hdist":{description:"The `mapper.hdist` function computes the total distance traveled while going through the points in the sliding window in chronological order. This distance is in meters.\n\nThe distance used is the loxodromic distance aka rhumb line. As a consequence, elevation is not taken into account in the distance.\n\nIf a point has no position in the sliding window, it is ignored.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe `mapper.hdist` function can be applied to data of any type since it only considers locations.\n\n@param `hdistMapper` A function which can be used in a mapper.\n\n",signature:" mapper.hdist  hdistMapper<AGGREGATOR>",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.hdist"},"mapper.highest":{description:"This mapper function returns the value associated with the highest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the most recent is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.highest  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.highest"},"mapper.hour":{description:"This mapper function returns the hour of the tick for which it is computed.\n\nThe `mapper.hour` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"timezone<STRING>  mapper.hour  result<AGGREGATOR>\noffset<NUMBER>  mapper.hour  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.hour"},"mapper.hspeed":{description:"This mapper function computes the horizontal speed along the path traveled in the sliding window.\n\nThe distance is computed by summing the distances along the rhumb line between two consecutive locations.\n\nIf there is only one tick in the sliding window, the speed is 0.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.hspeed` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.hspeed  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.hspeed"},"mapper.join":{description:"This mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"separator<STRING>  mapper.join  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join"},"mapper.join.forbid-nulls":{description:"**Deprecated**: `mapper.join.forbid-nulls` has the same behavior as `mapper.join`, use `mapper.join` instead.\n\nThis mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"separator<STRING>  mapper.join.forbid-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join.forbid-nulls"},"mapper.kernel.cosine":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [cosine kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics.\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.cosine  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.cosine"},"mapper.kernel.epanechnikov":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using an [epanechnikov kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.epanechnikov  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.epanechnikov"},"mapper.kernel.gaussian":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [gaussian kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.gaussian  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.gaussian"},"mapper.kernel.logistic":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [logistic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.logistic  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.logistic"},"mapper.kernel.quartic":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [quartic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.quartic  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.quartic"},"mapper.kernel.silverman":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [silverman kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.silverman  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.silverman"},"mapper.kernel.triangular":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triangular kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.triangular  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triangular"},"mapper.kernel.tricube":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [tricube kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.tricube  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.tricube"},"mapper.kernel.triweight":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triweight kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.triweight  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triweight"},"mapper.kernel.uniform":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [uniform kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"bandwidth<LONG> step<LONG>  mapper.kernel.uniform  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.uniform"},"mapper.last":{description:"This [`mapper`](/doc/MAP) function returns the last value of each sliding window with its associated location and elevation.\n\nThe `mapper.last` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.last  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.last"},"mapper.le":{description:"This mapper function returns the first value in a sliding window which is less or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.le` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.le` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",signature:"threshold<DOUBLE>  mapper.le  result<AGGREGATOR>\nthreshold<LONG>  mapper.le  result<AGGREGATOR>\nthreshold<STRING>  mapper.le  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.le"},"mapper.le.elev":{description:"This mapper function returns the first elevation in a sliding window which is less or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.le.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.le.elev  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.elev"},"mapper.le.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.le.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.le.hhcode  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.hhcode"},"mapper.le.lat":{description:"This mapper function returns the first latitude in a sliding window which is less or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.le.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.le.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.le.lat  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lat"},"mapper.le.lon":{description:"This mapper function returns the first longitude in a sliding window which is less or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.le.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.le.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.le.lon  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lon"},"mapper.le.tick":{description:"This mapper function returns the first tick in a sliding window which is less or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.le.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.le.tick  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.tick"},"mapper.log":{description:"This mapper function takes the log of the **single value** in a sliding window in the base used as parameter to `mapper.log`.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.log` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.log` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\nThe `mapper.log` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n\n@param `constant` Constant parameter\n\n@param `result` Mapper to apply\n\n",signature:"constant<DOUBLE>  mapper.log  result<AGGREGATOR>\nconstant<LONG>  mapper.log  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.log"},"mapper.lowest":{description:"This mapper function returns the value associated with the lowest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the one appearing first chronologically is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.lowest  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.lowest"},"mapper.lt":{description:"This mapper function returns the first value in a sliding window which is less than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.lt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.lt` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",signature:"threshold<DOUBLE>  mapper.lt  result<AGGREGATOR>\nthreshold<LONG>  mapper.lt  result<AGGREGATOR>\nthreshold<STRING>  mapper.lt  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.lt"},"mapper.lt.elev":{description:"This mapper function returns the first elevation in a sliding window which is less than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.lt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.lt.elev  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.elev"},"mapper.lt.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.lt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.lt.hhcode  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.hhcode"},"mapper.lt.lat":{description:"This mapper function returns the first latitude in a sliding window which is less than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.lt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.lt.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.lt.lat  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lat"},"mapper.lt.lon":{description:"This mapper function returns the first longitude in a sliding window which is less than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.lt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.lt.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.lt.lon  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lon"},"mapper.lt.tick":{description:"This mapper function returns the first tick in a sliding window which is less than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.lt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.lt.tick  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.tick"},"mapper.mad":{description:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) over each sliding window.\n\nThe returned location is the median of all the locations in the sliding window, and the returned elevation is the median of all the elevations in the window.\n\n@param `result` Instance of `mapper.mad`.\n\n",signature:" mapper.mad  result<AGGREGATOR>",tags:["mapper"],since:"1.2.0",OPB64name:"mapper.mad"},"mapper.max":{description:"This mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.max  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max"},"mapper.max.forbid-nulls":{description:"**Deprecated**: `mapper.max.forbid-nulls` has the same behavior as `mapper.max`, use `mapper.max` instead.\n\nThis mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",signature:" mapper.max.forbid-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max.forbid-nulls"},"mapper.max.x":{description:"This mapper function returns the max between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.max.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",signature:"constant<DOUBLE>  mapper.max.x  result<AGGREGATOR>\nconstant<LONG>  mapper.max.x  result<AGGREGATOR>\nconstant<STRING>  mapper.max.x  result<AGGREGATOR>\nconstant<BOOLEAN>  mapper.max.x  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.max.x"},"mapper.mean":{description:"This mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.mean  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean"},"mapper.mean.circular":{description:"This function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`mapper.mean.circular.exclude-nulls`](/doc/mapper.mean.circular.exclude-nulls) if your sliding windows may contain nulls.\n\nThe `mapper.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",signature:"modulo<NUMBER>  mapper.mean.circular  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular"},"mapper.mean.circular.exclude-nulls":{description:"**Deprecated**: `mapper.mean.circular.exclude-nulls` has the same behavior as `mapper.mean.circular`, use `mapper.mean.circular` instead.\n\nThis function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular.exclude-nulls` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `mapper.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",signature:"modulo<NUMBER>  mapper.mean.circular.exclude-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular.exclude-nulls"},"mapper.mean.exclude-nulls":{description:"**Deprecated**: `mapper.mean.exclude-nulls` has the same behavior as `mapper.mean`, use `mapper.mean` instead.\n        \nThis mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",signature:" mapper.mean.exclude-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.exclude-nulls"},"mapper.median":{description:"Pushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median`.\n\n",signature:" mapper.median  result<AGGREGATOR>",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.median"},"mapper.median.forbid-nulls":{description:"**Deprecated**: `mapper.median.forbid-nulls` has the same behavior as `mapper.median`, use `mapper.median` instead.\n\nPushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median.forbid-nulls`.\n\n",signature:" mapper.median.forbid-nulls  result<AGGREGATOR>",tags:["mapper","gts"],since:"2.4.0",OPB64name:"mapper.median.forbid-nulls"},"mapper.min":{description:"This mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.min  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min"},"mapper.min.forbid-nulls":{description:"**Deprecated**: `mapper.min.forbid-nulls` has the same behavior as `mapper.min`, use `mapper.min` instead.\n\nThis mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",signature:" mapper.min.forbid-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min.forbid-nulls"},"mapper.min.x":{description:"This mapper function returns the min between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.min.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",signature:"constant<DOUBLE>  mapper.min.x  result<AGGREGATOR>\nconstant<LONG>  mapper.min.x  result<AGGREGATOR>\nconstant<STRING>  mapper.min.x  result<AGGREGATOR>\nconstant<BOOLEAN>  mapper.min.x  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.min.x"},"mapper.minute":{description:"This mapper function returns the minute of the tick for which it is computed.\n\nThe `mapper.minute` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"timezone<STRING>  mapper.minute  result<AGGREGATOR>\noffset<NUMBER>  mapper.minute  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.minute"},"mapper.mod":{description:"Pushes onto the stack an AGGREGATOR which computes the remainder of a value given a modulus.\n\nThis MAPPER can only be applied to a single value.\n\n@param `modulus` Modulus to consider when computing the remainder.\n\n@param `result` Instance of `mapper.mod`.\n\n",signature:"modulus<NUMBER>  mapper.mod  result<AGGREGATOR>",tags:["mapper","gts"],since:"1.2.3",OPB64name:"mapper.mod"},"mapper.month":{description:"This mapper function returns the month of the tick for which it is computed.\n\nThe `mapper.month` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",signature:"timezone<STRING>  mapper.month  result<AGGREGATOR>\noffset<NUMBER>  mapper.month  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.month"},"mapper.mul":{description:"This mapper function multiplies by a constant the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.mul` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.mul` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",signature:"constant<LONG>  mapper.mul  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.mul  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.mul"},"mapper.ne":{description:"This mapper function returns the first value in a sliding window which is not equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ne` function can be applied to data of any type.\n\nThe `mapper.ne` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"parameter<LONG>  mapper.ne  result<AGGREGATOR>\nparameter<DOUBLE>  mapper.ne  result<AGGREGATOR>\nparameter<BOOLEAN>  mapper.ne  result<AGGREGATOR>\nparameter<STRING>  mapper.ne  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ne"},"mapper.ne.elev":{description:"This mapper function returns the first elevation in a sliding window which is not equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ne.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ne.elev  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.elev"},"mapper.ne.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is not equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ne.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ne.hhcode  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.hhcode"},"mapper.ne.lat":{description:"This mapper function returns the first latitude in a sliding window which is not equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ne.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ne.lat  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ne.lat  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lat"},"mapper.ne.lon":{description:"This mapper function returns the first longitude in a sliding window which is not equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ne.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ne.lon  result<AGGREGATOR>\nthreshold<DOUBLE>  mapper.ne.lon  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lon"},"mapper.ne.tick":{description:"This mapper function returns the first tick in a sliding window which is not equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ne.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"threshold<LONG>  mapper.ne.tick  result<AGGREGATOR>",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.tick"},"mapper.npdf":{description:"Pushes onto the stack an AGGREGATOR which returns the probability of a value given a normal distribution.\n\n@param `mu` Mean of the normal (Gaussian) distribution to consider.\n\n@param `sigma` Standard deviation of the normal (Gaussian) distribution to consider.\n\n@param `result` Instance of `mapper.npdf`.\n\n",signature:"mu<DOUBLE> sigma<DOUBLE>  mapper.npdf  result<AGGREGATOR>",tags:["gts","mapper"],since:"1.0.0",OPB64name:"mapper.npdf"},"mapper.or":{description:"This mapper function applies the logical operator OR on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.or  result<AGGREGATOR>",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.or"},"mapper.parsedouble":{description:"This mapper function converts a **STRING** single value in a sliding window to **DOUBLE**.\n\nThe `mapper.parsedouble` function can be applied to data of type **STRING**.\n\nThis function expects a [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) \nparameter in top of the mapper. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `tag` [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) parameter. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `result` Mapper to apply\n\n",signature:"tag<STRING>  mapper.parsedouble  result<AGGREGATOR>",tags:["mapper"],since:"1.2.5",OPB64name:"mapper.parsedouble"},"mapper.percentile":{description:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the sliding window.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `percentile` Percentile to consider.\n\n@param `result` Instance of `mapper.percentile`.\n\n",signature:"percentile<NUMBER>  mapper.percentile  result<AGGREGATOR>",tags:["mapper","gts"],since:"1.0.0",OPB64name:"mapper.percentile"},"mapper.pow":{description:"This mapper function raises the single value in a sliding window to a constant power.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.pow` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.pow` function must be parameterized with the constant.\n\nThe result is always of type DOUBLE.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",signature:"constant<LONG>  mapper.pow  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.pow  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.pow"},"mapper.product":{description:"This mapper function computes the product of all the values found in the sliding window.\n\nThe `mapper.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\nOn [bucketized](/doc/BUCKETIZE) Geo Time Series™, it is necessary to fill gaps with [`FILLVALUE`](/doc/FILLVALUE)\n\n@param `result` Mapper to apply\n\n",signature:" mapper.product  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.product"},"mapper.rate":{description:"This mapper function computes the rate of change between the first and last values (rate = (last - first) / (lastick - firsttick)) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.rate` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value. If the\nsliding window contains less than 2 values, the rate of change will be 0.0.\n\nThe rate of change is expressed in units per second.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.rate  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.rate"},"mapper.replace":{description:"This mapper function replaces windows with at least one value with a constant. The location and elevation returned are those associated with the most \nrecent value in the sliding window.\n\n@param `constant` constant used for replacement\n\n@param `result` Mapper to apply\n\n",signature:"constant<LONG>  mapper.replace  result<AGGREGATOR>\nconstant<DOUBLE>  mapper.replace  result<AGGREGATOR>\nconstant<STRING>  mapper.replace  result<AGGREGATOR>\nconstant<BOOLEAN>  mapper.replace  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.replace"},"mapper.rms":{description:"This mapper function returns the root mean square of all the values found in each sliding window. The associated location is the last one of the window.\n\nThe `mapper.rms` function can only be applied to values of type **LONG** or **DOUBLE**.\n\n\n@param `result` Mapper to apply\n\n",signature:" mapper.rms  result<AGGREGATOR>",tags:["mapper"],since:"1.2.18",OPB64name:"mapper.rms"},"mapper.round":{description:"This mapper function rounds the *single value* in a sliding window to the closests **LONG**.\n\nThe `mapper.round` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.round  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.round"},"mapper.sd":{description:"This mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"bessel<BOOLEAN>  mapper.sd  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd"},"mapper.sd.forbid-nulls":{description:"**Deprecated**: `mapper.sd.forbid-nulls` has the same behavior as `mapper.sd`, use `mapper.sd` instead.\n\nThis mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"bessel<BOOLEAN>  mapper.sd.forbid-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd.forbid-nulls"},"mapper.second":{description:"This mapper function returns the second of the tick for which it is computed.\n\nThe `mapper.second` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"timezone<STRING>  mapper.second  result<AGGREGATOR>\noffset<NUMBER>  mapper.second  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.second"},"mapper.sigmoid":{description:"This mapper function returns the sigmoid of *single value* in a sliding window.\n\nThe `mapper.sigmoid` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.sigmoid  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sigmoid"},"mapper.sqrt":{description:"This mapper function computes the square root of the single value in a sliding window.\n\nFor negative numerics, this mapper returns **NaN**. For string values, this mapper returns 0.\n\nThe associated location and elevation are those of the single value.\n\n> ### Note\n> The `mapper.sqrt` mapper needs a single value sliding window, i.e. pre-window and post-window to 0\n\n\n@param `result` Mapper to apply\n\n",signature:" mapper.sqrt  result<AGGREGATOR>",tags:["mapper"],since:"1.2.11",OPB64name:"mapper.sqrt"},"mapper.sum":{description:"This mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.sum  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum"},"mapper.sum.forbid-nulls":{description:"**Deprecated**: `mapper.sum.forbid-nulls` has the same behavior as `mapper.sum`, use `mapper.sum` instead.\n\nThis mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.sum.forbid-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum.forbid-nulls"},"mapper.tanh":{description:"This mapper function returns the hyperbolic tangent of *single value* in a sliding window.\n\nThe `mapper.tanh` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.tanh  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tanh"},"mapper.tick":{description:"This mapper function returns the tick for which it is computed. The associated location and elevation are those of the selected value.\n\nThe `mapper.tick` function can be applied to values of any type.        \n\n@param `result` Mapper to apply\n\n",signature:" mapper.tick  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.tick"},"mapper.toboolean":{description:"This mapper function converts the single value in a sliding window to **BOOLEAN**.\n\nThe `mapper.toboolean` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.toboolean  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.toboolean"},"mapper.todouble":{description:"This mapper function converts the single value in a sliding window to **DOUBLE**.\n\nThe `mapper.todouble` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.todouble  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.todouble"},"mapper.tolong":{description:"This mapper function converts the single value in a sliding window to **LONG**.\n\nThe `mapper.tolong` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.tolong  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tolong"},"mapper.tostring":{description:"This mapper function converts the single value in a sliding window to **STRING**.\n\nThe `mapper.tostring` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.tostring  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tostring"},"mapper.truecourse":{description:"Pushes onto the stack a mapper which will compute the initial [true course]http://www.edwilliams.org/avform.htm#Crs) on a great circle from the first to the last datapoint in the sliding window.\n\nThe location and elevation of the result is that of the tick being considered.\n\n@param `result` Instance of mapper.truecourse.\n\n",signature:" mapper.truecourse  result<AGGREGATOR>",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.truecourse"},"mapper.var":{description:"This mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"bessel<BOOLEAN>  mapper.var  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var"},"mapper.var.forbid-nulls":{description:"**Deprecated**: `mapper.var.forbid-nulls` has the same behavior as `mapper.var`, use `mapper.var` instead.\n\nThis mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"bessel<BOOLEAN>  mapper.var.forbid-nulls  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var.forbid-nulls"},"mapper.vdist":{description:"This mapper function computes the total distance traveled in the vertical plane in the sliding window.\n\nThe distance is computed by summing the distances between consecutive elevations (this differs from the computation done in [`mapper.vspeed`](/doc/mapper.vspeed))\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed distance is expressed in meters.\n\nThe `mapper.vdist` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.vdist  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vdist"},"mapper.vspeed":{description:"This mapper function computes the vertical speed between the first and last readings of the sliding window. It does not compute the speed based on the total\nvertical distance traveled in the sliding window, it only considers its extrema (it differs significantly of what is done for horizontal speed in\n[`mapper.hspeed`](/doc/mapper.hspeed)), thus the result can be positive or negative.\n\nIf one of the extrema of the sliding window has no elevation, no value is returned.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.vspeed` function can be applied to data of any type since it only considers elevations.\n\n@param `result` Mapper to apply\n\n",signature:" mapper.vspeed  result<AGGREGATOR>",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vspeed"},"mapper.weekday":{description:"This mapper function returns the day of the week of the tick for which it is computed.\n\nThe `mapper.weekday` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",signature:"timezone<STRING>  mapper.weekday  result<AGGREGATOR>\noffset<NUMBER>  mapper.weekday  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.weekday"},"mapper.year":{description:"This mapper function returns the year of the tick for which it is computed.\n\nThe `mapper.year` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"timezone<STRING>  mapper.year  result<AGGREGATOR>\noffset<NUMBER>  mapper.year  result<AGGREGATOR>",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.year"},"max.tick.sliding.window":{description:"Pushes onto the stack [`MAXLONG`](/doc/MAXLONG) divided by 2, to serve as the maximum number of ticks left or right of the current tick in a [`MAP`](/doc/MAP) sliding window.\n\nGiven that a Geo Time Series™ can have no more than 2**32 datapoints, this value is sufficient to cover the whole GTS left or right of the current tick.\n\n@param `max` Value pushed onto the stack.\n\n",signature:" max.tick.sliding.window  max<LONG>",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.tick.sliding.window"},"max.time.sliding.window":{description:"Pushes onto the stack half of the minimum LONG value, to serve as a *pre* or *post* extension of a [`MAP`](/doc/MAP) sliding window in time units.\n\nThis value spans a lot of time but may not be enough to cover the entirety of a GTS.\n\n@param `max` Value pushed onto the stack.\n\n",signature:" max.time.sliding.window  max<LONG>",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.time.sliding.window"},ms:{description:"Converts a number of milliseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of milliseconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of milliseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of milliseconds\n\n",signature:"input<NUMBER>  ms  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"ms"},ns:{description:"Converts a number of nanoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of nanoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of nanoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of nanoseconds\n\n",signature:"input<NUMBER>  ns  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"ns"},"op.add":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter Geo Time Series™.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator forbids null values, *i.e.* if a `null` is encountered, then there will be no result for the given tick.\n\n@param `op` The instance of operator.\n\n",signature:" op.add  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.add"},"op.add.ignore-nulls":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter GTS.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:" op.add.ignore-nulls  op<OPERATOR>",tags:["op"],since:"1.2.4",OPB64name:"op.add.ignore-nulls"},"op.and":{description:"To apply an `op.and` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.and  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.and"},"op.and.ignore-nulls":{description:"To apply an `op.and.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and.ignore-nulls` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:" op.and.ignore-nulls  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.and.ignore-nulls"},"op.div":{description:"To apply an `op.div` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.div is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.div` operation can only operate on equivalence classes which have two GTS (if the equivalence class has more than two GTS, there is no result guaranted). It will divide at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.div  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.div"},"op.eq":{description:"To apply an `op.eq` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.eq is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.eq` operation will check for equality at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.eq  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.eq"},"op.ge":{description:"To apply an `op.ge` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ge` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ge` operation will check at each tick if the value of the current GTS is greater or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.ge  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.ge"},"op.gt":{description:"To apply an `op.gt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.gt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.gt` operation will check at each tick if the value of the current GTS is greater than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n\n@param `op` The instance of operator.\n\n",signature:" op.gt  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.gt"},"op.le":{description:"To apply an `op.le` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.le` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.le` operation will check at each tick if the value of the current GTS is lesser or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.le  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.le"},"op.lt":{description:"To apply an `op.lt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.lt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.lt` operation will check at each tick if the value of the current GTS is lesser than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.lt  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.lt"},"op.mask":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), retains datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The instance of operator.\n\n",signature:" op.mask  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.mask"},"op.mul":{description:"To apply an `op.mul` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\n@param `op` The instance of operator.\n\n",signature:" op.mul  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.mul"},"op.mul.ignore-nulls":{description:"To apply an `op.mul.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul.ignore-nulls` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:" op.mul.ignore-nulls  op<OPERATOR>",tags:["op"],since:"1.2.4",OPB64name:"op.mul.ignore-nulls"},"op.ne":{description:"To apply an `op.ne` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ne` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ne` operation will check for inequality at each tick all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.ne  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.ne"},"op.negmask":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), removes datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The operator instance.\n\n",signature:" op.negmask  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.negmask"},"op.or":{description:"To apply an `op.or` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.or  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.or"},"op.or.ignore-nulls":{description:"To apply an `op.or.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or.ignore-nulls` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:" op.or.ignore-nulls  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.or.ignore-nulls"},"op.sub":{description:"To apply an `op.sub` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.sub` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe sub operator can only operate on equivalence classes which have **exactly two GTS**. It will substract at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:" op.sub  op<OPERATOR>",tags:["op"],since:"1.0.11",OPB64name:"op.sub"},pi:{description:"Alias of [PI](/doc/J3Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",signature:" pi  pi<DOUBLE>",tags:["math","constants"],since:"1.0.0",OPB64name:"R5Z"},ps:{description:"Converts a number of picoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of picoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of picoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of picoseconds\n\n",signature:"input<NUMBER>  ps  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"ps"},"reducer.and":{description:"The `reducer.and` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.and  reducer<AGGREGATOR>",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and"},"reducer.and.exclude-nulls":{description:"The `reducer.and.exclude-nulls` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ \nwhich are in the same equivalence class, excluding nulls from the computation.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, \nthe current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.and.exclude-nulls  reducer<AGGREGATOR>",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and.exclude-nulls"},"reducer.argmax":{description:"The `reducer.argmax` function outputs for each tick, the tick and the concatenation separated by ‘,’ of the values of the labels for which the\nvalue is the maximum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the maximum to report (use 0 to report all), and a **STRING**\nparameter to choose on which label it operates.\n\n@param `maximum` Maximum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",signature:"label<STRING> maximum<LONG>  reducer.argmax  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmax"},"reducer.argmin":{description:"The `reducer.argmin` function outputs for each tick, the tick and the concatenation separated by ‘,’ \nwith the values of the labels for which the value is the minimum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the minimum to report (use 0 to report all), and a **STRING** \nparameter to choose on which label it operates.\n\n@param `minimum` Minimum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",signature:"label<STRING> minimum<LONG>  reducer.argmin  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmin"},"reducer.count":{description:"The `reducer.count` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe include null version, [`reducer.count.include-nulls`](/doc/reducer.count.include-nulls), will include null values when computing the count. The exclude null version, \n[`reducer.count.exclude-nulls`](/doc/reducer.count.exclude-nulls), will exclude null values when computing the count.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.count  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count"},"reducer.count.exclude-nulls":{description:"The `reducer.count.exclude-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.count.exclude-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.exclude-nulls"},"reducer.count.include-nulls":{description:"The `reducer.count.include-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are included.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.count.include-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.include-nulls"},"reducer.count.nonnull":{description:"The `reducer.count.nonnull` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.count.nonnull  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.nonnull"},"reducer.join":{description:"The 'reducer.join' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will exclude all null values when computing the join.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"separator<STRING>  reducer.join  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join"},"reducer.join.forbid-nulls":{description:"Alias of [`reducer.join.nonnull`](/doc/reducer.join.nonnull).\n\nThe 'reducer.join.forbid-nulls' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"separator<STRING>  reducer.join.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.forbid-nulls"},"reducer.join.nonnull":{description:"Alias of [`reducer.join.forbid-nulls`](/doc/reducer.join.forbid-nulls).\n\nThe 'reducer.join.nonnull' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"separator<STRING>  reducer.join.nonnull  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.nonnull"},"reducer.join.urlencoded":{description:"The 'reducer.join.urlencoded' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) charset.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"separator<STRING>  reducer.join.urlencoded  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.urlencoded"},"reducer.mad":{description:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) for each ticks. Null values are removed before computing the MAD for each ticks.\n\nThe returned location is the median of all the locations and the returned elevation is the median of all the elevations.\n\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.mad  reducer<AGGREGATOR>",tags:["reducer"],since:"1.2.0",OPB64name:"reducer.mad"},"reducer.max":{description:"The `reducer.max` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will exclude all null values when computing the maximum.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.max  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max"},"reducer.max.forbid-nulls":{description:"Alias of [`reducer.max.nonnull`](/doc/reducer.max.nonnull).\n\nThe `reducer.max.forbid-nulls` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.max.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.forbid-nulls"},"reducer.max.nonnull":{description:"Alias of [`reducer.max.forbid-nulls`](/doc/reducer.max.forbid-nulls).\n\nThe `reducer.max.nonnull` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.max.nonnull  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.nonnull"},"reducer.mean":{description:"The `reducer.mean` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.mean  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean"},"reducer.mean.circular":{description:"The `reducer.mean.circular` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`reducer.mean.circular.exclude-nulls`](/doc/reducer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `reducer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"modulo<NUMBER>  reducer.mean.circular  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular"},"reducer.mean.circular.exclude-nulls":{description:"The `reducer.mean.circular.exclude-nulls` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `reducer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"modulo<NUMBER>  reducer.mean.circular.exclude-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular.exclude-nulls"},"reducer.mean.exclude-nulls":{description:"The `reducer.mean.exclude-nulls` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will exclude all null values when computing the mean.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.mean.exclude-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.exclude-nulls"},"reducer.median":{description:"The `reducer.median` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.median  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.median"},"reducer.median.forbid-nulls":{description:"The `reducer.median.forbid-nulls` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value, ie ticks do not match between Geo Times Series™ in the same equivalence class, it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.median.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"2.4.0",OPB64name:"reducer.median.forbid-nulls"},"reducer.min":{description:"The `reducer.min` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will exclude all null values when computing the minimum.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.min  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min"},"reducer.min.forbid-nulls":{description:"Alias of [`reducer.min.nonnull`](/doc/reducer.min.nonnull).\n\nThe `reducer.min.forbid-nulls` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.min.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.forbid-nulls"},"reducer.min.nonnull":{description:"Alias of [`reducer.min.forbid-nulls`](/doc/reducer.min.forbid-nulls).\n\nThe `reducer.min.nonnull` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.min.nonnull  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.nonnull"},"reducer.or":{description:"The `reducer.or` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.or  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or"},"reducer.or.exclude-nulls":{description:"The `reducer.or.exclude-nulls` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.or.exclude-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or.exclude-nulls"},"reducer.percentile":{description:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values for each tick.\n\nFor this reducer, GTS must be aligned and must have a value for each tick of each GTS. \n\nThe returned location and elevation are those of the chosen value.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.percentile  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.percentile"},"reducer.product":{description:"This reducer function computes the product of all the values for each tick.\n\nThe `reducer.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.product  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.product"},"reducer.rms":{description:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIf one value is null, there won't be any result for the concerned tick.\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.rms  reducer<AGGREGATOR>",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms"},"reducer.rms.exclude-nulls":{description:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms. Even if input GTS are misaligned, there will be one result per tick.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.rms.exclude-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms.exclude-nulls"},"reducer.sd":{description:"The `reducer.sd` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"bessel<BOOLEAN>  reducer.sd  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd"},"reducer.sd.forbid-nulls":{description:"The `reducer.sd.forbid-nulls` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"bessel<BOOLEAN>  reducer.sd.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd.forbid-nulls"},"reducer.shannonentropy.0":{description:"The `reducer.shannonentropy.0` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 0 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.shannonentropy.0  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.0"},"reducer.shannonentropy.1":{description:"The `reducer.shannonentropy.1` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 1 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.shannonentropy.1  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.1"},"reducer.sum":{description:"The `reducer.sum` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.sum  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum"},"reducer.sum.forbid-nulls":{description:"Alias of [`reducer.sum.nonnull`](/doc/reducer.sum.nonnull).\n\nThe `reducer.sum.forbid-nulls` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.sum.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.forbid-nulls"},"reducer.sum.nonnull":{description:"Alias of [`reducer.sum.forbid-nulls`](/doc/reducer.sum.forbid-nulls).\n\nThe `reducer.sum.nonnull` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:" reducer.sum.nonnull  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.nonnull"},"reducer.var":{description:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"bessel<BOOLEAN>  reducer.var  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var"},"reducer.var.forbid-nulls":{description:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"bessel<BOOLEAN>  reducer.var.forbid-nulls  reducer<AGGREGATOR>",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var.forbid-nulls"},s:{description:"Converts a number of seconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of seconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of seconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of seconds\n\n",signature:"input<NUMBER>  s  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"s"},us:{description:"Converts a number of microseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of microseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of microseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of microseconds\n\n",signature:"input<NUMBER>  us  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"us"},w:{description:"Converts a number of weeks (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of weeks from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of weeks to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of weeks\n\n",signature:"input<NUMBER>  w  output<LONG>",tags:["date"],since:"1.0.0",OPB64name:"w"},"{":{description:"Starts a map creation.\n\nThe `{` function creates a map by pushing a mark onto the stack. This is a syntactic help to better present map constructions. This function behaves like [`MARK`].\n\n@param `mark` A MARK object.\n\n",signature:" {  mark<MARK>",tags:["maps"],since:"1.0.0",OPB64name:"Tk"},"{}":{description:"The {} function creates an empty MAP on the top of the stack.\n\n\n@param `newmap` Empty map instance.\n\n",signature:" {}  newmap<MAP>",tags:["maps"],since:"1.0.0",OPB64name:"Tro"},"|":{description:"Performs a bitwise **OR** operation.\n\nThe `|` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **OR**.\n \nSince Warp 10™ 2.1, `|` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be OR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with OR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts OR with mask\n\n",signature:"p1<LONG> p2<LONG>  |  result<LONG>\ninputgts<GTS> mask<LONG>  |  maskedgts<GTS>\ngts1<GTS> gts2<GTS>  |  outputgts<GTS>",tags:["binary","operators"],since:"1.0.0",OPB64name:"U."},"||":{description:"The `||` operator is a synonymous for [`OR`](/doc/OR).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `||` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",signature:"p1<BOOLEAN> p2<BOOLEAN>  ||  result<BOOLEAN>\nl<LIST>  ||  result<BOOLEAN>\ngts1<GTS> gts2<GTS>  ||  gtsresult<GTS>",tags:["operators","logic"],since:"1.0.0",OPB64name:"U6k"},"}":{description:"Closes a currently open map and pushes it onto the stack.\n\nThe `}` function pops from the stack the elements (key/value pairs) of the map up to the first mark. The marks are consumed.\n\n@param `k1` The first key\n\n@param `v1` The first value\n\n@param `kN` The Nth key\n\n@param `vN` The Nth value\n\n@param `map` The built map\n\n@param `mark` The mark indicating the deepest level to consider when building the map\n\n",signature:"mark<MARK> k1<ANY> v1<ANY> kN<ANY> vN<ANY>  }  map<MAP>",tags:["maps"],since:"1.0.0",OPB64name:"UF"},"~":{description:"Computes the unary bitwise complement of the long value on top of the stack.\n\n@param `param` Value to compute\n\n@param `result` Bitwise result\n\n",signature:"param<LONG>  ~  result<LONG>",tags:["operators","binary","math"],since:"1.0.0",OPB64name:"UV"},"~=":{description:"The `~=` operator consumes three parameters from the top of the stack, two operands p1 and p2 and a tolerance factor lambda, \nand pushes onto the stack true if *|p1-p2| < lambda*, i.e. the difference between the two operands is lesser than lambda.\n\nThe two parameters must be of numeric types.\n\nThe operator `~=` is useful when making comparaisons between doubles, where floating point operations generate rounding errors.\n\n@param `p1` First number\n\n@param `p2` Second number\n\n@param `lambda` Tolerance factor lambda\n\n@param `result` \n\n",signature:"p2<DOUBLE> p1<DOUBLE> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<LONG> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<LONG> p1<DOUBLE> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<COUNTER> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<COUNTER> p1<DOUBLE> lambda<DOUBLE>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<DOUBLE> lambda<LONG>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<LONG> lambda<LONG>  ~=  result<BOOLEAN>\np2<LONG> p1<DOUBLE> lambda<LONG>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<COUNTER> lambda<LONG>  ~=  result<BOOLEAN>\np2<COUNTER> p1<DOUBLE> lambda<LONG>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<DOUBLE> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<LONG> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<LONG> p1<DOUBLE> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<DOUBLE> p1<COUNTER> lambda<COUNTER>  ~=  result<BOOLEAN>\np2<COUNTER> p1<DOUBLE> lambda<COUNTER>  ~=  result<BOOLEAN>",tags:["math","operators"],since:"1.0.0",OPB64name:"UYo"}},k=function(){function e(e){this.languageId=e}return e.prototype._provideHover=function(n,a,i,o){var s=n.getWordAtPosition(a);if(s){var r=new t.Range(a.lineNumber,s.startColumn,a.lineNumber,s.endColumn),l=s.word,c=o[l];if(c&&c.description){var p=[{value:"### "+l},{value:(c.signature||"").split("\n").map((function(e){return"+ "+e})).join("\n")},{value:c.description.replace(/(\/doc\/\w+)/g,(function(e){return"https://www.warp10.io"+e}))}];return{range:r,contents:e.toMarkedStringArray(p)}}}},e.toMarkedStringArray=function(t){if(t)return Array.isArray(t)?t.map(e.toMarkdownString):[e.toMarkdownString(t)]},e.toMarkdownString=function(e){return"string"==typeof e?{value:e}:{value:e.value}},e}(),B=function(e){function t(){return e.call(this,v.WARPSCRIPT_LANGUAGE)||this}return T(t,e),t.prototype.provideHover=function(t,n,a){return e.prototype._provideHover.call(this,t,n,a,A)},t}(k),C=function(){};C.reference=[{name:"!",detail:"!( input:BOOLEAN ): result:BOOLEAN\n!( gtsinput:GTS ): gtsresult:GTS",documentation:"Negates a boolean.\n\nThe `!` function is synonymous for [`NOT`](/doc/NOT). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nSince Warp 10™ 2.1, `!` can be applied on a boolean GTS to flip all values.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gtsinput` Since 2.1, a GTS with boolean value.\n\n@param `gtsresult` Since 2.1, a GTS with negated boolean value. GTS is not sorted by the operation. Metadata are kept.\n\n",tags:["logic","operators"],since:"1.0.0",OPB64name:"7F"},{name:"!=",detail:"!=( p1:ANY p2:ANY ): result:BOOLEAN\n!=( inputgts:GTS constant:ANY ): outgts:GTS\n!=( constant:ANY inputgts:GTS ): outgts:GTS\n!=( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Tests if both parameters are different.\n\nThe `!=` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are different, false otherwise.\n\nThe two parameters must be homogeneous of numeric, boolean or string types.\n\nSince Warp 10™ 2.1, as every other comparison operators, `!=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 !=` is strictly equivalent of a `42 mapper.ne` MAP operation, with a simplified syntax.\n\n@param `p1` First parameter to compare, anything except a GTS.\n\n@param `p2` Second parameter to compare, anything except a GTS.\n\n@param `result` True if p1 and p2 are different, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values different from constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is different from gts2 value.\n\n",tags:["operators"],since:"1.0.0",OPB64name:"7Io"},{name:"%",detail:"%( divisor:LONG dividend:LONG ): modulo:LONG\n%( divisor:DOUBLE dividend:LONG ): modulo:DOUBLE\n%( divisor:LONG dividend:DOUBLE ): modulo:DOUBLE\n%( divisor:DOUBLE dividend:DOUBLE ): modulo:DOUBLE\n%( divisor:COUNTER dividend:COUNTER ): modulo:LONG\n%( divisor:DOUBLE dividend:COUNTER ): modulo:DOUBLE\n%( divisor:COUNTER dividend:DOUBLE ): modulo:DOUBLE\n%( divisor:LONG dividend:COUNTER ): modulo:LONG\n%( divisor:COUNTER dividend:LONG ): modulo:LONG",documentation:"The `%` operator consumes two parameters from the top of the stack and pushes back the remainder of the Euclidean division of the first one by the second one.\n\nThe two parameters must be of numeric types.\n\n@param `dividend` Number divided by divisor\n\n@param `divisor` Number used to divide dividend\n\n@param `modulo` Modulo of the two given parameters\n\n",tags:["operators"],since:"1.0.0",OPB64name:"8F"},{name:"&",detail:"&( p1:LONG p2:LONG ): result:LONG\n&( inputgts:GTS mask:LONG ): maskedgts:GTS\n&( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Performs a bitwise **AND** operation.\n\nThe `&` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **AND**.\n\nSince Warp 10™ 2.1, `&` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be AND to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with AND between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts AND with mask\n\n",tags:["binary","operators"],since:"1.0.0",OPB64name:"8V"},{name:"&&",detail:"&&( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\n&&( l:LIST ): result:BOOLEAN\n&&( gts1:GTS gts2:GTS ): gtsresult:GTS",documentation:"The `&&` operator is a synonymous for [`AND`](/doc/AND).\n\nIt performs a logical **&&** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `&&` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical && applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with && between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"8XN"},{name:"(",detail:"((): mark:MARK",documentation:"Starts a set creation.\n\nThe `(` function creates a set by pushing a mark onto the stack. This is a syntactic help to better present set constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",tags:["sets"],since:"1.2.13",OPB64name:"9."},{name:"()",detail:"()( content:ANY ): newset:SET",documentation:"The `()` function creates an empty SET on the top of the stack.\nA Set is a collection that cannot contain duplicate elements.\n\nThis is an implementation of java [HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html). NULL object is permitted. It makes no guarantees as to the iteration order of the set.\n\nThe SET object could not be represented on the stack.\nIt has to be converted in a list to be displayed.\n\nStoring GTS into sets do not guarantee uniqueness. each GTS has a hidden id. see example.\n\n\n@param `content` 0 to n elements.\n\n@param `newset` set instance, initialized with content.\n\n",tags:["sets"],since:"1.2.13",OPB64name:"91Z"},{name:")",detail:")( mark:MARK v1:ANY vN:ANY ): set:SET",documentation:"Closes a currently open set and pushes it onto the stack.\n\nThe `)` function pops from the stack the elements of the set up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `set` The built set\n\n@param `mark` The mark indicating the deepest level to consider when building the set\n\n",tags:["sets"],since:"1.2.13",OPB64name:"9F"},{name:"*",detail:"*( p1:NUMBER p2:NUMBER ): result:NUMBER\n*( p1:VECTOR p2:NUMBER ): result:VECTOR\n*( p1:NUMBER p2:VECTOR ): result:VECTOR\n*( p1:MATRIX p2:NUMBER ): result:MATRIX\n*( p1:NUMBER p2:MATRIX ): result:MATRIX\n*( p1:MATRIX p2:VECTOR ): result:VECTOR\n*( p1:VECTOR p2:MATRIX ): result:VECTOR\n*( p1:MATRIX p2:MATRIX ): result:VECTOR\n*( p2:GTS p1:GTS ): result:GTS\n*( p2:GTS p1:NUMBER ): result:GTS\n*( p2:NUMBER p1:GTS ): result:GTS",documentation:"The `*` operator consumes two parameters from the top of the stack and pushes back the result of multiplying both of them.\n\nIf you want to multiply two matrices together, they have to be of the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Multiplication result\n\n",tags:["operators"],since:"1.0.0",OPB64name:"9V"},{name:"**",detail:"**( b:LONG n:LONG ): result:LONG\n**( b:DOUBLE n:LONG ): result:DOUBLE\n**( b:LONG n:DOUBLE ): result:DOUBLE\n**( b:DOUBLE n:DOUBLE ): result:DOUBLE\n**( b:COUNTER n:COUNTER ): result:LONG\n**( b:DOUBLE n:COUNTER ): result:DOUBLE\n**( b:COUNTER n:DOUBLE ): result:DOUBLE\n**( b:COUNTER n:LONG ): result:LONG\n**( b:LONG n:COUNTER ): result:LONG",documentation:'Returns the value of the first argument raised to the power of the second argument.\n\nThe `**` operator consumes two parameters from the top of the stack (a base **b** and an exponent **n**) and pushes back the result raising b to the power of n,\ni.e. b<sup>n</sup>. For special cases see [pow()](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#pow-double-double- "javadoc").\n\nThe two parameters must be of numeric types.\n\n@param `b` First parameter, the base\n\n@param `n` Second parameter, the exponent\n\n@param `result` The result of b<sup>n</sup>\n\n',tags:["math","operators"],since:"1.0.0",OPB64name:"9Xc"},{name:"+",detail:"+( param1:STRING param2:STRING ): result:STRING\n+( param1:LONG param2:LONG ): result:LONG\n+( param1:DOUBLE param2:LONG ): result:DOUBLE\n+( param1:COUNTER param2:LONG ): result:LONG\n+( param1:LONG param2:DOUBLE ): result:DOUBLE\n+( param1:DOUBLE param2:DOUBLE ): result:DOUBLE\n+( param1:COUNTER param2:DOUBLE ): result:DOUBLE\n+( param1:COUNTER param2:COUNTER ): result:LONG\n+( param1:DOUBLE param2:COUNTER ): result:DOUBLE\n+( param1:LONG param2:COUNTER ): result:LONG\n+( param1:LIST param2:ANY ): result:LIST\n+( param1:SET param2:ANY ): result:SET\n+( param1:VECTOR param2:NUMBER ): result:VECTOR\n+( param1:NUMBER param2:VECTOR ): result:VECTOR\n+( param1:VECTOR param2:VECTOR ): result:VECTOR\n+( param1:MACRO param2:MACRO ): result:MACRO\n+( param1:MATRIX param2:NUMBER ): result:MATRIX\n+( param1:NUMBER param2:MATRIX ): result:MATRIX\n+( param1:MATRIX param2:MATRIX ): result:MATRIX\n+( param2:GTS param1:GTS ): result:GTS\n+( param2:GTS param1:DOUBLE ): result:GTS\n+( param2:GTS param1:LONG ): result:GTS\n+( param2:GTS param1:STRING ): result:GTS\n+( param2:DOUBLE param1:GTS ): result:GTS\n+( param2:LONG param1:GTS ): result:GTS\n+( param2:STRING param1:GTS ): result:GTS\n+( param1:BYTES param2:BYTES ): result:BYTES",documentation:"The `+` operator consumes two parameters from the top of the stack and pushes back the result of adding them.\n\nThe meaning of adding depends on the type of parameter:\n\n- If both parameters are numbers, the result is the sum of both numbers.\n\n- If both parameters are strings, the result is the concatenation of both strings.\n- If both parameters are byte arrays, the result is the concatenation of both byte arrays (version 2.1+).\n\n- If the first parameter is a list, the + operator clones the list and appends the second parameter to the cloned list.\n\n- If the first parameter is a set, the + operator clones the set and appends the second parameter to the cloned set.\n\n- If both parameters are macros, the result is a macro concatenating the two others in any other case + with throw an exception.\n\n- If the first parameter is a vector, the + operator adds the second numeric parameter to each element of the vector.\n- If the second parameter is a vector, the + operator adds the first numeric parameter to each element of the vector.\n- If both parameters are vectors, the + operator adds each element of vectors which are on the same index. Vectors must be the same size.\n\n- If the first parameter is a matrix, the + operator adds the second numeric parameter to each element of the matrix.\n- If the second parameter is a matrix, the + operator adds the first numeric parameter to each element of the matrix.\n- If both parameters are matrices, the + operator adds each element of matrices which are on the same index. Matrices must be the same size.\n- If one of the parameters is a Geo Time Series™, the result will be a Geo Time Series™ of type DOUBLE.\n\n@param `param1` First parameter\n\n@param `param2` Second parameter\n\n@param `result` Result of the addition\n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"9k"},{name:"+!",detail:"+!( input:LIST item:ANY ): output:LIST\n+!( input:SET item:ANY ): output:SET",documentation:"The +! operator adds the element on top of the stack to the set or list below it. \nThe element is added to the existing collection. \n\n\n@param `input` reference to the list or set to be modified\n\n@param `output` copy of input list or set reference.\n\n@param `item` the item to append to inputlist. Depending on list content, could be any type.\n\n",tags:["lists","operators"],since:"1.2.0",OPB64name:"9m3"},{name:"-",detail:"-( p1:LONG p2:LONG ): result:LONG\n-( p1:LONG p2:DOUBLE ): result:DOUBLE\n-( p1:DOUBLE p2:LONG ): result:DOUBLE\n-( p1:DOUBLE p2:DOUBLE ): result:DOUBLE\n-( p1:COUNTER p2:COUNTER ): result:LONG\n-( p1:COUNTER p2:DOUBLE ): result:DOUBLE\n-( p1:DOUBLE p2:COUNTER ): result:DOUBLE\n-( p1:LONG p2:COUNTER ): result:LONG\n-( p1:COUNTER p2:LONG ): result:LONG\n-( p1:MATRIX p2:MATRIX ): result:MATRIX\n-( p1:VECTOR p2:VECTOR ): result:VECTOR\n-( p2:GTS p1:GTS ): result:GTS\n-( p2:GTS p1:NUMBER ): result:GTS\n-( p2:NUMBER p1:GTS ): result:GTS",documentation:"Subtracts two parameters.\n\nThe `-` operator consumes two parameters from the top of the stack and pushes back the result of subtracting the second one from the first one.\n\n- If both parameters are numbers, the result is the subtraction of both numbers.\n\n- If both parameters are vectors, the - operator subtracts each element of vectors which are on the same index. Vectors must be the same size.\n\n- If both parameters are matrices, the - operator subtracts each element of matrices which are on the same index. Matrices must be the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Subtraction result\n\n",tags:["operators"],since:"1.0.0",OPB64name:"AF"},{name:"->B64",detail:"->B64( input:STRING ): result:STRING\n->B64( input:BYTES ): result:STRING",documentation:"Encodes the string on top of the stack in [base64](https://en.wikipedia.org/wiki/Base64).\n\n@param `input` String or byte array to encode\n\n@param `result` Base64 encoded string\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYF"},{name:"->B64URL",detail:"->B64URL( input:STRING ): result:STRING\n->B64URL( bytes:BYTES ): result:STRING",documentation:"Encodes the string on top of the stack in [base64url](https://en.wikipedia.org/wiki/Base64#Variants_summary_table).\n\n@param `input` String to encode\n\n@param `bytes` Byte array to encode\n\n@param `result` Base64url encoded string\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYGKJZk"},{name:"->BIN",detail:"->BIN( input:STRING ): output:STRING\n->BIN( input:BYTES ): output:STRING",documentation:"The ->BIN function converts the byte array or the string on top of the stack \nto its binary representation.\n\nApplied on a string, `->BIN` replaces ` 'utf-8' ->BYTES ->BIN `\n\nIf the encoded content is not a \nvalid UTF-8 representation, the resulting string will reflect that. \n\n@param `input` Any string or byte array.\n\n@param `output` Binary representation of the input.\n\n",tags:["conversion","binary"],since:"1.0.6",OPB64name:"AIt1HJs"},{name:"->BYTES",detail:"->BYTES( input:STRING charset:STRING ): output:BYTES",documentation:"->BYTES function converts a string into a bytes array given a charset\nand put the result on top of the stack.\n\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\nBytes array cannot be represented on the stack.\n\n\n@param `input` String input.\n\n@param `charset` Charset to use.\n\n@param `output` Byte array representation of input.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"AIt1LKG4Jk"},{name:"->DOUBLEBITS",detail:"->DOUBLEBITS( number:NUMBER ): bits:LONG\n->DOUBLEBITS( gts:GTS ): longgts:GTS",documentation:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",tags:["math","gts","binary"],since:"1.2.3",OPB64name:"AIt3IpK1I3K1HKGI"},{name:"->ENCODER",detail:"->ENCODER( elements:LIST ): output:GTSENCODER\n->ENCODER( lgts:LIST<GTS> ): output:GTSENCODER\n->ENCODER( lwrappedgts:LIST<STRING> ): output:GTSENCODER\n->ENCODER( lrawwrappedgts:LIST<BYTES> ): output:GTSENCODER",documentation:"The `->ENCODER` function takes a list of points and encode them in a single encoder. Each point is a list of ( timestamp, latitude, longitude, elevation, value ). Since 2.1.1, a point can also be a Geo Time Series™ or a wrapped one. In that case all the points of the Geo Time Series™ are added to the encoder.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `elements` List of list of ( timestamp, latitude, longitude, elevation, value ). See example to see which element(s) can be omitted.\n\n@param `lgts` A list of Geo Time Series™ instances.\n\n@param `lwrappedgts` A list of wrapped Geo Time Series™ instances, such as produced by [`WRAP`](/doc/WRAP).\n\n@param `lrawwrappedgts` A list of raw wrapped Geo Time Series™ instances, such as produced by [`WRAPRAW`](/doc/WRAPRAW).\n\n@param `output` Encoder\n\n",tags:["encoder","conversion"],since:"1.2.9",OPB64name:"AIt4IZCEG3KH"},{name:"->ENCODERS",detail:"->ENCODERS( encoder:GTSENCODER ): output:MAP\n->ENCODERS( wrappedencoder:STRING ): output:MAP\n->ENCODERS( rawwrappedencoder:BYTES ): output:MAP",documentation:"The `->ENCODERS` function converts an encoder into one encoder per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content, when a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder.\n\n",tags:["gts","encoder","conversion"],since:"2.1.0",OPB64name:"AIt4IZCEG3KHJk"},{name:"->FLOATBITS",detail:"->FLOATBITS( input:NUMBER ): result:LONG",documentation:"Converts a numeric value to a **FLOAT** then to a **LONG** value of the raw bits of its representation.\n\nOnly the lower 32 bits of the **LONG** value are significant.\n\n@param `input` Double to convert\n\n@param `result` Raw bits representation\n\n",tags:["math","binary"],since:"1.2.3",OPB64name:"AIt5I3x0K388K4B"},{name:"->GEOCELL",detail:"->GEOCELL( hhPrefixS:STRING ): geocell:LONG\n->GEOCELL( hhPrefixB:BYTES ): geocell:LONG",documentation:"The `->GEOCELL` function converts a **STRING** or a **BYTES** HHCode prefix to a **LONG** geocell. The length of the input implicitly specifies the resolution of the cell.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `hhPrefixS` A HHCode prefix representing a cell. Resolution is twice the length of the **STRING**.\n\n@param `hhPrefixB` A HHCode prefix representing a cell. Resolution is four times the length of the **BYTES**.\n\n@param `geocell` The geocell representation.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJx2GJlB"},{name:"->GEOHASH",detail:"->GEOHASH( lat:DOUBLE lon:DOUBLE ): geohash:STRING\n->GEOHASH( hhcode:LONG ): geohash:STRING\n->GEOHASH( shape:GEOSHAPE ): geohashes:LIST<STRING>",documentation:"The `->GEOHASH` function packs a latitude and a longitude into a STRING [Geohash](https://en.wikipedia.org/wiki/Geohash), converts a [HHCode](https://en.wikipedia.org/wiki/HHCode) into its Geohash counterpart, or converts a `GEOSHAPE` into a list of Geohashes covering the same geographical area.\n\n@param `lat` Latitude to pack.\n\n@param `lon` Longitude to pack.\n\n@param `geohash` Geohash string packing the specified latitude and longitude.\n\n@param `hhcode` HHCode to transform.\n\n@param `shape` `GEOSHAPE` to convert.\n\n@param `geohashes` List of Geohashes covering the same area as `shape`.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"AIt6GJx7FKC7"},{name:"->GEOJSON",detail:"->GEOJSON( shape:GEOSHAPE ): geojson:STRING\n->GEOJSON( shape:GEOSHAPE allCells:BOOLEAN ): geojson:STRING\n->GEOJSON( wkt:STRING ): geojson:STRING\n->GEOJSON( wkb:BYTES ): geojson:STRING",documentation:"The `->GEOJSON` function translate the given GeoShape into a GeoJSON.\n\nThe resulting GeoJSON is a string representing a MultiPolygon geometry. By default, it defines the boundaries of the covered areas and any holes it these areas, if any.\n\nIt is also possible for this function to return a GeoJSON representing all the cells in the GeoShape.\n\n GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` The resulting GeoJSON.\n\n@param `wkt` A WKT string\n\n@param `wkb` WKB bytes\n\n",tags:["geo"],since:"2.4.1",OPB64name:"AIt6GJx9JoxD"},{name:"->GEOSHAPE",detail:"->GEOSHAPE( geocells:LIST<LONG> ): geoshape:GEOSHAPE\n->GEOSHAPE( hhPrefixesS:LIST<STRING> ): geoshape:GEOSHAPE\n->GEOSHAPE( hhPrefixesB:LIST<BYTES> ): geoshape:GEOSHAPE",documentation:"The `->GEOSHAPE` function converts a list of **LONG** geocells or HHCode prefixes (**STRING** or **BYTES**) to a **GEOSHAPE**.\n\n@param `geocells` List of geocells, as **LONGs**.\n\n@param `hhPrefixesS` List of HHCode prefixes, as **STRINGs**.\n\n@param `hhPrefixesB` List of HHCode prefixes, as **BYTESs**.\n\n@param `geoshape` The resulting **GEOSHAPE**.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJxIH34FGF"},{name:"->GTS",detail:"->GTS( encoder:GTSENCODER ): output:MAP\n->GTS( wrappedencoder:STRING ): output:MAP\n->GTS( rawwrappedencoder:BYTES ): output:MAP\n->GTS( lencoder:LIST<GTSENCODER> ): loutput:MAP\n->GTS( lwrappedencoder:LIST<STRING> ): loutput:MAP\n->GTS( lrawwrappedencoder:LIST<BYTES> ): loutput:MAP\n->GTS( encoder:GTSENCODER conversionmap:MAP ): conversionoutput:GTS\n->GTS( wrappedencoder:STRING conversionmap:MAP ): conversionoutput:GTS\n->GTS( rawwrappedencoder:BYTES conversionmap:MAP ): conversionoutput:GTS\n->GTS( lencoder:LIST<GTSENCODER> conversionmap:MAP ): conversionoutput:LIST<GTS>\n->GTS( lwrappedencoder:LIST<STRING> conversionmap:MAP ): conversionoutput:LIST<GTS>\n->GTS( lrawwrappedencoder:LIST<BYTES> conversionmap:MAP ): conversionoutput:LIST<GTS>",documentation:"The `->GTS` function converts an encoder into one GTS per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\n###### Since 2.4.0:\n- `->GTS` function can also take a conversion MAP input. Using this conversion MAP, the output is always a list of GTS.\n- The conversion map can also take a list of selectors for each output type.\n- The conversion map can be empty: In this case, the GTS type is enforced by the type of the first element in the encoder input.\n- The first selector match stops the research. It means key order matters. See Examples.\n- A new '.type' label is added to each output GTS. This could be overriden with the 'label.type' parameter of the conversion MAP.\n- `->GTS` function can handle encoders, or list of encoders.\n\n###### What is an encoder ?\nA Geo Time Series™ is limited to the type of the first value stored.\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content.\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder. Values are GTS.\n\n@param `lencoder` List of encoders input (supported since 2.4.0).\n\n@param `lwrappedencoder` List of encoders after WRAP (supported since 2.4.0).\n\n@param `lrawwrappedencoder` List of encoders after WRAPRAW (supported since 2.4.0).\n\n@param `loutput` Map with a key/value per type encountered in the input encoder. Values are a list of GTS.\n\n@param `conversionmap` Map with type as keys, selectors or list of selectors as values. The special key `label` allow to change the default `.type` label. Set label to NULL to avoid any new label. The conversion map could be empty.\n\n@param `conversionoutput` A GTS, or a list of GTS.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"1.2.9",OPB64name:"AIt6K4B"},{name:"->GTSHHCODE",detail:"->GTSHHCODE( lat:NUMBER lon:NUMBER ): hhcode:STRING",documentation:"The `->GTSHHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3J"},{name:"->GTSHHCODELONG",detail:"->GTSHHCODELONG( lat:NUMBER lon:NUMBER ): hhcode:STRING",documentation:"The `->GTSHHCODE` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3KBIot6"},{name:"->HEX",detail:"->HEX( input:STRING ): output:STRING\n->HEX( input:BYTES ): output:STRING",documentation:"Decodes an hex encoded string or a byte array.\nFor different encodings, use bytes array conversion [`BYTES->`](/doc/F__JGKBhEV).\n\n\nApplied on a string, `->HEX` replaces ` 'utf-8' ->BYTES ->HEX `\n\nIf the encoded content is not a\nvalid UTF-8 representation, the resulting string will reflect that.\n\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Decoded string of input, assuming utf-8 encoding of input.\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"AIt7GKV"},{name:"->HHCODE",detail:"->HHCODE( lat:NUMBER lon:NUMBER ): hhcode:STRING",documentation:"The `->HHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"AIt7H3CEG3J"},{name:"->HHCODELONG",detail:"->HHCODELONG( lat:NUMBER lon:NUMBER ): hhcode:LONG",documentation:"The `->HHCODELONG` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",tags:["geo"],since:"1.2.5",OPB64name:"AIt7H3CEG3KBIot6"},{name:"->JSON",detail:"->JSON( object:ANY ): output:STRING",documentation:"The `->JSON` functions serialize structures containing numbers, strings, booleans, lists, vlists and maps which do not reference the same list/map multiple times.\n\n@param `object` Object to serialize\n\n@param `output` JSON formatted string\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"AIt9JoxD"},{name:"->LIST",detail:"->LIST( content:ANY* N:LONG ): newlist:LIST",documentation:"The `->LIST` function create a list from N elements on the stack.\nN and the N next elements on the stack are consumed.\n\nIf N is greater than current stack depth, the function raises an error.\n\n@param `N` The number of elements to take on the top of the stack to build the list.\n\n@param `newlist` The list of N elements. [deepest in stack ... TOP-1 ]\n\n@param `content` 0 to n elements\n\n",tags:["lists","conversion"],since:"1.0.0",OPB64name:"AItBHKCJ"},{name:"->LONGBYTES",detail:"->LONGBYTES( number:LONG nbbytes:LONG ): output:BYTES\n->LONGBYTES( numberList:LIST<LONG> nbbytes:LONG ): output:BYTES",documentation:"`->LONGBYTES` converts a LONG to a byte array. It expects a number of bytes on the top of the stack.\n\nSince Warp 10™ 2.1, `->LONGBYTES` can also convert a list of LONG.\n\n@param `nbbytes` Number of bytes for number conversion: nbbytes could be 1 to 8. If less than 8, most significant bytes will be truncated.\n\n@param `number` must be a LONG\n\n@param `output` byte array, from 1 to 8 bytes per number\n\n@param `numberList` Since Warp 10 2.1, a list of LONG\n\n",tags:["binary","conversion"],since:"2.1.0",OPB64name:"AItBIot6F__JGKB"},{name:"->MAP",detail:"->MAP( N:LONG content:ANY* content:ANY* ): newmap:MAP",documentation:"The ->MAP function creates a MAP from an even number N of elements on the stack. \nN is consumed off the top of the stack. For each pair, the deepest element is the key, the shallowest is the value.\n\n\n@param `content` 0 to n pairs of key-value elements. Keys must be different.\n\n@param `N` Number of content elements to consume on the stack. It must be even.\n\n@param `newmap` map instance, initialized with content.\n\n",tags:["maps","conversion"],since:"1.0.0",OPB64name:"AItCFK."},{name:"->MAT",detail:"->MAT( [ input:LIST ] ): result:MATRIX",documentation:"The `->MAT` function converts nested lists of numbers (2D array with same number of columns) into a Matrix.\n\nMATRIX objects cannot be represented on the stack. \n\nMatrix entries must be numbers.\n\n\n@param `input` List of lists of values\n\n@param `result` A MATRIX object\n\n",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItCFKF"},{name:"->MVSTRING",detail:"->MVSTRING( input:STRING ): mvstring:STRING\n->MVSTRING( input:BYTES ): mvstring:STRING\n->MVSTRING( input:GTS ): mvstring:STRING\n->MVSTRING( input:GTSENCODER ): mvstring:STRING",documentation:"The `->MVSTRING` function generates a STRING representation of an ENCODER in the format expected by the `/update` endpoint for multi values.\n\nWhen encountering a binary element, the function attempts to interpret it as a wrapped encoder, if that fails then it will output the element as a binary (`b64:...`) value.\n\n@param `input` Wrapped or unwrapped Geo Time Series™ or ENCODER.\n\n@param `mvstring` MultiValue format representation of the wrapped encoder/GTS.\n\n",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"AItCK_CJJZ_DGk"},{name:"->OPB64",detail:"->OPB64( input:STRING ): output:STRING\n->OPB64( input:BYTES ): output:STRING",documentation:"Encode a String in order preserving base64. OPB64 is a Base64 like encoding which preserves the lexicographic order of\nthe original byte arrays in the encoded ones. This is useful to compare encoded byte arrays without having to first decode them.\n\n@param `input` Could be a string or a byte array.\n\n@param `output` OPB64 of input.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"AItEJ37qC."},{name:"->PICKLE",detail:"->PICKLE( input:ANY ): output:BYTES",documentation:"The `->PICKLE` function converts the object on top of the stack to a Python object and serializes it using Pickle protocol version 2.\nThe conversion table used is as follow:\n\n| WarpScript | Python |\n|------------|--------|\n| NULL | None |\n| BOOLEAN | bool |\n| BYTES | bytearray |\n| STRING | str/unicode |\n| DOUBLE | float |\n| LONG | int |\n| LIST | list |\n| MAP | dict |\n| SET | set |\n| GTS | dict |\n| ENCODER | dict |\n\nOther types are unsupported.\n\nPython example with `->PICKLE ->HEX` output:\n```python\n>>> s=\"80025d71002858060000005049434b4c4571015806000000535452494e4771025d7103284b0547400921fb54442d1865652e\"\n>>> import pickle\n>>> pickle.loads(s.decode(\"hex\"))\n[u'PICKLE', u'STRING', [5, 3.141592653589793]]\n```\n\n@param `input` A serializable object\n\n@param `output` Pickle encoded content\n\n",tags:["platform"],since:"1.0.7",OPB64name:"AItFHJCAI3J"},{name:"->Q",detail:"->Q( w:DOUBLE x:DOUBLE y:DOUBLE z:DOUBLE ): result:LONG",documentation:"The `->Q` function consumes on the stack 4 doubles (w, x, y, z, with z being on top) representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion)\nand push back quaternion representation into a **LONG**.\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `result` Quaternion representation\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"AItG"},{name:"->SET",detail:"->SET( input:LIST ): newset:SET",documentation:"The -`>SET` function converts a **LIST** on top of the stack into a **SET**.\n\nSETs are not viewable, null will be return if it remains on the stack.\n\nThe order in the SET is not garanteed, see [`()`](/doc/91Z).\n\n\n@param `input` The input list\n\n@param `newset` The new set reference. SETs are not viewable, null remains on the stack.\n\n",tags:["sets"],since:"1.0.0",OPB64name:"AItIGKF"},{name:"->TSELEMENTS",detail:"->TSELEMENTS( timestamp:LONG ): dateAndTimeElements:LIST<LONG>\n->TSELEMENTS( timestamp:LONG timezone:STRING ): dateAndTimeElements:LIST<LONG>",documentation:"The `->TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",tags:["date","time"],since:"1.2.0",OPB64name:"AItJJoKBGJp4I_GI"},{name:"->V",detail:"->V( list:LIST ): result:VLIST\n->V( set:SET ): result:VLIST",documentation:"The `->V` function converts a list of objects into a Pig Vector (VLIST).\n\nVLIST are represented as lists on the stack.\n\n@param `list` Input list\n\n@param `set` Input set\n\n@param `result` Result list\n\n",tags:["conversion","pig"],since:"1.0.11",OPB64name:"AItL"},{name:"->VARINT",detail:"->VARINT( number:LONG ): encoded:BYTES\n->VARINT( numbers:LIST<LONG> ): encoded:BYTES",documentation:"The `->VARINT` function encodes a `LONG` or a list of `LONG`s using [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoding. The result is a byte array containing the concatenation of the encoded numbers.\n\nThe `->VARINT` function is optimized for encoding unsigned `LONG`s, this means that negative numbers (with the most significant bit set to 1) will be encoded on 10 bytes. In order to reduce this footprint you can pre-process the numbers to encode so they are encoded unsing [ZigZag VarInt](https://developers.google.com/protocol-buffers/docs/encoding#types) encoding. The simple trick is to compute\n\n```\n$value 1 << $value 63 >> ^\n```\n\nthis will have the effect of alternatively encoding positive and negative numbers thus leading to a more efficient footprint for negative numbers.\n\nAt decoding time using `VARINT->`, simply undo the *Zig-Zag* trick:\n\n```\n$unsigned 63 << 63 >> $unsigned ^ 1 >>\n// Flip the top bit\n$unsigned 1 63 << & ^\n```\n\n@param `number` Single number to encode.\n\n@param `numbers` List of numbers to encode.\n\n@param `encoded` Byte array containing the encoded number(s).\n\n",tags:["conversion","binary"],since:"2.6.0",OPB64name:"AItLFK88I_F"},{name:"->VEC",detail:"->VEC( list:LIST ): result:VECTOR\n->VEC( matrix:MATRIX ): result:VECTOR",documentation:"The `->VEC` function converts a list of numbers into a Vector.\n\nVectors objects cannot be represented on the stack. \n\nVectors entries must be numbers.\n\n@param `list` List to convert\n\n@param `matrix` Matrix with a single column\n\n@param `result` Vector\n\n",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItLGJB"},{name:"->WKB",detail:"->WKB( shape:GEOSHAPE ): wkb:BYTES\n->WKB( shape:GEOSHAPE allCells:BOOLEAN ): wkb:BYTES\n->WKB( wkt:STRING ): wkb:BYTES\n->WKB( geojson:STRING ): wkb:BYTES",documentation:"The `->WKB` function converts a GeoJSON **STRING**, a WKT **STRING** or a **SHAPE** to WKB **BYTES**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` A WKT string\n\n@param `wkb` The resulting WKB.\n\n",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHo7"},{name:"->WKT",detail:"->WKT( shape:GEOSHAPE ): wkt:STRING\n->WKT( shape:GEOSHAPE allCells:BOOLEAN ): wkt:STRING\n->WKT( geojson:STRING ): wkt:STRING\n->WKT( wkb:BYTES ): wkt:STRING",documentation:"The `->WKT` function converts a GeoJSON **STRING**, a WKB **BYTES** or a **SHAPE** to WKT **STRING**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` The resulting  WKT.\n\n@param `wkb` WKB bytes.\n\n",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHpF"},{name:"->Z",detail:"->Z( longs:LIST<LONG> bitwidth:LONG ): z:BYTES",documentation:"The `->Z` function packs multiple **LONG** arguments into a byte array by interleaving the bits of the arguments. This produces a \n[Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) value encoding the original arguments. The value might be right padded with bits set to 0 to reach a multiple of 8 bits.\n\n@param `bitwidth` Number of bits to consider for each LONG in 'longs', from 1 to 63.\n\n@param `longs` List of LONGs to pack. Each LONG *MUST* be positive, i.e. with bit 63 set to 0.\n\n@param `z` Byte array containing the packed values.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"AItP"},{name:"/",detail:"/( long:LONG long:LONG ): long-result:LONG\n/( double:DOUBLE long:LONG ): double-result:DOUBLE\n/( long:LONG double:DOUBLE ): double-result:DOUBLE\n/( double:DOUBLE double:DOUBLE ): double-result:DOUBLE\n/( counter:COUNTER counter:COUNTER ): long-result:LONG\n/( double:DOUBLE counter:COUNTER ): long-result:DOUBLE\n/( counter:COUNTER double:DOUBLE ): long-result:DOUBLE\n/( counter:COUNTER long:LONG ): long-result:LONG\n/( long:LONG counter:COUNTER ): long-result:LONG\n/( double:VECTOR double:NUMBER ): double-result:VECTOR\n/( param2:GTS param1:GTS ): result:GTS\n/( param2:GTS param1:NUMBER ): result:GTS\n/( param2:NUMBER param1:GTS ): result:GTS",documentation:"The `/` operator consumes two parameters from the top of the stack and pushes back the result of dividing the first one by the second one.\n\nYou can't devide by zero.\n\nThe two parameters must be of numeric types, or Geo Time Series™, or a mix of the two.\n\n@param `long` Numeric integer\n\n@param `long-result` Numeric floor-rounded integer\n\n@param `double` Numeric floating point number\n\n@param `double-result` Numeric floating point number\n\n@param `counter` Numeric counter\n\n@param `param1` First parameter of the division.\n\n@param `param2` Second parameter of the division.\n\n@param `result` Resulting GTS, of type DOUBLE.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"Ak"},{name:"<",detail:"<( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n<( p1:STRING p2:STRING ): result:BOOLEAN\n<( inputgts:GTS constant:ANY ): outgts:GTS\n<( constant:ANY inputgts:GTS ): outgts:GTS\n<( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"The `<` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 < p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <` is strictly equivalent of a `42 mapper.lt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 < p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"E."},{name:"<<",detail:"<<( number:LONG shift:LONG ): result:LONG\n<<( inputgts:GTS number:LONG ): maskedgts:GTS\n<<( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Shifts the bits of a long by a number of positions to the left. The least significant bit is filled with 0 after each shift.\n\nSince Warp 10™ 2.1, `<<` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",tags:["operators"],since:"1.0.0",OPB64name:"E2k"},{name:"<=",detail:"<=( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n<=( p1:STRING p2:STRING ): result:BOOLEAN\n<=( inputgts:GTS constant:ANY ): outgts:GTS\n<=( constant:ANY inputgts:GTS ): outgts:GTS\n<=( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"The `<=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 <= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <=` is strictly equivalent of a `42 mapper.le` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 <= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less or equal than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"E2o"},{name:"==",detail:"==( p1:ANY p2:ANY ): result:BOOLEAN\n==( inputgts:GTS constant:ANY ): outgts:GTS\n==( constant:ANY inputgts:GTS ): outgts:GTS\n==( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Tests if both parameters are equal.\n\nThe `==` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are equal, false otherwise.\n\nThe two parameters must be of numeric, boolean, vector, matrix or string types.\nFor vector or matrix, the parameters must be the same size.\n\nSince 2.1.0, as every other comparison operators, `==` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 ==` is strictly equivalent of a `42 mapper.eq` MAP operation, with a simplified syntax.\n\nSince 2.1.1, `==` can be use to check equality between Lists, Maps and Sets. For for details about how this is defined, check the [java documentation](https://docs.oracle.com/en/java/javase/index.html).\n\n@param `p1` First parameter to compare\n\n@param `p2` Second parameter to compare\n\n@param `result` True if p1 and p2 are equal, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values equal to constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value equals gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"EIo"},{name:">",detail:">( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n>( p1:STRING p2:STRING ): result:BOOLEAN\n>( inputgts:GTS constant:ANY ): outgts:GTS\n>( constant:ANY inputgts:GTS ): outgts:GTS\n>( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"The `>` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 > p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >` is strictly equivalent of a `42 mapper.gt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 > p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"EV"},{name:">=",detail:">=( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n>=( p1:STRING p2:STRING ): result:BOOLEAN\n>=( inputgts:GTS constant:ANY ): outgts:GTS\n>=( constant:ANY inputgts:GTS ): outgts:GTS\n>=( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"The `>=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 >= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >=` is strictly equivalent of a `42 mapper.ge` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 >= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater or equal than gts2 value.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"EYo"},{name:">>",detail:">>( number:LONG shift:LONG ): result:LONG\n>>( inputgts:GTS number:LONG ): maskedgts:GTS\n>>( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Shifts the bits of a long by a number of positions to the right. The most significant bit after shifting depends on the sign of the unshifted long.\n\nSince Warp 10™ 2.1, `>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",tags:["operators"],since:"1.0.0",OPB64name:"EYs"},{name:">>>",detail:">>>( number:LONG shift:LONG ): result:LONG\n>>>( inputgts:GTS number:LONG ): maskedgts:GTS\n>>>( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Shifts the bits of a long by a number of positions to the right. The most significant bit after each shift is set to 0, regardless of the sign of \nthe unshifted long.\n\nSince Warp 10™ 2.1, `>>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",tags:["operators"],since:"1.0.0",OPB64name:"EYsy"},{name:"ABS",detail:"ABS( value:LONG ): result:LONG\nABS( value:COUNTER ): result:LONG\nABS( value:DOUBLE ): result:DOUBLE\nABS( lvalue:LIST<LONG> ): lresult:LIST<LONG>\nABS( lvalue:LIST<COUNTER> ): lresult:LIST<LONG>\nABS( lvalue:LIST<DOUBLE> ): lresult:LIST<DOUBLE>",documentation:"Computes the absolute value of a number value.\n\nThe `ABS` function consumes a numeric value from the top of the stack and pushes back its absolute value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` A numeric value\n\n@param `result` The absolute value of the given numeric value.\n\n@param `lvalue` A list of numeric values\n\n@param `lresult` A list of the absolute values of the given values.\n\n",tags:["math"],since:"1.0.0",OPB64name:"ABS"},{name:"ACCEL.CACHE",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.CACHE` function will enable accessing the in-memory data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.CACHE"},{name:"ACCEL.NOCACHE",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOCACHE` function will disable accessing the in-memory data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOCACHE"},{name:"ACCEL.NOPERSIST",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOPERSIST` function will disable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOPERSIST"},{name:"ACCEL.PERSIST",detail:"",documentation:"When the Warp 10 Accelerator is enabled, the `ACCEL.PERSIST` function will enable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.PERSIST"},{name:"ACCEL.REPORT",detail:"ACCEL.REPORT(): report:MAP",documentation:"The `ACCEL.REPORT` function will produce a map containing informations related to the Warp 10 Accelerator. The following table describes the various keys present in this map:\n\n| Key | Description |\n|-----|-------------|\n| `accelerated` | Boolean indicating whether or not the last [`FETCH`](/doc/FETCH) accessed the in-memory data managed by the Warp 10 Accelerator. |\n| `status` | Boolean indicating whether or not the Warp 10 Accelerator is enabled. |\n| `cache` | Boolean indicating if the in-memory data will be considered for update, fetch and delete operations. |\n| `persist` | Boolean indicating if the persistent data will be considered for update, fetch and delete operations. |\n| `chunkcount` | Number of chunks managed by the accelerator for its in-memory data. |\n| `chunkspan` | Length of each chunk expressed in platform time units. |\n\n@param `report` Map containing informations related to the Warp 10 Accelerator\n\n",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.REPORT"},{name:"ACOS",detail:"ACOS( value:NUMBER ): result:DOUBLE\nACOS( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `ACOS` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arccosine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arccosine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arccosine in radians of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ACOS"},{name:"ADDDAYS",detail:"ADDDAYS( timestamp:LONG timezone:STRING days:LONG ): result:LONG\nADDDAYS( timestamp:LONG days:LONG ): result:LONG\nADDDAYS( tselements:LIST<LONG> days:LONG ): tselementsresult:LIST<LONG>",documentation:'Adds days to a timestamp or a tselements.\n\nThe `ADDDAYS` function consumes from the top of the stack a number (positive or negative) of days, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the days and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `days` The number of days to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',tags:["date"],since:"1.2.0",OPB64name:"ADDDAYS"},{name:"ADDDURATION",detail:"ADDDURATION( timestamp:LONG timezone:STRING duration:STRING ): result:LONG\nADDDURATION( timestamp:LONG timezone:STRING duration:STRING factor:LONG ): result:LONG\nADDDURATION( timestamp:LONG duration:STRING ): result:LONG\nADDDURATION( timestamp:LONG duration:STRING factor:LONG ): result:LONG\nADDDURATION( tselements:LIST<LONG> duration:STRING ): tselementsresult:LIST<LONG>\nADDDURATION( tselements:LIST<LONG> duration:STRING factor:LONG ): tselementsresult:LIST<LONG>",documentation:"Adds an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) to a timestamp or a tselements.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `duration` The duration\n\n@param `factor` The number of durations to add. Can be negative. Default to 1 if not set.\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n",tags:["date"],since:"2.4.0",OPB64name:"ADDDURATION"},{name:"ADDEXACT",detail:"ADDEXACT( x:NUMBER y:NUMBER ): sum:LONG\nADDEXACT( list:LIST<NUMBER> ): ssum:LONG\nADDEXACT( lx:LIST<NUMBER> y:NUMBER ): lsum:LIST<LONG>",documentation:"The `ADDEXACT` function consumes two LONGs from the top of the stack and puts back the sum. If the sum overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `sum` The sum of x and y\n\n@param `list` List of numeric values\n\n@param `ssum` The sum of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lsum` List of **LONG** where each value is the sum of y and an element in lx\n\n",tags:["math"],since:"1.2.23",OPB64name:"ADDEXACT"},{name:"ADDMONTHS",detail:"ADDMONTHS( timestamp:LONG timezone:STRING months:LONG ): result:LONG\nADDMONTHS( timestamp:LONG months:LONG ): result:LONG\nADDMONTHS( tselements:LIST<LONG> months:LONG ): tselementsresult:LIST<LONG>",documentation:'Adds months to a timestamp or a tselements.\n\nThe `ADDMONTHS` function consumes from the top of the stack a number (positive or negative) of months, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the months and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `months` The number of months to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',tags:["date"],since:"1.2.0",OPB64name:"ADDMONTHS"},{name:"ADDVALUE",detail:"ADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:STRING ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:BYTES ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:BOOLEAN ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:DOUBLE ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:LONG ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:GTSENCODER ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:GTS ): result:GTS",documentation:"The `ADDVALUE` function adds a value to a GTS, without checking for tick duplicates. The added data point is appended to the GTS.\nThe [`SETVALUE`](/doc/SETVALUE) overrides an existing value.\n\nThe `ADDVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `ADDVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, for example by using [`GET`](/doc/GET)\nwith value 0 as parameter.\n\nIf latitude or longitude are NaN (not a number), value has only timestamp, elevation, value.\nIf elevation is NaN (not a number), value has only timestamp, latitude, longitude, value.\nIf elevation is NaN and longitude or latitude are NaN, value has only timestamp, value.\n\nWhen adding a Geo Time Series™ or GTS Encoder value, the value will be wrapped (as when using `WRAPRAW`) and added as a binary value.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Series™\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `result` The Geo Time Series™ with the new datapoint added\n\n@param `elevation` Elevation or NaN\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ADDVALUE"},{name:"ADDYEARS",detail:"ADDYEARS( timestamp:LONG timezone:STRING years:LONG ): result:LONG\nADDYEARS( timestamp:LONG years:LONG ): result:LONG\nADDYEARS( tselements:LIST<LONG> years:LONG ): tselementsresult:LIST<LONG>",documentation:'Adds years to a timestamp or a tselements.\n\nThe `ADDYEARS` function consumes from the top of the stack a number (positive or negative) of years, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the years and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `years` The number of years to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',tags:["date"],since:"1.2.0",OPB64name:"ADDYEARS"},{name:"AESUNWRAP",detail:"AESUNWRAP( key:BYTES data:BYTES ): decoded:BYTES",documentation:'Unwraps a byte array with the [AES WRAP](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") and pushes back the decrypted data into an bytes array.\n\n`AESUNWRAP` removes the a 64bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) added by [`AESWRAP`](/doc/AESWRAP) WarpScript function\n\n@param `data` Encoded Byte array.\n\n@param `key` Byte array, 128, 192 or 256 bits key.\n\n@param `decoded` Decoded Byte array.\n\n',tags:["crypto"],since:"1.0.11",OPB64name:"AESUNWRAP"},{name:"AESWRAP",detail:"AESWRAP( string:STRING key:BYTES ): encrypted:BYTES\nAESWRAP( bytes:BYTES key:BYTES ): encrypted:BYTES",documentation:'Wraps a byte array or String with the [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt) algorithm and pushes a byte array containing the encrypted data onto the stack.\n\n`AESWRAP` adds a 64 bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) prefix to the input in order to protect the encrypted data against AES block determinism as [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") uses a fixed Initialization Vector.\n\n@param `key` 128, 192 or 256 bits key to use for encryption.\n\n@param `string` String data to encrypt.\n\n@param `bytes` Byte array to encrypt.\n\n@param `encrypted` Encrypted result.\n\n',tags:["crypto"],since:"1.0.11",OPB64name:"AESWRAP"},{name:"AGO",detail:"AGO( offset:NUMBER ): timestamp:LONG",documentation:"The `AGO` function is a shortcut which enables you to compute timestamps by specifying an offset from the current time.\n\n@param `offset` The numbers of ticks in platform time unit to subtract, truncated if floating-point.\n\n@param `timestamp` The computed timestamp\n\n",tags:["date"],since:"1.2.0",OPB64name:"AGO"},{name:"AND",detail:"AND( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\nAND( l:LIST ): result:BOOLEAN\nAND( gts1:GTS gts2:GTS ): gtsresult:GTS",documentation:"The `AND` operator is a synonymous for [`&&`](/doc/8XN).\n\nIt performs a logical **AND** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `AND` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical AND applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with AND between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"AND"},{name:"APPEND",detail:"APPEND( inputlist:LIST newitems:LIST ): outputlist:LIST\nAPPEND( inputmap:MAP newitems:MAP ): outputmap:MAP\nAPPEND( inputGTS:GTS newitems:GTS ): outputGTS:MAP",documentation:"The `APPEND` function consumes two paramters from the top of the stack and appends the LIST, MAP or GTS on top of the stack to the one just below.\nThe augmented LIST, MAP or GTS is then pushed back on the stack.\n\n@param `newitems` items to append to input.\n\n@param `inputlist` LIST to be modified.\n\n@param `outputlist` The LIST that has been modified\n\n@param `inputmap` MAP to be modified.\n\n@param `outputmap` The AP that has been modified \n\n@param `inputGTS` GTS to be modified.\n\n@param `outputGTS` The GTS that has been modified\n\n",tags:["lists","maps"],since:"1.0.0",OPB64name:"APPEND"},{name:"APPLY",detail:"APPLY( [ gts:LIST<GTS>+ labels:LIST op:OPERATOR ] ): result:LIST<GTS>",documentation:"The `APPLY` framework provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can do. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` List of resulting GTS, one per equivalence class.\n\n@param `op` Operation to perform.\n\n",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"APPLY"},{name:"ASENCODERS",detail:"ASENCODERS( gts:GTS ): encoder:GTSENCODER\nASENCODERS( lgts:LIST<GTS> ): lencoder:LIST<GTSENCODER>\nASENCODERS( wrappedgts:STRING ): encoder:GTSENCODER\nASENCODERS( lwrappedgts:LIST<STRING> ): lencoder:LIST<GTSENCODER>\nASENCODERS( rawwrappedgts:BYTES ): encoder:GTSENCODER\nASENCODERS( lrawwrappedgts:LIST<BYTES> ): lencoder:LIST<GTSENCODER>\nASENCODERS( encoder:GTSENCODER ): encoder:GTSENCODER\nASENCODERS( lencoder:LIST<GTSENCODER> ): lencoder:LIST<GTSENCODER>",documentation:"The `ASENCODERS` function consumes a Geo Time Series™, a wrap or a raw wrap, or a list thereof and convert each one into an encoder.\n\n@param `gts` Geo Time Series™ to be converted.\n\n@param `lgts` List of Geo Time Series™ to be converted.\n\n@param `wrappedgts` Wrapped Geo Time Series™ to be converted.\n\n@param `lwrappedgts` List of wrapped Geo Time Series™ to be converted.\n\n@param `rawwrappedgts` Raw wrapped Geo Time Series™ to be converted.\n\n@param `lrawwrappedgts` List of raw wrapped Geo Time Series™ to be converted.\n\n@param `encoder` Encoder of the given Geo Time Series™.\n\n@param `lencoder` List of encoder, one for each given Geo Time Series™.\n\n",tags:["encoder","conversion"],since:"2.2.0",OPB64name:"ASENCODERS"},{name:"ASIN",detail:"ASIN( value:NUMBER ): result:DOUBLE\nASIN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `ASIN` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arcsine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arcsine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arcsine in radians of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ASIN"},{name:"ASREGS",detail:"ASREGS( macro:MACRO vars:LIST<STRING> ): macro:MACRO\nASREGS( macro:MACRO ): macro:MACRO",documentation:"Replaces in a macro the uses of the given symbols by the use of registers.\n\nIf there are not enough registers available, replace each of the symbols from the start of the list until all registers are used.\n\nSince 2.6.0, the list of symbols is optional. In that case, `ASREGS` first recursively extracts all the symbols from given the macro and uses that list to do the replacement.\n\n@param `macro` Macro to transform.\n\n@param `vars` List of symbols.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"ASREGS"},{name:"ASSERT",detail:"ASSERT( condition:BOOLEAN ): ",documentation:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise.\n\nThe `ASSERT` function consumes a **BOOLEAN** parameter from the top of the stack. If the boolean is **true** the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception.\n\n`ASSERT` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n",tags:["debug"],since:"1.0.0",OPB64name:"ASSERT"},{name:"ASSERTMSG",detail:"ASSERTMSG( condition:BOOLEAN message:STRING ): ",documentation:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise and displays a message.\n\nThe `ASSERTMSG` function consumes a **BOOLEAN** parameter and a **STRING** parameter from the top of the stack. If the boolean is **true**, the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception with a message displaying the **STRING** parameter.\n\n`ASSERTMSG` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n@param `message` The exception message to display if the test fails\n\n",tags:["debug"],since:"1.2.13",OPB64name:"ASSERTMSG"},{name:"ATAN",detail:"ATAN( value:NUMBER ): result:DOUBLE\nATAN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `ATAN` function consumes a floating point number between -1 et 1 from the top of the stack and pushes back its arctangent in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arctangent in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arctangent in radians of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ATAN"},{name:"ATAN2",detail:"ATAN2( y:NUMBER x:NUMBER ): result:DOUBLE\nATAN2( y:NUMBER lx:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nATAN2( ly:LIST<NUMBER> x:NUMBER ): lresult:LIST<DOUBLE>",documentation:"ATAN2 function returns the polar angle theta (azimut) from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta). This method computes the phase theta by computing an arc tangent of y/x in the range of `] -pi  pi ]`.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `result` theta in polar coordinates\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `lresult` List of thetas in polar coordinates\n\n",tags:["math","trigonometry"],since:"1.2.13",OPB64name:"ATAN2"},{name:"ATBUCKET",detail:"ATBUCKET( gts:GTS index:LONG ): result:LIST",documentation:"The `ATBUCKET` function consumes a bucketized GTS from the stack, looks at its `index`-th bucket and puts on the stack a\nlist with the timestamp, latitude, longitude, elevation and value for this bucket.\n\n@param `gts` Bucketized Geo Time Series™\n\n@param `index` Index of the bucket\n\n@param `result` List with the timestamp, latitude, longitude, elevation and value for the index-th bucket of the GTS\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"ATBUCKET"},{name:"ATINDEX",detail:"ATINDEX( gts:GTS index:NUMBER ): data:LIST\nATINDEX( lgts:LIST<GTS> index:NUMBER ): ldata:LIST<LIST>",documentation:"The `ATINDEX` function consumes a Geo Time Series™ or a list thereof from the stack, looks at its index-th point and put on the stack a list with the timestamp, longitude, \nlatitude, elevation and value for the `index`-th point of the GTS.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the GTS.\n\n@param `index` Index of the tick, truncated if floating-point.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ATINDEX"},{name:"ATTICK",detail:"ATTICK( gts:GTS timestamp:LONG ): data:LIST\nATTICK( lgts:LIST<GTS> timestamp:LONG ): ldata:LIST<LIST>\nATTICK( gts:GTS timestamp:COUNTER ): data:LIST\nATTICK( lgts:LIST<GTS> timestamp:COUNTER ): ldata:LIST<LIST>\nATTICK( gts:GTS timestamp:DOUBLE ): data:LIST\nATTICK( lgts:LIST<GTS> timestamp:DOUBLE ): ldata:LIST<LIST>",documentation:"The `ATTICK` function consumes a Geo Time Series™ from the stack, looks at its tick-th tick (the data point with a timestamp tick) and put on the \nstack a list with the timestamp, latitude, longitude, elevation and value for that data point.\n\nIf there is no data point with tick timestamp, it return a list with timestamp, latitude, longitude and elevation at **NaN** and value at **null**.\n\n@param `timestamp` Timestamp at which to take the data, if it is a floating-point value, it is truncated.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ATTICK"},{name:"ATTRIBUTES",detail:"ATTRIBUTES( gts:GTS ): return:MAP\nATTRIBUTES( encoder:GTSENCODER ): return:MAP",documentation:"Retrieves the attributes of a Geo Time Series™.\n\nThe `ATTRIBUTES` function takes a **GTS** on top of the stack and push back a **MAP** including all its attributes.\n\nAn attribute corresponds to a tag for a specific series.\nThe attribute system allows the user to add some information that can change in a series.\n\n@param `gts` The input Geo Time Series™\n\n@param `encoder` The input Geo Time Series™ Encoder\n\n@param `return` The attributes MAP of the input Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ATTRIBUTES"},{name:"AUTHENTICATE",detail:"AUTHENTICATE( token:STRING ): ",documentation:"The `AUTHENTICATE` function authenticates the current stack with the **read token** on top of the stack. This function removes the token from the stack.\n\nInside a WarpScript, the stack could be authenticated only once. An exception is thrown when the stack is already authenticated.\n\n@param `token` Read token\n\n",tags:["stack"],since:"1.0.0",OPB64name:"AUTHENTICATE"},{name:"B64->",detail:"B64->( content:STRING ): result:BYTES",documentation:"Decodes the [base64](http://tools.ietf.org/html/rfc4648#section-4) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoAIs"},{name:"B64TOHEX",detail:"B64TOHEX( content:STRING ): result:STRING",documentation:"Decodes the  [base64](http://tools.ietf.org/html/rfc4648#section-4) content on top of the stack and immediately re-encode it in hexadecimal.\nThis enables you to convert encoded content which would not be valid UTF-8 encoding from base64 to hexadecimal. \nAs the string are URL encoded, the symbol `+` have to be replaced by `%2B`, otherwise a space will replace the `+` in the string.\n\n@param `content` String to convert\n\n@param `result` Hexadecimal converted string\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"B64TOHEX"},{name:"B64URL->",detail:"B64URL->( content:STRING ): result:BYTES",documentation:"Decodes the [base64url](http://tools.ietf.org/html/rfc4648#section-5) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoKK8BAIs"},{name:"BBOX",detail:"BBOX( gts:GTS ): [  minlat:DOUBLE  minlon:DOUBLE  maxlat:DOUBLE  maxlon:DOUBLE  ]\nBBOX( lgts:LIST<GTS> ): extremas:LIST<LIST<DOUBLE>>",documentation:"The `BBOX` function computes the bounding box of a Geo Time Series™ or a list thereof. It returns a list with extremas, or a list of list of extremas.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `minlat` Latitude of lower left of bounding box.\n\n@param `minlon` Longitude of lower left of bounding box.\n\n@param `maxlat` Latitude of upper right of bounding box.\n\n@param `maxlon` Longitude of upper right of bounding box.\n\n@param `extremas` List of list containing minlat, minlon, maxlat, maxlon, for every GTS in lgts.\n\n",tags:["geo","gts"],since:"1.0.0",OPB64name:"BBOX"},{name:"BIN->",detail:"BIN->( binary:STRING ): result:BYTES",documentation:"The `->BIN` function decodes a binary string representation into a bytes array.\n\n@param `binary` The binary string representation\n\n@param `result` The bytes array\n\n",tags:["strings","conversion","binary"],since:"1.0.6",OPB64name:"FZ_DAIs"},{name:"BINTOHEX",detail:"BINTOHEX( content:STRING ): result:STRING",documentation:"Converts a string representing a binary number into a string representing a hexadecimal number.\n\nThe `BINTOHEX` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from binary to hexadecimal.\n\n@param `content` The string representing a binary number\n\n@param `result` The string representing a hexadecimal number\n\n",tags:["strings","conversion","binary"],since:"1.0.0",OPB64name:"BINTOHEX"},{name:"BITCOUNT",detail:"BITCOUNT( bitset:BITSET ): cardinality:LONG length:LONG",documentation:"Returns the logical size and the cardinality of a [BitSet](https://docs.oracle.com/javase/8/docs/api/java/util/BitSet.html).\n\nThe `BITCOUNT` function consumes a bitset on the top of the stack and push back its logical size and its cardinality.\n  * The logical size is the index of the highest bit set to true plus one.\n  * The cardinality is the number of bit set to true.\n\n@param `bitset` The BitSet to count\n\n@param `length` The logical size of the BitSet\n\n@param `cardinality` The number of bits set to true\n\n",tags:["bitset","binary"],since:"1.0.6",OPB64name:"BITCOUNT"},{name:"BITGET",detail:"BITGET( bitset:BITSET index:LONG ): return:BOOLEAN",documentation:"Returns the value of the bit with the specified index.\n\nThe `BITGET` function consumes a bitset and a long on the top of the stack. It returns the value of the bit with the specified index. The bit index starts at 0 from the right.\n\n@param `index` The bit index\n\n@param `bitset` The bitset\n\n@param `return` The value of the bit with the specified index\n\n",tags:["bitset","binary"],since:"1.0.5",OPB64name:"BITGET"},{name:"BITSTOBYTES",detail:"BITSTOBYTES( bitset:BITSET ): result:BYTES",documentation:"Converts a bitset into a bytes array.\n\n@param `bitset` Bitset\n\n@param `result` Bytes array\n\n",tags:["bitset","binary","conversion"],since:"1.0.6",OPB64name:"BITSTOBYTES"},{name:"BOOTSTRAP",detail:"",documentation:"This function is executed systematically before the WarpScript stack is available for anything else. By default this function does nothing, it is equivalent \nto [`NOOP`](/doc/NOOP).\n\nIf bootstrap code was specified in the Warp 10 platform configuration, for either or all of `egress`, `mobius` or `runner`, the `BOOTSTRAP` function might\nhave been redefined and actual code could be executed.\n\nThis function is not meant to be used in user provided scripts.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"BOOTSTRAP"},{name:"BREAK",detail:"",documentation:"The `BREAK` function breaks out of the current loop. It takes no argument.\n\n> If used outside a loop, an error is thown\n\n",tags:["logic","control"],since:"1.0.0",OPB64name:"BREAK"},{name:"BUCKETCOUNT",detail:"BUCKETCOUNT( gts:GTS ): result:LONG",documentation:"The function `BUCKETCOUNT` consumes a GTS off the stack and pushes its bucketcount onto the stack.\n\n> Note: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Number of buckets\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETCOUNT"},{name:"BUCKETIZE",detail:"BUCKETIZE( [ gts:GTS+ bucketizer:AGGREGATOR lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE( [ gtsList:LIST<GTS>+ bucketizer:AGGREGATOR lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE( [ gts:GTS+ macro:MACRO lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE( [ gtsList:LIST<GTS>+ macro:MACRO lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>",documentation:"The Geo Time Series™ kept in the Warp 10 platform grow over time as more measurements are added. Some series have very regular measurements,\nothers more sporadic ones. But when it comes to manipulating the data, it might be handy to be able to impose some kind of regularity to measurements.\nThis is exactly what the [`BUCKETIZE`](/doc/BUCKETIZE) framework does, it provides the tooling for putting the data of a Geo Time Series™ into regularly spaced\n**buckets**.\n\nA **bucket** is a time interval which spans a certain number of time units called the **bucketspan**, ending at a tick called the **lastbucket**.\n\nAs an example, the bucket spanning 10 time units and ending at time units 20 will contain all measurements taken at the following times:\n\n20, 19, 18, 17, 16, 15, 14, 13, 12, 11\n\nthe previous bucket with the same bucketspan ends at 10 and covers ticks 10 down to 1. The next bucket ends at 30 and covers ticks 21 to 30.\n\nA bucketized Geo Time Series™ is characterized by its **bucketspan**, its **bucketcount** and the **lastbucket**.\nA bucketized Geo Time Series™ has at most one measurement per bucket, there might be buckets with no measurements.\n\nThe `BUCKETIZE` framework is used to convert a non bucketized Geo Time Series™ into a bucketized one. The bucketization process collects\nthe measurements of the original geo time series which fall in each bucket and apply a bucketizer function on those data, thus leading to at most a\nsingle measurement for each bucket.\n\nThe `BUCKETIZE` framework comes with a number of bucketizer which implement very common aggregation functions such as SUM, MIN, MAX, MEAN, etc.\n\nA macro can be used instead of the bucketizer argument. In that case, in each bucket the measurements are collected as a sub Geo Time Series™ which is taken as parameter by the macro.\nThis macro must then push onto the stack its result (see description in signature description below).\n\nIf the bucketizer argument is NULL, then BUCKETIZE do not create any new Geo Time Series™ but instead sets the lastbucket, bucketspan and bucketcount of its inputs without processing their data.\n\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so the first value of the geo time series is at the beginning of the first bucket.\n\n@param `bucketspan` Width in time units of each bucket. If `bucketspan` is 0 but `bucketcount` is set, WarpScript will compute `bucketspan` so `bucketcount` buckets cover the complete set of values from firsttick to lasttick. If this value is set to -1, the number of buckets is computed so the first tick is towards the end of the first bucket.\n\n@param `lastbucket` Specifies the timestamp in time units since the Unix Epoch of the end of the most recent bucket. If you set this value to 0, this timestamp will be computed automatically so it covers the most recent value of the geo time series and falls on a `bucketspan` boundary.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS\n\n",tags:["framework","bucketize","gts","bucketizer"],since:"1.0.0",OPB64name:"BUCKETIZE"},{name:"BUCKETIZE.CALENDAR",detail:"BUCKETIZE.CALENDAR( [ gts:GTS+ bucketizer:AGGREGATOR lastbucket:LONG bucketduration:STRING bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE.CALENDAR( [ gts:GTS+ macro:MACRO lastbucket:LONG bucketduration:STRING bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE.CALENDAR( [ gts:GTS+ bucketizer:AGGREGATOR lastbucket:LONG bucketduration:STRING bucketcount:LONG timezone:STRING ] ): result:LIST<GTS>\nBUCKETIZE.CALENDAR( [ gts:GTS+ macro:MACRO lastbucket:LONG bucketduration:STRING bucketcount:LONG timezone:STRING ] ): result:LIST<GTS>",documentation:"Creates bucketized Geo Time Series with buckets that span a calendar duration that can be irregular (e.g. taking into account leap years and daylight saving time).\n\nInstead of using a bucketspan like the BUCKETIZE framework, it uses a bucketduration: a STRING in [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) format, as `PyYmMwWdDThHmMsS` similarly to that of ADDDURATION function. However, complex bucketdurations that can be non-positive from some ticks are not allowed.\n\nIn the result, the tick of each bucket is its index, which is equal to the number of buckets that are ended since Unix Epoch. In particular, the tick of the bucket that contains Unix Epoch is always 0. The resulting GTS is considered bucketized for further operations. Then, the function UNBUCKETIZE.CALENDAR can be used to replace bucket indices with their timestamp end boundaries.\n\nThis function answers the limitation of BUCKETIZE to regular buckets. For instance, BUCKETIZE.CALENDAR can be used with a duration of one month (`P1M`) or one year (`P1Y`).\n\nThe delta between Unix Epoch and the first timestamp of bucket 0th is called the bucketoffset. The bucketoffset, bucketduration and buckettimezone are stored in the attributes.\n\n@param `timezone` The timezone to consider. Default to UTC\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so every value of the GTS falls in a bucket.\n\n@param `bucketduration` Width in ISO 8601 duration format of each bucket.\n\n@param `lastbucket` Specifies the timestamp in platform time units of the end boundary of the most recent bucket. For coherency with BUCKETIZE, this value can not be set to 0.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS in the new time referential\n\n",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"BUCKETIZE.CALENDAR"},{name:"BUCKETSPAN",detail:"BUCKETSPAN( gts:GTS ): result:LONG",documentation:"The function `BUCKETSPAN` consumes a GTS off the stack and pushes its bucketspan onto the stack.\n\n> when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Bucketspan\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETSPAN"},{name:"BYTES->",detail:"BYTES->( bytes:BYTES charset:STRING ): result:STRING",documentation:"Converts a bytes array into a string with given a charset and put the string on top of the stack.\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\n\n@param `charset` Charset to use\n\n@param `bytes` Bytes array to convert\n\n@param `result` String converted byte array\n\n",tags:["strings","conversion"],since:"1.0.6",OPB64name:"F__JGKBhEV"},{name:"BYTESTOBITS",detail:"BYTESTOBITS( bytesarray:BYTES ): result:BITSET",documentation:"Converts a byte array into a bitset.\n\n@param `bytesarray` Bytes array\n\n@param `result` Bitset\n\n",tags:["bitset","conversion","binary"],since:"1.0.6",OPB64name:"BYTESTOBITS"},{name:"CALL",detail:"CALL( params:STRING program:STRING ): result:STRING",documentation:'The `CALL` function invokes the external program whose path (relative to the `warpscript.call.directory` directory) is on top of the stack. The calling convention will pass to the external\nprogram the **STRING** object below the path on a line by itself on standard input after having URL encoded the **STRING**. The invoked\nprogram is expected to return a URL encoded **STRING** object if invocation was successful, or a string starting with a space and followed by a URL encoded error message if an error was encoutered.\n\nIf you need to pass complex structures to the invoked program, you can use functions such as [`->JSON`](/doc/AIt9JoxD), [`->PICKLE`](/doc/AItFHJCAI3J)\nand [`->B64`](/doc/AIt1CYF) to encode the input prior to the invocation.\n\nExamples of callable programs are provided in [shell](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/sh/callable.sh)\nand [python](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/python/callable.py).\n\nThe program must be stored in the directory described by the `warpscript.call.directory` configuration parameter.\n\nThe program must first output on the stdout the number of concurrent thread allowed.\n\nExample:\n\n```bash\n#!/bin/bash\necho 5 # 5 threads allowed\nurldecode() {\n  # urldecode <string>\n  local url_encoded="${1//+/ }"\n  printf \'%b\' "${url_encoded//%/\\\\x}"\n}\nwhile true\n\ndo\n  read line\n  line=`urldecode "${line}"` # read the params given by the WarpScript\n  echo $line # Will be pushed on the stack\ndone\n```\n\n@param `program` Program path\n\n@param `params` URL encoded input\n\n@param `result` URL encoded output\n\n',tags:["platform"],since:"1.0.7",OPB64name:"CALL"},{name:"CBRT",detail:"CBRT( value:NUMBER ): result:DOUBLE\nCBRT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `CBRT` function consumes a numeric parameter from the top of the stack and pushes back its cubic root.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Cubic root of the given value.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of cubic root of each given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"CBRT"},{name:"CEIL",detail:"CEIL( value:NUMBER ): result:DOUBLE\nCEIL( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `CEIL` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number bigger than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-up value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-up values, for each given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"CEIL"},{name:"CEVAL",detail:"CEVAL( macros:LIST poolSize:LONG ): result:LIST",documentation:"The `CEVAL` function allows you to execute macros in a concurrent way on a pool of threads.\n\nAll macros will be executed with the maximum parallelism level specified. Each macro is executed on its own stack. The context of the global stack is\nreplicated to each of those stacks so each macro will have access to the existing symbols and the redefined functions. Any modification to the symbol\ntable or redifined functions done in a concurrent macro will not be reflected in the global stack afterwards.\n\nEach macro is invoked with its index in the list on top of the stack.\n\nUpon termination of each macro, the content of their respective stacks is put into a list, with the top of the stack at index 0, and those lists are\nmerged into a global list which is then pushed onto the stack. The resulting list for each macro appears at the index of the macro in the original macro list.\n\nBeware that no synchronization is implicitely performed between the concurrent macros. If you require synchronization between macros, for example because\nyou are modifying a list accessible by all macros via a symbol, you must use the [`SYNC`](/doc/SYNC) function.\n\nIf one of the macros fail, an attempt to interrupt the other running macros will be done and the failure will be propagated to the other macros. For the\ntime being, a call to [`STOP`](/doc/STOP) or [`RETURN`](/doc/RETURN) in one of the macros will stop all of them.\n\nUse of `CEVAL` is not available from within a macro currently executing in a `CEVAL` call.\n\nThe `CEVAL` function is part of the `io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```properties\n// Enable CEVAL and SYNC functions\nwarpscript.extension.concurrent = io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension\n```\n\n@param `poolSize` Parallelism level\n\n@param `macros` List of macros\n\n@param `result` Result list\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"CEVAL"},{name:"CHECKMACRO",detail:"CHECKMACRO( name:STRING ): ",documentation:"The `CHECKMACRO` function checks if a macro is defined and aborts the execution when it encounters an undefined macro.\n\n@param `name` The macro name\n\n",tags:["logic","control"],since:"2.1.0",OPB64name:"CHECKMACRO"},{name:"CHECKSHAPE",detail:"CHECKSHAPE( list:LIST ): result:LIST\nCHECKSHAPE( { list:LIST  } ): result:LIST",documentation:"Return a BOOLEAN indicating whether an input list and its nested lists sizes are coherent together to form a tensor (or multidimensional array).\n\n@param `list` The input list.\n\n@param `result` true or false.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"CHECKSHAPE"},{name:"CHRONOEND",detail:"CHRONOEND( name:STRING ): ",documentation:"The `CHRONOEND` function ends a stopwatch with the given name previously started with [`CHRONOSTART`](/doc/CHRONOSTART). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\nIt is a good practice to put `CHRONOEND` in the finally clause of a [`TRY`](/doc/TRY) for the timing to work even if exceptions are thrown.\n\n@param `name` A name identifying the stopwatch.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOEND"},{name:"CHRONOSTART",detail:"CHRONOSTART( name:STRING ): ",documentation:"The `CHRONOSTART` function starts a stopwatch with the given name. To stop the stopwatch, call [`CHRONOEND`](/doc/CHRONOEND). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\n@param `name` A name identifying the stopwatch.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTART"},{name:"CHRONOSTATS",detail:"CHRONOSTATS(): stats:MAP",documentation:"The `CHRONOSTATS` function \n\n@param `stats` A map with stopwatches names as keys and maps as values. These maps have two keys, `total_calls` and `total_time`. The former gives the number of calls to [`CHRONOSTART`](/doc/CHRONOSTART) and the latter gives the cumulative time between [`CHRONOSTART`](/doc/CHRONOSTART) and [`CHRONOEND`](/doc/CHRONOEND) in **nanoseconds**.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTATS"},{name:"CHUNK",detail:"CHUNK( gts:GTS lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<GTS>\nCHUNK( gtsList:LIST<GTS> lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<GTS>\nCHUNK( encoder:GTSENCODER lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): resultEncoders:LIST<GTSENCODER>\nCHUNK( lEncoder:LIST<GTSENCODER> lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): resultEncoders:LIST<GTSENCODER>",documentation:"The `CHUNK` is used to split a Geo Time Series™ into partial GTS. The split operation is controlled by multiple parameters.\nThe series will be splitted in chunks, each chunks will form a new GTS, with a label value corresponding to its first tick.\n\n@param `keepempty` If true empty chunks are kept\n\n@param `chunklabel` The label name of the label added by the split operation (with a value corresponding to the first tick of the chunk).\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` An overlap duration (in time units) between chunks, this is useful when chunking a GTS to apply an algorithm which operates on a sliding window.\n\n@param `chunkwidth` The width in time units of each chunk.\n\n@param `lastchunkend` The end timestamp of the most recent split to consider.\n\n@param `gts` A single GTS instance.\n\n@param `gtsList` A GTS list to split, each GTS will be splitted individually.\n\n@param `encoder` A single GTS Encoder instance.\n\n@param `lEncoder` A GTS Encoder list to split, each GTS Encoder will be splitted individually.\n\n@param `result` GTS Chunks, a list formed with its partial GTS.\n\n@param `resultEncoders` GTS Encoders Chunks, a list formed with its partial GTS Encoders.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"CHUNK"},{name:"CHUNKENCODER",detail:"CHUNKENCODER( GTSEncoder:GTSENCODER lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<GTSENCODER>\nCHUNKENCODER( GTSEncoderList:LIST<GTSENCODER> lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<LIST<GTSENCODER>>",documentation:"The `CHUNKENCODER` function is used to split a [GTSEncoder](/doc/NEWENCODER) into partial GTSEncoder. The user defines some parameters that will \nbe applied to the split operation. The series will be splitted in chunks, each chunks will form a new GTSEncoder, with a label value \ncorresponding to its first tick.\n\nDeprecated since 2.1, use CHUNK instead which behaves the same.\n\n@param `keepempty` If true empty chunk are kept\n\n@param `chunklabel` The label name of the label added by this split operation (add a value corresponding to the first tick of the chunk). Could be a regular expression.\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` A time overlap for each chunks in time units.\n\n@param `chunkwidth` The width in time unit of each chunks in time units.\n\n@param `lastchunkend` The split operation end when it encounters this timestamp.\n\n@param `GTSEncoder` A single GTSEncoder \n\n@param `GTSEncoderList` A GTSEncoder list to split, each GTSEncoder will be splitted individually.\n\n@param `result` GTSEncoder Chunks, a list formed with its partial GTSEncoder\n\n",tags:["encoder"],since:"1.2.9",OPB64name:"CHUNKENCODER"},{name:"CLEAR",detail:"CLEAR( input:ANY* ): ",documentation:"The `CLEAR` function empties the stack.\n\n@param `input` all the input on the stack will be erased from the stack.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEAR"},{name:"CLEARDEFS",detail:"",documentation:"The `CLEARDEFS` function allows you to clear all [redefined WarpScript functions](/doc/DEF).\n\nBy default, all redefined WarpScript function, will not be available anymore. Set the `warpscript.def.unshadow` \nconfiguration property to change this behaviour.\n\nThis configuration parameter determines if undefining a function (via NULL 'XXX' DEF) will unshadow the original statement \nthus making it available again or if it will replace it with a function that will fail with a message saying the function is undefined.\nThe safest behavior is to leave this undefined or set to **false**.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEARDEFS"},{name:"CLEARREGS",detail:"CLEARREGS(): value:ANY",documentation:"Clears all registers, setting their current value to `NULL`.\n\n@param `value` Value from the designated register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"CLEARREGS"},{name:"CLEARSYMBOLS",detail:"",documentation:"The `CLEARSYMBOLS` function clears all symbols defined with the function [`STORE`](/doc/STORE).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEARSYMBOLS"},{name:"CLEARTOMARK",detail:"CLEARTOMARK( mark:MARK inputs:ANY* ): ",documentation:"Removes elements from the stack up to and including the first mark encountered.\n\n@param `inputs` all the inputs references on the stack will be erased\n\n@param `mark` the mark will also be erased\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CLEARTOMARK"},{name:"CLIP",detail:"CLIP( gts:GTS bounds:LIST<LIST<LONG>> ): result:LIST<GTS>\nCLIP( lgts:LIST<GTS> bounds:LIST<LIST<LONG>> ): result:LIST<LIST<GTS>>\nCLIP( encoder:GTSENCODER bounds:LIST<LIST<LONG>> ): result:LIST<GTSENCODER>\nCLIP( lencoder:LIST<GTSENCODER> bounds:LIST<LIST<LONG>> ): result:LIST<LIST<GTS>>",documentation:"The `CLIP` function clips a Geo Time Series™, encoders or list thereof according to a series of limits. The limits are lists of pair containing the lower and upper \ntimestamps used to clip. Each pair will generate a clipped GTS or encoder for each instance.\n\n@param `bounds` List of timestamp pairs. Each pair is a list of LONG.\n\n@param `gts` GTS to clip\n\n@param `lgts` List of GTSs to clip\n\n@param `encoder` Emcoder to clip\n\n@param `lencoder` List of encoders to clip\n\n@param `result` List of clipped GTS\n\n",tags:["gts"],since:"1.2.0",OPB64name:"CLIP"},{name:"CLONE",detail:"CLONE( gts:GTS ): original:GTS clone:GTS\nCLONE( list:LIST ): original:LIST clone:LIST\nCLONE( map:MAP ): original:MAP clone:MAP\nCLONE( set:SET ): original:SET clone:SET\nCLONE( vector:VECTOR ): original:VECTOR clone:VECTOR\nCLONE( encoder:GTSENCODER ): original:GTSENCODER clone:GTSENCODER",documentation:"The `CLONE` function does a shallow copy of a given Geo Time Series™, List, Map or Vector. Since 2.1.1 it can also clone Encoders.\n\nAs it makes a shallow copy, be careful when using CLONE on a List of Geo Time Series™ like those generated by the use of [`FETCH`](/doc/FETCH). Modifying a Geo Time Series™ in any of those list will alter the matching Geo Time Series™ in the other List.\nIf you want to use `CLONE` after a [`FETCH`](/doc/FETCH), you will need to extract the Geo Time Series™ from the list, for example by using [`LIST->`](/doc/I3_IK1oy), [`GET`](/doc/GET) or [`LMAP`](/doc/LMAP).\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `list` The List to clone\n\n@param `map` The Map to clone\n\n@param `set` The Set to clone\n\n@param `vector` The Vector to clone\n\n@param `encoder` The Encoder to clone\n\n@param `clone` The cloned Geo Time Series™, List, Map, Vector or Encoder\n\n@param `original` The original Geo Time Series™, List, Map, Vector or Encoder\n\n",tags:["gts","lists","maps"],since:"1.0.0",OPB64name:"CLONE"},{name:"CLONEEMPTY",detail:"CLONEEMPTY( gts:GTS ): result:GTS\nCLONEEMPTY( gtsList:LIST<GTS> ): resultList:LIST<GTS>\nCLONEEMPTY( encoder:GTSENCODER ): encoderResult:GTSENCODER\nCLONEEMPTY( encoderList:LIST<GTSENCODER> ): encoderResultList:LIST<GTSENCODER>",documentation:"Clones a Geo Time Series™, an Encoder or all the instances in a list of Geo Time Series™ or an Encoder, keeping only the metadata and not the values.\n\nThe `CLONEEMPTY` function takes as parameter a Geo Time Series™, an Encoder or a list thereof. It creates an empty clone of the input with only his metadata. The cloned metadata are:\n * Classname\n * Labels\n * Attributes\n * Lastbucket, for Geo Time Series™ only\n * Bucketspan, for Geo Time Series™ only\n * Bucketcount, for Geo Time Series™ only\n * Base timestamp, for Encoders only\n * Wrapping key, for Encoders only\n\nThe input parameter is consumed and the clone or list of clones is left on the stack.\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `gtsList` The list of Geo Time Series™ to clone\n\n@param `result` The cloned Geo Time Series™\n\n@param `resultList` The cloned list of Geo Time Series™\n\n@param `encoder` The encoder to clone\n\n@param `encoderList` The list of encoder to clone\n\n@param `encoderResult` The cloned encoder\n\n@param `encoderResultList` The cloned list of encoders\n\n",tags:["gts"],since:"1.0.0",OPB64name:"CLONEEMPTY"},{name:"CLONEREVERSE",detail:"CLONEREVERSE( input:LIST ): output:LIST\nCLONEREVERSE( input:STRING ): output:STRING\nCLONEREVERSE( input:BYTES ): output:BYTES",documentation:"The function CLONEREVERSE clone the input and reverses the order of the elements. \nOutput is a reference to a new object.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n@param `input` reference of the list or string to reverse.\n\n@param `output` reference to a new reversed list or string or byte array.\n\n",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"CLONEREVERSE"},{name:"COMMONTICKS",detail:"COMMONTICKS( gtsList:LIST<GTS> ): result:LIST<GTS>",documentation:"Take a list of Geo Time Series™ and output A GTS list with only the set of ticks they have in common compared by timestamp.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with common ticks\n\n",tags:["gts"],since:"1.0.0",OPB64name:"COMMONTICKS"},{name:"COMPACT",detail:"COMPACT( gts:GTS ): result:GTS\nCOMPACT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `COMPACT` function expects a Geo Time Series™ or a **LIST** of GTS on top of the stack. For each GTS instance it reads, it will \nproduce a GTS whith fewer values, by removing measurements which have the same value, location and elevation as the previous one. The first tick will be the kept, then ticks with value or position change will be kept. The last tick from the original gts will be copied, in order to keep the same LASTTICK.\n\n@param `gts` A GTS to compact\n\n@param `gtsList` A GTS list to compact\n\n@param `result` A compacted GTS\n\n@param `resultList` A compacted GTS list\n\n",tags:["gts"],since:"1.0.0",OPB64name:"COMPACT"},{name:"CONTAINS",detail:"CONTAINS( list:LIST item:ANY ): list:LIST presence:BOOLEAN\nCONTAINS( set:SET item:ANY ): set:LIST presence:BOOLEAN\nCONTAINS( str:STRING substr:STRING ): presence:BOOLEAN",documentation:"The `CONTAINS` function checks if the element on top of the stack is contained by the list on second position. A boolean is pushed on the stack.\n\nIf the parameters are two STRINGs, `CONTAINS` checks if the second STRING is contained in the first one, leaving a boolean on the stack. This latter usage is available since revision 2.1.0.\n\n@param `item` Depending on list construction, could be a number, a string, a boolean, NULL, a GTS...\n\n@param `presence` true if inputlist contains the item. false otherwise or if inputlist is empty.\n\n@param `list` reference to the LIST to search.\n\n@param `set` reference to the SET to search.\n\n@param `str` STRING in which to find `substr`.\n\n@param `substr` STRING to find in `str`.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"CONTAINS"},{name:"CONTAINSKEY",detail:"CONTAINSKEY( inputmap:MAP key:ANY ): outputmap:MAP presence:BOOLEAN",documentation:"The `CONTAINSKEY` function checks if the key element on top of the stack is a key \nof the map on second position. \n\nThe key is consumed, and a boolean is pushed on the stack.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this key. Do not trust presence if key is NULL.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSKEY"},{name:"CONTAINSVALUE",detail:"CONTAINSVALUE( inputmap:MAP value:ANY ): outputmap:MAP presence:BOOLEAN",documentation:"The `CONTAINSVALUE` function checks if the value element on top of the stack is a value \nof the map on second position. \n\nThe value is consumed, and a boolean is pushed on the stack.\n\n@param `value` Depending on map construction, could be a number, a string, a boolean, NULL.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this value in at least one pair of its key-value.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSVALUE"},{name:"CONTINUE",detail:"",documentation:"Immediately stop executing the current iteration of an ongoing loop and start the next one.\n\n",tags:["logic","control"],since:"1.0.0",OPB64name:"CONTINUE"},{name:"COPYGEO",detail:"COPYGEO( gts:GTS geogts:GTS ): result:GTS\nCOPYGEO( gtsList:LIST<GTS> geogts:GTS ): resultList:LIST<GTS>",documentation:"The `COPYGEO` function forces the location elements of a GTS onto others. `COPYGEO` expects two parameters on the stack.\nFirst input is GTS or a gts list: those series(s) will have their location overwritten by the one of the second GTS parameter. Geo information will be copied only if they are present in the second paramaters on the same tick otherwise it keep the existing location. See [`COMMONTICKS`](/doc/COMMONTICKS) to keep only commonticks before calling `COPYGEO`.\n\n@param `gts` A GTS\n\n@param `gtsList` A list of GTS\n\n@param `geogts` A GTS with the geo information you want to copy to other (list of) gts.\n\n@param `result` A GTS with the geo information of the geogts input\n\n@param `resultList` A list of GTS with the geo information of the geogts input\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"COPYGEO"},{name:"COPYSIGN",detail:"COPYSIGN( p1:NUMBER p2:NUMBER ): result:DOUBLE\nCOPYSIGN( p1:NUMBER list2:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nCOPYSIGN( list1:LIST<NUMBER> p2:NUMBER ): lresult:LIST<DOUBLE>",documentation:"The `COPYSIGN` function copies the sign of a number on another one and pushes back the value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` Numeric parameter on which sign is applied\n\n@param `p2` Numeric parameter on which sign is extracted\n\n@param `list1` List of numeric parameter on wich sign is applied\n\n@param `list2` List of numeric parameter on wich sign is extracted\n\n@param `result` Value of p1 with the sign of p2 s a DOUBLE\n\n@param `lresult` List of results\n\n",tags:["math"],since:"1.0.0",OPB64name:"COPYSIGN"},{name:"CORRELATE",detail:"CORRELATE( baseGTS:GTS gtsList:LIST timeOffsets:LIST ): result:LIST<GTS>",documentation:"The `CORRELATE` function allows you to compute correlation between one base Geo Time Series™ and a set of others. \nBy putting the base GTS in the set of others, cross correlation can be computed.\n\n@param `baseGTS` The base Geo Time Series\n\n@param `gtsList` A list of Geo Time Series against which to compute the correlation\n\n@param `timeOffsets` A list of time offsets for which the correlation will be computed (expressed in time units of the Warp instance)\n\n@param `result` A list of synthetic Geo Time Series™ whose timestamps are the offsets from the initial offset list and the values are the computed correlations. There is one GTS per GTS in the list at TOP-1.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"CORRELATE"},{name:"COS",detail:"COS( value:NUMBER ): result:DOUBLE\nCOS( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `COS` function consumes a floating point number from the top of the stack and pushes back its cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Cosine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of cosine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COS"},{name:"COSH",detail:"COSH( value:NUMBER ): result:DOUBLE\nCOSH( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `COSH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic cosine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic cosine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COSH"},{name:"COUNTER",detail:"COUNTER(): counter:COUNTER",documentation:"The `COUNTER` function pushes a counter (AtomicLong) initialized with the value 0 onto the stack.\n\nThis atomic counter can be safely shared in multiple concurrent macros (see [`CEVAL`](/doc/CEVAL)).\n\n@param `counter` Counter instance.\n\n",tags:["counters"],since:"1.0.0",OPB64name:"COUNTER"},{name:"COUNTERDELTA",detail:"COUNTERDELTA( counter:COUNTER increment:LONG ): counter:COUNTER",documentation:"The `COUNTERDELTA` function increments a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `increment` Counter increment.\n\n",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERDELTA"},{name:"COUNTERSET",detail:"COUNTERSET( counter:COUNTER value:LONG ): counter:COUNTER",documentation:"The `COUNTERSET` function set the value of a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `value` Counter value.\n\n",tags:["counters"],since:"1.2.22",OPB64name:"COUNTERSET"},{name:"COUNTERVALUE",detail:"COUNTERVALUE( counter:COUNTER ): value:LONG",documentation:"The `COUNTERVALUE` function pushes the counter value onto the stack.\n\n@param `counter` The counter instance.\n\n@param `value` The value of the counter.\n\n",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERVALUE"},{name:"COUNTTOMARK",detail:"COUNTTOMARK(): result:LONG",documentation:"Counts the number of elements on the stack up to but excluding the first mark encountered. Neither the mark nor the\nelements on top of it are removed from the stack.\n\n@param `result` Stack depth until `MARK`\n\n",tags:["stack"],since:"1.0.0",OPB64name:"COUNTTOMARK"},{name:"CPOPR",detail:"CPOPR( value:ANY ): ",documentation:"Pops a value from the top of the stack and stores it into the designated register if the register is empty (*i.e.* has `NULL` as its current value).\n\nThe `CPOPR` function is really a family of functions named `CPOPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"CPOPR"},{name:"CPROB",detail:"CPROB( gts:GTS separator:STRING ): result:GTS\nCPROB( lgts:LIST<GTS> separator:STRING ): lresult:LIST<GTS>",documentation:"The function `CPROB` generates a new Geo Time Series™ from an input Geo Time Series™ by computing a conditional probability.\n\nThe function expects a **STRING** separator on top of the stack and expects the input Geo Time Series™ to have \nvalues of the form given1< SEP >given2< SEP >....< SEP >event. It will then emit P(event|given1,given2,...).\n\nIf the separator is **NULL**, `CPROB` behaves like [`PROB`](/doc/PROB).\n\n@param `separator` Value separator\n\n@param `gts` Geo Time Series™\n\n@param `lgts` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `lresult` List of Geo Time Series™\n\n",tags:["gts"],since:"1.0.6",OPB64name:"CPROB"},{name:"CROP",detail:"CROP( gts:GTS ): result:GTS\nCROP( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `CROP` function works on bucketized Geo Time Series™ instances, if transforms a GTS into another one whose bucketcount, last bucket parameters span the smallest interval with actual values. Bucket span remains the same.\n\nWhen called on a non bucketized GTS instance, `CROP` simply clones it.\n\nThis function expects a list of GTS instances on the top of the stack.\n\n@param `gts` Bucketized GTS\n\n@param `result` ropped version of GTS or a clone thereof if GTS was not bucketized.\n\n@param `gtsList` List of bucketized GTS\n\n@param `resultList` A list of cropped version of GTS or a clone thereof if GTS was not bucketized.\n\n",tags:["bucketize"],since:"1.0.0",OPB64name:"CROP"},{name:"CSTORE",detail:"CSTORE( value:ANY symbol:STRING ): \nCSTORE( value:ANY register:LONG ): ",documentation:"The `CSTORE` function stores a value in a symbol or a register only if that symbol or register is not yet defined. The name of this function stands for Conditional STORE.\n\n@param `symbol` Name of symbol under which to store `value`.\n\n@param `register` Number of the register under which to store `value`.\n\n@param `value` Value to store unde `symbol`.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"CSTORE"},{name:"CUDF",detail:"CUDF( class:STRING ): ",documentation:"The `CUDF` function invokes a User Defined Function from a Jar as [`UDF`](/doc/UDF) but reuses a cached instance of the function.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",tags:["control"],since:"1.0.0",OPB64name:"CUDF"},{name:"DEBUGOFF",detail:"",documentation:"Turns off stack debugging which was turned on by [`DEBUGON`](/doc/DEBUGON) or [`NDEBUGON`](/doc/NDEBUGON).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGOFF"},{name:"DEBUGON",detail:"",documentation:"Turns on stack debugging which returns the stack content in case of error. Stack debugging is off by default.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGON"},{name:"DECREMENTEXACT",detail:"DECREMENTEXACT( value:NUMBER ): result:DOUBLE\nDECREMENTEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `DECREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value decremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be decremented by one\n\n@param `result` The decremented value\n\n@param `lvalue` List of values to be decremented by one\n\n@param `lresult` List of decremented values\n\n",tags:["math"],since:"1.2.23",OPB64name:"DECREMENTEXACT"},{name:"DEDUP",detail:"DEDUP( gts:GTS ): result:GTS\nDEDUP( gts:GTS mapper:AGGREGATOR ): lresult:GTS\nDEDUP( gts:GTS macro:MACRO ): lresult:GTS\nDEDUP( lgts:LIST<GTS> ): lresult:LIST<GTS>\nDEDUP( lgts:LIST<GTS> mapper:AGGREGATOR ): lresult:LIST<GTS>\nDEDUP( lgts:LIST<GTS> macro:MACRO ): lresult:LIST<GTS>",documentation:"Removes duplicate ticks.\n\nThe `DEDUP` function consumes a Geo Time Series™ or a **LIST** thereof from the top of the stack and pushes back the Geo Time Series™ with deduplicated ticks.\n\nSince the 2.7.0 version, this function can be given an optional mapper or macro to combine the duplicate data points.\n\n@param `gts` The Geo Time Series™ to deduplicate\n\n@param `result` The Geo Time Series™ with deduplicated ticks\n\n@param `lgts` The list of Geo Time Series™ to deduplicate\n\n@param `lresult` The list of Geo Time Series™ with deduplicated ticks\n\n@param `mapper` Mapper used to aggregate duplicate values\n\n@param `macro` Macro used to aggregate duplicate values given as a GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"DEDUP"},{name:"DEF",detail:"DEF( newDef:MACRO name:STRING ): ",documentation:"The `DEF` function allows you to define new WarpScript functions or redefine existing ones for the duration of your script execution.\n\nThe function expects on the stack a macro which will be used as the content of the newly defined function, and a name under which to define the new function.\n\nWhen redefining a function, if the function being redefined is used within the macro, the code which will be executed is the current one, \nas the binding of function to code is done at the time when the macro is defined and not when it is executed.\n\nYou may therefore add limits to the use of an existing function by rewrapping it in a macro which will be associated with the original function name.\n\nTo remove redefined functions see [`CLEARDEFS`](/doc/CLEARDEFS).\n\n@param `name` New function name\n\n@param `newDef` Macro which will be used as the content of the newly defined function\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEF"},{name:"DEFINED",detail:"DEFINED( name:STRING ): result:BOOLEAN",documentation:"The `DEFINED` function checks whether or not a symbol is defined.\n\n@param `name` Symbol name\n\n@param `result` Whether or not the symbol is defined\n\n",tags:["logic","control"],since:"1.0.0",OPB64name:"DEFINED"},{name:"DEFINEDMACRO",detail:"DEFINEDMACRO( name:STRING ): result:BOOLEAN",documentation:"The `DEFINEDMACRO` function checks if a macro is defined and pushes true or false on the stack accordingly.\n\n@param `name` The macro name\n\n@param `result` True if the macro is defined, false otherwise\n\n",tags:["logic","control"],since:"1.0.16",OPB64name:"DEFINEDMACRO"},{name:"DEFLATE",detail:"DEFLATE( string:STRING ): compressed:BYTES\nDEFLATE( bytes:BYTES ): compressed:BYTES",documentation:"The `DEFLATE` function compresses a STRING or a byte array using the [Zlib](https://en.wikipedia.org/wiki/Zlib) library. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",tags:["conversion"],since:"2.1.0",OPB64name:"DEFLATE"},{name:"DELETE",detail:"DELETE( writeToken:STRING gts_selector:STRING start_timestamp:LONG end_timestamp:LONG count:LONG ): result:LONG",documentation:"The `DELETE` function is used to delete a set of GTS from a Warp 10 platform. A delete endpoint must be set on the Warp 10 configuration.\n\nDelete expects 5 parameters on top of the stack: the write token of the Warp 10 application, a string corresponding to a gts selector, a start \nand a end timestamp and finally the number of GTS expected to be deleted.\n\nFor safety reasons `DELETE` will first perform a dryrun call to the /delete endpoint to retrieve the number of GTS which would be deleted by the call. \nIf this number is above the expected number provided by the user the actual delete will not be performed and instead an error will be raised.\n\nDelete will push as a result the number of GTS really deleted.\n\nIf both end_timestamp and start_timestamp are NULL, Warp 10 will perform a delete all. FETCH won't find anything after a delete all.\n\n```flow\n// Write token\n'TOKEN'\n\n// Gts selector\n'gts.to.delete{}'\n\n// Start Timestamp\n1479372838011043\n\n// End timestamp\nNOW\n\n// DELETE expects a count number (if nb GTS > count, DELETE is stopped)\n1\n\nDELETE \n```\n\n@param `count` Number of GTS expected to be deleted\n\n@param `end_timestamp` End timestamp or NULL\n\n@param `start_timestamp` Start timestamp or NULL\n\n@param `gts_selector` GTS selector\n\n@param `writeToken` Write token\n\n@param `result` Actual deleted GTS count\n\n",tags:["gts"],since:"1.0.5",OPB64name:"DELETE"},{name:"DELETEOFF",detail:"DELETEOFF( message:STRING secret:STRING ): ",documentation:"Disables delete operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a delete operation is attempted.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"DELETEOFF"},{name:"DELETEON",detail:"DELETEON( secret:STRING ): ",documentation:"Enables delete operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"DELETEON"},{name:"DEPTH",detail:"DEPTH(): result:LONG",documentation:"The `DEPTH` function pushes on top of the stack the depth (i.e. number of levels) of the stack prior to the call.\n\n@param `result` Stack depth\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DEPTH"},{name:"DEREF",detail:"DEREF( macro:MACRO values:MAP ): macro:MACRO",documentation:"Replaces in a Macro the occurrences of symbol dereferencing (`$x`) or calls to `LOAD` with a `STRING` argument or calls to `PUSHRx` by the values associated with either the symbol name or register number in a parameter map.\n\nValues are used verbatim except for Macros which are inserted as functions, *i.e.* they are inserted followed by a call to `EVAL` so they are executed in the target macro instead of ending up on the stack. If you wish to replace a symbol dereference by a Macro, you need to write the macro inside of another Macro.\n\n\n@param `macro` Macro to transform.\n\n@param `values` Map of symbol name or register number to replacement value.\n\n",tags:["stack"],since:"2.3.0",OPB64name:"DEREF"},{name:"DET",detail:"DET( matrix:MATRIX ): det:DOUBLE",documentation:"Computes the [determinant](https://en.wikipedia.org/wiki/Determinant) of a matrix.\n\n@param `matrix` The matrix for which to compute the determinant.\n\n@param `det` The computed determinant.\n\n",tags:["math"],since:"1.0.6",OPB64name:"DET"},{name:"DIFFERENCE",detail:"DIFFERENCE( setA:SET setB:SET ): output:SET",documentation:"Computes the difference between two sets.\n\nThe `DIFFERENCE` function consumes two sets from the top of the stack and pushes back its mathematical difference (ie: the elements in *A* but not in *B*).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* - *B*, the set of elements in *A* but not in *B*\n\n",tags:["sets"],since:"1.0.0",OPB64name:"DIFFERENCE"},{name:"DISCORDS",detail:"DISCORDS( lgts:LIST<GTS> wsize:LONG length:LONG scale:LONG maximum:LONG overlapping:BOOLEAN distance:DOUBLE ): lresult:LIST<GTS>\nDISCORDS( gts:GTS wsize:LONG length:LONG scale:LONG maximum:LONG overlapping:BOOLEAN distance:DOUBLE ): result:GTS",documentation:"The `DISCORDS` function detects discords in a Geo Time Series™. The discord detection algorithm is based on identifying outlier patterns in\nthe Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `DISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0\n\n@param `overlapping` Flag indicating whether or not the `DISCORDS` function should report overlapping discords\n\n@param `maximum` The maximum number of discords to identify\n\n@param `lresult` The list of Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `result` The Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"DISCORDS"},{name:"DOC",detail:"DOC( string:STRING ): string:STRING",documentation:"Consumes the String on the stack or leave it there and stop the script if the stack is currently in documentation mode ([`DOCMODE`](/doc/DOCMODE)) \n\nYou can use it to document macros.\n\n@param `string` Text to display in [`DOCMODE`](/doc/DOCMODE)\n\n",tags:["help"],since:"1.0.0",OPB64name:"DOC"},{name:"DOCMODE",detail:"",documentation:"Toggle the 'documentation mode' of the stack\n\n",tags:["help"],since:"1.0.0",OPB64name:"DOCMODE"},{name:"DOUBLEBITS->",detail:"DOUBLEBITS->( input:LONG ): result:DOUBLE",documentation:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the **LONG** value as the raw bits of the **DOUBLE**\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",tags:["conversion","binary"],since:"1.2.3",OPB64name:"G3xKFZl4FZ_JJmoy"},{name:"DOUBLEEXPONENTIALSMOOTHING",detail:"DOUBLEEXPONENTIALSMOOTHING( gts:GTS alpha:DOUBLE beta:DOUBLE ): result:LIST<GTS>",documentation:"The `DOUBLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Double Exponential Smoothing aka Holt's linear trend method](https://www.otexts.org/fpp/7/2) formula.\n\nIt consumes three parameters from the top of the stack:\n * A trend smoothing factor beta (a numeric parameter between 0 < beta < 1)\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** and levels are pushed onto the stack (in this order in the **LIST**).\n\n@param `beta` The trend smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The list within the smoothed Geo Time Series™ and its levels\n\n",tags:["gts","statistics"],since:"1.0.0",OPB64name:"DOUBLEEXPONENTIALSMOOTHING"},{name:"DROP",detail:"DROP( input:ANY ): ",documentation:"The `DROP` function removes the element at the top of the stack.\n\n@param `input` object reference to drop from the top of the stack.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DROP"},{name:"DROPN",detail:"DROPN( number:NUMBER ): ",documentation:"The `DROPN` function removes the top N elements of the stack after having consumed N which was on the top of the stack prior to calling `DROPN`.\n\n@param `number` The number of elements to drop\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DROPN"},{name:"DTW",detail:"DTW( gts1:GTS gts2:GTS threshold:DOUBLE ): dtw:DOUBLE",documentation:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) or -1 if the threshold was reached.\n\n",tags:["gts","distance"],since:"1.0.0",OPB64name:"DTW"},{name:"DUP",detail:"DUP( input:ANY ): input:ANY out:ANY",documentation:"The `DUP` function duplicates the element on the top of the stack, it doesn’t copy the content. If you apply DUP to a GTS you will\nhave two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `input` any parameter on top of the stack\n\n@param `out` a reference copy of input on top of the stack\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DUP"},{name:"DUPN",detail:"DUPN( number:NUMBER ): ",documentation:"The `DUPN` function duplicates the top N elements of the stack after having consumed N which is on the top of the stack when calling `DUPN`.\n\nAs the [`DUP`](/doc/DUP) function, `DUPN` duplicates the references of the N elements on the top of the stack, it doesn’t copy the elements.\nIf you apply `DUPN` to a GTS you will have two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `number` The number of elements to duplicate\n\n",tags:["stack"],since:"1.0.0",OPB64name:"DUPN"},{name:"DURATION",detail:"DURATION( isoDuration:STRING ): duration:LONG",documentation:"The `DURATION` function consumes a **STRING** representing an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) and pushes back a **LONG** duration in platform time unit.\n\nThe ISO 8601 duration can be expessed as `PwWdDThHmMsS` with:\n- `w` weeks\n- `d` days\n- `h` hours\n- `m` minutes\n- `s` or `s.ssssss...` seconds\nEach of these values can be either positive or negative. Each value/unit couple can be omitted if the value is zero but at least one value/couple should be defined.\n\nIf the consumed ISO 8601 duration has precision under platform time unit, superfluous digits will be ignored. Prior to revision 2.4, precision below milliseconds were always ignored, independently of platform time unit.\n\n@param `isoDuration` A representation of a ISO 8601 duration with some limitations, see the description.\n\n@param `duration` Number of platform time unit corresponding to the duration.\n\n",tags:["time"],since:"1.0.0",OPB64name:"DURATION"},{name:"DWTSPLIT",detail:"DWTSPLIT( gts:GTS label-name:STRING ): result:GTS\nDWTSPLIT( lgts:LIST<GTS> label-name:STRING ): lresult:LIST<GTS>",documentation:"The `DWTSPLIT` function splits a Geo Time Series™ produced by [`FDWT`](/doc/FDWT) into multiple series, one per resolution level of the Wavelet transform.\n\n\n@param `label-name` Label name used in the generated series to indicate the level of each Geo Time Series™\n\n@param `gts` GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `lgts` List of GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `result` Splited GTS\n\n@param `lresult` List of splited GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"DWTSPLIT"},{name:"E",detail:"E(): eValue:DOUBLE",documentation:"Alias of [e](/doc/OF).\n\nThe `E` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"GF"},{name:"ECGEN",detail:"ECGEN( curve:STRING ): private:MAP public:MAP",documentation:"The `ECGEN` function generates a public/private key pair parameters suitable for performing [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n\nThe resulting parameters can serve as input to [`ECPRIVATE`](/doc/ECPRIVATE) and [`ECPUBLIC`](/doc/ECPUBLIC) to generate the actual private and public keys.\n\nThe following curves are supported:\n\n`c2pnb272w1`, `c2tnb191v3`, `c2pnb208w1`, `c2tnb191v2`, `c2tnb191v1`, `prime192v3`, `c2tnb359v1`, `prime192v2`, `prime192v1`, `c2tnb239v3`, `c2pnb163v3`, `c2tnb239v2`, `c2pnb163v2`, `c2tnb239v1`, `c2pnb163v1`, `c2pnb176w1`, `prime256v1`, `c2pnb304w1`, `c2pnb368w1`, `c2tnb431r1`, `prime239v3`, `prime239v2`, `prime239v1`, `sect233r1`, `secp112r2`, `secp112r1`, `secp256k1`, `sect113r2`, `secp521r1`, `sect113r1`, `sect409r1`, `secp192r1`, `sect193r2`, `sect131r2`, `sect193r1`, `sect131r1`, `secp160k1`, `sect571r1`, `sect283k1`, `secp384r1`, `sect163k1`, `secp256r1`, `secp128r2`, `secp128r1`, `secp224k1`, `sect233k1`, `secp160r2`, `secp160r1`, `sect409k1`, `sect283r1`, `sect163r2`, `sect163r1`, `secp192k1`, `secp224r1`, `sect239k1`, `sect571k1`, `B-163`, `P-521`, `P-256`, `B-233`, `P-224`, `B-409`, `P-384`, `B-283`, `B-571`, `P-192`, `brainpoolp512r1`, `brainpoolp384t1`, `brainpoolp256r1`, `brainpoolp192r1`, `brainpoolp512t1`, `brainpoolp256t1`, `brainpoolp224r1`, `brainpoolp320r1`, `brainpoolp192t1`, `brainpoolp160r1`, `brainpoolp224t1`, `brainpoolp384r1`, `brainpoolp320t1`, `brainpoolp160t1`\n\n@param `curve` Name of the elliptic curve to use.\n\n@param `public` Map containing the public key parameters.\n\n@param `private` Map containing the private key parameters.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECGEN"},{name:"ECHOOFF",detail:"ECHOOFF(): ",documentation:"Turns off the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"ECHOOFF"},{name:"ECHOON",detail:"ECHOON( levels:NUMBER ): ",documentation:"Turns on the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of topmost stack levels to display after each WarpScript™ line, truncated if floating-point.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"ECHOON"},{name:"ECPRIVATE",detail:"ECPRIVATE( private:MAP ): key:KEY",documentation:"The `ECPRIVATE` function generates a private key from private key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `private` Map containing ECC private key parameters.\n\n@param `key` ECC private key.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECPRIVATE"},{name:"ECPUBLIC",detail:"ECPUBLIC( public:MAP ): key:KEY",documentation:"The `ECPUBLIC` function generates a public key from public key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `public` Map containing ECC public key parameters.\n\n@param `key` ECC public key.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECPUBLIC"},{name:"ECSIGN",detail:"ECSIGN( data:BYTES alg:STRING private:KEY ): signature:BYTES",documentation:"The `ECSIGN` function generates a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) private key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Content to sign.\n\n@param `alg` Signing algorithm to use.\n\n@param `private` Private key to use for signining.\n\n@param `signature` Resulting signature.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECSIGN"},{name:"ECVERIFY",detail:"ECVERIFY( data:BYTES signature:BYTES alg:STRING public:KEY ): result:BOOLEAN",documentation:"The `ECVERIFY` function verifies a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) public key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Signed data.\n\n@param `alg` Signing algorithm to use.\n\n@param `public` Public key to use for verification.\n\n@param `signature` Signature to verify.\n\n@param `result` Validity of the signature.\n\n",tags:["crypto"],since:"2.6.0",OPB64name:"ECVERIFY"},{name:"ELAPSED",detail:"ELAPSED(): result:LIST<LONG>",documentation:"The `ELAPSED` function pushes onto the stack a list containing timing informations. The first element of the list is the timestamp at which \nthe script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution \nof the associated script line.\n\nTiming informations are only collected after a call to [`TIMINGS`](/doc/TIMINGS) (its line included) and before a call to [`NOTIMINGS`](/doc/NOTIMINGS)\n (its line excluded).\n\n@param `result` The first element of the list is the timestamp at which the script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution of the associated script line.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ELAPSED"},{name:"ELEVATIONS",detail:"ELEVATIONS( gts:GTS ): elevations:LIST<LONG>\nELEVATIONS( lgts:LIST<GTS> ): lelevations:LIST<LIST<LONG>>",documentation:"The `ELEVATIONS` function consumes a Geo Time Series™ or a list thereof from the stack, extracts its elevations, puts them in a list and pushes the list onto the stack.      \n\n@param `gts` The Geo Time Series™ from which to extract the elevations\n\n@param `lgts` The list of Geo Time Series™ from which to extract the elevations\n\n@param `elevations` The elevations of the given Geo Time Series™\n\n@param `lelevations` The list of elevations of the given Geo Time Series™\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"ELEVATIONS"},{name:"EMPTY",detail:"EMPTY( gtsList:LIST<GTS> ): result:LIST<GTS>",documentation:"Reject GTS instances with values.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with empty values\n\n",tags:["gts"],since:"1.2.5",OPB64name:"EMPTY"},{name:"ENCODER->",detail:"ENCODER->( encoder:GTSENCODER ): name:STRING attributes:MAP labels:MAP output:LIST\nENCODER->( wrappedinput:STRING ): name:STRING attributes:MAP labels:MAP output:LIST\nENCODER->( rawwrappedinput:BYTES ): name:STRING attributes:MAP labels:MAP output:LIST",documentation:"The `ENCODER->` functions convert an encoder into a list of ( timestamp, latitude, longitude, elevation, value ) list. It also pushes attributes, labels and name on the stack.\nFunction also accepts wrapped or raw-wrapped encoders or gts.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedinput` Encoder or GTS after WRAP. \n\n@param `rawwrappedinput` Encoder or GTS after WRAPRAW.\n\n@param `output` List of list of ( timestamp, latitude, longitude, elevation, value ). Missing values in the encoder or GTS are replaced by NaN.\n\n@param `name` Name of encoder or GTS. If no name was defined, will be NULL.\n\n@param `attributes` Attributes of encoder or GTS input. If none defined, will be an empty map.\n\n@param `labels` Labels of encoder or GTS input. If none defined, will be an empty map.\n\n",tags:["encoder","conversion","gts"],since:"1.2.9",OPB64name:"GJt2IoG4JXoy"},{name:"ERROR",detail:"ERROR(): error:LIST<MAP>",documentation:"Pushes onto the stack a list containing the current error (as caught by a [`TRY`](/doc/TRY)) and its causes. Each error is a map with the following fields:\n\n| Field | Description |\n| --- | --- |\n| type | Type of the error, the Java class of the underlying exception |\n| message | The message associated with the error |\n| stacktrace | A list of lists, each containing `filename`, `line number`, `class name`, `method name` |      \n\nThe current error is the first element of the list.\n\nIf there is no current error, the returned list will be empty.\n\n@param `error` List of maps describing the current error and its causes.\n\n",tags:["stack"],since:"1.2.11",OPB64name:"ERROR"},{name:"ESDTEST",detail:"ESDTEST( gts:GTS k:LONG mad:BOOLEAN alpha:DOUBLE ): result:LIST<LONG>\nESDTEST( gts:GTS k:LONG mad:BOOLEAN ): result:LIST<LONG>\nESDTEST( gtsList:LIST<GTS> k:LONG mad:BOOLEAN alpha:DOUBLE ): resultList:LIST<LIST<LONG>>\nESDTEST( gtsList:LIST<GTS> k:LONG mad:BOOLEAN ): resultList:LIST<LIST<LONG>>",documentation:"The `ESDTEST` function detects outliers in a GTS (or a **LIST** of GTS), by applying a [generalized extreme studentized deviate test](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm).\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nA [Grubbs’](/doc/GRUBBSTEST)test is done for one candidate at a time. Then, the candidate is removed from the set and another [Grubbs’](/doc/GRUBBSTEST)test\nis performed. This process is iterated a given number of times. The detected outliers are the removed values and the current candidate of the last successful\ntest.\n\nA **LIST** of ticks (or a **LIST** of **LIST** of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ESDTEST"},{name:"EVAL",detail:"EVAL( macro:MACRO ): \nEVAL( string:STRING ): ",documentation:"The `EVAL` function evaluates the statements contained in the string at the top of the stack as if they had been entered individually or runs the macro at the top os the stack.\n\n@param `string` String to evaluate\n\n@param `macro` Macro to run\n\n",tags:["control"],since:"1.0.0",OPB64name:"EVAL"},{name:"EVALSECURE",detail:"EVALSECURE( secure:STRING ): return:ANY",documentation:"The `EVALSECURE` function executes a secure script. The script must have been created on a platform with the same secure script cryptographic key as the current platform (note that this is not the *secret* set using [`SECUREKEY`](doc/SECUREKEY)).\n\n@param `secure` String containing the secure script to execute.\n\n@param `return` The return values depend on the actual code of the secure script.\n\n",tags:["crypto","stack"],since:"1.0.0",OPB64name:"EVALSECURE"},{name:"EVERY",detail:"EVERY( macro:MACRO repeat:LONG ): ",documentation:"When called via the `/mobius` endpoint, the `EVERY` function sets the repeat interval for the preceding macro.\n\nWhen called outside of `/mobius`, the `EVERY` function simply executes the macro.\n\n@param `repeat` The repeat interval to enforce, in milliseconds.\n\n@param `macro` The macro to execute.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"EVERY"},{name:"EXP",detail:"EXP( value:NUMBER ): result:DOUBLE\nEXP( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a floating point value x consumed from the top of the stack,\n i.e. e<sup>x</sup>.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List where each value is e<sup>x</sup>\n\n",tags:["math"],since:"1.0.0",OPB64name:"EXP"},{name:"EXPM1",detail:"EXPM1( value:NUMBER ): result:DOUBLE\nEXPM1( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a DOUBLE value x consumed from the top of the stack then subtracts one, i.e. e<sup>x</sup>-1.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>-1\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List of e<sup>x</sup>-1\n\n",tags:["math"],since:"1.0.0",OPB64name:"EXPM1"},{name:"EXPORT",detail:"EXPORT( symbol:STRING ): \nEXPORT( symbols:LIST ): ",documentation:"The `EXPORT` function allows you to set or update a list of symbols which will be dumped upon script termination. This proves handy when \ndebugging a script as you can visualize, even in the case of errors, the value of specific symbols.\n\nThe function expects either a symbol name (a **STRING**) which will be added to the current list of exported symbols, a list of symbol \nname which will replace the current list of exported symbols, an empty list to disable symbol export altogether, or a list with a single\n**NULL** element to instruct the WarpScript engine to export all existing symbols.\n\nWhen symbols should be exported, the debug mode is implied (see [`DEBUGON`](/doc/DEBUGON)).\n\n@param `symbol` Symbol name\n\n@param `symbols` List of symbols\n\n",tags:["stack","debug"],since:"1.0.2",OPB64name:"EXPORT"},{name:"EXTLOADED",detail:"EXTLOADED( ext:STRING ): loaded:BOOLEAN",documentation:"Checks if a WarpScript extension is loaded or not and therefore available.      \n\n@param `ext` Name of extension to check.\n\n@param `loaded` Boolean indicating whether or not the specified extension is loaded in the WarpScript environment.\n\n",tags:["stack"],since:"1.2.13",OPB64name:"EXTLOADED"},{name:"F",detail:"F(): b:BOOLEAN",documentation:"`F` stand for `false`. It is a boolean constant.\n\n\n@param `b` false\n\n",tags:["logic","constants"],since:"1.0.0",OPB64name:"F"},{name:"FAIL",detail:"",documentation:"The `FAIL` function stops the execution of the WarpScript scripts by throwing an exception.\n\n",tags:["control"],since:"1.0.0",OPB64name:"FAIL"},{name:"FDWT",detail:"FDWT( gts:GTS wavelet:STRING ): fdwt:GTS\nFDWT( lgts:LIST<GTS> wavelet:STRING ): lfdwt:LIST<GTS>",documentation:"The `FDWT` function performs a [Forward Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Fast_wavelet_transform#Forward_DWT) on a Geo Time Series™.\n\nA number of different [Wavelets](https://en.wikipedia.org/wiki/Wavelet) are available, the list is inspired by that available on \nthe [Wavelet Browser](http://wavelets.pybytes.com/).\n\nThe list of Wavelets which can be used is the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\nThe FDWT can only be applied to Geo Time Series™ with a number of values which is a power of 2.\n\nAssuming the input GTS has 2<sup>n</sup> values, the result of the FDWT transformation is a GTS with 2<sup>n</sup> values (the wavelet coefficients) with timestamps from 0 to 2<sup>n</sup>-1.\n\nThe ticks of the `n` levels are contiguous, with the first tick being for level `n`, the next 2 for level `n-1`, the next 4 for level `n-2`, up to the last 2<sup>n-1</sup> for level 1.\n\nLevel 1 has the finest time resolution but the coarsest frequency resolution. Each level has half (coarser) the time resolution and double (finer) the frequency resolution as the previous level.\n\n@param `wavelet` Name of wavelet to use for the transformation.\n\n@param `gts` Geo Time Series™ instance on which to perform the FDWT.\n\n@param `lgts` List of Geo Time Series™ on which to apply the FDWT.\n\n@param `fdwt` Transformed Geo Time Series™.\n\n@param `lfdwt` List of transformed Geo Time Series™.\n\n",tags:["math","gts"],since:"1.0.0",OPB64name:"FDWT"},{name:"FETCH",detail:"FETCH( [ token:STRING class:STRING labels:MAP end:LONG timespan:LONG ] ): data:LIST<GTS>\nFETCH( [ token:STRING class:STRING labels:MAP start:STRING end:STRING ] ): data:LIST<GTS>\nFETCH( { token:STRING class:STRING labels:MAP end:LONG start:STRING timespan:LONG count:LONG selector:STRING selectors:LIST<STRING> metaset:STRING type:STRING typeattr:STRING extra:LIST<STRING> active.after:LONG quiet.after:LONG gts:LIST<GTS> boundary.post:LONG boundary.pre:LONG boundary:LONG skip.count:LONG sampling.ratio:DOUBLE  } ): data:LIST<GTS>",documentation:"The `FETCH` function interacts with the Warp 10 Storage Engine to retrieve data according to given criteria.\n\n`FETCH` either accepts a list of 5 parameters or a map with the parameters. Those are defining the **read access rights**, the **concerned Geo Time Series** and the **time window**. Other parameters in the map input are optional. \n\nThe list input is here to keep backward compatibility with old WarpScripts. The map input allows a great flexibility, as described below.\n\n### Access rights\nA valid read token is needed to read data with fetch. If you use a [metaset](/doc/METASET) and also specify a token, the token included in the metaset will be ignored.\n\n### Concerned Geo Time Series\n`FETCH` selects Geo Time Series according to:\n+ The `selectors` parameter, which is a list of selector.\n+ If `selectors` is not found, `FETCH` uses the `selector` parameter which is a single selector.\n+ If `selector` is not found, `FETCH`  uses both `class` and `labels` parameters.  \n\n### Time window\n`FETCH`  begins from the newest value and stop when the oldest value is collected. Thus, `end` must be defined in your request and defines the newest included value in your time window. If `end` is anterior to your oldest value, the result will be empty (no Geo Time Series). The span of the time window ending at `end` is then defined according to:\n+ The `timespan` parameter.\n+ If `timespan` is not defined, `FETCH` collects a maximum of `count` point.\n+ If `count` is not defined, `FETCH` determines `timespan` with `start`. If `start` is more recent than `end`, `end` and `start` are permuted internally. Be careful, this means `end` is included but  **`start` is excluded from the time window**.\n\n### Boundaries\nSince version 2.3.0, you can define *boundaries* around the requested data. When fetching data based on a time range, both a *pre* and *post* boundaries can be specified. When fetching by count, only a *pre* boundary can be requested.\nBoundaries are a number of datapoints which are either before (*pre* boundary) or after (*post* boundary) the fetched data. Fetching boundaries is very useful when storing only the changes of values as they enable you to always fetch datapoints even if the requested time range does not contain any. They can also be used to fetch the first `N` datapoints after a given timestamp.\nNote that fetching *post* boundaries is less efficient than fetching the requested range or a *pre* boundary as the data has to be scanned in reverse order which has an impact on I/Os and ultimately on performance.\n\n### Sampling options\n+ Since version 2.3.0, you can randomly sample points with the `sample` parameter. If `sample` equals 0.1, `FETCH` will randomly return one point out of ten. This implementation is the fastest way to resample data.\n+ Since version 2.3.0, you can `skip` the N newest datapoints in the time window specified.\n\n### Query without looking into directory\nThe fetch time to read one gts among millions of gts recorded with the same classname, the same application and the same owner can take time. Use the `gts` parameter to select if you exactly know the classname and all the labels.\n\nIf you want to read only Geo Time Series attributes or labels, using [FIND](/doc/FIND) is more efficient than fetching the last value.\n\n@param `token` Read token to use to fetch the data.\n\n@param `class` Selector for the GTS classes. Can either be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `labels` Map of labels selectors. The key is the label name, the value a selector which can be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `start` Oldest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `end` Newest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `data` List of fetched Geo Time Series™.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n@param `metaset` A set of Geo Time Series™ produced by the [`METASET`](/doc/METASET) function.\n\n@param `type` Name of type to force for the GTS, either LONG, DOUBLE, BOOLEAN or STRING.\n\n@param `typeattr` Name of label to use for storing the GTS type. This option is incompatible with 'type', when set values of different types are ventilated in separate GTS with the same set of class and labels and an additional *type* label of the given name.\n\n@param `timespan` Depth to consider when fetching the datapoints. If the value is positive then it is interpreted as a duration in time units, if it is negative then as the maximum number of datapoints to fetch. If negative, incompatible with 'count'.\n\n@param `count` Maximum number of datapoints to fetch for each GTS. Incompatible with negative 'timespan'.\n\n@param `extra` List of extraneous classes to fetch. For each GTS matching the selection criteria, GTS with those extra class names will be fetched too (with the *exact* same set of labels).\n\n@param `active.after` Timestamp after which a GTS must have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `quiet.after` Timestamp after which a GTS must not have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `gts` Explicit list of Geo Time Series™ to fetch. The class and labels will be used as is and not serve as selectors.\n\n@param `boundary` Number of datapoints to include in both *pre* and *post* boundaries.\n\n@param `boundary.pre` Number of datapoints in the *pre* boundary.\n\n@param `boundary.post` Number of datapoints in the *post* boundary.\n\n@param `sampling.ratio` A probability between 0 (excluded, no datapoints returned) and 1.0 (all datapoints returned). The random sampling is done by the storage layer, which is the most efficient.\n\n@param `skip.count` Set fetch to ignore the N newest points in the time window you specified.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCH"},{name:"FETCHBOOLEAN",detail:"FETCHBOOLEAN( linput:LIST ): data:LIST<GTS>\nFETCHBOOLEAN( minput:MAP ): data:LIST<GTS>",documentation:"The `FETCHBOOLEAN` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type BOOLEAN.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHBOOLEAN"},{name:"FETCHDOUBLE",detail:"FETCHDOUBLE( linput:LIST ): data:LIST<GTS>\nFETCHDOUBLE( minput:MAP ): data:LIST<GTS>",documentation:"The `FETCHDOUBLE` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type DOUBLE.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHDOUBLE"},{name:"FETCHLONG",detail:"FETCHLONG( linput:LIST ): data:LIST<GTS>\nFETCHLONG( minput:MAP ): data:LIST<GTS>",documentation:"The `FETCHLONG` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type LONG.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHLONG"},{name:"FETCHSTRING",detail:"FETCHSTRING( linput:LIST ): data:LIST<GTS>\nFETCHSTRING( minput:MAP ): data:LIST<GTS>",documentation:"The `FETCHSTRING` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type STRING.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FETCHSTRING"},{name:"FFT",detail:"FFT( gts:GTS ): result:LIST<GTS>\nFFT( gtsList:LIST<GTS> ): result:LIST<LIST<GTS>>",documentation:"The `FFT` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFT` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe real parts of the `FFT` coefficients, the second the imaginary parts. The scale factor is equal to X/(n * bucketspan) where n is the number\nof elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the number\nof values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFT` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the real parts of the `FFT` coefficients, the second the imaginary parts.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FFT"},{name:"FFTAP",detail:"FFTAP( gts:GTS ): result:LIST<GTS>\nFFTAP( gtsList:LIST<GTS> ): result:LIST<LIST<GTS>>",documentation:"The `FFTAP` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFTAP` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe amplitude of the coefficient at that frequency and the second the associated phase. The scale factor is equal to X/(n * bucketspan) where n is\nthe number of elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the\nnumber of values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFTAP` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the amplitude of the coefficient at that frequency and the second the associated phase.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FFTAP"},{name:"FFTWINDOW",detail:"FFTWINDOW( gts:GTS window:STRING ): windowed:GTS\nFFTWINDOW( lgts:LIST<GTS> window:STRING ): lwindowed:LIST<GTS>",documentation:"The `FFTWINDOW` transforms Geo Time Series™ by applying a [window function](https://en.wikipedia.org/wiki/Window_function) to its values. The function supports the following windows:\n\n| Name | Window |\n| --- | --- |\n| `triangular` | [Triangular](https://en.wikipedia.org/wiki/Window_function#Triangular_window) |\n| `parzen` | [Parzen](https://en.wikipedia.org/wiki/Window_function#Parzen_window) |\n| `welch` | [Welch](https://en.wikipedia.org/wiki/Window_function#Welch_window) |\n| `sine` | [Sine](https://en.wikipedia.org/wiki/Window_function#Sine_window) |\n| `hann` | [Hann](https://en.wikipedia.org/wiki/Window_function#Hann_window) |\n| `hamming` | [Hamming](https://en.wikipedia.org/wiki/Window_function#Hamming_window) |\n| `blackman` | [Blackman](https://en.wikipedia.org/wiki/Window_function#Blackman_window) |\n| `nuttall` | [Nuttall](https://en.wikipedia.org/wiki/Window_function#Nuttall_window,_continuous_first_derivative) | \n| `blackman-nuttall` | [Blackman-Nuttall](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Nuttall_window) |\n| `blackman-harris` | [Blackman-Harris](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Harris_window) |\n| `flattop` | [Flat top](https://en.wikipedia.org/wiki/Window_function#Flat_top_window) |\n| `rectangular` | [Rectangular](https://en.wikipedia.org/wiki/Window_function#Rectangular_window) |\n\n@param `window` Name of the window function to apply.\n\n@param `gts` Single Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `windowed` Tranformed Geo Time Series™.\n\n@param `lwindowed` List of transformed Geo Time Series™.\n\n",tags:["gts"],since:"1.2.13",OPB64name:"FFTWINDOW"},{name:"FILL",detail:"FILL( gtsa:GTS gtsb:GTS filler:FILLER ): gtsa:GTS gtsb:GTS",documentation:"The `FILL` function fills missing values in two Geo Time Series™ so they end up with identical ticks.\n\nThe filling is done using a *filler* function which applies a given strategy. Filler functions can be created using macros via the [`MACROFILLER`](/doc/MACROFILLER) function.\n\n@param `gtsa` First Geo Time Series™ to fill.\n\n@param `gtsb` Second Geo Time Series™ to fill.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"FILL"},{name:"FILLNEXT",detail:"FILLNEXT( gts:GTS ): result:GTS\nFILLNEXT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `FILLNEXT` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation of the \nnext non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLNEXT"},{name:"FILLPREVIOUS",detail:"FILLPREVIOUS( gts:GTS ): result:GTS\nFILLPREVIOUS( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `FILLPREVIOUS` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation \nof the previous non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLPREVIOUS"},{name:"FILLTICKS",detail:"FILLTICKS( gts:GTS data:LIST ): result:GTS\nFILLTICKS( gtsList:LIST<GTS> data:LIST ): resultList:LIST<GTS>",documentation:"The `FILLTICKS` function add values to a Geo Time Series™ instance or a list thereof for ticks in the given **LIST**.\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n@param `data` List of (latitude, longitude, elevation, ticks) where ticks is a list of ticks.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FILLTICKS"},{name:"FILLVALUE",detail:"FILLVALUE( gts:GTS data:LIST ): result:GTS\nFILLVALUE( gtsList:LIST<GTS> data:LIST ): resultList:LIST<GTS>",documentation:"The `FILLVALUE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with a fixed value/location/elevation.\n\nIt expects a GTS or a list thereof on the top of the stack after having consumed a list of parameters (latitude, longitude, elevation, value)\nsitting on top of the stack prior to the call.\n\nLocation must be floating point numbers (e.g. 0.0 not 0). Elevation must be an integer. If no location or elevation should be set, **NaN** can\nbe used instead of specific value.\n\nThis function has no effect on non bucketized GTS instances.\n\n\n\nThe value is cast to the type of the GTS value\n\n@param `gts` The Geo Time Series™ to fill\n\n@param `gtsList` The list of Geo Time Series™ to fill\n\n@param `result` The filled Geo Time Series™\n\n@param `resultList` The list of filled Geo Time Series™\n\n@param `data` The list of parameters (latitude, longitude, elevation, value)\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLVALUE"},{name:"FILTER",detail:"FILTER( [ gtsList:LIST<GTS> labels:LIST<STRING> filter:FILTER ] ): result:LIST<GTS>",documentation:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `FILTER` framework allows for advanced filtering using N-ary functions\n(functions which accept N parameters).\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A single list containing only the selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `FILTER`.\n\n",tags:["framework","filter"],since:"1.0.0",OPB64name:"FILTER"},{name:"FILTERBY",detail:"FILTERBY( list:LIST macro:MACRO ): sublist:LIST",documentation:"The `FILTERBY` function selects elements of a list based on the boolean return value of a macro evaluated for each element.\n\n@param `macro` Macro used for filtering. This macro should consume the element of the list pushed on top of the stack and leave a boolean on the stack. If this boolean is `true`, the element will be retained.\n\n@param `list` List of elements to filter.\n\n@param `sublist` List with the selected elements from `list`.\n\n",tags:["lists"],since:"1.2.22",OPB64name:"FILTERBY"},{name:"FIND",detail:"FIND( [ token:STRING classSelector:STRING labelsSelector:MAP ] ): data:LIST<GTS>\nFIND( [ uuidattribute:BOOLEAN token:STRING classSelector:STRING labelsSelector:MAP ] ): data:LIST<GTS>\nFIND( { token:STRING classSelector:STRING labelsSelector:MAP  } ): data:LIST<GTS>\nFIND( { token:STRING selector:STRING  } ): data:LIST<GTS>\nFIND( { token:STRING selectors:LIST<STRING>  } ): data:LIST<GTS>",documentation:"The `FIND` function finds Geo Time Series™ labels and attributes of GTS, not their values. It is the fastest way to read attributes of GTS. `FIND` ask only `directory` component of Warp&nbsp;10™, while [FETCH](/doc/FETCH) first ask `directory`, then ask `store` to read GTS values. \n\nSyntax is close to [FETCH](/doc/FETCH), without time boundaries or data point count.\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `data` List of fetched Geo Time Series™. These GTS does not contain any value.\n\n@param `uuidattribute` Setting this to true add `.uuid` attribute in the output data. This UUID is a hash of class and label.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FIND"},{name:"FINDSETS",detail:"FINDSETS( [ token:STRING classSelector:STRING labelsSelector:MAP ] ): classes:LIST<STRING> labels:MAP attributes:MAP",documentation:"The `FINDSETS` function returns sets of values for the classes, labels and attributes of the Geo Time Series™ which matched the selection criteria.\n\nThose results can be used for example to update a UI with lists of possible values for labels when exploring a corpus of GTS.\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label names to exact match or regular expression (if the value starts with a *~*) for matching labels and attributes.\n\n@param `attributes` Map of attribute names to value list.\n\n@param `labels` Map of label names to value list.\n\n@param `classes` List of class names.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FINDSETS"},{name:"FINDSTATS",detail:"FINDSTATS( [ token:STRING classSelector:STRING labelsSelector:MAP ] ): result:MAP",documentation:"The `FINDSTATS` function computes statistics on matching Geo Time Series™. The estimations are based on the use of [HyperLogLogPlus](https://en.wikipedia.org/wiki/HyperLogLog) estimators.\n\nThe function returns a map containing information about the matching Geo Time Series. The fields of the map are the following:\n\n| Key | Value |\n|-----|-------|\n| `gts.estimate` | Estimation of the number of matching Geo Time Series™ |\n| `classes.estimate` | Estimation of the number of distinct class names |\n| `labelnames.estimate` | Estimation of the number of distinct label names |\n| `labelvalues.estimate` | Estimation of the number of distinct label values |\n| `per.class.estimate` | If the number of matching classes is below the `directory.stats.class.maxcardinality`, this key will be associated with a map containing per class estimate of number of GTS |\n| `per.label.value.estimate` | If the number of label names in the matching GTS is below `directory.stats.labels.maxcardinality`, this key will be associated with a map containing an estimation of distinct label values per label name |\n| `error.rate` | This is the error rate of the estimators used for computing the estimations |\n| `partial.results` | When accessing a sharded Directory, this will be set to `true` if only partial results were collected |\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `result` Map containing stats such as error rate or whether estimates on classes, gts, or labels.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FINDSTATS"},{name:"FIRSTTICK",detail:"FIRSTTICK( gts:GTS ): result:LONG\nFIRSTTICK( lgts:LIST<GTS> ): result:LONG",documentation:"The `FIRSTTICK` function pushes on the stack the timestamp of the first tick of the Geo Time Series™ on top of the stack.\n\nWhen applied to a list of GTS, `FIRSTTICK` will return the lowest first tick found across all Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™\n\n@param `gts` Geo Time Series™\n\n@param `result` Timestamp. If the GTS does not have values, **Long.MAX_VALUE** is pushed.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FIRSTTICK"},{name:"FLATTEN",detail:"FLATTEN( input:LIST ): output:LIST\nFLATTEN( notAList:ANY ): notAList:ANY",documentation:"The function `FLATTEN` inspects the top of the stack.\n\nIf it is a LIST of values,\nit inspects each value and replaces each value which was a LIST with its content.\n`FLATTEN` proceed recursively until all LISTs have been flattened.\n\nIf it is not a LIST, the function exits and let the stack in the same state.\n\n@param `input` Input is a list who may contains lists\n\n@param `notAList` An object which is not a list\n\n@param `output` Output list do not contains anymore nested lists\n\n",tags:["lists"],since:"1.0.0",OPB64name:"FLATTEN"},{name:"FLOATBITS->",detail:"FLOATBITS->( input:LONG ): result:DOUBLE",documentation:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the 32 lower bits of the **LONG** value as the raw bits of a **FLOAT**.\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",tags:["conversion","binary"],since:"1.2.3",OPB64name:"GZlEFKG1HKGIAIs"},{name:"FLOOR",detail:"FLOOR( value:NUMBER ): result:DOUBLE\nFLOOR( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `FLOOR` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number smaller than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-down value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-down values, for each given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"FLOOR"},{name:"FLOORDIV",detail:"FLOORDIV( dividend:NUMBER divisor:NUMBER ): fDiv:LONG\nFLOORDIV( dividend:NUMBER ldivisor:LIST<NUMBER> ): lfDiv:LIST<LONG>\nFLOORDIV( ldividend:LIST<NUMBER> divisor:NUMBER ): lfDiv:LIST<LONG>",documentation:"The `FLOORDIV` function consumes two NUMBER values, convert them to LONGs and pushes back largest LONG value that is less than or equal to the algebraic quotient.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fDiv` The largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfDiv` List of largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n",tags:["math"],since:"1.2.23",OPB64name:"FLOORDIV"},{name:"FLOORMOD",detail:"FLOORMOD( dividend:NUMBER divisor:NUMBER ): fMod:LONG\nFLOORMOD( dividend:NUMBER ldivisor:LIST<NUMBER> ): lfMod:LIST<LONG>\nFLOORMOD( ldividend:LIST<NUMBER> divisor:NUMBER ): lfMod:LIST<LONG>",documentation:"The `FLOORMOD` function consumes two NUMBER values, convert them to LONGs and pushes back the floor modulus which is x - (floorDiv(x, y) * y).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fMod` The floor modulus x - (floorDiv(x, y) * y)\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfMod` List of floor modulus x - (floorDiv(x, y) * y)\n\n",tags:["math"],since:"1.2.23",OPB64name:"FLOORMOD"},{name:"FOR",detail:"FOR( initial:NUMBER final:NUMBER macro:MACRO ): \nFOR( initial:NUMBER final:NUMBER macro:MACRO index:BOOLEAN ): ",documentation:"The `FOR` function implements a for loop. It takes three arguments from the stack: the initial and the final values of the loop index and a macro to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",tags:["control"],since:"1.0.0",OPB64name:"FOR"},{name:"FOREACH",detail:"FOREACH( list:LIST exec:MACRO ): \nFOREACH( map:MAP exec:MACRO ): \nFOREACH( set:SET exec:MACRO ): \nFOREACH( vector:VLIST exec:MACRO ): \nFOREACH( string:STRING exec:MACRO ): \nFOREACH( gts:GTS exec:MACRO ): \nFOREACH( encoder:GTSENCODER exec:MACRO ): \nFOREACH( list:LIST exec:MACRO index:BOOLEAN ): \nFOREACH( map:MAP exec:MACRO index:BOOLEAN ): \nFOREACH( set:SET exec:MACRO index:BOOLEAN ): \nFOREACH( vector:VLIST exec:MACRO index:BOOLEAN ): \nFOREACH( string:STRING exec:MACRO index:BOOLEAN ): \nFOREACH( gts:GTS exec:MACRO index:BOOLEAN ): \nFOREACH( encoder:GTSENCODER exec:MACRO index:BOOLEAN ): ",documentation:"The `FOREACH` function implements a for loop on a list or map.\n\nFor each iteration i on a list, the i-th element on the list is put on top of the stack, and the exec macro is then called.\n\nFor each iteration i on a map, the exec macro is called with the i-th value on top of the stack, and the i-th key just below on the stack.\nYou can start your macro with `'value' STORE 'key' STORE`.\n\nSince release 2.1, `FOREACH` has the ability to iterate over Geo Time Series™ and GTS Encoders. When iterating over a GTS or Encoder, the macro is fed with a list of the form `[ tick lat lon elev value ]` where `lat`, `lon` and `elev` may be `NaN` if unset. In the case of an Encoder, `value` can be a byte array or a `BigDecimal` on top of `LONG`, `DOUBLE`, `STRING` or `BOOLEAN`.\n\nSince release 2.4.0, you can force FOREACH to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `exec` Macro to apply\n\n@param `list` List to iterate on\n\n@param `map` Map to iterate on\n\n@param `set` Set to iterate on\n\n@param `vector` Vector to iterate on\n\n@param `gts` GTS to iterate on\n\n@param `string` String to iterate on\n\n@param `encoder` GTSEncoder to iterate on\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",tags:["control"],since:"1.0.0",OPB64name:"FOREACH"},{name:"FORGET",detail:"FORGET( symbol:STRING ): ",documentation:"Removes a symbol from the symbol table.      \n\n@param `symbol` Name of the symbol to remove.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"FORGET"},{name:"FORSTEP",detail:"FORSTEP( initial:NUMBER final:NUMBER step:MACRO macro:MACRO ): \nFORSTEP( initial:NUMBER final:NUMBER step:MACRO macro:MACRO index:BOOLEAN ): ",documentation:"The `FORSTEP` function implements for loop with an index step. It takes four arguments from the stack: the initial and the final values of the loop index,\na macro step to evaluate after each iteration and an other one to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `step` Macro step to evaluate after each iteration, typically to compute index\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",tags:["control"],since:"1.0.0",OPB64name:"FORSTEP"},{name:"FROMBIN",detail:"FROMBIN( input:STRING ): output:LONG",documentation:"Converts the binary representation on top of the stack into the corresponding long.\n\n@param `input` Binary representation of a signed long, 64 characters max.\n\n@param `output` Signed long of input.\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBIN"},{name:"FROMBITS",detail:"FROMBITS( input:LONG ): result:DOUBLE",documentation:"**This function is deprecated. Replace it in your code by the [`DOUBLEBITS->`](/doc/G3xKFZl4FZ_JJmoy) function.**\n\nConverts the **LONG** on top of the stack into a **DOUBLE** by considering it a raw bit representation.\n\n@param `input` Raw bit representation to convert\n\n@param `result` Converted value\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBITS"},{name:"FROMHEX",detail:"FROMHEX( input:STRING ): output:LONG",documentation:"Converts an hexadecimal representation into a signed long. 64bits max.\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Signed long\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"FROMHEX"},{name:"FUNCTIONS",detail:"FUNCTIONS(): functions:LIST<STRING>",documentation:"FUNCTIONS returns a list of every functions available in your Warp 10 environnment, including native and extension functions.\n\nIt could be useful when coding your own extension to check your new functions are correctly registered.\n\n\nFUNCTIONS allow anyone to discover new extensions you created on the platform, so it is deactivated by default.\n\nYou must add `warpscript.extension.inventory=io.warp10.script.ext.inventory.InventoryWarpScriptExtension` in your configuration file for this function to be available.\n\n@param `functions` List of Warp 10 functions available on this instance\n\n",tags:["platform","extensions"],since:"1.2.16",OPB64name:"FUNCTIONS"},{name:"FUSE",detail:"FUSE( chunks:LIST<GTS> ): gts:GTS",documentation:"Fuses Geo Time Series™ chunks. The fusion process attempts to keep the bucketization parameters if all chunks are bucketized with compatible `bucketspan` and `lastbucket` values.\n\nAll chunks must be of the same type.\n\nThe fused GTS will have the common class name of the chunks or no class name if some chunks have a different class name. The labels will be those common to all chunks, so when fusing chunks created with [`CHUNK`](/doc/CHUNK), the chunk id will be dropped.\n\n@param `chunks` List of Geo Time Series™ to fuse.\n\n@param `gts` Geo Time Series™ resulting from the fusion of `chunk`.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"FUSE"},{name:"GEO.BUFFER",detail:"GEO.BUFFER( params:MAP ): wkb:BYTES\nGEO.BUFFER( params:MAP ): area:STRING\nGEO.BUFFER( params:MAP ): ",documentation:"The `GEO.BUFFER` function allows to create [*buffer*](https://en.wikipedia.org/wiki/Buffer_(GIS)) **GEOSHAPE** objects. The function takes a `MAP` instance as input. This map can contain the following entries:\n\n| Key | Description |\n|-----|-------------|\n| `dist` | Distance of the buffer, as a central angle expressed in degrees. |\n| `mdist` | Distance of the buffer expressed in meters. This key is only taken into account if `dist` is not specified. |\n| `cap` | The end cap style to consider, use `SQUARE`, `FLAT` or `ROUND` (default). |\n| `join` | The join style to use, use `BEVEL`, `MITRE` or `ROUND` (default). |\n| `limit` | The mitre limit to use. Defaults to 5.0. |\n| `segments` | Number of segments to use per quadrant, defaults to 8. |\n| `singlesided` | Set to `true` to compute a single sided buffer. If `true`, positive distance will indicate left-hand side and negative distance right-hand side. End cap is ignored for single sided buffers. |\n| `wkb` | Byte array containing a [WKB](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary) definition of a geographic area. |\n| `wkt` | String containing a [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) definition of a geographic area. |\n| `geojson` | String containing a [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) definition of a geographic area. |\n\nIf a geographic area is defined, only one of `wkb`, `wkt` or `geojson` may be specified. The output of the function is a new definition of a geographic area with the buffer added to the original definition.\n\nIf no geographic area is defined, `GEO.BUFFER` will define a buffer which will be used by the next call to either [`GEO.WKT`](/doc/GEO.WKT), [`GEO.WKB`](/doc/GEO.WKB) or [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `params` Parameter map containing keys as defined above.\n\n@param `wkb` Area definition with the buffer added, if `params` had a value for key `wkb`.\n\n@param `area` Area definition with the buffer added, in WKT or GeoJSON depending on the presence of key `wkt` or `geojson` in `params`.\n\n",tags:["geo"],since:"2.7.0",OPB64name:"GEO.BUFFER"},{name:"GEO.COVER",detail:"GEO.COVER( gts:GTS resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER( encoder:GTSENCODER resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER( list:LIST resolution:LONG ): geoshapes:LIST<GEOSHAPE>",documentation:"The `GEO.COVER` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* in which the input Geo Time Series™ or GTS Encoder had datapoints.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER"},{name:"GEO.COVER.RL",detail:"GEO.COVER.RL( gts:GTS resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER.RL( encoder:GTSENCODER resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER.RL( list:LIST resolution:LONG ): geoshapes:LIST<GEOSHAPE>",documentation:"The `GEO.COVER.RL` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* which cover the path of an input Geo Time Series™ or GTS Encoder. The path is considered to follow [rhumb lines](https://en.wikipedia.org/wiki/Rhumb_line), hence the function suffix `.RL`.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER.RL"},{name:"GEO.DIFFERENCE",detail:"GEO.DIFFERENCE( shapeA:GEOSHAPE shapeB:GEOSHAPE ): shape:GEOSHAPE",documentation:"The `GEO.DIFFERENCE` function computes the difference between two GEOSHAPE. The resulting GEOSHAPE instance contains cells which cover the part of the first GEOSHAPE which is not in the second. If you need to have cells up to a certain resolution, you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the result.\n\n@param `shapeA` GEOSHAPE instance from which to subtract the second shape.\n\n@param `shapeB` GEOSHAPE to subtract from 'shapeA'.\n\n@param `shape` GEOSHAPE containing 'shapeA' minus 'shapeB'.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.DIFFERENCE"},{name:"GEO.INTERSECTION",detail:"GEO.INTERSECTION( shapeA:GEOSHAPE shapeB:GEOSHAPE ): shape:GEOSHAPE\nGEO.INTERSECTION( shapes:LIST<GEOSHAPE> ): shape:GEOSHAPE",documentation:"The `GEO.INTERSECTION` function computes the intersection of two GEOSHAPE instances. The intersection process will produce a GEOSHAPE whose cells are common to the two initial shapes. The common cells will be of various resolutions, depending on the resolutions of the cells from the initial shapes. If you need the resulting shape to contain cells up to a specific resolution, you can call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) either on the result or on the initial shapes.\n\n@param `shapeA` First GEOSHAPE instance.\n\n@param `shapeB` Second GEOSHAPE instance.\n\n@param `shapes` GEOSHAPE instances.\n\n@param `shape` Geographical area (GEOSHAPE) resulting from the intersection of the given shapes.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.INTERSECTION"},{name:"GEO.INTERSECTS",detail:"GEO.INTERSECTS( gts:GTS shape:GEOSHAPE ): result:BOOLEAN\nGEO.INTERSECTS( lgts:LIST<GTS> shape:GEOSHAPE ): results:LIST<BOOLEAN>\nGEO.INTERSECTS( shapeA:GEOSHAPE shapeB:GEOSHAPE ): result:BOOLEAN",documentation:"The `GEO.INTERSECTS` function checks if a Geo Time Series or each GTS from a list has at least one data point with a position inside a given geographical area. Since `2.7.1`, the function can also check if two `GEOSHAPE` instances intersect.\n\n@param `shapeA` First `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shapeB` Second `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shape` Instance of GEOSHAPE containing the area which the Geo Time Series must intersect.\n\n@param `gts` Single instance of Geo Time Series.\n\n@param `lgts` List of Geo Time Series.\n\n@param `result` Boolean indicating whether or not the Geo Time Series had at least one datapoint in 'shape' or if the two shapes intersect.\n\n@param `results` List of boolean results indicating whether or not each GTS had at least one datapoint in 'shape'.\n\n",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.INTERSECTS"},{name:"GEO.JSON",detail:"GEO.JSON( GeoJSON:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.JSON( GeoJSON:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",documentation:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"1.2.9",OPB64name:"GEO.JSON"},{name:"GEO.JSON.UNIFORM",detail:"GEO.JSON.UNIFORM( GeoJSON:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.JSON.UNIFORM( GeoJSON:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",documentation:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.JSON`](doc/GEO.JSON), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"1.2.13",OPB64name:"GEO.JSON.UNIFORM"},{name:"GEO.NORMALIZE",detail:"GEO.NORMALIZE( shapeA:GEOSHAPE shapeB:GEOSHAPE ): normalizedA:GEOSHAPE normalizedB:GEOSHAPE",documentation:"The `GEO.NORMALIZE` function ensures that the intersection of two **GEOSHAPE**s is present in both as an identical set of cells.\n\n@param `shapeA` The first GEOSHAPE to normalize.\n\n@param `shapeB` The second GEOSHAPE to normalize.\n\n@param `normalizedA` A normalized copy of the first GEOSHAPE.\n\n@param `normalizedB` A normalized copy of the second GEOSHAPE.\n\n",tags:["geo"],since:"2.5.0",OPB64name:"GEO.NORMALIZE"},{name:"GEO.OPTIMIZE",detail:"GEO.OPTIMIZE( shape:GEOSHAPE resolution:LONG ): optimized:GEOSHAPE",documentation:"The `GEO.OPTIMIZE` function optimizes a GEOSHAPE instance by modifying its cells to either limit the finest resolution present in the shape or reduce the number of cells by merging cells which cover a whole cell at the coarser resolution.\n\n@param `shape` GEOSHAPE instance to optimize.\n\n@param `resolution` Finest resolution acceptable (even number from 2 to 32) or 0 to reduce the number of cells.\n\n@param `optimized` Optimized GEOSHAPE instance\n\n",tags:["geo"],since:"1.2.13",OPB64name:"GEO.OPTIMIZE"},{name:"GEO.REGEXP",detail:"GEO.REGEXP( shape:GEOSHAPE ): regexp:STRING",documentation:"The `GEO.REGEXP` function converts a GEOSHAPE into a regular expression to select hexadecimal [HHCode](https://en.wikipedia.org/wiki/HHCode) STRINGs which are included in the GEOSHAPE.\n\n@param `shape` An instance of GEOSHAPE.\n\n@param `regexp` A regular expression for matching HHCodes covered by 'shape'.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"GEO.REGEXP"},{name:"GEO.UNION",detail:"GEO.UNION( shapeA:GEOSHAPE shapeB:GEOSHAPE ): shape:GEOSHAPE\nGEO.UNION( shapes:LIST<GEOSHAPE> ): shape:GEOSHAPE",documentation:"The `GEO.UNION` function computes a GEOSHAPE which is the union of two other shapes. The resulting shape will have cells covering the two original shapes. If you need to have cells up to a certain resolution you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the resulting shape.\n\n@param `shapeA` First GEOSHAPE instance to merge.\n\n@param `shapeB` Second GEOSHAPE instance to merge.\n\n@param `shapes` GEOSHAPE instances to merge.\n\n@param `shape` Resulting GEOSHAPE which is the union of the given shapes.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.UNION"},{name:"GEO.WITHIN",detail:"GEO.WITHIN( gts:GTS shape:GEOSHAPE ): result:BOOLEAN\nGEO.WITHIN( lgts:LIST<GTS> shape:GEOSHAPE ): results:LIST<BOOLEAN>",documentation:"The `GEO.WITHIN` function checks whether a Geo Time Series™ or each GTS from a list have all its datapoints with a location inside a given geographical area.\n\n@param `shape` Instance of GEOSHAPE containing the area inside which the Geo Time Series™ must be contained.\n\n@param `gts` Single instance of Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `result` Boolean indicating whether or not the Geo Time Series™ had all its datapoints with a location inside 'shape'.\n\n@param `results` List of boolean results indicating whether or not each GTS had all its datapoints with a location inside 'shape'.\n\n",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.WITHIN"},{name:"GEO.WKB",detail:"GEO.WKB( WKB:BYTES percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKB( WKB:BYTES resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",documentation:"The `GEO.WKB` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB"},{name:"GEO.WKB.UNIFORM",detail:"GEO.WKB.UNIFORM( WKB:BYTES percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKB.UNIFORM( WKB:BYTES resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",documentation:"The `GEO.WKB.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKB`](doc/GEO.WKB), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geographical area output.\n\n",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB.UNIFORM"},{name:"GEO.WKT",detail:"GEO.WKT( WKT:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKT( WKT:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",documentation:"The `GEO.WKT` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geoshape object.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"GEO.WKT"},{name:"GEO.WKT.UNIFORM",detail:"GEO.WKT.UNIFORM( WKT:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKT.UNIFORM( WKT:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",documentation:"The `GEO.WKT.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKT`](doc/GEO.WKT), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geographical area output.\n\n",tags:["geo"],since:"1.2.11",OPB64name:"GEO.WKT.UNIFORM"},{name:"GEOCELL->",detail:"GEOCELL->( geocell:LONG ): hhPrefix:STRING",documentation:"The `GEOCELL->` function converts a **LONG** geocell to a **STRING** HHCode prefix. The resulting string length is half the resolution of the geocell.\n\nThis function cannot convert to **BYTES** because this representation is limited to resolutions multiple of 4.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `geocell` A geocell.\n\n@param `hhPrefix` A HHCode prefix representing the given cell.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"GoKEFoKBI1oy"},{name:"GEOHASH->",detail:"GEOHASH->( geohash:STRING ): lat:DOUBLE lon:DOUBLE\nGEOHASH->( geohash:STRING toHHCodeString:BOOLEAN ): hhcode:ANY\nGEOHASH->( geohashes:LIST<STRING> ): shape:GEOSHAPE",documentation:"The `GEOHASH->` converts a [Geohash](https://en.wikipedia.org/wiki/Geohash), exposing the latitude and longitude it contains, or transforms a list of Geohashes into a `GEOSHAPE`.\n\n@param `geohash` Geohash to unpack.\n\n@param `geohashes` List of Geohashes defining a geographical area.\n\n@param `lat` Unpacked latitude.\n\n@param `lon` Unpacked longitude.\n\n@param `toHHCodeString` Set to `true` to convert the GeoHash to a HHCode STRING or to `false` to convert it to a LONG HHCode instead of extracting its latitude and longitude.\n\n@param `hhcode` The HHCode for `geohash`, as a LONG or STRING.\n\n@param `shape` Warp 10 `GEOSHAPE` covering the same geographic area as the Geohashes in `geohashes`.\n\n",tags:["geo"],since:"1.0.11",OPB64name:"GoKEH34IH1oy"},{name:"GEOPACK",detail:"GEOPACK( shape:GEOSHAPE ): packed:STRING",documentation:"The `GEOPACK` function takes a **GEOSHAPE** and packs it into a String.\n\n@param `shape` The GEOSHAPE instance to pack.\n\n@param `packed` The packed string representation of the GEOSHAPE.\n\n",tags:["geo"],since:"1.0.7",OPB64name:"GEOPACK"},{name:"GEOSHAPE->",detail:"GEOSHAPE->( geoshape:GEOSHAPE ): geocells:LIST<LONG>\nGEOSHAPE->( geoshape:GEOSHAPE toString:BOOLEAN ): geocellsOrHHPrefixes:LIST<ANY>",documentation:"The `GEOSHAPE->` function converts **GEOSHAPE** to a list of **LONG** geocells or **STRING** HHCode prefixes. Conversion to list of **BYTES** is not supported, because this representation only supports resolution multiple of 4.\n\n@param `geoshape` The geoshape to get the cells from.\n\n@param `toString` Whether to convert the cells to **STRING** HHCode prefix (true) or geocells (false).\n\n@param `geocells` List of geocells.\n\n@param `geocellsOrHHPrefixes` List of **LONG** geocells or **STRING** HHCode prefixes.\n\n",tags:["geo"],since:"2.6.0",OPB64name:"GoKEJoW0J3JhEV"},{name:"GEOSHIFT",detail:"GEOSHIFT( shape:GEOSHAPE lat:DOUBLE lon:DOUBLE precision:LONG ): output:GEOSHAPE\nGEOSHIFT( shape:GEOSHAPE meridian:DOUBLE lat:DOUBLE lon:DOUBLE precision:LONG ): output:GEOSHAPE",documentation:"`GEOSHIFT` functions shifts a geoshape on the earth. It is able to safely overlap the poles or the 180th meridian.\n- Longitude shift keeps distances.\n- Latitude shift keeps angles, not distances.\n- When doing latitude shift, you can specify a meridian to shift along this meridian. It means a positive shift became a negative shift behind this meridian +/- 90°.\n\nSet precision parameter to zero for safe shifting operation. See [`GEO.WKT`](/doc/GEO.WKT) for precision encoding.\n\nUse [`->GEOJSON`](/doc/AIt6GJx9JoxD) to visualize shapes and the results. GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `lon` degrees of longitude to shift (-360 to 360).\n\n@param `lat` degrees of latitude to shift (-180 to 180).\n\n@param `precision` even number from 0 to 30. Set to 0 for automatic resolution. Force to another value if you know the input resolution to be finer and you want a coarser resolution.\n\n@param `shape` The input geoshape.\n\n@param `output` The shifted geoshape.\n\n@param `meridian` When doing latitude shift, you can specify a meridian to shift along this meridian. (-180 to 180)\n\n",tags:["geo"],since:"2.5.0",OPB64name:"GEOSHIFT"},{name:"GEOSPLIT",detail:"GEOSPLIT( shape:GEOSHAPE ): subshapes:LIST<GEOSHAPE>",documentation:"The `GEOSPLIT` function splits a **GEOSHAPE** into a set of **GEOSHAPE**s which have no adjacent cells (each shape is a connected space).\n\nAdjacent cells share part of their side. Adjacency is not provided by corners and cells on each side of the international date line are not considered adjacent either.\n\n@param `shape` The GEOSHAPE instance to split.\n\n@param `subshapes` The shapes whose union form `shape` and which each form a connected space.\n\n",tags:["geo"],since:"2.5.0",OPB64name:"GEOSPLIT"},{name:"GEOUNPACK",detail:"GEOUNPACK( packed:STRING ): shape:GEOSHAPE\nGEOUNPACK( packedbytes:BYTES ): shape:GEOSHAPE",documentation:"The `GEOUNPACK` function unpacks a GEOSHAPE previously packed using [`GEOPACK`](/doc/GEOPACK).\n\n@param `packed` A packed string representation of a GEOSHAPE.\n\n@param `packedbytes` A byte array representation of a GEOSHAPE.\n\n@param `shape` The decoded instance of GEOSHAPE.\n\n",tags:["geo"],since:"1.0.7",OPB64name:"GEOUNPACK"},{name:"GET",detail:"GET( map:MAP key:ANY ): mapvalue:ANY\nGET( list:LIST index:LONG ): value:ANY\nGET( list:LIST index:LIST ): value:ANY\nGET( array:BYTES index:LONG ): bytevalue:LONG",documentation:"Retreive a value in a **MAP** or a **list**.\n\nThe `GET` function consumes on the top of the stack a list, a byte array, or a map, and the index (or the key), \nthen put the result on the stack. \n\nIf key is not found, it returns NULL on the stack.\n\nIf index is out of bound, `GET` raises an error.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, GET can operate recursively on nested lists. In this case, the index is a list.\n\n@param `map` The input MAP.\n\n@param `key` Depending on map construction, could be a number, a string, a list, another map, a GTS, a boolean.\n\n@param `mapvalue` The value for the requested key. If key do not exists in map, returns NULL\n\n@param `index` The index number in the list. Valid values in [-size; size-1]\n\n@param `list` The input LIST.\n\n@param `value` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `array` Byte array from which to read a byte.\n\n@param `bytevalue` The value of the byte, always unsigned (from 0 to 255).\n\n",tags:["lists","maps","binary"],since:"1.0.0",OPB64name:"GET"},{name:"GETEXPONENT",detail:"GETEXPONENT( n:NUMBER ): exponent:LONG",documentation:"The `GETEXPONENT` function consumes a DOUBLE, a LONG casted as a DOUBLE or a COUNTER caster as DOUBLE and pushes back the unbiased exponent used in the representation of this DOUBLE.\n\n@param `n` The decimal value to get the exponent from, will be converted to DOUBLE if not already the case.\n\n@param `exponent` the unbiased exponent of the argument\n\n",tags:["math"],since:"1.2.23",OPB64name:"GETEXPONENT"},{name:"GETHOOK",detail:"GETHOOK( token:STRING hook:STRING ): secure:STRING",documentation:"Extracts the macro associated with a token hook and pushes it onto the stack wrapped as a secure script.\n\nIf the token does not contain the given hook, an empty macro will be wrapped.\n\n@param `hook` Name of the hook to extract from the token.\n\n@param `token` Read token from which to extract the hook.\n\n@param `secure` Hook macro wrapped in a secure script.\n\n",tags:["platform"],since:"1.0.8",OPB64name:"GETHOOK"},{name:"GETSECTION",detail:"GETSECTION(): section:STRING",documentation:"The `GETSECTION` function pushes onto the stack the name of the current section.\n\n@param `section` Name of the current section.\n\n",tags:["stack","debug"],since:"1.2.7",OPB64name:"GETSECTION"},{name:"GOLDWRAP",detail:"GOLDWRAP( encoder:GTSENCODER ): wrapped:BYTES\nGOLDWRAP( gts:GTS ): wrapped:BYTES\nGOLDWRAP( wrap:BYTES ): wrapped:BYTES\nGOLDWRAP( list:LIST<GTS> ): lwrapped:LIST<BYTES>\nGOLDWRAP( list:LIST<GTSENCODER> ): lwrapped:LIST<BYTES>\nGOLDWRAP( list:LIST<BYTES> ): lwrapped:LIST<BYTES>",documentation:"The `GOLDWRAP` function wraps a Geo Time Series™ or a GTS Encoder in a deterministic way, by sorting on timestamps but also on values, locations and elevations.\n\nThis version of a `WRAP` like function is meant to create a *gold standard* blob from its input. In order to ensure reproducibility of the processs, attributes should be dropped prior to calling `GOLDWRAP`.\n\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `wrap` Wrapped Geo Time Series™ instance to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n@param `list` List of Geo Time Series™ or GTS Encoders to wrap.\n\n",tags:["gts"],since:"2.2.0",OPB64name:"GOLDWRAP"},{name:"GROUPBY",detail:"GROUPBY( list:LIST macro:MACRO ): grouped:LIST",documentation:"The `GROUPBY` function groups the elements of a list according to the value returned by a macro.\n\n@param `macro` Macro used for grouping, consumes an element off the stack and produces a value on the stack.\n\n@param `list` List of elements to group.\n\n@param `grouped` List of groups, each group is a list whose first element is the group key and whose second element is the sublist of `list` for which `macro` produced the same value.\n\n",tags:["lists"],since:"1.2.22",OPB64name:"GROUPBY"},{name:"GRUBBSTEST",detail:"GRUBBSTEST( gts:GTS mad:BOOLEAN alpha:DOUBLE ): result:LIST<LONG>\nGRUBBSTEST( gts:GTS mad:BOOLEAN ): result:LIST<LONG>\nGRUBBSTEST( gtsList:LIST<GTS> mad:BOOLEAN alpha:DOUBLE ): resultList:LIST\nGRUBBSTEST( gtsList:LIST<GTS> mad:BOOLEAN ): resultList:LIST<LIST<LONG>>",documentation:"The `GRUBBSTEST` function detects an outlier in a GTS (or a LIST of GTS), by applying a \n[Grubbs’](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm) test.\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nIt tests whether there is exactly a single outlier in a GTS or not. For an iterative version which can detect multiple outliers, use instead\n[`ESDTEST`](/doc/ESDTEST).\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> ### Reference \n> Grubbs, Frank (February 1969). “Procedures for Detecting Outlying Observations in Samples”. Technometrics (Technometrics, Vol. 11, No. 1).\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"GRUBBSTEST"},{name:"GTSHHCODE->",detail:"GTSHHCODE->( hhcode:LONG ): lat:DOUBLE lon:DOUBLE\nGTSHHCODE->( hhcode:STRING ): lat:DOUBLE lon:DOUBLE\nGTSHHCODE->( hhcode:BYTES ): lat:DOUBLE lon:DOUBLE",documentation:"The `GTSHHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude. This function is very similar to [`HHCODE->`](/doc/H3W2IoG4AIs) except that when given the internal value used by Geo Time Series™ for a missing location it pushes back `NaN NaN`.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",tags:["geo"],since:"2.2.0",OPB64name:"GpGIH3W2IoG4AIs"},{name:"GZIP",detail:"GZIP( string:STRING ): compressed:BYTES\nGZIP( bytes:BYTES ): compressed:BYTES",documentation:"The `GZIP` function compresses a STRING or a byte array using the [gzip](https://en.wikipedia.org/wiki/Gzip) algorithm. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",tags:["conversion"],since:"1.0.11",OPB64name:"GZIP"},{name:"HASH",detail:"HASH( str:STRING ): result:LONG\nHASH( bytes:BYTES ): result:LONG",documentation:"Computes a 64 bits hash of the string or byte array on top of the stack.\n\n@param `str` String to hash\n\n@param `bytes` Bytes to hash\n\n@param `result` 64bit hash\n\n",tags:["strings"],since:"1.0.0",OPB64name:"HASH"},{name:"HAVERSINE",detail:"HAVERSINE( p1_latitude:NUMBER p1_longitude:NUMBER p2_latitude:NUMBER p2_longitude:NUMBER ): haversineDistance:DOUBLE",documentation:"The `HAVERSINE` function consumes two coordinates and pushes back a **DOUBLE** [great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance) in meters.\n\n@param `p2_longitude` Point 2 longitude.\n\n@param `p2_latitude` Point 2 latitude.\n\n@param `p1_longitude` Point 1 longitude.\n\n@param `p1_latitude` Point 1 latitude.\n\n@param `haversineDistance` Great circle distance using the haversine fonction.\n\n",tags:["geo"],since:"1.0.0",OPB64name:"HAVERSINE"},{name:"HEADER",detail:"HEADER( name:STRING value:STRING ): ",documentation:"The `HEADER` function allows you to set custom headers which should be returned in the HTTP response. This obviously works only for the `/exec` Warp 10 endpoint.\n\n@param `name` Name of HTTP header to return, MUST start with `X-`, *i.e.* be a custom header.\n\n@param `value` Value to return for the `name` header. If `NULL`, the specified header is removed from the list of headers to return.\n\n",tags:["stack"],since:"1.0.14",OPB64name:"HEADER"},{name:"HEX->",detail:"HEX->( input:STRING ): output:BYTES",documentation:"Converts a hexadecimal string representation into a bytes array.\nBytes array cannot be represented on the stack.\n\n@param `input` A valid hexadecimal string.\n\n@param `output` Bytes Array from input. Seen as null on the stack.\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"H3KNAIs"},{name:"HEXTOB64",detail:"HEXTOB64( input:STRING ): output:STRING",documentation:"Decodes the hex encoded content on top of the stack and \nimmediately re-encode it in base64. This enables you to \nconvert encoded content which would not be valid UTF-8 encoding \nfrom hexadecimal to base64.      \n\n@param `input` A valid hexadecimal string\n\n@param `output` Base64 representation of input\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"HEXTOB64"},{name:"HEXTOBIN",detail:"HEXTOBIN( input:STRING ): output:STRING",documentation:"Converts a string representing a hexadecimal number into a string representing a binary number.\n\nThe `HEXTOBIN` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from hexadecimal to binary.\n\n@param `input` The string representing a hexadecimal number\n\n@param `output` The string representing a binary number\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"HEXTOBIN"},{name:"HHCODE->",detail:"HHCODE->( hhcode:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE->( hhcode:STRING ): lat:DOUBLE lon:DOUBLE\nHHCODE->( hhcode:BYTES ): lat:DOUBLE lon:DOUBLE",documentation:"The `HHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",tags:["geo"],since:"1.0.11",OPB64name:"H3W2IoG4AIs"},{name:"HHCODE.BBOX",detail:"HHCODE.BBOX( hhCode:STRING resolution:LONG ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:LONG resolution:LONG ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:BYTES resolution:LONG ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:STRING ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:BYTES ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE",documentation:"The `HHCODE.BBOX` function returns the bounding box of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the bounding box representing the lat/lon of North-Easth and South-West corners of the bbox.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `latSW` Latitude of the south west corner of the bounding box\n\n@param `lonSW` Longitude of the south west corner of the bounding box\n\n@param `latNE` Latitude of the north east corner of the bounding box\n\n@param `lonNE` Longitude of the north east corner of the bounding box\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.BBOX"},{name:"HHCODE.CENTER",detail:"HHCODE.CENTER( hhCode:STRING resolution:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:LONG resolution:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:BYTES resolution:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:STRING ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:BYTES ): lat:DOUBLE lon:DOUBLE",documentation:"The `HHCODE.CENTER` function returns the center of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the center and returns its lat/lon.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `lat` Latitude of the center of the given HHCode\n\n@param `lon` Longitude of the center of the given HHCode\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.CENTER"},{name:"HHCODE.EAST",detail:"HHCODE.EAST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.EAST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.EAST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.EAST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.EAST( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.EAST` function returns the cell east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.EAST"},{name:"HHCODE.NORTH",detail:"HHCODE.NORTH( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.NORTH( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.NORTH( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.NORTH( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.NORTH( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.NORTH` function returns the cell north of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH"},{name:"HHCODE.NORTH.EAST",detail:"HHCODE.NORTH.EAST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.NORTH.EAST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.NORTH.EAST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.NORTH.EAST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.NORTH.EAST( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.NORTH.EAST` function returns the cell north east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.EAST"},{name:"HHCODE.NORTH.WEST",detail:"HHCODE.NORTH.WEST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.NORTH.WEST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.NORTH.WEST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.NORTH.WEST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.NORTH.WEST( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.NORTH.WEST` function returns the cell north west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.WEST"},{name:"HHCODE.SOUTH",detail:"HHCODE.SOUTH( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.SOUTH( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.SOUTH( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.SOUTH( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.SOUTH( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.SOUTH` function returns the cell south of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH"},{name:"HHCODE.SOUTH.EAST",detail:"HHCODE.SOUTH.EAST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.SOUTH.EAST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.SOUTH.EAST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.SOUTH.EAST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.SOUTH.EAST( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.SOUTH.EAST.EAST` function returns the cell south east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.EAST"},{name:"HHCODE.SOUTH.WEST",detail:"HHCODE.SOUTH.WEST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.SOUTH.WEST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.SOUTH.WEST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.SOUTH.WEST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.SOUTH.WEST( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.SOUTH.WEST` function returns the cell south west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.WEST"},{name:"HHCODE.WEST",detail:"HHCODE.WEST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.WEST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.WEST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.WEST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.WEST( inputHHCode:BYTES ): outputHHCode:BYTES",documentation:"The `HHCODE.WEST` function returns the cell west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.WEST"},{name:"HIDE",detail:"HIDE( levels:LONG ): hidden:LONG",documentation:"The `HIDE` function hides some levels of the stack to the rest of the executing code. This allows a kind of protection for levels which should not be accessed by a macro call for example. Note that this is not a real protection since a call to [`SHOW`](/doc/SHOW) could reveal the hidden levels.\n\nThe hidden levels are always the deepest. Depending on the `levels` parameter to the call to `HIDE`, the hidden levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there remains at most a certain number ((*abs(`levels`)*) with `levels` < 0).\n\nWhen called with `NULL` as parameter, `HIDE` will hide all the visible levels.\n\nThe number of newly hidden levels is returned.\n\n@param `levels` Number of levels to hide or to remain visible, or `NULL` to hide them all.\n\n@param `hidden` Number of levels actually hidden.\n\n",tags:["stack"],since:"2.7.1",OPB64name:"HIDE"},{name:"HLOCATE",detail:"HLOCATE( gts:LIST<GTS> ): result:LIST",documentation:"The `HLOCATE` function locates the HBase regions containing a list of Geo Time Series™.\n\nThis function only works with the distributed version of Warp 10™.\n\nIt outputs a list of lists containing a GTS selector, the host and port of the RegionServer currently serving the region and the region id of a region containing data for this GTS.\n\n@param `gts` List of Geo Time Series™ to locate.\n\n@param `result` List of GTS, RegionServer, region tuples.\n\n",tags:["extensions"],since:"1.2.13",OPB64name:"HLOCATE"},{name:"HULLSHAPE",detail:"HULLSHAPE( list:LIST ): shape:LIST\nHULLSHAPE( { list:LIST  } ): shape:LIST",documentation:"Return the shape of a tensor (or multidimensional array) that would be able to contain all the values of an input nested list. The size of the returned shape is equal to the deepest level of nesting plus one. Its i-th value is equal to the size of the largest list that is nested i levels deep.\n\n@param `list` The input list.\n\n@param `shape` The hull shape of the input list.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"HULLSHAPE"},{name:"HUMANDURATION",detail:"HUMANDURATION( duration:LONG ): humanReadableDuration:STRING",documentation:"The `HUMANDURATION` function consumes a **LONG** duration and push back an easily readable **STRING** representation of this duration.\n\nThe format of the pushed back **STRING** is **[Dd][Hh][Mm]S.XXXXXXs** with D as days, H as hours, M as minutes, S as seconds and XXXXXX the number of ms (3 digits), us (6 digits) or ns (9 digits) depending on the platform configuration. If the duration is less than a day, Dd is omitted, sames goes with Hh and Mm.\n\n@param `duration` Duration expressed in the platform time unit.\n\n@param `humanReadableDuration`  A representation of the duration, easily readable for a human.\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"HUMANDURATION"},{name:"HYBRIDTEST",detail:"HYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG alpha:DOUBLE parameters:MAP ): result:LIST<LONG>\nHYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LONG>\nHYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG ): result:LIST<LONG>\nHYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG parameters:MAP ): result:LIST<LONG>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG alpha:DOUBLE parameters:MAP ): result:LIST<LIST<LONG>>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LIST<LONG>>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG ): result:LIST<LIST<LONG>>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG parameters:MAP ): result:LIST<LIST<LONG>>",documentation:"The `HYBRIDTEST` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\nLike [`STLESDTEST`](/doc/STLESDTEST), `HYBRIDTEST` performs an [`ESDTEST`](/doc/ESDTEST) onto a GTS that have been relieved of its seasonal and trend part. \nBut unlike the mentioned test, [`STL`](/doc/STL) and [`ESDTEST`](/doc/ESDTEST) are performed piecewise. Plus, the trend is approximated with the piecewise \nmedian instead of the trend part of the [`STL`](/doc/STL) decomposition.\n\nA LIST of ticks (or a LIST of LIST of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis technique was first developped at [Twitter](https://blog.twitter.com/2015/introducing-practical-and-robust-anomaly-detection-in-a-time-series).\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ## References\n> - Owen Vallis, Jordan Hochenbaum, Arun Kejariwal. “A Novel Technique for Long-Term Anomaly Detection in the Cloud”, Twitter Inc (2014).\n> - Cleveland, Robert B., et al. “STL: A seasonal-trend decomposition procedure based on loess.” Journal of Official Statistics 6.1 (1990): 3-73.\n> - Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n\n@param `parameters` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `lgts` List of [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST"},{name:"HYBRIDTEST2",detail:"HYBRIDTEST2( gts:GTS period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LONG>\nHYBRIDTEST2( gts:GTS period:LONG piece:LONG k:LONG ): result:LIST<LONG>\nHYBRIDTEST2( gtsList:LIST<GTS> period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LIST<LONG>>\nHYBRIDTEST2( gtsList:LIST<GTS> period:LONG piece:LONG k:LONG ): result:LIST<LIST<LONG>>",documentation:"The `HYBRIDTEST2` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\n`HYBRIDTEST2` is almost the same procedure than [`HYBRIDTEST`](/doc/HYBRIDTEST) except that it does not use [`STL`](/doc/STL) decomposition for the \nseasonal extract.\n\nThe seasonal part is approximated by pondering each value with the [entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29) of the \n[modified Z-score](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm) of its seasonal subseries (series with only the values of the \nsame season).\n\nThis test is usually preferred when it is meaningful to think in term of entropy, for example when the GTS represents counters of events. Also as it \ndoes not use [`STL`](/doc/STL) decomposition, it is not prone to border effects, but at the cost of not detecting slight outliers.\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n@param `gtsList` List of GTS\n\n",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST2"},{name:"HYPOT",detail:"HYPOT( x:NUMBER y:NUMBER ): result:DOUBLE\nHYPOT( x:NUMBER ly:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nHYPOT( lx:LIST<NUMBER> y:NUMBER ): lresult:LIST<DOUBLE>",documentation:"HYPOT function returns the radius r from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta), r = sqrt(x²+y²).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `result` radius r in polar coordinates\n\n@param `lresult` List of radiuses r in polar coordinates\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"HYPOT"},{name:"IDENT",detail:"IDENT(): ident:STRING",documentation:"The `IDENT` function pushes onto the stack the value of the system property `warp.ident`.\n\n@param `ident` The value of the `warp.ident` property.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"IDENT"},{name:"IDWT",detail:"IDWT( gts:GTS wavelet:STRING ): result:GTS",documentation:"The `IDWT` function computes an Inverse [Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Discrete_wavelet_transform) on a Geo Time Series™.\n\nThe names of the available Wavelet are the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\n\n@param `wavelet` Wavelet to consider\n\n@param `gts` Geo Time Series™ which contains the wavelet coefficients as is returned by [`FDWT`](/doc/FDWT).\n\n@param `result` Reconstructed Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"IDWT"},{name:"IEEEREMAINDER",detail:"IEEEREMAINDER( dividend:NUMBER divisor:NUMBER ): result:LONG\nIEEEREMAINDER( dividend:NUMBER ldivisor:LIST<NUMBER> ): lresult:LIST<LONG>\nIEEEREMAINDER( ldividend:LIST<NUMBER> divisor:NUMBER ): lresult:LIST<LONG>",documentation:"The `IEEEREMAINDER` function consumes two parameters, a dividend f1 and a divisor f2. This function push the remainder onto the stack as\nprescribed by the [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_754-1985).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` Dividend, converted as DOUBLE if not already the case.\n\n@param `divisor` Divisor, converted as DOUBLE if not already the case.\n\n@param `result` Remainder\n\n@param `ldividend` List of dividends, converted as DOUBLE if not already the case.\n\n@param `ldivisor` List of divisors, converted as DOUBLE if not already the case.\n\n@param `lresult` List of remainders\n\n",tags:["operators"],since:"1.0.0",OPB64name:"IEEEREMAINDER"},{name:"IFFT",detail:"IFFT( real:GTS im:GTS ): result:GTS",documentation:"The `IFFT` function computes an Inverse [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) of two Geo Time Series™ \nrepresenting real and imaginary parts of FFT coefficients.\n\nThe result is the reconstructed Geo Time Series™. The ticks of this reconstructed GTS are the coefficient indices. They must be multipled by the original \nbucketspan to space the ticks according to the decomposed Geo Time Series™. The bucketspan is equal to `X / (n * factor)` where `X` is the number of time \nunits in a second, `n` is the number of coefficients and `factor` is the scale factor returned by `FFT`.\n\n@param `im` GTS containing the imaginary part\n\n@param `real` GTS containing the real parts of the `FFT` coefficients\n\n@param `result` Reconstructed Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"IFFT"},{name:"IFT",detail:"IFT( if:MACRO then:MACRO ): result:ANY*\nIFT( check:BOOLEAN then:MACRO ): result:ANY*",documentation:"The `IFT` function is a conditional construct which will run a macro only if a boolean condition is true. The condition can either be a boolean on the stack or the result of a macro run.\n\n@param `check` Boolean which will be checked as the conditional test.\n\n@param `if` Macro which will be executed to determine the conditional test. This macro must leave a boolean on the stack.\n\n@param `then` Macro which is executed if the conditional test is `true`.\n\n@param `result` State of the stack after the `then` macro is executed.\n\n",tags:["control"],since:"1.0.0",OPB64name:"IFT"},{name:"IFTE",detail:"IFTE( if:MACRO then:MACRO else:MACRO ): result:ANY*\nIFTE( condition:BOOLEAN then:MACRO else:MACRO ): result:ANY*",documentation:"The `IFTE` function is a conditional construct which evaluates a condition and executes one of two macros depending on the condition (`true` or `false`). The condition can either be a BOOLEAN value on the stack or a macro which will be executed and must leave a BOOLEAN on the stack.\n\n@param `else` Macro executed if the condition is `false`.\n\n@param `then` Macro executed if the condition is `true`.\n\n@param `if` Macro executed to evaluate the condition. Must leave a BOOLEAN on top of the stack.\n\n@param `condition` Boolean value used as the condition.\n\n@param `result` Result of the execution of either the `then` or `else` macro.\n\n",tags:["control"],since:"1.0.0",OPB64name:"IFTE"},{name:"IMMUTABLE",detail:"IMMUTABLE( list:LIST ): immutableList:LIST\nIMMUTABLE( map:MAP ): immutableMap:MAP\nIMMUTABLE( set:SET ): immutableSet:SET\nIMMUTABLE( vector:VLIST ): immutableVector:VLIST",documentation:"Transforms a collection (**LIST**, **MAP**, **VLIST**, **SET**) into an immutable one. Any attempt to modify the immutable collection will fail. The original collection is not modified.\n\n@param `list` List to wrap into an immutable wrapper.\n\n@param `map` Map to wrap into an immutable wrapper.\n\n@param `set` Set to wrap into an immutable wrapper.\n\n@param `vector` Vector to wrap into an immutable wrapper.\n\n@param `immutableList` Immutable version of 'list'.\n\n@param `immutableMap` Immutable version of 'map'.\n\n@param `immutableSet` Immutable version of 'set'.\n\n@param `immutableVector` Immutable version of 'vector'.\n\n",tags:["lists","maps","sets"],since:"1.0.0",OPB64name:"IMMUTABLE"},{name:"IMPORT",detail:"IMPORT( prefix:STRING as:STRING ): ",documentation:"The `IMPORT` function allows to create aliases for macro name prefixes. This is handy when accessing macros from WarpFleet™ repositories which might have multiple versions and/or long group and artifact ids. When fetching a macro, the *imported* prefixes will be scanned and the longest matching one will be replaced by the associated alias.\n\n@param `prefix` Original prefix to *import*.\n\n@param `as` Name under which `prefix` will be imported.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"IMPORT"},{name:"INCREMENTEXACT",detail:"INCREMENTEXACT( value:NUMBER ): result:DOUBLE\nINCREMENTEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `INCREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value incremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be incremented by one\n\n@param `result` The incremented value\n\n@param `lvalue` List of values to be incremented by one\n\n@param `lresult` List of incremented values\n\n",tags:["math"],since:"1.2.23",OPB64name:"INCREMENTEXACT"},{name:"INFLATE",detail:"INFLATE( compressed:BYTES ): uncompressed:BYTES",documentation:"Decompresses a byte array containing data compressed by [`DEFLATE`](doc/DEFLATE).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",tags:["conversion"],since:"2.1.0",OPB64name:"INFLATE"},{name:"INFO",detail:"INFO( { plugin:STRING ext:STRING name:STRING since:STRING deprecated:STRING deleted:STRING version:STRING tags:LIST desc:STRING sig:LIST params:MAP related:LIST examples:LIST conf:LIST  } ): ",documentation:"Generate documentation of a function or a macro.\n\n@param `conf` String list of related configuration keys existing in the Warp 10 configuration.\n\n@param `examples` String list of WarpScript examples.\n\n@param `related` String list of related functions.\n\n@param `params` Map describing the parameters defined in `sig`.\n\n@param `sig` List of signatures. Each signature is a **LIST** with 2 lists (input and output) which contain parameter definitions: *eg* `param1:STRING` in stack order (top first)\n\n@param `desc` Description of the function or macro.\n\n@param `tags` String list tags (*eg* categories).\n\n@param `version` Version of the Warp 10 distribution on which this funcion is available (`standalone` | `distributed` | `all` | `pkg` | `ext` | `plugin`)\n\n@param `deleted` Version's number of Warp 10 where this function (or macro) was deleted.\n\n@param `deprecated` Version's number of Warp 10 where this function (or macro) was deprecated.\n\n@param `since` Version's number of Warp 10 where this function (or macro) was included.\n\n@param `name` Name of the function or macro.\n\n@param `ext` Fully qualified class name of the WarpScript Extension defining the function.\n\n@param `plugin` Fully qualified class name of the WarpScript Plugin defining the function.\n\n",tags:["platform","help"],since:"1.2.14",OPB64name:"INFO"},{name:"INFOMODE",detail:"INFOMODE(): ",documentation:"Toggles the info mode ON or OFF depending on its current state. Default is OFF when the stack is created.\n\nWhen info mode is ON, the [`INFO`](/doc/INFO) function pushes its map parameter on the stack and stops the current execution as [`STOP`](/doc/STOP) would do.\n\n",tags:["platform","help"],since:"1.2.14",OPB64name:"INFOMODE"},{name:"INTEGRATE",detail:"INTEGRATE( gts:GTS initial:NUMBER ): result:GTS\nINTEGRATE( lgts:LIST<GTS> initial:NUMBER ): lresult:LIST<GTS>",documentation:"The `INTEGRATE` function takes a GTS or a list thereof and integrates it/them, considering the value at each tick is a rate of change per second.\n\n@param `initial` Initial value\n\n@param `gts` GTS to integrate\n\n@param `lgts` List of GTS to integrate\n\n@param `result` Integrated GTS\n\n@param `lresult` List of integrated GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"INTEGRATE"},{name:"INTERPOLATE",detail:"INTERPOLATE( gts:GTS ): result:GTS\nINTERPOLATE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `INTERPOLATE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with by interpolating linearly. \n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled bucketized GTS\n\n@param `resultList` list of filled bucketized GTS\n\n",tags:["bucketize"],since:"1.0.0",OPB64name:"INTERPOLATE"},{name:"INTERSECTION",detail:"INTERSECTION( setA:SET setB:SET ): output:SET",documentation:"Computes the intersection &#x2229; of two sets.\n\nThe `INTERSECTION` function consumes two sets from the top of the stack and pushes back its mathematical intersection (ie: the elements in common).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x2229; *B*\n\n",tags:["sets"],since:"1.0.0",OPB64name:"INTERSECTION"},{name:"INV",detail:"INV( matrix:MATRIX ): inverse:MATRIX",documentation:"Inverts a matrix. The inversion is attempted using the [LU Decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.\n\nIf the matrix is singular or not square an error will be raised.\n\n@param `matrix` Matrix to invert.\n\n@param `inverse` Inverse of the original matrix.\n\n",tags:["math"],since:"1.0.6",OPB64name:"INV"},{name:"ISAUTHENTICATED",detail:"ISAUTHENTICATED(): result:BOOLEAN",documentation:"Returns true or false whether or not the stack is authenticated\n\n@param `result` True if the stack is authenticated, false otherwise\n\n",tags:["stack"],since:"1.2.11",OPB64name:"ISAUTHENTICATED"},{name:"ISNULL",detail:"ISNULL( p:ANY ): result:BOOLEAN",documentation:"The `ISNULL` function consumes a parameter p from the top of the stack and pushes onto the stack true if p is null, else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p is null\n\n",tags:["math","logic"],since:"1.0.0",OPB64name:"ISNULL"},{name:"ISNaN",detail:"ISNaN( p:ANY ): result:BOOLEAN",documentation:"The `ISNaN` function consumes a numeric parameter p from the top of the stack and pushes onto the stack true if p is Not a Number (NaN), else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p a Double and is NaN, false  otherwise\n\n",tags:["math"],since:"1.0.0",OPB64name:"ISNaN"},{name:"ISO8601",detail:"ISO8601( timestamp:LONG ): iso8601dateAndTime:STRING\nISO8601( timestamp:LONG timezone:STRING ): iso8601dateAndTime:STRING",documentation:"The `ISO8601` function consumes an optional **STRING** timezone and a **LONG** UTC timestamp and pushes back a **STRING** representing the date and time according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\n\nDepending on the platform time unit, the part representing seconds can have 3, 6 or 9 significant figures respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time representation.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `iso8601dateAndTime` Representation of the date and time of the given timestamp for the givent timezone according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"ISO8601"},{name:"ISODURATION",detail:"ISODURATION( duration:LONG ): iso8601duration:STRING",documentation:"The `ISODURATION` function consumes a **LONG** duration in platform unit and pushes back a **STRING** reresenting an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). Whatever the platform time unit is, the representation maximum resolution is milliseconds.\n\nThe format of the ISO 8601 representation is `PThHmMs.xS` with `h` as hours, `m` as minutes, `s` as seconds and `x` as milliseconds. If any of these value is zero, the value and unit are omitted. The only exception is for a duration of 0 which is represented as `PT0S`. If the duration is negative, `h`, `m` and `s`, if displayed, are negative numbers. \n\n@param `duration` A duration expressed in platform time unit.\n\n@param `iso8601duration` A representation of the consumed duration according to ISO 8601.\n\n",tags:["time"],since:"1.0.0",OPB64name:"ISODURATION"},{name:"ISONORMALIZE",detail:"ISONORMALIZE( gts:GTS ): result:GTS\nISONORMALIZE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `ISONORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between -1 and 1 (i.e. it replaces X by \n(X - mean)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ISONORMALIZE"},{name:"JOIN",detail:"JOIN( string:STRING* sep:STRING n:LONG ): result:STRING\nJOIN( objects:LIST sep:STRING ): result:STRING",documentation:"Join N strings with the given separator.\n\n@param `n` Number of elements to join that it needs to take from the top of the stack.\n\n@param `sep` Separator used to join the strings.\n\n@param `string` One or more string on the stack.\n\n@param `objects` List of objects whose string representations are to be joined.\n\n@param `result` Joined string.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"JOIN"},{name:"JSON->",detail:"JSON->( json:STRING ): resultMap:MAP\nJSON->( json:STRING ): resultList:LIST",documentation:"The `JSON->` function parses a string as [JSON](http://json.org/) from the top of the stack and pushes the result onto the stack.\n\n@param `json` String JSON representation\n\n@param `resultMap` Map JSON representation if it is a JSON object\n\n@param `resultList` List JSON representation if it is a JSON array\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"H_CEIXoy"},{name:"JSONLOOSE",detail:"",documentation:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONLOOSE` function configures the stack to send results in a loose [JSON](http://json.org/) format where `NaN` and `Infinite` are valid values.\n\nIf the [JSON](http://json.org/) parser you’re using is strict, you should either configurate the [`JSONSTRICT`](/doc/JSONSTRICT) mode or dealing with \n`NaN` and `Infinite` values outside the parser.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"JSONLOOSE"},{name:"JSONSTACK",detail:"JSONSTACK(): ",documentation:"Select the JSON format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"JSONSTACK"},{name:"JSONSTRICT",detail:"",documentation:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONSTRICT` function configures the stack to send results in strict [JSON](http://json.org/) format.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"JSONSTRICT"},{name:"KEYLIST",detail:"KEYLIST( map:MAP ): result:LIST",documentation:"Gets keys from a **MAP**.\n\nThe function `KEYLIST` extracts the keys of a map on the top of the stack and pushes on the stack a list with those keys. The map is consumed.      \n\n@param `map` Map from which you want to extract keys\n\n@param `result` List of keys\n\n",tags:["maps"],since:"1.0.0",OPB64name:"KEYLIST"},{name:"KURTOSIS",detail:"KURTOSIS( gts:GTS bessel:BOOLEAN ): kurtosis:DOUBLE\nKURTOSIS( lgts:LIST<GTS> bessel:BOOLEAN ): lkurtosis:LIST<DOUBLE>",documentation:"The `KURTOSIS` function computes the [kurtosis](https://en.wikipedia.org/wiki/Kurtosis) of a Geo Time Series™ or a list thereof.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the kurtosis.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `kurtosis` Computed kurtosis of the Geo Time Series™ instance.\n\n@param `lkurtosis` List of computed kurtosis of the Geo Time Series™ instances.\n\n",tags:["gts","statistics"],since:"1.2.13",OPB64name:"KURTOSIS"},{name:"LABELS",detail:"LABELS( gts:GTS ): return:MAP\nLABELS( encoder:GTSENCODER ): return:MAP",documentation:"The `LABELS` function consumes a GTS from the stack, extracts its labels, puts them in a map and pushes the map onto the stack.\n\n@param `gts` The Geo Time Series™ to get the labels from.\n\n@param `encoder` The Geo Time Series™ Encoder to get the labels from.\n\n@param `return` Labels MAP\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LABELS"},{name:"LASTACTIVITY",detail:"LASTACTIVITY( gts:GTS ): lastactivity:LONG\nLASTACTIVITY( encoder:GTSENCODER ): lastactivity:LONG\nLASTACTIVITY( lgts:LIST<GTS> ): llastactivity:LONG\nLASTACTIVITY( lencoder:LIST<GTSENCODER> ): llastactivity:LONG",documentation:"Extracts the timestamp of last activity recorded in the Geo Time Series™ metadata.\n\nThe timestamp is expressed as platform time units elapsed since the Unix Epoch.\n\n@param `gts` Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `encoder` Geo Time Series™ encoder from which to extract the last activity timestamp.\n\n@param `lgts` List of Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `lencoder` List of Geo Time Series™ encoders from which to extract the last activity timestamp.\n\n@param `lastactivity` Timestamp of last activity.\n\n@param `llastactivity` List of timestamps of last activity.\n\n",tags:["gts"],since:"2.0.0",OPB64name:"LASTACTIVITY"},{name:"LASTBUCKET",detail:"LASTBUCKET( gts:GTS ): result:LONG",documentation:"The function `LASTBUCKET` consumes a GTS off the stack and pushes its lastbucket onto the stack.\n\nNote: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Last bucket timestamp\n\n",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"LASTBUCKET"},{name:"LASTSORT",detail:"LASTSORT( gtsList:LIST<GTS> ): result:LIST<GTS>",documentation:"Sorts a list of Geo Time Series™ according to their most recent value. If most recent values are identical, ticks will be compared, the most recent \nappearing first. If the ticks are also identical, then metadata (class and labels) will be compared.\n\nUse this function to compute Top N queries.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Sorted list of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LASTSORT"},{name:"LASTTICK",detail:"LASTTICK( gts:GTS ): result:LONG\nLASTTICK( lgts:LIST<GTS> ): result:LONG",documentation:"The `LASTTICK` function pushes on the stack the newest tick of the Geo Time Series™ on top of the stack or, if the GTS is bucketized, its last bucket.\n\nWhen applied to a list of GTS, `LASTTICK` will return the greatest last tick found across all Geo Time Series™.\n\nIf the GTS does not have values, `Long.MIN_VALUE` is pushed.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `gts` Geo Time Series™.\n\n@param `result` Last tick value.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LASTTICK"},{name:"LBOUNDS",detail:"LBOUNDS( lower:DOUBLE upper:DOUBLE n:LONG ): bounds:LIST<DOUBLE>",documentation:"The `LBOUNDS` function computes bounds which divide a specified interval into `n` intervals of equal length.\n\nThe result of `LBOUNDS` is a list of `n+1` bounds, defining `n` intervals inside the specified range plus the two bounds of this range which define the intervals before and after the range.\n\n@param `n` Number of intervals to generate.\n\n@param `upper` Upper bound of the range to subdivide.\n\n@param `lower` Lower bound of the range to subdivide.\n\n@param `bounds` List of computed bounds.\n\n",tags:["math"],since:"1.0.0",OPB64name:"LBOUNDS"},{name:"LFLATMAP",detail:"LFLATMAP( inputlist:LIST macro:MACRO ): results:LIST\nLFLATMAP( inputlist:LIST macro:MACRO index:BOOLEAN ): results:LIST",documentation:"The `LFLATMAP` function applies a macro on each element of a list, producing a list \nwith the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the list index on top and the element \nat that particular index below it. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\nDifference with `LMAP`: if the macro returns a list, then LFLATMAP will produce a \nlist with the elements of the macro output list (_i.e._ it will _flatten_ the list). \n\nDifference with `LMAP FLATTEN`: flatten will do the list flattening recursively. \n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count -1) will be on the top of the stack. By default, true.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"LFLATMAP"},{name:"LIMIT",detail:"LIMIT( maxDataPoints:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and \na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `LIMIT` function modifies the maximum number of datapoints which can be fetched during a script execution by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call `AUTHENTICATE` with a valid token.\n\n@param `maxDataPoints` Maximal data points retrieved from database in a single FETCH\n\n",tags:["platform"],since:"1.0.0",OPB64name:"LIMIT"},{name:"LINEOFF",detail:"",documentation:"The `LINEOFF` function disables the automatic labelling of WarpScript code as enabled by `LINEON`.      \n\n",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEOFF"},{name:"LINEON",detail:"",documentation:"The `LINEON` function enables the automatic section labelling at the beginning of each line of the input WarpScript code. This handy feature greatly simplifies the debug process as the exact line number where an error happens will appear in the error message embedded as a section name of the form `[Line #xx]`.\n\nThis automatic labelling only works with the `/exec` endpoint of Warp 10.\n\n",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEON"},{name:"LIST->",detail:"LIST->( input:LIST ): elements:ANY* listlength:LONG",documentation:"The `LIST->` function extracts the elements of the **LIST** at the top of the stack\nand pushes them onto the stack one by one. The function then pushes\nonto the stack the number of elements that were in the **LIST**.\n\n@param `input` The input list, will be consumbed\n\n@param `listlength` The length N of input\n\n@param `elements` N elements pushed on the stack\n\n",tags:["lists","conversion"],since:"1.0.0",OPB64name:"I3_IK1oy"},{name:"LMAP",detail:"LMAP( inputlist:LIST macro:MACRO ): results:LIST\nLMAP( inputlist:LIST macro:MACRO index:BOOLEAN ): results:LIST",documentation:"The `LMAP` function applies a macro on each element of a **LIST**, producing a **LIST** with the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **LIST** index on top and the element at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"LMAP"},{name:"LOAD",detail:"LOAD( name:STRING ): value:ANY\nLOAD( register:LONG ): value:ANY",documentation:"The `LOAD` function pushes onto the stack the value currently associated with a symbol name.      \n\nIf the symbol is not defined, an error will be raised.\n\n@param `name` Name of symbol whose value should be retrieved.\n\n@param `register` Register number whose value should be retrieved.\n\n@param `value` Retrieved value.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"LOAD"},{name:"LOCATIONOFFSET",detail:"LOCATIONOFFSET( gts:GTS distance:NUMBER ): result:GTS\nLOCATIONOFFSET( gtsList:LIST<GTS> distance:NUMBER ): resultList:LIST<GTS>",documentation:"The `LOCATIONOFFSET` function downsamples a Geo Time Series™ by retaining the first and last datapoints and only those datapoints which are \nmore than a given distance away.\n\n@param `distance` Distance in meters\n\n@param `gts` Geo Time Series™ to downsample\n\n@param `gtsList` List of Geo Time Series™ to downsample\n\n@param `result` Downsampled Geo Time Series™\n\n@param `resultList` List of downsampled Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LOCATIONOFFSET"},{name:"LOCATIONS",detail:"LOCATIONS( gts:GTS ): latitudes:LIST<DOUBLE> longitudes:LIST<DOUBLE>",documentation:"The `LOCATIONS` function consumes a Geo Time Series™ from the stack, extracts the locations of a Geo Time Series™, puts them in two lists \n(a list of latitudes and a list of longitudes) and pushes the two lists onto the stack.\n\n@param `gts` GTS\n\n@param `longitudes` List of longitudes\n\n@param `latitudes` List of latitudes\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCATIONS"},{name:"LOCSTRINGS",detail:"LOCSTRINGS( gts:GTS ): result:LIST<STRING>",documentation:"The `LOCSTRINGS` function extract the locations from a Geo Time Series™ and builds a list of the 64 bits hexadecimal representation of their \n[HHCode](https://en.wikipedia.org/wiki/HHCode).\n\n@param `gts` Geo Time Series™\n\n@param `result` List of [HHCode](https://en.wikipedia.org/wiki/HHCode)\n\n",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCSTRINGS"},{name:"LOG",detail:"LOG( value:NUMBER ): result:DOUBLE\nLOG( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `LOG` function consumes a floating point number x from the top of the stack and pushes back its natural logarithm, log<sub>e</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Natural logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of natural logarithms of the given values\n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG"},{name:"LOG10",detail:"LOG10( value:NUMBER ): result:DOUBLE\nLOG10( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `LOG10` function consumes a floating point number x from the top of the stack and pushes back its common logarithm, log<sub>10</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Common logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of common logarithms of the given values\n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG10"},{name:"LOG1P",detail:"LOG1P( value:NUMBER ): result:DOUBLE\nLOG1P( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"Returns the natural logarithm of the sum of the argument and 1.\n\nThe `LOG1P` function consumes a number from the top of the stack and pushes back the natural logarithm for (arg + 1).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Logarithm of (value + 1)\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of logarithm of (value + 1)\n\n",tags:["math"],since:"1.0.0",OPB64name:"LOG1P"},{name:"LOGEVENT->",detail:"LOGEVENT->( logline:STRING ): decodedlog:STRING",documentation:"Warp&nbsp;10™ runner execution logs are encrypted. See [this documentation](/content/03_Documentation/06_Operations/05_Logs/).\n\nThe easiest way to read logs is to copy the log output and use this function.\n\n\n@param `logline` The opb64 representation of the aes encrypted log line\n\n@param `decodedlog` The decoded logs.\n\n",tags:["debug"],since:"1.2.7",OPB64name:"I3x6GKO4I_FhEV"},{name:"LOGMSG",detail:"LOGMSG( msg:STRING ): ",documentation:"`LOGMSG` function prints millisecond timestamp and input text on the standard output.\n\nThe `LOGMSG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"LOGMSG"},{name:"LOWESS",detail:"LOWESS( gts:GTS bandwidth:LONG ): result:GTS\nLOWESS( gtsList:LIST<GTS> bandwidth:LONG ): lresult:LIST<GTS>",documentation:"The `LOWESS` function consumes a bandwidth (a **LONG**) from the top of the stack, then smooths a GTS or a **LIST** of GTS that are below by using \nlocal regression.\n\nTo obtain a good smoothing, it is advised to choose an odd number of at least 5 as the bandwidth parameter.\n\n@param `bandwidth` The bandwitdth parameter is the number of nearest neighbours to consider when applying the local regression.\n\n@param `gts` Geo Time Series™.\n\n@param `gtsList` List of Geo Time Series™.\n\n@param `lresult` List of Geo Time Series™ result.\n\n@param `result` Geo Time Series™ result.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"LOWESS"},{name:"LR",detail:"LR( gts:GTS ): alpha:DOUBLE beta:DOUBLE",documentation:"Compute the [simple linear regression](https://en.wikipedia.org/wiki/Linear_regression) parameters `alpha` (y-intercept) and `beta` (line slope) for the given numerical Geo Time Series™.\n\n@param `gts` Geo Time Series™ on which to compute linear regression.\n\n@param `beta` The slope of the line fitted on the GTS values.\n\n@param `alpha` The y-intercept of the lined fitted on the GTS values.\n\n",tags:["gts","statistics"],since:"1.0.13",OPB64name:"LR"},{name:"LSORT",detail:"LSORT( inputlist:LIST ): sortedlist:LIST",documentation:"The `LSORT` function sorts the list on the top of the stack.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `inputlist` The reference of the list to sort\n\n@param `sortedlist` The original list sorted, this is not a new list object\n\n",tags:["lists"],since:"1.0.0",OPB64name:"LSORT"},{name:"LTTB",detail:"LTTB( gts:GTS samples:LONG ): downsampled:GTS\nLTTB( lgts:LIST<GTS> samples:LONG ): ldownsampled:LIST<GTS>",documentation:"The `LTTB` function downsamples a Geo Time Series™ or list thereof using the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",tags:["gts"],since:"1.0.11",OPB64name:"LTTB"},{name:"MACROBUCKETIZER",detail:"MACROBUCKETIZER( macro:MACRO ): result:AGGREGATOR",documentation:"`MACROBUCKETIZER` converts a macro into a bucketizer which can be used with the [`BUCKETIZE`](/doc/BUCKETIZE) framework.\n\nFor each tick in the mapped GTS, the macro will be called with a list containing the following elements on the stack:\n\n```js\n[tick_of_computation,[gts_classes],[label_bucketize],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n@param `macro` Macro used as a bucketizer\n\n@param `result` Bucketizer to apply\n\n",tags:["bucketize","bucketizer"],since:"1.0.0",OPB64name:"MACROBUCKETIZER"},{name:"MACROCONFIG",detail:"MACROCONFIG( key:STRING ): ",documentation:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration keys looked up are those built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIG`.\n\n`MACROCONFIG` will check if the keys exists, if not it will remove the part of the macro name after the last `/` and will try that new key. It will successively try all names up to the last part of the macro name.\n\nIf none of those keys existed, the call will end in error.\n\nSo for example, if `MACROCONFIG` is called from a macro `my/test/macro` to retrieve the value associated with `mykey`, it will look up the following keys in the configuration:\n\n```\nmykey@my/test/macro\nmykey@my/test\nmykey@my\n```\n\n@param `key` Configuration key to look up.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIG"},{name:"MACROCONFIGDEFAULT",detail:"MACROCONFIGDEFAULT( key:STRING default:STRING ): ",documentation:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration key looked is built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIGDEFAULT`.\n\n`MACROCONFIGDEFAULT` will check if the keys exists, if not it will push the provided default value onto the stack, or fail with an error if the default was `NULL`. If the key is found, the associated value is pushed on the stack.\n\n@param `key` Configuration key to look up.\n\n@param `default` Default value to use if the key was not found, or `NULL` to fail if the key is absent.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGDEFAULT"},{name:"MACROCONFIGSECRET",detail:"MACROCONFIGSECRET( oldSecret:STRING newSecret:STRING ): ",documentation:"The `MACROCONFIGSECRET` macro consumes 2 elements on the stack, the current and new secret to be set. If no secret has been set, the function will throw an error.\n\nThe secret set by this function is the secret used by [`SETMACROCONFIG`](/doc/SETMACROCONFIG).\n\n@param `newSecret` New secret to override the current one.\n\n@param `oldSecret` Currently set secret.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGSECRET"},{name:"MACROFILLER",detail:"MACROFILLER( macro:MACRO prewindow:LONG postwindow:LONG ): filler:FILLER",documentation:"`MACROFILLER` converts a macro into a *filler* which can be used with the [`FILL`](/doc/FILL) function.\n\nThe macro will find the following elements on the stack when it is called:\n\n```\n6: Geo Time Series™ to fill. Both this GTS and the one above are only meant to expose the metadata\n5: Geo Time Series™ of the *other* GTS with a value at the current tick\n4: list of [ tick latitude longitude elevation value ] for the pre window\n3: [ tick latitude longitude elevation value ] of the *other* Geo Time Series™\n2: list of [ tick latitude longitude elevation value ] for the post window\nTOP: tick which is being filled\n```\n\nIt must leave on the stack a list containing the following elements, in this order:\n\n*tick*, *latitude* or `NaN`, *longitude* or `NaN`, *elevation* or `NaN`, *value*\n\n\n@param `macro` Macro to wrap.\n\n@param `prewindow` Number of datapoints needed ahead of the missing datapoint.\n\n@param `postwindow` Number of datapoints needed after the missing datapoint.\n\n@param `filler` Filler instance.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"MACROFILLER"},{name:"MACROFILTER",detail:"MACROFILTER( macro:MACRO ): result:FILTER",documentation:"`MACROFILTER` converts a macro into a filter which can be used with the [`FILTER`](/doc/FILTER) framework\n\nFor each equivalence classes in the filter set of Geo Time Series™, the macro will be called with the following elements on the stack:\n\n```\n[gts], {labels_equivalence_class}\n```\n\nAfter each call the macro is expected to leave a list on the stack.\n\n@param `macro` Macro to apply\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"MACROFILTER"},{name:"MACROMAPPER",detail:"MACROMAPPER( macro:MACRO ): result:AGGREGATOR",documentation:"`MACROMAPPER` converts a macro into a mapper which can be used with the [`MAP`](/doc/MAP) framework.\n\nFor each tick in the mapped Geo Time Series™, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROMAPPER` can also create a multivariate mapper, that is, a mapper that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate mapper with MAP, each input GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n\n@param `macro` Macro to convert\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"MACROMAPPER"},{name:"MACROREDUCER",detail:"MACROREDUCER( macro:MACRO ): result:AGGREGATOR",documentation:"`MACROREDUCER` converts a macro into a reducer which can be used with the [`REDUCE`](/doc/REDUCE) framework\n\nFor each tick in the Geo Time Series™ to reduce, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nEach list have a length of the number of GTSs in the partition. Each missing value are replaced by `null`, each missing tick by the minimum value of long and each missing latitude, longitude or elevation by NaN. The `label_maps` list as one more element at the end compared to the other lists: the common labels for the GTSs of the partition.\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROREDUCER` can also create a multivariate reducer, that is, a reducer that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate reducer with REDUCE, each input List of GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n@param `macro` Macro to apply\n\n@param `result` Reducer to apply\n\n",tags:["reducer"],since:"1.0.0",OPB64name:"MACROREDUCER"},{name:"MACROTTL",detail:"MACROTTL( ttl:LONG ): ",documentation:"In a file defining a server side macro, the `MACROTTL` function defines the time to live of the macro code. If the macro is accessed after this delay has expired and ondemand loading of macros is enabled, it will unconditionnaly be reloaded from disk.\n\nThis feature is very useful when you have macros generated dynamically on the server side which change frequently. Using `MACROTTL` you can ensure the newest code is loaded regardless of the rescan interval of the macro directory.\n\nIn a the file defining a server side macro, the call to `MACROTTL` should appear before or after the actual macro definition but not within.\n\nThe time after which the macro will no longer be valid is the time of the call to `MACROTTL` plus its parameter.\n\n@param `ttl` The time to live to apply to the macro, in ms.\n\n",tags:["platform"],since:"1.2.13",OPB64name:"MACROTTL"},{name:"MAKEGTS",detail:"MAKEGTS( timestamps:LIST latitudes:LIST longitudes:LIST elevations:LIST values:LIST ): result:GTS",documentation:"The `MAKEGTS` function builds a Geo Time Series™ from **LIST**s.\n\nThe timestamp and values lists must be of the exact same size.\nHowever, as latitudes, longitudes and elevations are optional in a Geo Time Series™, these lists can be shorter than the timestamps lists or even empty. If there are missing latitudes, longitudes and elevations, use [`NaN`](/doc/NaN).\n\n@param `values` Values of the GTS\n\n@param `elevations` Elevations of the GTS\n\n@param `longitudes` Longitudes of the GTS\n\n@param `latitudes` Latitudes of the GTS\n\n@param `timestamps` Timestamps of the GTS\n\n@param `result` Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MAKEGTS"},{name:"MAN",detail:"MAN( function:STRING ): url:STRING\nMAN( any:ANY ): url:STRING\nMAN(): url:STRING",documentation:"The `MAN` function returns the help link for a function name.\n\nIf the function does not exists, it returns http://www.warp10.io/\n\n\n@param `function` The function name\n\n@param `any` Anything except a function name\n\n@param `url` URL of the online help\n\n",tags:["misc","help"],since:"1.2.18",OPB64name:"MAN"},{name:"MAP",detail:"MAP( [ gts:GTS+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG ] ): result:LIST<GTS>\nMAP( [ gtsList:LIST<GTS>+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG ] ): result:LIST<GTS>\nMAP( [ gts:GTS+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG ] ): result:LIST<GTS>\nMAP( [ gtsList:LIST<GTS>+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG ] ): result:LIST<GTS>\nMAP( [ gts:GTS+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN ] ): result:LIST<GTS>\nMAP( [ gtsList:LIST<GTS>+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN ] ): result:LIST<GTS>\nMAP( gts:GTS+ { mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN outputTicks:LIST<LONG>  } ): result:LIST<GTS>\nMAP( gtsList:LIST<GTS>+ { mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN outputTicks:LIST<LONG>  } ): result:LIST<GTS>",documentation:"The `MAP` framework applies a function on values of a Geo Time Series™ that fall into a sliding window.\n\nThe `MAP` framework is designed to use an existing MAPPER or a custom MACROMAPPER. It could also accept a macro: the current window is passed as a GTS to the macro. See examples below.\n\n@param `result` List of Geo Time Series™, one for each input, whose values are the results of the function application on each sliding window. If the input series is bucketized, the result series will be too unless outputTicks is non null.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `mapper` Mapper function to apply\n\n@param `pre` Width of the sliding window before the current tick. This parameter is interpreted as a number of ticks if its value is positive, and as a number of time units if its value is negative. A value of 0 means the sliding window does not cover the past. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the past. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `post` Width of the sliding window after the current tick. Values have the same semantics as for the `pre` parameter. A value of 0 means the sliding window does not cover the future. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the future. Defaults to 0.\n\n@param `occurrences` Limit the number of computations to that number. If the value is 0, compute a value for each tick of the input Geo Time Series™. If it is non-negative, compute that many values starting from the oldest to the most recent tick. In the other case, do that many computations in the reverse order. This is useful when you are interested in a single result, like the max or sum of all values. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `step` The step size in number of ticks. The mapper beggins at the oldest tick and goes to the tick `step` after the current one and so on. Defaults to 1.\n\n@param `overrideTick` If set to true, the tick value returned by the mapper is used to update the current tick, else it is ignored and the original tick is kept. Defaults to false.\n\n@param `outputTicks` If non null, it sets the list of ticks that is traversed to anchor the sliding windows (instead of the ticks of the input Geo Time Series™). In that case, a tick of the input Geo Time Series™ that would be equal to one of these anchor points is counted by a positive `post` if `occurences` is non-negative, or by a positive `pre` if `occurences` is negative.\n\n",tags:["mapper","framework"],since:"1.0.0",OPB64name:"MAP"},{name:"MAP->",detail:"MAP->( map:MAP ): key:ANY* value:ANY* mapsize:LONG",documentation:"The `MAP->` function expands the **MAP** on top of the stack into pairs of elements followed by the number of elements extracted. If the **MAP** was \ncreated by a call to `->MAP`, the order of the elements will be the same as prior to calling `->MAP`.\n\n@param `map` Map to expand\n\n@param `key` Key of the pair\n\n@param `value` Value of the pair\n\n@param `mapsize` The number of key value pushed on the stack.\n\n",tags:["maps","conversion"],since:"1.0.0",OPB64name:"IJ4FAIs"},{name:"MAPID",detail:"MAPID( input:MAP ): result:STRING",documentation:"Generates a fingerprint of a map.\n\n@param `input` Input map\n\n@param `result` Fingerprint of the map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"MAPID"},{name:"MARK",detail:"MARK(): mark:MARK",documentation:"Pushes a mark onto the stack.\n\n@param `mark` A MARK instance.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"MARK"},{name:"MAT->",detail:"MAT->( input:MATRIX ): [  result:LIST<LIST<DOUBLE>>  ]",documentation:"The `MAT->` function converts a Matrix into nested lists.\n\n\n@param `input` Matrix to convert\n\n@param `result` Nested list of values\n\n",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"IJ4JAIs"},{name:"MATCH",detail:"MATCH( string:STRING regexp:STRING ): result:LIST<STRING>\nMATCH( string:STRING regexp:MATCHER ): result:LIST<STRING>",documentation:"The `MATCH` function applies a regular expression (regexp) to a string.\n\nIt consumes two parameters from the top of the stack: the regexp pattern and the string to test matching with.\n\nIf the string doesn’t match the regexp, the function return an empty list. If it matches, the function will return a list of every matching group.\n\nInstead of using a regular expression **STRING**, you can also use the result of [`MATCHER`](/doc/MATCHER) for improved performance.\n\n@param `regexp` Regular expression to apply\n\n@param `string` String to evaluate\n\n@param `result` List of every matching group.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"MATCH"},{name:"MATCHER",detail:"MATCHER( regexp:STRING ): result:MATCHER",documentation:"The `MATCHER` function will compile a regular expression into an efficient object which can be used by [`MATCH`](/doc/MATCH).\n\n@param `regexp` Regular expression to compile\n\n@param `result` Compiled regula expression\n\n",tags:["strings"],since:"1.0.0",OPB64name:"MATCHER"},{name:"MAX",detail:"MAX( p1:LONG p2:LONG ): result:LONG\nMAX( p1:LONG p2:DOUBLE ): result:DOUBLE\nMAX( p1:DOUBLE p2:LONG ): result:DOUBLE\nMAX( p1:DOUBLE p2:DOUBLE ): result:DOUBLE\nMAX( p1:COUNTER p2:COUNTER ): result:LONG\nMAX( p1:COUNTER p2:DOUBLE ): result:DOUBLE\nMAX( p1:DOUBLE p2:COUNTER ): result:DOUBLE\nMAX( p1:COUNTER p2:LONG ): result:DOUBLE\nMAX( p1:LONG p2:COUNTER ): result:DOUBLE\nMAX( llist:LIST<LONG> ): sresult:LONG\nMAX( dlist:LIST<DOUBLE> ): sresult:DOUBLE\nMAX( clist:LIST<COUNTER> ): sresult:LONG\nMAX( llist:LIST<LONG> value:LONG ): lresult:LIST<LONG>\nMAX( clist:LIST<COUNTER> value:COUNTER ): lresult:LIST<LONG>\nMAX( dlist:LIST<DOUBLE> value:DOUBLE ): lresult:LIST<DOUBLE>",documentation:"Returns the greater of two numeric values.\n\nThe `MAX` function consumes two numeric parameters from the top of the stack and pushes back the greatest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The larger of p1 and p2.\n\n@param `sresult` The larger of the elements in the given list.\n\n@param `lresult` A list where each value is the max between the element in the list and the given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"MAX"},{name:"MAXBUCKETS",detail:"MAXBUCKETS( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXBUCKETS` function modifies the maximum number of buckets which can be created by a call to [`BUCKETIZE`](/doc/BUCKETIZE) by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform","bucketize"],since:"1.0.0",OPB64name:"MAXBUCKETS"},{name:"MAXDEPTH",detail:"MAXDEPTH( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXDEPTH` function modifies the maximum depth (number of levels) of the execution stack by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform","stack"],since:"1.0.0",OPB64name:"MAXDEPTH"},{name:"MAXGEOCELLS",detail:"MAXGEOCELLS( maxcells:LONG ): ",documentation:"Modifies the maximum number of cells a **GEOSHAPE** created by [`GEO.WKT`](/doc/GEO.WKT) or [`GEO.JSON`](/doc/GEO.JSON) can have. The limit can be modified up to the configured value for `warpscript.maxgeocells.hard`.\n\n@param `maxcells` New limit to set.\n\n",tags:["platform"],since:"1.2.11",OPB64name:"MAXGEOCELLS"},{name:"MAXGTS",detail:"MAXGTS( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard limit \nwhich can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXGTS` function modifies the maximum number of Geo Time Series™ which can be fetched by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform","gts"],since:"1.0.0",OPB64name:"MAXGTS"},{name:"MAXJSON",detail:"MAXJSON( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to\nthe hard limit value.\n\nThe `MAXJSON` function modifies the maximum number of characters in a json produced by [`->JSON`](/doc/AIt9JoxD).\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"2.5.0",OPB64name:"MAXJSON"},{name:"MAXLONG",detail:"MAXLONG(): result:LONG",documentation:"Pushes [Long.MAX_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MAX_VALUE) onto the stack.\n\n@param `result` Long.MAX_LONG\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"MAXLONG"},{name:"MAXLOOP",detail:"MAXLOOP( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard\nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe MAXLOOP function modifies the maximum number of milliseconds which can be spent in a loop setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXLOOP"},{name:"MAXOPS",detail:"MAXOPS( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXOPS` function modifies the maximum number of operations which can be performed during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXOPS"},{name:"MAXPIXELS",detail:"MAXPIXELS( pixels:LONG ): ",documentation:"Modifies the maximum size (in pixels) of images which can be created by [`PGraphics`](/doc/PGraphics). The limit can be modified up to the value configured in `warpscript.maxpixels.hard`.\n\n@param `pixels` Maximum size (in pixels).\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXPIXELS"},{name:"MAXRECURSION",detail:"MAXRECURSION( depth:LONG ): ",documentation:"Modifies the maximum nesting depth of macro calls. The limit can be modified up to the value configured in `warpscript.maxrecursion.hard`.\n\n@param `depth` Maximum nesting depth.\n\n",tags:["platform"],since:"1.2.13",OPB64name:"MAXRECURSION"},{name:"MAXSYMBOLS",detail:"MAXSYMBOLS( limit:LONG ): ",documentation:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a \nhard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXSYMBOLS` function modifies the maximum number of simultaneous symbols which can be defined on the stack during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",tags:["platform"],since:"1.0.0",OPB64name:"MAXSYMBOLS"},{name:"MAXURLFETCHCOUNT",detail:"MAXURLFETCHCOUNT( limit:LONG ): ",documentation:"The `MAXURLFETCHCOUNT` function modifies the maximum number of URLs which can be fetched with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.MAXURLFETCHCOUNT.limit.hard`.\n\n@param `limit` The maximum number of URLs which can be fetched.\n\n",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHCOUNT"},{name:"MAXURLFETCHSIZE",detail:"MAXURLFETCHSIZE( limit:LONG ): ",documentation:"The `MAXURLFETCHSIZE` function modifies the maximum cumulative size of fetched payloads with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.urlfetch.maxsize.hard` and is expressed as a number of bytes.\n\n@param `limit` The maximum cumulative size of fetched payloads.\n\n",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHSIZE"},{name:"MD5",detail:"MD5( input:BYTES ): result:BYTES",documentation:"The `MD5` function digests a byte array on the stack with the cryptographic hash function [`MD5`](https://en.wikipedia.org/wiki/MD5).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"MD5"},{name:"MERGE",detail:"MERGE( gtsList:LIST<GTS> ): result:GTS",documentation:"Merge several Geo Time Series™ together.\n\nThe `MERGE` function expects a **LIST** of Geo Time Series™ on the top of the stack. It will consume these GTS and push onto the stack a single GTS instance\nwith all measurements found in the GTS instances present in the **LIST**. The name and labels of the resulting GTS instance are those of the first one of the\n**LIST**.\n\n`MERGE` do not override values on the same timestamp, they are appenned.\n\n@param `gtsList` The list of Geo Time Series™\n\n@param `result` The merged Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MERGE"},{name:"META",detail:"META( gtsList:LIST<GTS> writeToken:STRING ): ",documentation:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `META` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",tags:["gts"],since:"1.0.0",OPB64name:"META"},{name:"METADIFF",detail:"METADIFF( gtsList:LIST<GTS> writeToken:STRING ): ",documentation:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend in an incremental manner. New attributes are added and already existing attributes are updated or removed if their value is an empty string.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `METADIFF` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",tags:["gts"],since:"2.3.0",OPB64name:"METADIFF"},{name:"METAOFF",detail:"METAOFF( message:STRING secret:STRING ): ",documentation:"Disables meta operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a meta operation is attempted.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"METAOFF"},{name:"METAON",detail:"METAON( secret:STRING ): ",documentation:"Enables meta operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"METAON"},{name:"METASET",detail:"METASET( [ token:STRING class:STRING labels:MAP notbefore:LONG notafter:LONG maxduration:LONG ttl:LONG ] ): metaset:STRING",documentation:"Performs a [`FIND`](/doc/FIND), retrieving a list of Geo Time Series™ and builds a *metaset* which can be distributed to allow access to those GTS without having to give away credentials.\n\nMetaset support is only available if a key has been set for `warp.aes.metasets`.\n\n@param `ttl` Time to live of the produces metaset. It will not be usable after that much time has elapsed since the current time. The ttl is specified in time units.\n\n@param `maxduration` The maximum span of data which can be retrieved using this metaset, in time units.\n\n@param `notafter` Most recent timestamp of the data this metaset can retrieve.\n\n@param `notbefore` Most ancient timestamp of the data this meataset can retrieve.\n\n@param `labels` Map of label selectors.\n\n@param `class` Geo Time Series™ class selector.\n\n@param `token` Read token to use for retrieving the GTS.\n\n@param `metaset` Encrypted metaset which can be used with a [`FETCH`](/doc/FETCH).\n\n",tags:["gts"],since:"1.2.5",OPB64name:"METASET"},{name:"METASORT",detail:"METASORT( gts:LIST<GTS> elements:LIST ): sorted:LIST<GTS>",documentation:"Sorts a list of Geo Time Series™ according to elements of their metadata. The list of elements to consider for sorting can contain label names or NULL to consider the classname. Elements will be considered in the order in which they appear in the list.\n\n@param `gts` List of Geo Time Series™ to sort.\n\n@param `elements` Metadata elements to consider for sorting.\n\n@param `sorted` Sorted list of GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"METASORT"},{name:"MIN",detail:"MIN( p1:LONG p2:LONG ): result:LONG\nMIN( p1:LONG p2:DOUBLE ): result:DOUBLE\nMIN( p1:DOUBLE p2:LONG ): result:DOUBLE\nMIN( p1:DOUBLE p2:DOUBLE ): result:DOUBLE\nMIN( p1:COUNTER p2:COUNTER ): result:LONG\nMIN( p1:COUNTER p2:DOUBLE ): result:DOUBLE\nMIN( p1:DOUBLE p2:COUNTER ): result:DOUBLE\nMIN( p1:COUNTER p2:LONG ): result:DOUBLE\nMIN( p1:LONG p2:COUNTER ): result:DOUBLE\nMIN( llist:LIST<LONG> ): sresult:LONG\nMIN( dlist:LIST<DOUBLE> ): sresult:DOUBLE\nMIN( clist:LIST<COUNTER> ): sresult:LONG\nMIN( llist:LIST<LONG> value:LONG ): lresult:LIST<LONG>\nMIN( clist:LIST<COUNTER> value:COUNTER ): lresult:LIST<LONG>\nMIN( dlist:LIST<DOUBLE> value:DOUBLE ): lresult:LIST<DOUBLE>",documentation:"Returns the smaller of two numeric values.\n\nThe `MIN` function consumes two numeric parameters from the top of the stack and pushes back the smallest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The smaller of p1 and p2.\n\n@param `sresult` The smaller of the elements in the given list.\n\n@param `lresult` A list where each value is the min between the element in the list and the given value.\n\n",tags:["math"],since:"1.0.0",OPB64name:"MIN"},{name:"MINLONG",detail:"MINLONG(): result:LONG",documentation:"Pushes [Long.MIN_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MIN_VALUE) onto the stack.\n\n@param `result` Long.MIN_VALUE\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"MINLONG"},{name:"MINREV",detail:"MINREV( revision:STRING ): newer:BOOLEAN",documentation:"The `MINREV` function consumes a string representing a revision on the stack and puts back a boolean indicating if the revision of the current Warp 10™ platform is newer or equal.\n\n@param `revision` A string representing a revision (semantic versioning). Given a version number MAJOR.MINOR.PATCH, .MINOR or .MINOR.PATCH can be omitted.\n\n@param `newer` A boolean indicating wether the revision of the current Warp 10™ platform is newer or equal to the given revision.\n\n",tags:["platform"],since:"1.2.23",OPB64name:"MINREV"},{name:"MMAP",detail:"MMAP( inputmap:MAP macro:MACRO ): results:MAP\nMMAP( inputmap:MAP macro:MACRO index:BOOLEAN ): results:MAP",documentation:"The `MMAP` function applies a macro on each key/value pair of a **MAP**, producing a **MAP** with the two elements on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **MAP** index on top and the key/value pair at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each entry in inputmap.\n\n@param `inputmap` Map to iterate on.\n\n@param `results` Map of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",tags:["maps"],since:"2.7.0",OPB64name:"MMAP"},{name:"MODE",detail:"MODE( gts:GTS ): result:LIST\nMODE( gtsList:LIST<GTS> ): [  result:LIST<LIST>  ]",documentation:"The `MODE` function computes the mode(s) for a given Geo Time Series™ or a GTS **LIST**. Foreach Geo Time Series™ pushes back on the stack a list containing \ntheir mode(s).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Mode of the list (the items that occurs most often)\n\n",tags:["gts"],since:"1.0.11",OPB64name:"MODE"},{name:"MONOTONIC",detail:"MONOTONIC( gts:GTS trend:BOOLEAN ): result:GTS\nMONOTONIC( gtsList:LIST<GTS> trend:BOOLEAN ): resultList:LIST<GTS>",documentation:"Produces a new Geo Time Series™ from an input by modifying the value so the result is monotonous. This is technically applying a ratchet effect on values.\n\nThe `MONOTONIC` function expects a boolean on top of the stack and a Geo Time Series™ or list thereof below the boolean. The boolean indicates whether the\nresult should be monotonically increasing (false) or decreasing (true).\n\n@param `trend` Whether the result should be monotonically increasing (false) or decreasing (true)\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` New Geo Time Series™\n\n@param `resultList` List of new Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MONOTONIC"},{name:"MOTIONSPLIT",detail:"MOTIONSPLIT( gts:GTS parameters:MAP ): splits:LIST<GTS>\nMOTIONSPLIT( lgts:LIST<GTS> parameters:MAP ): lsplits:LIST<LIST<GTS>>",documentation:'The `MOTIONSPLIT` function splits Geo Time Series™ instances based on several possible motion criteria. Split parameters can be combined to split on multiple criteria.\n\n`MOTIONSPLIT` can split on:\n- stopped state detection\n- moving to stopped transition\n- time difference between two ticks (just as [`TIMESPLIT`](/doc/TIMESPLIT) does).\n- maximal distance between two consecutive positions.\n\n`MOTIONSPLIT` parameters:\n- **timesplit**: LONG value, time in platform time unit. Splits if the time difference between two consecutive ticks is strictly greater than this parameter. If defined, the split type label will be "timesplit".\n- **distance.split**: DOUBLE value, distance in meter. Splits if the orthodromic distance between two consecutive locations is strictly greater than this parameter. If defined, the split type label will be "distancesplit".\n- **stopped.min.time**: LONG value, time in platform time unit. This is the minimum time the consecutive locations should stay in the stopped zone radius to consider a stop state. If defined, the split type label will be "stopped".\n- **stopped.max.radius**: DOUBLE value, distance in meter. As long as consecutive positions remains in the radius during stopped.min.time, `MOTIONSPLIT` detect a stopped state.\n- **stopped.max.speed**: DOUBLE value, speed in m/s. If the speed is greater than this value while in stopped state, `MOTIONSPLIT` exits the stopped state.\n- **stopped.max.mean.speed**: DOUBLE value, speed in m/s. Maximum mean speed in the proximity zone that prevent the split. `MOTIONSPLIT` will split only if there is a full stop during the given time and radius, and if the mean speed in the proximity zone is less than this parameter.\n- **stopped.split**: BOOLEAN value. If true, `MOTIONSPLIT` also splits between stopped and moving sequences. If defined, the split type label will be "stopped" or "moving".\n- **label.stopped.time**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the time in stopped state. If the split source is not a stop detection, this label won\'t be set.\n- **label.split.number**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the split number, starting from 1.\n- **label.split.type**: STRING value. If defined, `MOTIONSPLIT` will add an extra label that contains the split reason. It could be "timesplit", "distancesplit", "end", "stopped" or "moving".\n\n`MOTIONSPLIT` split type priorities:\n- If stopped.min.time and stopped.max.radius are set, the stop detection has the first priority.\n- If `MOTIONSPLIT` does not detect a stopped state, it looks for a distance split.\n- If `MOTIONSPLIT` does not detect a stopped state or a distance split, it looks for a time split.\n\n\n@param `parameters` List of splitting parameters. See the function description.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n',tags:["gts"],since:"2.3.0",OPB64name:"MOTIONSPLIT"},{name:"MSGFAIL",detail:"MSGFAIL( message:STRING ): ",documentation:"The `MSGFAIL` function stops the execution of WarpScript code by throwing an exception. \n\n@param `message` The exception message\n\n",tags:["control"],since:"1.0.0",OPB64name:"MSGFAIL"},{name:"MSORT",detail:"MSORT( map:MAP ): result:MAP",documentation:"The function `MSORT` inspects the top of the stack. If it is a **MAP**, it sorts the **MAP** according to its keys. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\n@param `map` Map to sort\n\n@param `result` Sorted map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"MSORT"},{name:"MSTU",detail:"MSTU(): numberTimeUnits:LONG",documentation:"The `MSTU` function pushes onto the stack the number of platform time units in one millisecond. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one millisecond.\n\n",tags:["date","time","platform"],since:"1.0.0",OPB64name:"MSTU"},{name:"MULTIPLYEXACT",detail:"MULTIPLYEXACT( x:NUMBER y:NUMBER ): prod:LONG\nMULTIPLYEXACT( list:LIST<NUMBER> ): sprod:LONG\nMULTIPLYEXACT( lx:LIST<NUMBER> y:NUMBER ): lprod:LIST<LONG>",documentation:"The `MULTIPLYEXACT` function consumes two LONGs from the top of the stack and puts back the product. If the product overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `prod` The product of x and y\n\n@param `list` List of numeric values\n\n@param `sprod` The product of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lprod` List of **LONG** where each value is the product of y and an element in lx\n\n",tags:["math"],since:"1.2.23",OPB64name:"MULTIPLYEXACT"},{name:"MUSIGMA",detail:"MUSIGMA( gts:GTS bessel:BOOLEAN ): mu:DOUBLE sigma:DOUBLE",documentation:"The `MUSIGMA` function calculates the mean and the standard deviation of a Geo Time Series. It consumes two parameters from the top of the stack: a boolean \n(to choose if [Bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction) should be applied on the standard deviation) and a numeric GTS, and \nit pushes onto the stack its mean (mu) and its standard deviation (sigma).\n\n@param `bessel` True if apply a [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `sigma` Standard deviation\n\n@param `mu` Mean\n\n@param `gts` A single Geo Time Series\n\n",tags:["gts"],since:"1.0.0",OPB64name:"MUSIGMA"},{name:"MUTEX",detail:"MUTEX( macro:MACRO mutex:STRING ): ",documentation:"Attempts to hold a named lock, creating it if needed, and execute a macro while holding the lock. When the macro execution terminates, either normally or with an error, the lock is released.\n\n@param `mutex` Name of lock to hold.\n\n@param `macro` Macro to execute while holding the lock.\n\n",tags:["extensions","stack"],since:"2.0.0",OPB64name:"MUTEX"},{name:"MVELEVATIONS",detail:"MVELEVATIONS( input:GTSENCODER ): output:LIST\nMVELEVATIONS( input:GTS ): output:LIST\nMVELEVATIONS( linput:LIST ): output:LIST",documentation:"The `MVELEVATIONS` function extracts elevations from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVELEVATIONS` function will emit a list with two elements (a pair), the first element will be the elevation associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the elevations of the Multivariate value itself.\n\nIf a tick has no associated elevation, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted elevations.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVELEVATIONS"},{name:"MVHHCODES",detail:"MVHHCODES( input:GTSENCODER ): output:LIST\nMVHHCODES( input:GTS ): output:LIST\nMVHHCODES( linput:LIST ): output:LIST",documentation:"The `MVHHCODES` function extracts [`HHCodes`](https://en.wikipedia.org/wiki/HHCode) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVHHCODES` function will emit a list with two elements (a pair), the first element will be the HHCode associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the HHCodes of the Multivariate value itself.\n\nIf a tick has no associated location, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted HHCodes.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVHHCODES"},{name:"MVINDEXSPLIT",detail:"MVINDEXSPLIT( input:GTSENCODER ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTSENCODER indices:LIST ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTSENCODER renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTSENCODER indices:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS indices:LIST ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS indices:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> indices:LIST ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> indices:LIST renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> indices:LIST ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> indices:LIST renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>",documentation:"The `MVINDEXSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVINDEXSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element index (first element being at index 0).\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:INDEX` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of indices or indices ranges can be specified to only produce encoders for the indices which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `indices` List of indices or indices ranges (list of two indices), used to restrict which indices to consider.\n\n@param `renaming` Map of index (LONG) to parameter to `RENAME`. If no entry is present for an index, `+:INDEX` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVINDEXSPLIT"},{name:"MVLOCATIONS",detail:"MVLOCATIONS( input:GTSENCODER ): output:LIST\nMVLOCATIONS( input:GTS ): output:LIST\nMVLOCATIONS( linput:LIST ): output:LIST",documentation:"The `MVLOCATIONS` function extracts location (latitude, longitude) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVLOCATIONS` function will emit a list with two elements (a pair), the first element will be the latitude and longitude (a list) associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the latitudes and longitudes of the Multivariate value itself.\n\nIf a tick has no associated location, `[ NaN NaN ]` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted locations.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVLOCATIONS"},{name:"MVTICKS",detail:"MVTICKS( input:GTSENCODER ): output:LIST\nMVTICKS( input:GTS ): output:LIST\nMVTICKS( linput:LIST ): output:LIST",documentation:"The `MVTICKS` function extracts ticks from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVTICKS` function will emit a list with two elements (a pair), the first element will be the tick at which the Multivariate value was encountered, the second element will be a list containing the ticks of the Multivariate value itself.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted ticks.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKS"},{name:"MVTICKSPLIT",detail:"MVTICKSPLIT( input:GTSENCODER ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTSENCODER timestamps:LIST ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTSENCODER renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTSENCODER timestamps:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS timestamps:LIST ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS timestamps:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> timestamps:LIST ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> renaming:MAP ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> timestamps:LIST renaming:MAP ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> timestamps:LIST ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> renaming:MAP ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> timestamps:LIST renaming:MAP ): loutput:LIST<GTSENCODER>",documentation:"The `MVTICKSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVTICKSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element timestamp.\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:TIMESTAMP` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of timestamps or timestamp ranges can be specified to only produce encoders for the timestamps which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `timestamps` List of timestamps or timestamps ranges (list of two timestamps), used to restrict which timestamps to consider.\n\n@param `renaming` Map of timestamp (LONG) to parameter to `RENAME`. If no entry is present for a timestamp, `+:TIMESTAMP` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKSPLIT"},{name:"MVVALUES",detail:"MVVALUES( input:GTSENCODER ): output:LIST\nMVVALUES( input:GTS ): output:LIST\nMVVALUES( linput:LIST ): output:LIST",documentation:"The `MVVALUES` function extracts values from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted values.\n\n",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVVALUES"},{name:"NAME",detail:"NAME( gts:GTS ): result:STRING\nNAME( encoder:GTSENCODER ): result:STRING",documentation:"The `NAME` function consumes a Geo Time Series™ from the stack, extracts its class name, and pushes it onto the stack.\n\n@param `gts` Geo Time Series™\n\n@param `encoder` Geo Time Series™ Encoder\n\n@param `result` Class name\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NAME"},{name:"NBOUNDS",detail:"NBOUNDS( mu:NUMBER sigma:NUMBER n:LONG ): bounds:LIST<DOUBLE>",documentation:"The `NBOUNDS` function computes bounds defining a specified number of intervals which have the same area under the curve of a normal distribution with a given mean and standard deviation.\n\n@param `n` Number of desired intervals.\n\n@param `sigma` Positive standard deviation to use for the normal distribution.\n\n@param `mu` Mean to use for the normal distribution.\n\n@param `bounds` List of `n`-1 bounds defining the `n` intervals.\n\n",tags:["math"],since:"1.0.0",OPB64name:"NBOUNDS"},{name:"NDEBUGON",detail:"NDEBUGON( n:NUMBER ): ",documentation:"Turns on stack debugging so up to the given number of stack levels will be returned in case of error. Stack debugging is off by default.\n\n@param `n` Maximum number of stack levels to return in case of error.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"NDEBUGON"},{name:"NEGATEEXACT",detail:"NEGATEEXACT( value:NUMBER ): result:DOUBLE\nNEGATEEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `NEGATEEXACT` function consumes one LONG from the top of the stack and puts back the negated value. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be negated\n\n@param `result` The negated value\n\n@param `lvalue` List of values to be negated\n\n@param `lresult` List of negated values\n\n",tags:["math"],since:"1.2.23",OPB64name:"NEGATEEXACT"},{name:"NEWENCODER",detail:"NEWENCODER(): encoder:GTSENCODER",documentation:"The `NEWENCODER` function creates an empty encoder and pushes it onto the stack. An encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` A newly created empty encoder instance.\n\n",tags:["encoder","multivariate"],since:"1.2.9",OPB64name:"NEWENCODER"},{name:"NEWGTS",detail:"NEWGTS(): gts:GTS",documentation:"The `NEWGTS` function pushes onto the stack an empty Geo Time Series™ instance.\n\n@param `gts` A newly created empty GTS instance.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NEWGTS"},{name:"NEXTAFTER",detail:"NEXTAFTER( from:NUMBER to:NUMBER ): result:DOUBLE\nNEXTAFTER( from:NUMBER lto:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nNEXTAFTER( lfrom:LIST<NUMBER> to:NUMBER ): lresult:LIST<DOUBLE>",documentation:"The `NEXTAFTER` function consumes two numeric parameter from the top of the stack and pushes back the **DOUBLE** adjacent to the first argument in the direction of the second argument. In other words, the result is between *from* and *to* and adjacent to *from*.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `from` Starting value\n\n@param `to` Direction used to calculate the adjacent value\n\n@param `result` Next **DOUBLE** from *from* to *to*\n\n@param `lfrom` List of starting values\n\n@param `lto` List of directions used to calculate the adjacent value\n\n@param `lresult` List of next **DOUBLE** from *from* to *to*\n\n",tags:["math"],since:"1.0.0",OPB64name:"NEXTAFTER"},{name:"NEXTDOWN",detail:"NEXTDOWN( value:NUMBER ): result:DOUBLE\nNEXTDOWN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `NEXTDOWN` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of negative infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of negative infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of negative infinity\n\n",tags:["math"],since:"1.2.23",OPB64name:"NEXTDOWN"},{name:"NEXTUP",detail:"NEXTUP( value:NUMBER ): result:DOUBLE\nNEXTUP( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `NEXTUP` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of positive infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of positive infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of positive infinity\n\n",tags:["math"],since:"1.0.0",OPB64name:"NEXTUP"},{name:"NOLOG",detail:"NOLOG(): ",documentation:"The `NOLOG` function resets java.util.logging.LogManager.\n\nIt can be useful to do this during developments and tests of an extension.\n\nThe `NOLOG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n",tags:["extensions"],since:"1.2.19",OPB64name:"NOLOG"},{name:"NONEMPTY",detail:"NONEMPTY( gtsList:LIST<GTS> ): results:LIST<GTS>",documentation:"Filter a list of Geo Time Series™ in order to retain only those that have at least one value.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `results` Filtered list of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NONEMPTY"},{name:"NONNULL",detail:"NONNULL( list:LIST ): nonnulls:LIST",documentation:"The `NONNULL` function consumes a list and produces a list containing only the non NULL elements of the argument list.\n\n@param `list` The argument list to filter\n\n@param `nonnulls` A new list with only those elements from `list` which are not NULL\n\n",tags:["math","logic"],since:"1.2.7",OPB64name:"NONNULL"},{name:"NOOP",detail:"",documentation:"It does nothing.\n\nWhile it does not have a usefulness of its own, it can be used when generating code from within WarpScript code prior to executing it with [`EVAL`](/doc/EVAL).\n\n",tags:["platform"],since:"1.0.0",OPB64name:"NOOP"},{name:"NORMALIZE",detail:"NORMALIZE( gts:GTS ): result:GTS\nNORMALIZE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"The `NORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between 0 and 1 (i.e. it replaces X by \n(X - min)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NORMALIZE"},{name:"NOT",detail:"NOT( input:BOOLEAN ): result:BOOLEAN\nNOT( gts:GTS ): negatedgts:GTS",documentation:"Negates a boolean.\n\nThe `NOT` function is synonymous for [`!`](/doc/7F). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gts` A boolean Geo Time Series™\n\n@param `negatedgts` A boolean Geo Time Series™\n\n",tags:["logic"],since:"1.0.0",OPB64name:"NOT"},{name:"NOTAFTER",detail:"NOTAFTER( timestamp:LONG ): \nNOTAFTER( date:STRING ): ",documentation:"Checks that the current time is not after the provided timestamp.\n\nThe `NOTAFTER` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not after the provided timestamp.\nIf it is not after the WarpScript execution continues, otherwise it throws an exception.\n\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",tags:["date"],since:"1.0.0",OPB64name:"NOTAFTER"},{name:"NOTBEFORE",detail:"NOTBEFORE( timestamp:LONG ): \nNOTBEFORE( date:STRING ): ",documentation:"Checks that the current time is not before the provided timestamp.\n\nThe `NOTBEFORE` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not before the provided timestamp.\nIf it is not before the WarpScript execution continues, otherwise it throws an exception.\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",tags:["date"],since:"1.0.0",OPB64name:"NOTBEFORE"},{name:"NOTIMINGS",detail:"",documentation:"Use of the `NOTIMINGS` function disables the collection of timing information for each line of the input script. Use [`TIMINGS`](/doc/TIMINGS) to enable it again.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"NOTIMINGS"},{name:"NOW",detail:"NOW(): timestamp:LONG",documentation:"The `NOW` function pushes onto the stack the current **LONG** timestamp expressed in the platform time unit. This timestamp is the number of platform time unit elapsed since 00:00:00 on 1 January 1970 UTC minus the number of leap seconds, see [Unix time](https://en.wikipedia.org/wiki/Unix_time).\n\nThis function is mostly linear with time but this property is violated when the OS resynchronises its clock (ie consecutive calls to `NOW` may 'jump' or 'go backward').\n\n@param `timestamp` The current timestamp in platform time unit.\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"NOW"},{name:"NPDF",detail:"NPDF( mu:NUMBER sigma:NUMBER ): npdf:FUNCTION",documentation:"The `NPDF` function builds a function which outputs the probability of occurrence of a given value under a specified normal distribution.\n\nThe normal distribution is defined by its mean and standard deviation. The result of the `NPDF` function is itself a function which can be invoked via [`EVAL`](doc/EVAL).\n\n*NPDF* stands for Normal (Gaussian) distribution Probability Density Function.\n\n@param `sigma` Standard deviation of the normal distribution to consider.\n\n@param `mu` Mean of the normal distribution to consider.\n\n@param `npdf` Function which given an input number outputs the probability of its occurence under the given normal distribution.\n\n",tags:["math"],since:"1.0.0",OPB64name:"NPDF"},{name:"NPEEK",detail:"NPEEK( levels:NUMBER ): ",documentation:"Displays a given number of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of stack levels to display.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"NPEEK"},{name:"NRETURN",detail:"NRETURN( levelnumber:LONG ): ",documentation:"Immediately exit a certain number of macros being executed. The `NRETURN` function expects a number of levels on top of the stack.\n\n@param `levelnumber` Number of levels of macro to exit.\n\n",tags:["control"],since:"1.0.0",OPB64name:"NRETURN"},{name:"NSUMSUMSQ",detail:"NSUMSUMSQ( gts:GTS ): cardinality:LONG sum:DOUBLE square:DOUBLE",documentation:"Computes the cardinality, sum of values and sum of squared values of a Geo Time Series™. Pushes those results on the stack in the order they were mentioned.\n\nOnly numeric series are allowed.\n\n@param `square` Sum of squared values\n\n@param `sum` Sum of values\n\n@param `cardinality` Values count\n\n@param `gts` Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"NSUMSUMSQ"},{name:"NULL",detail:"NULL(): result:NULL",documentation:"The `NULL` function pushes the symbolic value *null* onto the stack.\n\n@param `result` Symbolic value *null*\n\n",tags:["constants"],since:"1.0.0",OPB64name:"NULL"},{name:"NaN",detail:"NaN(): result:DOUBLE",documentation:"Pushes the double value *NaN* (Not a Number) onto the stack.\n\n@param `result` Value *NaN*\n\n",tags:["constants"],since:"1.0.0",OPB64name:"NaN"},{name:"ONLYBUCKETS",detail:"ONLYBUCKETS( gts:GTS ): result:GTS\nONLYBUCKETS( lgts:LIST<GTS> ): lresult:LIST<GTS>",documentation:"Only retains ticks from Geo Time Series™ with timestamps which are bucket ends. If an input GTS is not bucketized, a clone of the GTS will be returned.\n\nThe `ONLYBUCKETS` function does not remove duplicate ticks, please consider using [`DEDUP`](/doc/DEDUP) for that purpose.\n\n@param `gts` Single instance of Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `result` Transformed GTS.\n\n@param `lresult` List of transformed GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ONLYBUCKETS"},{name:"OPB64->",detail:"OPB64->( input:STRING ): output:BYTES",documentation:"Decode a String in order preserving base64 into a byte array.\n\nBytes array cannot be represented on the stack.\n\n@param `input` Any valid opbbase64 string.\n\n@param `output` Byte array of the input decoded input.\n\n",tags:["conversion"],since:"1.0.7",OPB64name:"Ip01CYFhEV"},{name:"OPB64TOHEX",detail:"OPB64TOHEX( input:STRING ): output:STRING",documentation:"The OPB64TOHEX function decodes the order preserving base64 string on top of the stack and immediately re-encode it in hex string.\n\n\n@param `input` OPBase64 encoded string\n\n@param `output` hexadecimal representation\n\n",tags:["conversion"],since:"1.0.2",OPB64name:"OPB64TOHEX"},{name:"OPS",detail:"OPS(): ops:LONG",documentation:"Pushes onto the stack the current number of operations which were performed by the WarpScript code execution.\n\n@param `ops` number of operations\n\n",tags:["platform"],since:"1.0.0",OPB64name:"OPS"},{name:"OPTDTW",detail:"OPTDTW( data:LIST query:LIST match:LONG ): result:LIST",documentation:"The `OPTDTW` function finds the top subsequence matches in a sequence for a given query sequence. The function uses [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping)\nto assess the subsequence similarity with the query.\n\n@param `match` Number of top matches. Use 0 as the number of matches to return to return them all.\n\n@param `query` Query numerical sequence, thr shortest\n\n@param `data` Data sequence in which to find matches\n\n@param `result` List of matches, each match being a pair of (index, distance).\n\n",tags:["math","distance"],since:"1.0.0",OPB64name:"OPTDTW"},{name:"OPTIMIZE",detail:"OPTIMIZE( gts:GTS ratio:NUMBER ): gts:GTS\nOPTIMIZE( encoder:GTSENCODER ratio:NUMBER ): optencoder:GTSENCODER\nOPTIMIZE( lgts:LIST<GTS> ratio:NUMBER ): lgts:LIST<GTS>\nOPTIMIZE( lencoder:LIST<GTSENCODER> ratio:NUMBER ): loptencoder:LIST<GTSENCODER>",documentation:"Optimizes the memory footprint of Geo Time Series™ and GTS Encoder instances.\n\n@param `ratio` Ratio of memory footprint to number of values, if this ratio is not exceeded, no optimization will take place. As a result, optimization is always done when ratio <= 1 or ratio is NaN.\n\n@param `gts` Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `encoder` Instance of GTS Encoder to optimize.\n\n@param `optencoder` Optimized version of the encoder, or the original instance if no optimization occurred.\n\n@param `lgts` List of Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `lencoder` List of instances of GTS Encoder to optimize.\n\n@param `loptencoder` List of optimized version of the encoders or the original instances if no optimization occurred.\n\n",tags:["gts"],since:"1.2.9",OPB64name:"OPTIMIZE"},{name:"OR",detail:"OR( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\nOR( l:LIST ): result:BOOLEAN\nOR( gts1:GTS gts2:GTS ): gtsresult:GTS",documentation:"The `OR` operator is a synonymous for [`||`](/doc/U6k).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `OR` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"OR"},{name:"PACK",detail:"PACK( input:LIST format:STRING ): result:BYTES",documentation:"The `PACK` function packs a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n@param `input` List to pack\n\n@param `format` Format used to pack\n\n@param `result` Bytes array\n\n",tags:["lists"],since:"1.0.7",OPB64name:"PACK"},{name:"PAPPLY",detail:"PAPPLY( [ op:OPERATOR labels:LIST gts:LIST<GTS>+ ] ): result:MAP",documentation:"The `PAPPLY` function performs operations in a way identical to the [`APPLY`](/doc/APPLY) framework but produces a map of results keyed by the label map of each equivalence class.\n\nAs [`APPLY`](/doc/APPLY), `PAPPLY` provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can due. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` Map of resulting GTS, one per equivalence class, keyed with the equivalence class labels.\n\n@param `op` Operation to perform.\n\n",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"PAPPLY"},{name:"PARSE",detail:"PARSE( data:STRING ): result:LIST<GTS>",documentation:"The `PARSE` function parses an input **STRING** containing datapoints in the [Geo Time Series™ input format](/content/03_Documentation/03_Interacting_with_Warp_10/03_Ingesting_data/02_GTS_input_format) and pushes onto the stack the parsed Geo Time Series™.\n\n@param `data` Datapoints in the Geo Time Series™ input format\n\n@param `result` List of parsed Geo Time Series™\n\n",tags:["gts","strings"],since:"1.0.11",OPB64name:"PARSE"},{name:"PARSESELECTOR",detail:"PARSESELECTOR( selector:STRING ): classselector:STRING labelselector:MAP",documentation:"The `PARSESELECTOR` function parses a GTS Selector (STRING) returnss the class selector and labels selectors.\n\nIn order for `PARSESELECTOR` to parse correctly a selector, the following characters MUST appear percent-encoded in the `STRING` to parse, the equal sign (`=`, `%3D`), the comma (`,` `%2C`) and closing curly brace (`}` `%7D`). Due to the way WarpScript parses `STRING` constants, the `%` sign MUST be percent-encoded (`%25`) in the `STRING` if it appears in WarpScript code:\n\nThe `STRING` `class{label=comm%2Cequal%3Dsign}` must appear in WarpScript as:\n\n```\n'class{label=comm%252Cequal%253Dsign'\n```\n\nCombined with `TOSELECTOR`, it can be used to build a selector from a subset of GTS.\n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature'\n  { 'sensorId' '=01' }\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\nFETCH\n\n```\nThis can be used to simplify the syntax of a FETCH or FIND request. \n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature{sensorId=01}' PARSESELECTOR\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\n\nFETCH\n```\n\n\n\n@param `selector` String selector.\n\n@param `labelselector` MAP of label selectors.\n\n@param `classselector` Class name selector.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PARSESELECTOR"},{name:"PARSEVALUE",detail:"PARSEVALUE( input:STRING ): value:ANY",documentation:"The `PARSEVALUE` function parses a STRING representing a valid value in the Geo Time Series™ input format.\n\nThe underlying implementation being the internal WarpScript function, some of the returned types might not be easily handled in the rest of the calling script. Most notably, some floating point representations might lead to BigDecimal instances being produced.\n\n@param `input` String representation of the value to parse.\n\n@param `value` Parsed value, could be a STRING, LONG, DOUBLE, BIGDECIMAL, BOOLEAN or BYTES elements.\n\n",tags:["gts"],since:"2.1.0",OPB64name:"PARSEVALUE"},{name:"PARTITION",detail:"PARTITION( lgts:LIST<GTS> labels:LIST<STRING> ): result:MAP",documentation:"The `PARTITION` function splits a Geo Time Series™ list in equivalence classes based on label values.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels` plus all labels with common values among the GTS in the equivalence class.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PARTITION"},{name:"PATTERNDETECTION",detail:"PATTERNDETECTION( gts:GTS patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nPATTERNDETECTION( lgts:LIST<GTS> patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",documentation:"The `PATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it\n\n@param `lresult` The list of result GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNDETECTION"},{name:"PATTERNS",detail:"PATTERNS( gts:GTS wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nPATTERNS( lgts:LIST<GTS> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",documentation:"The `PATTERNS` function extracts symbolic patterns (or motifs) from a Geo Time Series™. Those patterns are similar to [iSAX](http://www.cs.ucr.edu/~eamonn/iSAX/iSAX.html) symbols.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNS` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNS"},{name:"PEEK",detail:"PEEK(): ",documentation:"Displays the top of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PEEK"},{name:"PEEKN",detail:"PEEKN( distance:NUMBER ): ",documentation:"Displays the content of the level of the stack at the given distance from the top.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `distance` Distance (in stack levels) between the top of the stack and the level to display.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PEEKN"},{name:"PERMUTE",detail:"PERMUTE( tensor:LIST pattern:LIST ): tensor:LIST\nPERMUTE( { tensor:LIST pattern:LIST fast:BOOLEAN  } ): tensor:LIST",documentation:"Permute the dimensions of a nested LIST as if it were a tensor or a multidimensional array.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent before operating. Default to false.\n\n@param `pattern` The permutation pattern (a LIST of LONG).\n\n@param `tensor` The resulting nested LIST.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"PERMUTE"},{name:"PFILTER",detail:"PFILTER( [ gtsList:LIST<GTS> labels:LIST<STRING> filter:FILTER ] ): result:MAP",documentation:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `PFILTER framework allows for advanced filtering using N-ary functions \n(functions which accept N parameters). Returned GTS are grouped by equivalence classes.\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A map keyed by the label set of each equivalence class whose values are lists of selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `PFILTER`.\n\n",tags:["framework","filter"],since:"1.0.0",OPB64name:"PFILTER"},{name:"PGraphics",detail:"PGraphics( width:LONG height:LONG imgtype:STRING ): pg:PGRAPHICS",documentation:'Warp 10 includes a large subset of the [Processing](http://www.processing.org) drawing library. You can create and manipulate images, then push a base64 encoded png onto the stack.\n\n+ Step 1: create a processing graphic object with `PGraphics` function.\n+ Step 2: manipulate this object with Processing functions.\n+ Step 3: render the processing graphic with `Pencode` function.\n\nDocumentation of every function has a link to original Processing website. Original website includes more examples for each function.\n\nProcessing functions offers a lot of different signatures for colors. The most efficient is to keep the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n\nUp to Warp 10 1.2.18, antialiasing was not available. It is now available, by appending a digit to the **imgtype** string argument. The maximum anti-aliasing level is determined by the hardware of the machine that is running the software, so 2D4 and 2D8 mode will not work with every computer.\n\n+ "2D": no antialiasing\n+ "2D2": bilinear smoothing\n+ "2D3": bicubic smoothing\n+ "2D4": 4x antialiasing\n+ "2D8": 8x antialiasing\n\n\nYou can adjust the maximal number of pixel allowed in Warp 10 configuration file.\n\n@param `imgtype` \'2D\', \'3D\', or \'2Dx\', where x is the level of anti aliasing (2, 3, 4, or 8).\n\n@param `width` Pixel width of the image.\n\n@param `height` Pixel height of the image.\n\n@param `pg` Processing graphic object.\n\n',tags:["processing"],since:"1.0.0",OPB64name:"PGraphics"},{name:"PI",detail:"PI(): pi:DOUBLE",documentation:"Alias of [pi](/doc/R5Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"J3Z"},{name:"PICK",detail:"PICK( level:NUMBER ): result:ANY",documentation:"The `PICK` function copies on top of the stack the element at level N. Parameter N is consumed off the top of the stack when `PICK` is called.\n\n@param `level` Level of the stack\n\n@param `result` What is on stack at *level*\n\n",tags:["stack"],since:"1.0.0",OPB64name:"PICK"},{name:"PICKLE->",detail:"PICKLE->( input:BYTES ): output:ANY",documentation:"The `PICKLE->` function decodes some Pickle encoded content contained in a byte array.\nThe conversion is done using [Pyrolite v4](https://github.com/irmen/pickle).\n\nIt can read all pickle protocol versions (0 to 4, so this includes\nthe latest additions made in Python 3.4).\n\n```python\n>>> myobject={ 'apple':3.5,'banana':18 }\n>>> pickle.dumps(myobject).encode(\"hex\")\n'286470300a53276170706c65270a70310a46332e350a73532762616e616e61270a70320a4931380a732e'\n```\n\n@param `input` Byte array of a pickle encoded content\n\n@param `output` Warp 10 object\n\n",tags:["platform"],since:"1.0.7",OPB64name:"J3_2Hol4AIs"},{name:"PIGSCHEMA",detail:"PIGSCHEMA( elt:ANY* ): elt:ANY* schema:STRING",documentation:"The `PIGSCHEMA` function produces on top of the stack a STRING representing the [Pig](https://en.wikipedia.org/wiki/Pig_(programming_tool)) schema definition for the current stack content.\n\n@param `elt` Stack content.\n\n@param `schema` Schema for the current stack, usable when working with WarpScript in Pig.\n\n",tags:["pig","stack"],since:"1.2.5",OPB64name:"PIGSCHEMA"},{name:"PIVOT",detail:"PIVOT( input:LIST<GTS> pivot:LIST<GTS> ): result:LIST<GTS>",documentation:"The `PIVOT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick of GTS from the first list, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n1// C3{C1=C} 2\n2// C4{C2=F} 30\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n4// C3{} 5\n4// C4{} 50\n```\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",tags:["gts"],since:"2.2.0",OPB64name:"PIVOT"},{name:"PIVOTSTRICT",detail:"PIVOTSTRICT( input:LIST<GTS> pivot:LIST<GTS> ): result:LIST<GTS>",documentation:"The `PIVOTSTRICT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™ in a way similar to what [`PIVOT`](/doc/PIVOT) does.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick common to Geo Time Series™ of both lists, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOTSTRICT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n```\n\nOnly ticks 0 and 3 appear in the result as those are the only ticks present in both `C1` and `C2`.\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",tags:["gts"],since:"2.2.0",OPB64name:"PIVOTSTRICT"},{name:"POPR",detail:"POPR( value:ANY ): ",documentation:"Pops a value from the top of the stack and stores it into the designated register.\n\nThe `POPR` function is really a family of functions named `POPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"POPR"},{name:"PREDUCE",detail:"PREDUCE( [ gts:LIST<GTS>+ labels:LIST<STRING> reducer:AGGREGATOR ] ): result:MAP",documentation:"Behaves as [`REDUCE`](/doc/REDUCE) but produces a map of results keyed by the label map of each equivalence class.\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` Map keyed by the label map of each equivalence class and whose values are the Geo Time Series™ produced for each class.\n\n",tags:["reducer","framework"],since:"1.0.5",OPB64name:"PREDUCE"},{name:"PRNG",detail:"PRNG( seed:LONG ): ",documentation:"The `PRNG` function initializes the stack's seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator). This PRNG can later be used by the [`SRAND`](/doc/SRAND) function to produce random numbers in a deterministic way (!).\n\n@param `seed` The seed to use for initializing the PRNG.\n\n",tags:["math"],since:"1.2.9",OPB64name:"PRNG"},{name:"PROB",detail:"PROB( gts:GTS ): result:GTS\nPROB( gtslist:LIST<GTS> ): resultList:LIST<GTS>",documentation:"Computes probability for each value of the input Geo Time Series™.\n\nThe function `PROB` consumes a GTS or a list of the GTS from the top of the stack. It pushes back the probability for each value.\n\nThe probabilities are computed using the value histogram.\n\n@param `gts` The input Geo Time Series™\n\n@param `gtslist` The input list of Geo Time Series™\n\n@param `result` The Geo Time Series™ wit probability for each value\n\n@param `resultList` The List of Geo Time Series™ with probability for each value\n\n",tags:["gts","statistics"],since:"1.0.6",OPB64name:"PROB"},{name:"PROBABILITY",detail:"PROBABILITY( valueHistogram:MAP ): result:STRING",documentation:"Pushes on the stack a function which computes probabilities according to a provided value histogram.\n\nTo use the function pushed by `PROBABILITY` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function expects a value on top of the stack and will output the probability of occurrence of this value.\n\n",tags:["math","statistics"],since:"1.0.0",OPB64name:"PROBABILITY"},{name:"PSTACK",detail:"",documentation:"When in interactive (REPL) mode, prints the content of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PSTACK"},{name:"PUSHR",detail:"PUSHR(): value:ANY",documentation:"Pushes onto the stack the value currently contained in the designated register.\n\nThe `PUSHR` function is really a family of functions named `PUSHRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value from the designated register.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"PUSHR"},{name:"PUT",detail:"PUT( inputmap:MAP newvalue:ANY newkey:ANY ): outputmap:MAP",documentation:"The `PUT` function inserts a new key-value pair in a map.\nIf the key already exists in the input MAP, the value is replaced by the new one.\n\n`PUT` function puts the reference of the MAP on top of the stack.\n\n@param `newkey` Depending on map construction, could be a number, a string, a boolean\n\n@param `newvalue` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `inputmap` reference to the map to be modified\n\n@param `outputmap` copy of input map reference. Useful to chain other instructions on the same map.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"PUT"},{name:"Palpha",detail:"Palpha( pg:PGRAPHICS color:NUMBER ): pg:PGRAPHICS alpha:DOUBLE",documentation:"Extracts the alpha value from a color.\n\nThe `Palpha` function is easy to use and understand, but it is slower than bit shifting... \n\n\n[Link to original Processing doc](https://processing.org/reference/alpha_.html)\n\n@param `color` Any value of the color datatype\n\n@param `alpha` Alpha component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Palpha"},{name:"Parc",detail:"Parc( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE start:DOUBLE stop:DOUBLE ): pg:PGRAPHICS\nParc( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE start:DOUBLE stop:DOUBLE mode:STRING ): pg:PGRAPHICS",documentation:"Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse defined by the **a**, **b**, **c**, and **d** parameters. The origin of the arc's ellipse may be changed with the [`PellipseMode`](/doc/PellipseMode) function. Use the **start** and **stop** parameters to specify the angles (in radians) at which to draw the arc.\n\n\n\nThere are three ways to draw an arc; the rendering technique used is defined by the optional seventh parameter. The three options, depicted in the examples, are PIE, OPEN, and CHORD. The default mode is the OPEN stroke with a PIE fill.\n\n\n\nIn some cases, the `Parc` function isn't accurate enough for smooth drawing. For example, the shape may jitter on screen when rotating slowly. If you're having an issue with how arcs are rendered, you'll need to draw the arc yourself with [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) or a **PShape**.\n\n\n[Link to original Processing doc](https://processing.org/reference/arc_.html)\n\n@param `b` y-coordinate of the arc's ellipse\n\n@param `a` x-coordinate of the arc's ellipse\n\n@param `c` width of the arc's ellipse by default\n\n@param `d` height of the arc's ellipse by default\n\n@param `start` angle to start the arc, specified in radians\n\n@param `stop` angle to stop the arc, specified in radians\n\n@param `mode` closing mode. either PIE, OPEN, or CHORD\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Parc"},{name:"Pbackground",detail:"Pbackground( pg:PGRAPHICS argb:LONG ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS gray:DOUBLE ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS image:PIMAGE ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS rgb:LONG alpha:NUMBER ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS gray:DOUBLE alpha:NUMBER ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS",documentation:"The `Pbackground` function sets the color used for the background of the processing graphics object. \n\nAn image object can also be used as the background for a sketch, although the image's width and height must match that of the processing object. Images used with `Pbackground` will ignore the current [`Ptint`](/doc/Ptint) setting. \n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pbackground` calls internally [`Pcolor`](/doc/Pcolor).\n\n\n[Link to original Processing doc](https://processing.org/reference/background_.html)\n\n@param `argb` any argb color value.\n\n@param `rgb` any rgb color value.\n\n@param `alpha` opacity of the background. 0 = transparent, 255 = opaque.\n\n@param `gray` a value between white (255) and black (0)\n\n@param `image` PImage to set as background (must be same size as pg)\n\n@param `v1` red or hue value (depending on the current color mode)\n\n@param `v2` green or saturation value (depending on the current color mode)\n\n@param `v3` blue or brightness value (depending on the current color mode)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbackground"},{name:"PbeginContour",detail:"PbeginContour( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Use the `PbeginContour` and [`PendContour`](/doc/PendContour) function to create negative shapes within shapes such as the center of the letter 'O'. `PbeginContour` begins recording vertices for the shape and [`PendContour`](/doc/PendContour) stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\n\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a `PbeginContour`/[`PendContour`](/doc/PendContour) pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginContour_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbeginContour"},{name:"PbeginShape",detail:"PbeginShape( pg:PGRAPHICS kind:STRING ): pg:PGRAPHICS\nPbeginShape( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Using the `PbeginShape` and [`PendShape`](/doc/PendShape) functions allow creating more complex forms. `PbeginShape` begins recording vertices for a shape and [`PendShape`](/doc/PendShape) stops recording. \n\nThe value of the **kind** parameter tells it which types of shapes to create from the provided vertices. The parameters available for beginShape() are POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the `PbeginShape` function, a series of [`Pvertex`](/doc/Pvertex) commands must follow. To stop drawing the shape, call [`PendShape`](/doc/PendShape). The [`Pvertex`](/doc/Pvertex) function with two parameters specifies a position in 2D. Each shape will be outlined with the current stroke color and filled with the fill color. \n\n\nTransformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within `PbeginShape`. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within `PbeginShape`. \n\n\nThe P2D and P3D renderers allow [`Pstroke`](/doc/Pstroke) and [`Pfill`](/doc/Pfill) to be altered on a per-vertex group basis. Settings such as [`PstrokeWeight`](/doc/PstrokeWeight), [`PstrokeCap`](/doc/PstrokeCap), and [`PstrokeJoin`](/doc/PstrokeJoin) cannot be changed while inside a `PbeginShape`/[`PendShape`](/doc/PendShape) block with any renderer.\n\nUp to Warp 10 1.2.18, `PbeginShape` could be called without the **kind** parameter. It defaults to POLYGON.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginShape_.html)\n\n@param `kind` Either POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbeginShape"},{name:"Pbezier",detail:"Pbezier( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS\nPbezier( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE z1:DOUBLE x2:DOUBLE y2:DOUBLE z2:DOUBLE x3:DOUBLE y3:DOUBLE z3:DOUBLE x4:DOUBLE y4:DOUBLE z4:DOUBLE ): pg:PGRAPHICS",documentation:"Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezier_.html)\n\n@param `x1` coordinates for the first anchor point\n\n@param `y1` coordinates for the first anchor point\n\n@param `z1` coordinates for the first anchor point\n\n@param `x2` coordinates for the first control point\n\n@param `y2` coordinates for the first control point\n\n@param `z2` coordinates for the first control point\n\n@param `x3` coordinates for the second control point\n\n@param `y3` coordinates for the second control point\n\n@param `z3` coordinates for the second control point\n\n@param `x4` coordinates for the second anchor point\n\n@param `y4` coordinates for the second anchor point\n\n@param `z4` coordinates for the second anchor point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbezier"},{name:"PbezierDetail",detail:"PbezierDetail( pg:PGRAPHICS detail:NUMBER ): pg:PGRAPHICS",documentation:"Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the **P3D** renderer; the default **P2D** renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierDetail_.html)\n\n@param `detail` resolution of the curves\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierDetail"},{name:"PbezierPoint",detail:"PbezierPoint( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",documentation:"Evaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierPoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierPoint"},{name:"PbezierTangent",detail:"PbezierTangent( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",documentation:"Calculates the tangent of a point on a Bezier curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierTangent"},{name:"PbezierVertex",detail:"PbezierVertex( pg:PGRAPHICS x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS",documentation:"Specifies vertex coordinates for Bezier curves. Each call to `PbezierVertex` defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PbezierVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only with POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/bezierVertex_.html)\n\n@param `x2` The x-coordinate of the 1st control point\n\n@param `y2` The y-coordinate of the 1st control point\n\n@param `x3` The x-coordinate of the 2nd control point\n\n@param `y3` The y-coordinate of the 2nd control point\n\n@param `x4` The x-coordinate of the anchor point\n\n@param `y4` The y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PbezierVertex"},{name:"Pblend",detail:"Pblend( pg:PGRAPHICS src:PIMAGE sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG mode:STRING ): pg:PGRAPHICS\nPblend( pg:PGRAPHICS sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG mode:STRING ): pg:PGRAPHICS",documentation:"Blends a region of pixels from one image into another (or in itself again) with full alpha channel support.\n\nHere are the available modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n\n+ BLEND - linear interpolation of colours: C = A*factor + B\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - Multiply the colors, result will always be darker.\n+ SCREEN - Opposite multiply, uses inverse values of the colors.\n+ OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values,and screens light values.\n+ HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n+ SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n+ DODGE - Lightens light tones and increases contrast, ignores darks.Called \"Color Dodge\" in Illustrator and Photoshop.\n+ BURN - Darker areas are applied, increasing contrast, ignores lights.Called \"Color Burn\" in Illustrator and Photoshop.\n\nAll modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the **src** parameter is not used, the display window is used as the source image.\n\n[Link to original Processing doc](https://processing.org/reference/blend_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `mode` Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pblend"},{name:"PblendMode",detail:"PblendMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",documentation:"Blends the pixels in the display window according to a defined mode. \n\nHere are the available modes to blend the source pixels (A) with the ones of pixels already in the display window (B). \n\n+ BLEND - linear interpolation of colours: C = A*factor + B. This is the default blending mode.\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - multiply the colors, result will always be darker.\n+ SCREEN - opposite multiply, uses inverse values of the colors.\n+ REPLACE - the pixels entirely replace the others and don't utilize alpha (transparency) values\n\nA pixel's final color is the result of applying one of the above blend modes with each channel of (A) and (B) independently. For example, red is compared with red, green with green, and blue with blue.\n\nWe recommend using `PblendMode` and not the previous [`Pblend`](/doc/Pblend) function. However, unlike [`Pblend`](/doc/Pblend), the `PblendMode` function does not support the following: HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN. On older hardware, the LIGHTEST, DARKEST, and DIFFERENCE modes might not be available as well. \n\n[Link to original Processing doc](https://processing.org/reference/blendMode_.html)\n\n@param `mode` The blending mode to use\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PblendMode"},{name:"Pblue",detail:"Pblue( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS blue:DOUBLE",documentation:"Extracts the blue value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pblue` function is easy to use and understand, but it is slower than bit masking. \n\n\n[Link to original Processing doc](https://processing.org/reference/blue_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `blue` Blue component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pblue"},{name:"Pbox",detail:"Pbox( pg:PGRAPHICS size:NUMBER ): pg:PGRAPHICS\nPbox( pg:PGRAPHICS w:NUMBER h:NUMBER d:NUMBER ): pg:PGRAPHICS",documentation:"A box is an extruded rectangle. A box with equal dimensions on all sides is a cube.\n\n\n[Link to original Processing doc](https://processing.org/reference/box_.html)\n\n@param `size` dimension of the box in all dimensions (creates a cube)\n\n@param `w` dimension of the box in the x-dimension\n\n@param `h` dimension of the box in the y-dimension\n\n@param `d` dimension of the box in the z-dimension\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbox"},{name:"Pbrightness",detail:"Pbrightness( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS brightness:DOUBLE",documentation:"Extracts the brightness value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/brightness_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `brightness` Brightness component of input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pbrightness"},{name:"Pclear",detail:"Pclear( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Clears the pixels. This function clears everything in a **PGraphics** object to make all of the pixels 100% transparent.\n\n\n[Link to original Processing doc](https://processing.org/reference/clear_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pclear"},{name:"Pclip",detail:"Pclip( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS",documentation:"Limits the rendering to the boundaries of a rectangle defined by the parameters. The boundaries are drawn based on the state of the [`PimageMode`](/doc/PimageMode) function, either CORNER, CORNERS, or CENTER. \n\n\n[Link to original Processing doc](https://processing.org/reference/clip_.html)\n\n@param `a` x-coordinate of the rectangle, by default\n\n@param `b` y-coordinate of the rectangle, by default\n\n@param `c` width of the rectangle, by default\n\n@param `d` height of the rectangle, by default\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pclip"},{name:"Pcolor",detail:"Pcolor( pg:PGRAPHICS gray:NUMBER ): pg:PGRAPHICS color:LONG\nPcolor( pg:PGRAPHICS gray:NUMBER alpha:NUMBER ): pg:PGRAPHICS color:LONG\nPcolor( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS color:LONG\nPcolor( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS color:LONG",documentation:"`Pcolor` creates colors for storing in ARGB LONG datatype.\n\n+ RGB: The most efficient is to skip Pcolor function, using the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n+ HSB: For Hue Saturation Brightness to RGB conversion, use [`PcolorMode`](/doc/PcolorMode) to specify HSB, then use Pcolor to convert to ARGB.\n\nThe parameters are interpreted as RGB or HSB values depending on the current [`PcolorMode`](/doc/PcolorMode). The default mode is RGB values from 0 to 255.\n\nNote that if only one value is provided to `Pcolor`, it will be interpreted as a grayscale value. Add a second value, and it will be used for alpha transparency. When three values are specified, they are interpreted as either RGB or HSB values. Adding a fourth value applies alpha transparency.\n\n\n[Link to original Processing doc](https://processing.org/reference/color_.html)\n\n@param `gray` int: number specifying value between white and black\n\n@param `alpha` float, or int: relative to current color range\n\n@param `v1` float, or int: red or hue values relative to the current color range\n\n@param `v2` float, or int: green or saturation values relative to the current color range\n\n@param `v3` float, or int: blue or brightness values relative to the current color range\n\n@param `color` ARGB color.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pcolor"},{name:"PcolorMode",detail:"PcolorMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS\nPcolorMode( pg:PGRAPHICS mode:STRING max:DOUBLE ): pg:PGRAPHICS\nPcolorMode( pg:PGRAPHICS mode:STRING max1:DOUBLE max2:DOUBLE max3:DOUBLE ): pg:PGRAPHICS\nPcolorMode( pg:PGRAPHICS mode:STRING max1:DOUBLE max2:DOUBLE max3:DOUBLE maxA:DOUBLE ): pg:PGRAPHICS",documentation:"Changes the way Processing interprets color data. By default, the parameters for [`Pfill`](/doc/Pfill), [`Pstroke`](/doc/Pstroke), [`Pbackground`](/doc/Pbackground), and [`Pcolor`](/doc/Pcolor) are defined by values between 0 and 255 using the RGB color model. The `PcolorMode` function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling **colorMode(RGB, 1.0)** will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters **max**, **max1**, **max2**, **max3**, and **maxA**.\n\nWhen using max different from default values, do not work with grayscale.\n\nAfter changing the range of values for colors with code like **colorMode(HSB, 360, 100, 100)**, those ranges remain in use until they are explicitly changed again. For example, after running **colorMode(HSB, 360, 100, 100)** and then changing back to **colorMode(RGB)**, the range for R will be 0 to 360 and the range for G and B will be 0 to 100. To avoid this, be explicit about the ranges when changing the color mode. For instance, instead of **colorMode(RGB)**, write **colorMode(RGB, 255, 255, 255)**. \n\n\n[Link to original Processing doc](https://processing.org/reference/colorMode_.html)\n\n@param `mode` Either 'RGB' or 'HSB', corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n\n@param `max` range for all color elements\n\n@param `max1` range for the red or hue depending on the current color mode\n\n@param `max2` range for the green or saturation depending on the current color mode\n\n@param `max3` range for the blue or brightness depending on the current color mode\n\n@param `maxA` range for the alpha\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcolorMode"},{name:"Pconstrain",detail:"Pconstrain( pg:PGRAPHICS x:DOUBLE low:DOUBLE high:DOUBLE ): pg:PGRAPHICS clamped:DOUBLE",documentation:"Constrains a value to not exceed a maximum and minimum value. Also known as clamping a value. \n\nIt could be done with warpscript MIN MAX functions, see example.\n\n[Link to original Processing doc](https://processing.org/reference/constrain_.html)\n\n@param `x` The value to clamp.\n\n@param `low` Minimum limit.\n\n@param `high` Maximum limit.\n\n@param `clamped` Clamped value of x in [low high] range.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pconstrain"},{name:"Pcopy",detail:"Pcopy( pg:PGRAPHICS src:PIMAGE sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG ): pg:PGRAPHICS\nPcopy( pg:PGRAPHICS sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG ): pg:PGRAPHICS\nPcopy( pg:PGRAPHICS ): pg:PGRAPHICS img:PIMAGE",documentation:"Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an image used as the **src** parameter into the display window. If the source and destination regions are not the same size, it will automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/copy_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `img` PIMAGE object, copy of pg\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pcopy"},{name:"PcreateFont",detail:"PcreateFont( pg:PGRAPHICS name:STRING ): pg:PGRAPHICS font:PFONT\nPcreateFont( pg:PGRAPHICS name:STRING size:NUMBER ): pg:PGRAPHICS font:PFONT\nPcreateFont( pg:PGRAPHICS name:STRING size:NUMBER smooth:BOOLEAN ): pg:PGRAPHICS font:PFONT\nPcreateFont( pg:PGRAPHICS name:STRING size:NUMBER smooth:BOOLEAN charset:STRING ): pg:PGRAPHICS font:PFONT",documentation:"Dynamically converts a font to the format used by Processing from a font that is installed on the computer.  Not all fonts can be used and some might work with one operating system and not others.\n\nThe **size** parameter states the font size you want to generate. The **smooth** parameter specifies if the font should be antialiased or not.\n\nSince the 2.5.0 version, the name of the font can be a URI to a OpenType or Type1 font which will be resolved by a macro defined by the `processing.font.resolver` configuration.\n\n[Link to original Processing doc](https://processing.org/reference/createFont_.html)\n\n@param `name` Name of the font to load or URI from where to load the font.\n\n@param `size` Point size of the font\n\n@param `smooth` True for an antialiased font, false for aliased\n\n@param `charset` subset of ascii characters to be generated.\n\n@param `font` Processing font object compatible with PtextFont.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcreateFont"},{name:"Pcurve",detail:"Pcurve( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS\nPcurve( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE z1:DOUBLE x2:DOUBLE y2:DOUBLE z2:DOUBLE x3:DOUBLE y3:DOUBLE z3:DOUBLE x4:DOUBLE y4:DOUBLE z4:DOUBLE ): pg:PGRAPHICS",documentation:"Draws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of `Pcurve` functions together or using [`PcurveVertex`](/doc/PcurveVertex). An additional function called [`PcurveTightness`](/doc/PcurveTightness) provides control for the visual quality of the curve. The `Pcurve` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n[Link to original Processing doc](https://processing.org/reference/curve_.html)\n\n@param `x1` float: coordinates for the beginning control point\n\n@param `y1` float: coordinates for the beginning control point\n\n@param `x2` float: coordinates for the first point\n\n@param `y2` float: coordinates for the first point\n\n@param `x3` float: coordinates for the second point\n\n@param `y3` float: coordinates for the second point\n\n@param `x4` float: coordinates for the ending control point\n\n@param `y4` float: coordinates for the ending control point\n\n@param `z1` float: coordinates for the beginning control point\n\n@param `z2` float: coordinates for the first point\n\n@param `z3` float: coordinates for the second point\n\n@param `z4` float: coordinates for the ending control point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pcurve"},{name:"PcurveDetail",detail:"PcurveDetail( pg:PGRAPHICS detail:NUMBER ): pg:PGRAPHICS",documentation:"Sets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveDetail_.html)\n\n@param `detail` Resolution of the curves\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveDetail"},{name:"PcurvePoint",detail:"PcurvePoint( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",documentation:"Evaluates the curve at point **t** for points **a**, **b**, **c**, **d**. The parameter **t** may range from 0 (the start of the curve) and 1 (the end of the curve). **a** and **d** are points on the curve, and **b** and **c** are the control points. This can be used once with the **x** coordinates and a second time with the **y** coordinates to get the location of a curve at **t**.\n\n\n[Link to original Processing doc](https://processing.org/reference/curvePoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of second point on the curve\n\n@param `c` coordinate of third point on the curve\n\n@param `d` coordinate of fourth point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurvePoint"},{name:"PcurveTangent",detail:"PcurveTangent( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",documentation:"Calculates the tangent of a point on a curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTangent"},{name:"PcurveTightness",detail:"PcurveTightness( pg:PGRAPHICS tightness:NUMBER ): pg:PGRAPHICS",documentation:"Modifies the quality of forms created with [`Pcurve`](/doc/Pcurve) and [`PcurveVertex`](/doc/PcurveVertex). The parameter **tightness** determines how the curve fits to the vertex points. The value 0.0 is the default value for **tightness** (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTightness_.html)\n\n@param `tightness` Amount of deformation from the original vertices\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTightness"},{name:"PcurveVertex",detail:"PcurveVertex( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPcurveVertex( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS",documentation:"Specifies vertex coordinates for curves. This function may only be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). The first and last points in a series of `PcurveVertex` lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with `PcurveVertex` will draw the curve between the second, third, and fourth points. The `PcurveVertex` function is an implementation of Catmull-Rom splines. \n\n[Link to original Processing doc](https://processing.org/reference/curveVertex_.html)\n\n@param `x` The x-coordinate of the vertex\n\n@param `y` The y-coordinate of the vertex\n\n@param `z` The z-coordinate of the vertex\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PcurveVertex"},{name:"Pdecode",detail:"Pdecode( b64img:STRING ): img:PIMAGE\nPdecode( rawimg:BYTES ): img:PIMAGE",documentation:"`Pdecode` takes the image representation on the stack and pushes a Pimage object on the stack. This object can only be used as an input for [`Pset`](/doc/Pset), [`Pimage`](/doc/Pimage), [`Pbackground`](/doc/Pbackground).\n\nInput string must start with the header `data:image/png;base64,`.\n\nSupported input types: PNG, GIF, JPG.\n\n@param `img` Processing Pimage object.\n\n@param `rawimg` Image bytes.\n\n@param `b64img` Base64 encoded image string\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pdecode"},{name:"Pdist",detail:"Pdist( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE z1:DOUBLE x2:DOUBLE y2:DOUBLE z2:DOUBLE ): pg:PGRAPHICS\nPdist( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE ): pg:PGRAPHICS",documentation:"Calculates the distance between two points, in 2D or 3D space.\n\n\n[Link to original Processing doc](https://processing.org/reference/dist_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `z1` z-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pdist"},{name:"Pellipse",detail:"Pellipse( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS",documentation:"Draws an ellipse (oval) to the screen. An ellipse with equal width and height is a circle. By default, the first two parameters set the location, and the third and fourth parameters set the shape's width and height. The origin may be changed with the [`PellipseMode`](/doc/PellipseMode) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/ellipse_.html)\n\n@param `a` float: x-coordinate of the ellipse\n\n@param `b` float: y-coordinate of the ellipse\n\n@param `c` float: width of the ellipse by default\n\n@param `d` float: height of the ellipse by default\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pellipse"},{name:"PellipseMode",detail:"PellipseMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",documentation:"Modifies the location from which ellipses are drawn by changing the way in which parameters given to [`Pellipse`](/doc/Pellipse) are intepreted.\n\nThe default mode is **ellipseMode(CENTER)**, which interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**ellipseMode(RADIUS)** also uses the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, but uses the third and fourth parameters to specify half of the shapes's width and height.\n\n**ellipseMode(CORNER)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**ellipseMode(CORNERS)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the location of one corner of the ellipse's bounding box, and the third and fourth parameters as the location of the opposite corner.\n\n[Link to original Processing doc](https://processing.org/reference/ellipseMode_.html)\n\n@param `mode` Either CENTER, RADIUS, CORNER, or CORNERS\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PellipseMode"},{name:"Pencode",detail:"Pencode( pg:PGRAPHICS ): b64img:STRING\nPencode( pg:PGRAPHICS metadata:MAP ): b64img:STRING",documentation:"`Pencode` function takes a processing graphic object on the top of the stack, render it to a png file, encode it in base64, prefix the result with the standard png header \"data:image/png;base64,\".\n\nThe resulting string is ready to use in an html document.\n\n@param `pg` Processing graphic object.\n\n@param `b64img` Base64 encoded image string, ready to use in an html page.\n\n@param `metadata` Map of metadata to add to the PNG. Accepted keys are 'tEXt', 'zTXt' and 'iTXt', while values are lists of maps with 'keyword' and 'text' keys.\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pencode"},{name:"PendContour",detail:"PendContour( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Use the [`PbeginContour`](/doc/PbeginContour) and `PendContour` function to create negative shapes within shapes such as the center of the letter 'O'. [`PbeginContour`](/doc/PbeginContour) begins recording vertices for the shape and `PendContour` stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a [`PbeginContour`](/doc/PbeginContour)/`PendContour` pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n[Link to original Processing doc](https://processing.org/reference/endContour_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PendContour"},{name:"PendShape",detail:"PendShape( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS\nPendShape( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"The `PendShape` function is the companion to [`PbeginShape`](/doc/PbeginShape) and may only be called after [`PbeginShape`](/doc/PbeginShape). When `Pendshape` is called, all of image data defined since the previous call to [`PbeginShape`](/doc/PbeginShape) is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end). \n\nUp to Warp 10 1.2.18, `PendShape` could be called without the **mode** parameter. It defaults to OPEN.\n\n[Link to original Processing doc](https://processing.org/reference/endShape_.html)\n\n@param `mode` Use CLOSE to close the shape, OPEN otherwise.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PendShape"},{name:"Pfill",detail:"Pfill( pg:PGRAPHICS argb:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS gray:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS argb:LONG alpha:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS v1:LONG v2:LONG v3:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS v1:LONG v2:LONG v3:LONG alpha:LONG ): pg:PGRAPHICS",documentation:'Sets the color used to fill shapes. For example, if you run **fill(204, 102, 0)**, all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current [`PcolorMode`](/doc/PcolorMode). The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\nThe value for the "gray" parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\nTo change the color of an image or a texture, use [`Ptint`](/doc/Ptint).\n\n[Link to original Processing doc](https://processing.org/reference/fill_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n',tags:["processing"],since:"1.0.0",OPB64name:"Pfill"},{name:"Pfilter",detail:"Pfilter( pg:PGRAPHICS kind:STRING ): pg:PGRAPHICS\nPfilter( pg:PGRAPHICS kind:STRING param:DOUBLE ): pg:PGRAPHICS",documentation:"Filters the display window using a preset filter or with a custom shader. Using a shader with `Pfilter` is much faster than without. Shaders require the P2D or P3D renderer in size().\n\n\nThe presets options are:\n\n+ **THRESHOLD** Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The parameter must be between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n+ **GRAY** Converts any colors in the image to grayscale equivalents. No parameter is used.\n+ **OPAQUE** Sets the alpha channel to entirely opaque. No parameter is used.\n+ **INVERT** Sets each pixel to its inverse value. No parameter is used.\n+ **POSTERIZE** Limits each channel of the image to the number of colors specified as the parameter. The parameter can be set to values between 2 and 255, but results are most noticeable in the lower ranges.\n+ **BLUR** Executes a Guassian blur with the level parameter specifying the extent of the blurring. If no parameter is used, the blur is equivalent to Guassian blur of radius 1. Larger values increase the blur.\n+ **ERODE** Reduces the light areas. No parameter is used.\n+ **DILATE** Increases the light areas. No parameter is used.\n\n\n[Link to original Processing doc](https://processing.org/reference/filter_.html)\n\n@param `kind` Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE\n\n@param `param` unique for each, see above\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.2.17",OPB64name:"J5OdQ6G_RV"},{name:"Pget",detail:"Pget( pg:PGRAPHICS ): pg:PGRAPHICS img:PIMAGE\nPget( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS color:LONG\nPget( pg:PGRAPHICS x:NUMBER y:NUMBER w:NUMBER h:NUMBER ): pg:PGRAPHICS img:PIMAGE",documentation:"Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned (same as `Pcopy`). Use the **x** and **y** parameters to get the value of one pixel. Get a section of the display window by specifying additional **w** and **h** parameters. When getting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\nIf the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with **colorMode(HSB)**, the numbers returned will be in RGB format.\n\nGetting the color of a single pixel with **get(x, y)** is easy, but not as fast as grabbing the data directly from [`Ppixels`](/doc/Ppixels).\n\n[Link to original Processing doc](https://processing.org/reference/get_.html)\n\n@param `x` int: x-coordinate of the pixel\n\n@param `y` int: y-coordinate of the pixel\n\n@param `w` int: width of pixel rectangle to get\n\n@param `h` int: height of pixel rectangle to get\n\n@param `img` PIMAGE object\n\n@param `color` Color of the pixel, 32bits ARGB format.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pget"},{name:"Pgreen",detail:"Pgreen( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS green:DOUBLE",documentation:"Extracts the green value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pgreen` function is easy to use and understand, but it is slower than bit shifting. \n\n\n[Link to original Processing doc](https://processing.org/reference/green_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `green` Green component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pgreen"},{name:"Phue",detail:"Phue( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS hue:DOUBLE",documentation:"Extracts the hue value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/hue_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `hue` Hue component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Phue"},{name:"Pimage",detail:"Pimage( pg:PGRAPHICS img:PIMAGE a:NUMBER b:NUMBER ): pg:PGRAPHICS\nPimage( pg:PGRAPHICS img:PIMAGE a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS",documentation:"The `Pimage` function draws a Pimage (see [`Pdecode`](/doc/Pdecode)) on a PGraphic object.\n\nThe **img** parameter specifies the image to display and by default the **a** and **b** parameters define the location of its upper-left corner. The image is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PimageMode`](/doc/PimageMode) function can be used to change the way these parameters draw the image.\n\nThe color of an image may be modified with the [`Ptint`](/doc/Ptint) function. This function will maintain transparency for GIF and PNG images.\n\n[Link to original Processing doc](https://processing.org/reference/image_.html)\n\n@param `img` PImage: the image to display\n\n@param `a` float: x-coordinate of the image by default\n\n@param `b` float: y-coordinate of the image by default\n\n@param `c` float: width to display the image by default\n\n@param `d` float: height to display the image by default\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pimage"},{name:"PimageMode",detail:"PimageMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",documentation:"Modifies the location from which images are drawn by changing the way in which parameters given to [`Pimage`](/doc/Pimage) are intepreted.\n\nThe default mode is **imageMode(CORNER)**, which interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the upper-left corner of the image. If two additional parameters are specified, they are used to set the image's width and height.\n\n**imageMode(CENTER)** interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the image's center point. If two additional parameters are specified, they are used to set the image's width and height.\n\n\n[Link to original Processing doc](https://processing.org/reference/imageMode_.html)\n\n@param `mode` could be CORNER or CENTER\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PimageMode"},{name:"Plerp",detail:"Plerp( pg:PGRAPHICS start:NUMBER stop:NUMBER amt:NUMBER ): pg:PGRAPHICS",documentation:"Calculates a number between two numbers at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for creating motion along a straight path and for drawing dotted lines, or any linear interpolation.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerp_.html)\n\n@param `start` first value\n\n@param `stop` second value\n\n@param `amt` float between 0.0 and 1.0\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Plerp"},{name:"PlerpColor",detail:"PlerpColor( pg:PGRAPHICS c1:NUMBER c2:NUMBER amt:NUMBER ): pg:PGRAPHICS outcolor:LONG",documentation:"Calculates a color between two colors at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 is equal to the first point, 0.1 is very near the first point, 0.5 is halfway in between, etc. \n\nAn amount below 0 will be treated as 0. Likewise, amounts above 1 will be capped at 1. This is different from the behavior of `Plerp`, but necessary because otherwise numbers outside the range will produce strange and unexpected colors.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerpColor_.html)\n\n@param `c1` interpolate from this color\n\n@param `c2` interpolate to this color\n\n@param `amt` between 0.0 and 1.0\n\n@param `outcolor` the interpolated result\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PlerpColor"},{name:"Pline",detail:"Pline( pg:PGRAPHICS x1:NUMBER y1:NUMBER x2:NUMBER y2:NUMBER ): pg:PGRAPHICS\nPline( pg:PGRAPHICS x1:NUMBER y1:NUMBER z1:NUMBER x2:NUMBER y2:NUMBER z2:NUMBER ): pg:PGRAPHICS",documentation:"Draws a line (a direct path between two points) to the screen. The version of `Pline` with four parameters draws the line in 2D.  To color a line, use the [`Pstroke`](/doc/Pstroke) function. A line cannot be filled, therefore the [`Pfill`](/doc/Pfill) function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the [`PstrokeWeight`](/doc/PstrokeWeight) function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the **z** parameter requires the P3D parameter.\n\n\n[Link to original Processing doc](https://processing.org/reference/line_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z1` z-coordinate of the first point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pline"},{name:"PloadShape",detail:"PloadShape( svg:STRING ): Pshape:PSHAPE",documentation:"`PloadShape` can load a [SVG image](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) and return a PSHAPE object. WarpScript does not support [OBJ files](https://en.wikipedia.org/wiki/Wavefront_.obj_file) yet. \n\nThis feature is experimental, some files may render empty. \n\n@param `svg` A one line or a multiline SVG string.\n\n@param `Pshape` A PSHAPE object which can be used with Pshape.\n\n",tags:["processing"],since:"1.2.18",OPB64name:"PloadShape"},{name:"Pmag",detail:"Pmag( pg:PGRAPHICS a:NUMBER b:NUMBER ): pg:PGRAPHICS mag:DOUBLE",documentation:'Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly used in computer graphics and linear algebra. Because it has no "start" position, the magnitude of a vector can be thought of as the distance from the coordinate 0,0 to its x,y value. Therefore, `Pmag` is a shortcut for writing **0 0 x y Pdist**. It is exactly the same as warpscript function [`HYPOT`](/doc/HYPOT).\n\n3D is not yet supported.\n\n[Link to original Processing doc](https://processing.org/reference/mag_.html)\n\n@param `a` first value\n\n@param `b` second value\n\n@param `mag` result\n\n@param `pg` Processing graphic object\n\n',tags:["processing"],since:"1.0.0",OPB64name:"Pmag"},{name:"Pmap",detail:"Pmap( pg:PGRAPHICS value:DOUBLE start1:DOUBLE stop1:DOUBLE start2:DOUBLE stop2:DOUBLE ): pg:PGRAPHICS output:DOUBLE",documentation:"Re-maps a number from one range to another.\n\nIn the first example, the number 25 is converted from a value in the range of 0 to 100 into a value that ranges from the left edge of the window (0) to the right edge (width).\n\n\nAs shown in the second example, numbers outside of the range are not clamped to the minimum and maximum parameters values, because out-of-range values are often intentional and useful.\n\n\n[Link to original Processing doc](https://processing.org/reference/map_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start1` lower bound of the value's current range\n\n@param `stop1` upper bound of the value's current range\n\n@param `start2` lower bound of the value's target range\n\n@param `stop2` upper bound of the value's target range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pmap"},{name:"Pmask",detail:"Pmask( mask_image:PIMAGE orginal_img:PIMAGE ): masked_image:PIMAGE\nPmask( mask_image:PIMAGE orginal_grp:PGRAPHICS ): masked_grp:PGRAPHICS\nPmask( mask_grp:PGRAPHICS orginal_img:PIMAGE ): masked_image:PIMAGE\nPmask( mask_grp:PGRAPHICS orginal_grp:PGRAPHICS ): masked_grp:PGRAPHICS",documentation:"The `Pmask` function copies the blue channel of an image to the alpha channel of an other.\n\nAs **PGRAPHICS** intances are alse **PIMAGE** instances, you can use this fonction with **PGRAPHICS**.\n\n@param `orginal_img` PImage to be masked\n\n@param `mask_image` Pimage to serve as mask\n\n@param `masked_image` Masked Pimage\n\n@param `orginal_grp` PGraphics to be masked\n\n@param `mask_grp` PGraphics to serve as mask\n\n@param `masked_grp` Masked PGraphics\n\n",tags:["processing"],since:"2.7.0",OPB64name:"Pmask"},{name:"PnoClip",detail:"PnoClip( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Disables the clipping previously started by the [`Pclip`](/doc/Pclip) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/noClip_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoClip"},{name:"PnoFill",detail:"PnoFill( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Disables filling geometry. If both [`PnoStroke`](/doc/PnoStroke) and `PnoFill` are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noFill_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoFill"},{name:"PnoStroke",detail:"PnoStroke( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Disables drawing the stroke (outline). If both `PnoStroke` and [`PnoFill`](/doc/PnoFill) are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noStroke_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoStroke"},{name:"PnoTint",detail:"PnoTint( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Removes the current fill value for displaying images and reverts to displaying images with their original hues.\n\n\n[Link to original Processing doc](https://processing.org/reference/noTint_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PnoTint"},{name:"Pnorm",detail:"Pnorm( pg:PGRAPHICS value:NUMBER start:NUMBER stop:NUMBER ): pg:PGRAPHICS output:DOUBLE",documentation:"Normalizes a number from another range into a value between 0 and 1. Identical to `value low high 0 1 Pmap`.\n\nNumbers outside of the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. \n\n\n[Link to original Processing doc](https://processing.org/reference/norm_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start` lower bound of the value's current range\n\n@param `stop` upper bound of the value's current range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pnorm"},{name:"Ppixels",detail:"Ppixels( pg:PGRAPHICS ): pg:PGRAPHICS pixels:LIST<LONG>\nPpixels( img:PIMAGE ): img:PIMAGE pixels:LIST<LONG>",documentation:"Returns an array containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. After **pixels** has been modified, the [`PupdatePixels`](/doc/PupdatePixels) function must be run to update the content of the display window.\n\n\n[Link to original Processing doc](https://processing.org/reference/pixels.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ppixels"},{name:"Ppoint",detail:"Ppoint( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPpoint( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS",documentation:"Draws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point.\n\nUse [`Pstroke`](/doc/Pstroke) to set the color of a `Ppoint`.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight.\n\n\n[Link to original Processing doc](https://processing.org/reference/point_.html)\n\n@param `x` x-coordinate of the point\n\n@param `y` y-coordinate of the point\n\n@param `z` z-coordinate of the point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ppoint"},{name:"PpopMatrix",detail:"PpopMatrix( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The [`PpushMatrix`](/doc/PpushMatrix) function saves the current coordinate system to the stack and `PpopMatrix` restores the prior coordinate system. [`PpushMatrix`](/doc/PpushMatrix) and `PpopMatrix` are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/popMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpopMatrix"},{name:"PpopStyle",detail:"PpopStyle( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"The [`PpushStyle`](/doc/PpushStyle) function saves the current style settings and `PpopStyle` restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with [`PpushStyle`](/doc/PpushStyle), it builds on the current style information. The [`PpushStyle`](/doc/PpushStyle) and `PpopStyle` functions can be nested to provide more control (see example for a demonstration.)\n\n\n[Link to original Processing doc](https://processing.org/reference/popStyle_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpopStyle"},{name:"PpushMatrix",detail:"PpushMatrix( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Pushes the current transformation matrix onto the matrix stack. Understanding `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) requires understanding the concept of a matrix stack. The `PpushMatrix` function saves the current coordinate system to the stack and [`PpopMatrix`](/doc/PpopMatrix) restores the prior coordinate system. `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpushMatrix"},{name:"PpushStyle",detail:"PpushStyle( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"The `PpushStyle` function saves the current style settings and [`PpopStyle`](/doc/PpopStyle) restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `PpushStyle`, it builds on the current style information. The `PpushStyle` and [`PpopStyle`](/doc/PpopStyle) functions can be nested to provide more control. (See example for a demonstration.)\n\n\nThe style information controlled by the following functions are included in the style:fill, stroke, tint, strokeWeight, strokeCap, strokeJoin, imageMode, rectMode, ellipseMode, shapeMode, colorMode, textAlign, textFont, textMode, textSize, textLeading, emissive, specular, shininess, ambient.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushStyle_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PpushStyle"},{name:"Pquad",detail:"Pquad( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS",documentation:"A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n\n\n[Link to original Processing doc](https://processing.org/reference/quad_.html)\n\n@param `x1` float: x-coordinate of the first corner\n\n@param `y1` float: y-coordinate of the first corner\n\n@param `x2` float: x-coordinate of the second corner\n\n@param `y2` float: y-coordinate of the second corner\n\n@param `x3` float: x-coordinate of the third corner\n\n@param `y3` float: y-coordinate of the third corner\n\n@param `x4` float: x-coordinate of the fourth corner\n\n@param `y4` float: y-coordinate of the fourth corner\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pquad"},{name:"PquadraticVertex",detail:"PquadraticVertex( pg:PGRAPHICS cx:DOUBLE cy:DOUBLE x3:DOUBLE y3:DOUBLE ): pg:PGRAPHICS",documentation:"Specifies vertex coordinates for quadratic Bezier curves. Each call to `PquadraticVertex` defines the position of one control point and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PquadraticVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when there is no MODE parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/quadraticVertex_.html)\n\n@param `cx` the x-coordinate of the control point\n\n@param `cy` the y-coordinate of the control point\n\n@param `x3` the x-coordinate of the anchor point\n\n@param `y3` the y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PquadraticVertex"},{name:"Prect",detail:"Prect( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS\nPrect( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER r:NUMBER ): pg:PGRAPHICS\nPrect( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER tl:NUMBER tr:NUMBER br:NUMBER bl:NUMBER ): pg:PGRAPHICS",documentation:"Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. The way these parameters are interpreted, however, may be changed with the [`PrectMode`](/doc/PrectMode) function.\n\n\n\nTo draw a rounded rectangle, add a fifth parameter, which is used as the radius value for all four corners.\n\n\n\nTo use a different radius value for each corner, include eight parameters. When using eight parameters, the latter four set the radius of the arc at each corner separately, starting with the top-left corner and moving clockwise around the rectangle.\n\n\n[Link to original Processing doc](https://processing.org/reference/rect_.html)\n\n@param `a` float: x-coordinate of the rectangle by default\n\n@param `b` float: y-coordinate of the rectangle by default\n\n@param `c` float: width of the rectangle by default\n\n@param `d` float: height of the rectangle by default\n\n@param `r` float: radii for all four corners\n\n@param `tl` float: radius for top-left corner\n\n@param `tr` float: radius for top-right corner\n\n@param `br` float: radius for bottom-right corner\n\n@param `bl` float: radius for bottom-left corner\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Prect"},{name:"PrectMode",detail:"PrectMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",documentation:"Modifies the location from which rectangles are drawn by changing the way in which parameters given to [`Prect`](/doc/Prect) are intepreted.\n\nThe default mode is **CORNER**, which interprets the first two parameters of [`Prect`](/doc/Prect) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**CORNERS** interprets the first two parameters of [`Prect`](/doc/Prect) as the location of one corner, and the third and fourth parameters as the location of the opposite corner.\n\n**CENTER** interprets the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**RADIUS** also uses the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, but uses the third and fourth parameters to specify half of the shape's width and height.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n\n[Link to original Processing doc](https://processing.org/reference/rectMode_.html)\n\n@param `mode` either CORNER, CORNERS, CENTER, or RADIUS\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PrectMode"},{name:"Pred",detail:"Pred( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS red:DOUBLE",documentation:"Extracts the red value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pred` function is easy to use and understand, but it is slower than bit shifting. \n\n[Link to original Processing doc](https://processing.org/reference/red_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `red` Red component of the input color\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pred"},{name:"PresetMatrix",detail:"PresetMatrix( pg:PGRAPHICS ): pg:PGRAPHICS",documentation:"Replaces the current matrix with the identity matrix. \n\n\n[Link to original Processing doc](https://processing.org/reference/resetMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PresetMatrix"},{name:"Protate",detail:"Protate( pg:PGRAPHICS angle:NUMBER ): pg:PGRAPHICS",documentation:"Rotates the amount specified by the **angle** parameter. Angles must be specified in radians (values from **0** to **2 PI**). \n\nThe coordinates are always rotated around their relative position to the origin. Positive numbers rotate objects in a clockwise direction and negative numbers rotate in the couterclockwise direction. Transformations apply to everything that happens afterward, and subsequent calls to the function compound the effect. For example, calling `pi 2.0 / Protate` once and then calling `pi 2.0 / Protate` a second time is the same as a single `pi Protate`. \n \n\nTechnically, `Protate` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/rotate_.html)\n\n@param `angle` angle of rotation specified in radians\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Protate"},{name:"Psaturation",detail:"Psaturation( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS saturation:DOUBLE",documentation:"Extracts the saturation value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/saturation_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `saturation` Saturation component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Psaturation"},{name:"Pscale",detail:"Pscale( pg:PGRAPHICS s:NUMBER ): pg:PGRAPHICS\nPscale( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPscale( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS",documentation:"Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call `2.0 Pscale` increases the dimension of a shape by 200%.\n\n\n\nTransformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling `2.0 Pscale` and then `1.5 Pscale` is the same as `3.0 Pscale`. This function can be further controlled with [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/scale_.html)\n\n@param `s` percentage to scale the object\n\n@param `x` percentage to scale the object in the x-axis\n\n@param `y` percentage to scale the object in the y-axis\n\n@param `z` percentage to scale the object in the z-axis\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pscale"},{name:"Pset",detail:"Pset( pg:PGRAPHICS x:NUMBER y:NUMBER c:NUMBER ): pg:PGRAPHICS\nPset( pg:PGRAPHICS x:NUMBER y:NUMBER img:PIMAGE ): pg:PGRAPHICS",documentation:"Changes the color of any pixel, or writes an image directly to the display window.\n\n\n\nThe **x** and **y** parameters specify the pixel to change and the **c** parameter specifies the color value. The **c** parameter is interpreted according to the current color mode.  (The default color mode is RGB values from 0 to 255.)  When setting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\n\n\nSetting the color of a single pixel with **set(x, y)** is easy, but not as fast as putting the data directly into the list of pixels returned by  [`Ppixels`](/doc/Ppixels).\n\n\n[Link to original Processing doc](https://processing.org/reference/set_.html)\n\n@param `x` X-coordinate of the pixel\n\n@param `y` Y-coordinate of the pixel\n\n@param `c` Any value of the color datatype\n\n@param `img` Image to copy into the original image\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pset"},{name:"Pshape",detail:"Pshape( pg:PGRAPHICS shape:PSHAPE ): pg:PGRAPHICS\nPshape( pg:PGRAPHICS shape:PSHAPE x:DOUBLE y:DOUBLE ): pg:PGRAPHICS\nPshape( pg:PGRAPHICS shape:PSHAPE a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE ): pg:PGRAPHICS",documentation:"Draws shapes to the display window. Shapes must be loaded with [`PloadShape`](/doc/PloadShape). Processing currently works with SVG, OBJ, and custom-created shapes. WrapScript only support SVG. The **shape** parameter specifies the shape to display and the coordinate parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PshapeMode`](/doc/PshapeMode) function can be used to change the way these parameters are interpreted.\n\n\n[Link to original Processing doc](https://processing.org/reference/shape_.html)\n\n@param `shape` the shape to display\n\n@param `x` x-coordinate of the shape\n\n@param `y` y-coordinate of the shape\n\n@param `a` x-coordinate of the shape\n\n@param `b` y-coordinate of the shape\n\n@param `c` width to display the shape\n\n@param `d` height to display the shape\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.2.18",OPB64name:"Pshape"},{name:"PshapeMode",detail:"PshapeMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",documentation:"Modifies the location from which shapes draw. The default mode is **shapeMode(CORNER)**, which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. The syntax **shapeMode(CORNERS)** uses the first and second parameters of [`Pshape`](/doc/Pshape) to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax **shapeMode(CENTER)** draws the shape from its center point and uses the third and forth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. \n\n\n[Link to original Processing doc](https://processing.org/reference/shapeMode_.html)\n\n@param `mode` int: either CORNER, CORNERS, CENTER\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PshapeMode"},{name:"PshearX",detail:"PshearX( pg:PGRAPHICS angle:NUMBER ): pg:PGRAPHICS",documentation:"Shears a shape around the x-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearX` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearX_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PshearX"},{name:"PshearY",detail:"PshearY( pg:PGRAPHICS angle:NUMBER ): pg:PGRAPHICS",documentation:"Shears a shape around the y-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearY` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearY_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PshearY"},{name:"Psize",detail:"Psize( img:PIMAGE ): width:LONG height:LONG\nPsize( pg:PGRAPHICS ): width:LONG height:LONG",documentation:"The `Psize` function returns the pixel `width` and `height` of a Pimage or PGraphics object.\n\n@param `img` PImage instance to measure.\n\n@param `pg` PGraphics instance to measure.\n\n@param `height` Object height in pixels.\n\n@param `width` Object height in pixels.\n\n",tags:["processing"],since:"2.6.0",OPB64name:"Psize"},{name:"Psphere",detail:"Psphere( pg:PGRAPHICS r:NUMBER ): pg:PGRAPHICS",documentation:"A sphere is a hollow ball made from tessellated triangles.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphere_.html)\n\n@param `r` the radius of the sphere\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Psphere"},{name:"PsphereDetail",detail:"PsphereDetail( pg:PGRAPHICS res:NUMBER ): pg:PGRAPHICS\nPsphereDetail( pg:PGRAPHICS ures:NUMBER vres:NUMBER ): pg:PGRAPHICS",documentation:"Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you are going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until `PsphereDetail` is called again with a new parameter and so should **not** be called prior to every [`Psphere`](/doc/Psphere) statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphereDetail_.html)\n\n@param `res` int: number of segments (minimum 3) used per full circle revolution\n\n@param `ures` int: number of segments used longitudinally per full circle revolutoin\n\n@param `vres` int: number of segments used latitudinally from top to bottom\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PsphereDetail"},{name:"Pstroke",detail:"Pstroke( pg:PGRAPHICS argb:LONG ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS gray:DOUBLE ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS argb:LONG alpha:DOUBLE ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS gray:DOUBLE alpha:DOUBLE ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS",documentation:"Sets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current **colorMode** The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n[Link to original Processing doc](https://processing.org/reference/stroke_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pstroke"},{name:"PstrokeCap",detail:"PstrokeCap( pg:PGRAPHICS cap:STRING ): pg:PGRAPHICS",documentation:"Sets the style for rendering line endings. These ends are either squared, extended, or rounded, each of which specified with the corresponding parameters: SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n\n\n[Link to original Processing doc](https://processing.org/reference/strokeCap_.html)\n\n@param `cap` Either SQUARE, PROJECT, or ROUND\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeCap"},{name:"PstrokeJoin",detail:"PstrokeJoin( pg:PGRAPHICS join:STRING ): pg:PGRAPHICS",documentation:"Sets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER. \n\n\n[Link to original Processing doc](https://processing.org/reference/strokeJoin_.html)\n\n@param `join` Either MITER, BEVEL, ROUND\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeJoin"},{name:"PstrokeWeight",detail:"PstrokeWeight( pg:PGRAPHICS weight:NUMBER ): pg:PGRAPHICS",documentation:"Sets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight. See [`Ppoint`](/doc/Ppoint) example.\n\n[Link to original Processing doc](https://processing.org/reference/strokeWeight_.html)\n\n@param `weight` The weight (in pixels) of the stroke.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeWeight"},{name:"Ptext",detail:"Ptext( pg:PGRAPHICS s:STRING x:DOUBLE y:DOUBLE ): pg:PGRAPHICS\nPtext( pg:PGRAPHICS s:STRING x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE ): pg:PGRAPHICS",documentation:"Draws text to the screen. Displays the information specified in the first parameter on the screen in the position specified by the additional parameters. A default font will be used unless a font is set with the [`PtextFont`](/doc/PtextFont) function and a default size will be used unless a font is set with [`PtextSize`](/doc/PtextSize). Change the color of the text with the [`Pfill`](/doc/Pfill) function. The text displays in relation to the [`PtextAlign`](/doc/PtextAlign) function, which gives the option to draw to the left, right, and center of the coordinates.\n\n\n\nThe **x2** and **y2** parameters define a rectangular area to display within and may only be used with string data. When these parameters are specified, they are interpreted based on the current [`PrectMode`](/doc/PrectMode) setting. Text that does not fit completely within the rectangle specified will not be drawn to the screen.\n\n\n\nNote that Processing now lets you call `Ptext` without first specifying a PFont with [`PtextFont`](/doc/PtextFont). In that case, a generic sans-serif font will be used instead.\n\n\n[Link to original Processing doc](https://processing.org/reference/text_.html)\n\n@param `s` the string to be displayed\n\n@param `x` by default, x-coordinate of text\n\n@param `y` by default, y-coordinate of text\n\n@param `x1` by default, the x-coordinate of text, see PrectMode for more info\n\n@param `y1` by default, the y-coordinate of text, see PrectMode for more info\n\n@param `x2` by default, the width of the text box, see PrectMode for more info\n\n@param `y2` by default, the height of the text box, see PrectMode for more info\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptext"},{name:"PtextAlign",detail:"PtextAlign( pg:PGRAPHICS alignX:STRING ): pg:PGRAPHICS\nPtextAlign( pg:PGRAPHICS alignX:STRING alignY:STRING ): pg:PGRAPHICS",documentation:"Sets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the **x** and **y** parameters of the [`Ptext`](/doc/Ptext) function.\n\n\n\nAn optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current [`PtextDescent`](/doc/PtextDescent). For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.\n\n\n\nWhen using [`Ptext`](/doc/Ptext) with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)\n\n\n\nThe vertical alignment is based on the value of [`PtextAscent`](/doc/PtextAscent), which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of [`PtextAscent`](/doc/PtextAscent) or [`PtextDescent`](/doc/PtextDescent) so that the hack works even if you change the size of the font.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAlign_.html)\n\n@param `alignX` Horizontal alignment, either LEFT, CENTER, or RIGHT\n\n@param `alignY` Vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextAlign"},{name:"PtextAscent",detail:"PtextAscent( pg:PGRAPHICS ): pg:PGRAPHICS ascent:DOUBLE",documentation:"Returns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the `PtextAscent` and [`PtextDescent`](/doc/PtextDescent) values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAscent_.html)\n\n@param `ascent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextAscent"},{name:"PtextDescent",detail:"PtextDescent( pg:PGRAPHICS ): pg:PGRAPHICS descent:DOUBLE",documentation:"Returns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the [`PtextAscent`](/doc/PtextAscent) and `PtextDescent` values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textDescent_.html)\n\n@param `descent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextDescent"},{name:"PtextFont",detail:"PtextFont( pg:PGRAPHICS font:PFONT ): pg:PGRAPHICS\nPtextFont( pg:PGRAPHICS font:PFONT size:NUMBER ): pg:PGRAPHICS",documentation:"Sets the current font that will be drawn with the [`Ptext`](/doc/Ptext) function. Fonts must be created for Processing with [`PcreateFont`](/doc/PcreateFont) before they can be used. The font set through `PtextFont` will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/textFont_.html)\n\n@param `font` Any variable of the type PFont\n\n@param `size` the size of the letters in pixel.\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextFont"},{name:"PtextLeading",detail:"PtextLeading( pg:PGRAPHICS leading:NUMBER ): pg:PGRAPHICS",documentation:"Sets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.  Note, however, that the leading is reset by [`PtextSize`](/doc/PtextSize). For example, if the leading is set to 20 with `20 PtextLeading`, then if `48 PtextSize` is run at a later point, the leading will be reset to the default for the text size of 48.\n\n\n[Link to original Processing doc](https://processing.org/reference/textLeading_.html)\n\n@param `leading` The size in pixels for spacing between lines\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextLeading"},{name:"PtextMode",detail:"PtextMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",documentation:"Sets the way text draws to the screen, either as texture maps or as vector geometry. The default **textMode(MODEL)**, uses textures to render the fonts. The **textMode(SHAPE)** mode draws text using the glyph outlines of individual characters rather than as textures. This mode is only supported with the **PDF** and **P3D** renderer settings. With the **PDF** renderer, you must call **textMode(SHAPE)** before any other drawing occurs. If the outlines are not available, then **textMode(SHAPE)** will be ignored and **textMode(MODEL)** will be used instead.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/textMode_.html)\n\n@param `mode` int: either MODEL or SHAPE\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextMode"},{name:"PtextSize",detail:"PtextSize( pg:PGRAPHICS size:NUMBER ): pg:PGRAPHICS",documentation:"Sets the current font size. This size will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function. Font size is measured in units of pixels.\n\n\n[Link to original Processing doc](https://processing.org/reference/textSize_.html)\n\n@param `size` float: the size of the letters in units of pixels\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextSize"},{name:"PtextWidth",detail:"PtextWidth( pg:PGRAPHICS str:STRING ): pg:PGRAPHICS w:DOUBLE",documentation:"Calculates and returns the width of any character or text string.\n\n\n[Link to original Processing doc](https://processing.org/reference/textWidth_.html)\n\n@param `str` The String of characters to measure\n\n@param `w` The width of the input string\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PtextWidth"},{name:"Ptint",detail:"Ptint( pg:PGRAPHICS argb:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS gray:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS argb:NUMBER alpha:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS",documentation:"Sets the fill value for displaying images. Images can be tinted to specified colors or made transparent by including an alpha value.\n\n\n\nTo apply transparency to an image without affecting its color, use white as the tint color and specify an alpha value. For instance, **tint(255, 128)** will make an image 50pc transparent (assuming the default alpha range of 0-255, which can be changed with [`PcolorMode`](/doc/PcolorMode)).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/tint_.html)\n\n@param `argb` any argb color value.\n\n@param `alpha` opacity of the image\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptint"},{name:"PtoImage",detail:"PtoImage( pg:PGRAPHICS ): img:PIMAGE",documentation:"The `PtoImage` function transforms a `PGRAPHICS` to a `PIMAGE`.\n\nThe `PGRAPHICS` can still be used after the transformation as this function copies the pixel values. This is equivalent to `Pencode Pdecode` but it is a lot faster.\n\n@param `pg` Processing graphic object.\n\n@param `img` Processing Pimage object.\n\n",tags:["processing"],since:"2.1.0",OPB64name:"PtoImage"},{name:"Ptranslate",detail:"Ptranslate( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS",documentation:"Specifies an amount to displace objects within the display window. The **x** parameter specifies left/right translation, the **y** parameter specifies up/down translation.\n\n\n\nTransformations are cumulative and apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling **50 0 Ptranslate** and then **20 0 Ptranslate** is the same as **70 0 Ptranslate**. This function can be further controlled by using [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/translate_.html)\n\n@param `x` left/right translation\n\n@param `y` up/down translation\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptranslate"},{name:"Ptriangle",detail:"Ptriangle( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE ): pg:PGRAPHICS",documentation:"A triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point. \n\n\n[Link to original Processing doc](https://processing.org/reference/triangle_.html)\n\n@param `x1` float: x-coordinate of the first point\n\n@param `y1` float: y-coordinate of the first point\n\n@param `x2` float: x-coordinate of the second point\n\n@param `y2` float: y-coordinate of the second point\n\n@param `x3` float: x-coordinate of the third point\n\n@param `y3` float: y-coordinate of the third point\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Ptriangle"},{name:"PupdatePixels",detail:"PupdatePixels( pg:PGRAPHICS pixels:LIST<LONG> ): pg:PGRAPHICS\nPupdatePixels( img:PIMAGE pixels:LIST<LONG> ): img:PIMAGE",documentation:"Updates the display window with the data in the **pixels[]** array. Use in conjunction with [`Ppixels`](/doc/Ppixels). If you are only reading pixels from the array, there's no need to call `PupdatePixels` - updating is only necessary to apply changes.\n\n[Link to original Processing doc](https://processing.org/reference/updatePixels_.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"PupdatePixels"},{name:"Pvertex",detail:"Pvertex( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPvertex( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS\nPvertex( pg:PGRAPHICS x:NUMBER y:NUMBER u:NUMBER v:NUMBER ): pg:PGRAPHICS\nPvertex( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER u:NUMBER v:NUMBER ): pg:PGRAPHICS",documentation:"All shapes are constructed by connecting a series of vertices. `Pvertex` is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons. It is used exclusively within the [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/vertex_.html)\n\n@param `x` x-coordinate of the vertex\n\n@param `y` y-coordinate of the vertex\n\n@param `z` float: z-coordinate of the vertex\n\n@param `u` float: horizontal coordinate for the texture mapping\n\n@param `v` float: vertical coordinate for the texture mapping\n\n@param `pg` Processing graphic object\n\n",tags:["processing"],since:"1.0.0",OPB64name:"Pvertex"},{name:"Q->",detail:"Q->( input:LONG ): w:DOUBLE x:DOUBLE y:DOUBLE z:DOUBLE",documentation:"The `Q->` function consumes on the stack a [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long and push back the quaternion into\n4 doubles (w, x, y, z, with z being on top).\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `input` Quaternion representation\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"JHoy"},{name:"QCONJUGATE",detail:"QCONJUGATE( quaternion:LONG ): result:LONG",documentation:"The `QCONJUGATE` function performs a [conjugation](https://en.wikipedia.org/wiki/Quaternion#Conjugation,_the_norm,_and_reciprocal) of a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the quaternion conjugate into a long.\n\n@param `quaternion` The input quaternion\n\n@param `result` The conjugated quaternion\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QCONJUGATE"},{name:"QDIVIDE",detail:"QDIVIDE( q:LONG r:LONG ): result:LONG",documentation:"The `QDIVIDE` function divides a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of dividing them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from division *q* by *r*\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QDIVIDE"},{name:"QMULTIPLY",detail:"QMULTIPLY( q:LONG r:LONG ): result:LONG",documentation:"The `QMULTIPLY` function multiplies a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of multiplying them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from multiplication *q* by *r*\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QMULTIPLY"},{name:"QROTATE",detail:"QROTATE( x:DOUBLE y:DOUBLE z:DOUBLE quaternion:LONG ): x:DOUBLE y:DOUBLE z:DOUBLE",documentation:"Rotates a vector by a [quaternion](https://en.wikipedia.org/wiki/Quaternion).\n\nThe `QROTATE` function consumes on the top of the stack three doubles representing a vector(x, y, z) and a long representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the vector rotated into 3 doubles (x, y, z with z being on top).\n\n@param `quaternion` The quaternion used to rotate the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATE"},{name:"QROTATION",detail:"QROTATION( quaternion:LONG ): x:DOUBLE y:DOUBLE z:DOUBLE angle:DOUBLE",documentation:"The `QROTATION` extracts the axis and angle of the rotation represented by the [quaternion](https://en.wikipedia.org/wiki/Quaternion) on the stack.\n\n@param `quaternion` The input quaternion\n\n@param `angle` The angle of rotation\n\n@param `x` The X axis\n\n@param `y` The Y axis\n\n@param `z` The Z axis\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATION"},{name:"QUANTIZE",detail:"QUANTIZE( gts:GTS bounds:LIST<DOUBLE> values:LIST ): qgts:GTS\nQUANTIZE( lgts:LIST<GTS> bounds:LIST<DOUBLE> values:LIST ): lqgts:LIST<GTS>",documentation:'The `QUANTIZE` function produces a quantized version of a Geo Time Series™ by replacing each value with a value from a finite list according to the interval the original value falls in. This function only works on numeric Geo Time Series™.\nThis function can help to "discretify" data before calling [`VALUEHISTOGRAM`](/doc/VALUEHISTOGRAM).\nThe list of intervals is defined as: [-∞,bounds<sub>0</sub>], (bounds<sub>0</sub>,bounds_<sub>1</sub>], (bounds<sub>1</sub>,bounds<sub>2</sub>], ..., (bounds<sub>n-1</sub>,+∞]\n\n@param `values` List of `n+1` values, one for each interval defined by `bounds`. If empty, the list `[ `0` `1` ... `n+1` ]` will be used.\n\n@param `bounds` Sorted list of `n` finite bounds defining `n+1` intervals.\n\n@param `gts` Geo Time Series™ to quantize.\n\n@param `qgts` Quantized GTS.\n\n@param `lgts` List of Geo Time Series™ to quantize.\n\n@param `lqgts` List of quantized GTS.\n\n',tags:["gts"],since:"1.0.0",OPB64name:"QUANTIZE"},{name:"RAND",detail:"RAND(): num:DOUBLE",documentation:"The `RAND` function pushes onto the stack a random floating point number between 0.0 (inclusive) and 1.0 (exlusive) generated by the default random generator.\n\nThis generation is cryptographically secure.\n\n@param `num` Generated random number between 0 and 1.\n\n",tags:["math"],since:"1.0.0",OPB64name:"RAND"},{name:"RANDOM",detail:"RANDOM(): num:DOUBLE",documentation:"The `RANDOM` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThis function is very similar to [SRAND](/doc/SRAND) except the seed is choosen pseudorandomly when the function is first called. Subsequent calls use the same generator.\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",tags:["math"],since:"1.2.23",OPB64name:"RANDOM"},{name:"RANDPDF",detail:"RANDPDF( valueHistogram:MAP ): result:STRING",documentation:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe result if a function pushed onto the stack. This function does not have any arguments.\n\nTo use the function pushed by `RANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",tags:["math","statistics"],since:"1.0.7",OPB64name:"RANDPDF"},{name:"RANGE",detail:"RANGE( [ end:LONG ] ): output:LIST<LONG>\nRANGE( [ start:LONG end:LONG ] ): output:LIST<LONG>\nRANGE( [ start:LONG end:LONG step:LONG ] ): output:LIST<LONG>",documentation:"`RANGE` pushes onto the stack a list of integers in the given range [start included, end excluded[. If start is not in the parameter list, start=0.\n\n`RANGE` also accepts a step parameter in the parameter list.\n\n\n@param `start` The start of range, default is 0\n\n@param `end` The end of range\n\n@param `step` The step between integers, default is 1\n\n@param `output` The list of every integers in the range [start end[\n\n",tags:["counters"],since:"1.0.0",OPB64name:"RANGE"},{name:"RANGECOMPACT",detail:"RANGECOMPACT( gts:GTS ): compacted:GTS\nRANGECOMPACT( lgts:LIST<GTS> ): lcompacted:LIST<GTS>",documentation:"The `RANGECOMPACT` simplifies a Geo Time Series™ by simplifying ranges of identical values (with identical latitude, longitude and elevation), retaining only the first and last ticks of each range.\n\n@param `gts` Geo Time Series™ to compact.\n\n@param `compacted` Compacted GTS.\n\n@param `lgts` List of Geo Time Series™ to compact.\n\n@param `lcompacted` List of compacted GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RANGECOMPACT"},{name:"RAWDTW",detail:"RAWDTW( gts1:GTS gts2:GTS threshold:DOUBLE ): dtw:DOUBLE",documentation:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe computation is performed on the raw Geo Time Series™, no transformation is applied to them.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",tags:["gts","distance"],since:"1.2.11",OPB64name:"RAWDTW"},{name:"REDEFS",detail:"REDEFS( flag:BOOLEAN ): ",documentation:"The `REDEFS` function allows or disallows execution of redefined functions.\n\n@param `flag` Shall we allow or disallow the execution of redefined functions.\n\n",tags:["stack"],since:"1.2.5",OPB64name:"REDEFS"},{name:"REDUCE",detail:"REDUCE( [ gts:LIST<GTS>+ labels:LIST<STRING> reducer:AGGREGATOR ] ): result:LIST<GTS>\nREDUCE( [ gts:LIST<GTS>+ labels:LIST<STRING> reducer:AGGREGATOR overrideTick:BOOLEAN ] ): result:LIST<GTS>",documentation:"The `REDUCE` framework groups Geo Time Series™ by equivalence classes based on label values and applies a function on each equivalence class of Geo Time Series™, considering the values of each tick and producing one GTS per equivalence class.\n\nAs the selected reducer function is applied tick by tick, it is usually wise to [`BUCKETIZE`](/doc/BUCKETIZE) the GTS first with a common value of `lastbucket`.\n\nThe labels whose values are common to all the GTS in an equivalence class will be retained.\n\nSince 2.1 you can make REDUCE override the GTSs ticks. This usage in mainly to be used in conjuction with [`MACROREDUCER`](/doc/MACROREDUCER).\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` List of resulting Geo Time Series™.\n\n@param `overrideTick` Boolean, if true allows the reducer to modify the ticks of the GTSs. If not set, the reducer cannot modify the ticks.\n\n",tags:["reducer","framework"],since:"1.0.0",OPB64name:"REDUCE"},{name:"RELABEL",detail:"RELABEL( gts:GTS labels:MAP ): gts:GTS\nRELABEL( lgts:LIST<GTS> labels:MAP ): lgts:LIST<GTS>\nRELABEL( encoder:GTSENCODER labels:MAP ): encoder:GTSENCODER\nRELABEL( lencoder:LIST<GTSENCODER> labels:MAP ): lencoder:LIST<GTSENCODER>",documentation:"Modifies the labels of a Geo Time Series™. The `RELABEL` function expects a parameter MAP whose entries are labels to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `RELABEL` function will use the rest of the MAP as the actual labels to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing labels.\n\nAn entry with an empty STRING value or a NULL value will have the effect of removing the label from the GTS' labels.        \n\n@param `labels` Parameter map of label names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `encoder` Encoder to relabel\n\n@param `lencoder` List of encoders to relabel\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RELABEL"},{name:"REMOVE",detail:"REMOVE( inputlist:LIST index:LONG ): outputlist:LIST removeditem:ANY\nREMOVE( inputmap:MAP key:ANY ): outputmap:MAP removeditem:ANY\nREMOVE( inputgts:GTS pointindex:LONG ): outputgts:GTS removedpoint:LIST",documentation:"Removes an entry from a MAP or from a LIST.\n\nThe `REMOVE` function consumes a list (or a map) and a index (or a key), then remove the entry.\nIt lets the input on the stack and puts the removed item on top of the stack. \nAs a result, the input map or list is modified and the map or list left on top of the stack is *not* a copy. \n\nIf the index is out of bound, the returned value is `NULL` and the list or array is unmodified.\nIf the key does not exist in the map, it returns null as the removed entry.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **GTS**.\n\nSince 2.7, `REMOVE` can be called on a **GTS**.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean\n\n@param `inputmap` The reference to the map to be modified\n\n@param `index` The index of the list, 0 for the first item\n\n@param `inputlist` The reference to the list to be modified\n\n@param `removeditem` Depending on map or list content, could be any type\n\n@param `outputmap` The input map modified\n\n@param `outputlist` The input list modified\n\n@param `pointindex` Index of the point in the GTS, 0-indexed, handles negative indexing.\n\n@param `inputgts` The GTS to remove the point from.\n\n@param `removedpoint` The removed point. List of timestamp, latitude, longitude, elevation and value.\n\n@param `outputgts` The acopy of the original GTS with the requested point removed.\n\n",tags:["maps","lists"],since:"1.0.0",OPB64name:"REMOVE"},{name:"REMOVETICK",detail:"REMOVETICK( gts:GTS tick:LONG ): pruned:GTS\nREMOVETICK( gts:GTS lticks:LIST<LONG> ): pruned:GTS\nREMOVETICK( gts:GTS lticks:SET<LONG> ): pruned:GTS",documentation:"The `REMOVETICK` function transforms a Geo Time Series™ by removing all occurrences of a tick or ticks.\n\n@param `tick` Tick (timestamp) to remove.\n\n@param `lticks` List or Set of ticks to remove.\n\n@param `gts` Geo Time Series™ to transform.\n\n@param `pruned` Tranformed Geo Time Series™.\n\n",tags:["gts"],since:"1.2.19",OPB64name:"REMOVETICK"},{name:"RENAME",detail:"RENAME( gts:GTS name:STRING ): gts:GTS\nRENAME( lgts:LIST<GTS> name:STRING ): lgts:LIST<GTS>\nRENAME( encoder:GTSENCODER name:STRING ): encoder:GTSENCODER\nRENAME( lencoder:LIST<GTSENCODER> name:STRING ): lencoder:LIST<GTSENCODER>",documentation:"The `RENAME` function changes the name of a Geo Time Series™, an Encoder or a list thereof. This operation may be required prior to using some functions. If the name starts with '+', the specified name will be appended to the current name of the GTS or Encoder.\n\nIf you want to rename a Geo Time Series™ or an Encoder so its name starts with a '+', you must first set its name to the empty string then use rename with the desired name prefixed with an additional '+'.\n\n@param `gts` Geo Time Series™ instance to rename.\n\n@param `lgts` List of Geo Time Series™ instances to rename.\n\n@param `encoder` Encoder to rename.\n\n@param `lencoder` Encoder to rename.\n\n@param `name` New name to give to the GTS.\n\n",tags:["gts","encoder"],since:"1.0.0",OPB64name:"RENAME"},{name:"REOPTALT",detail:"REOPTALT( alternatives:LIST<STRING> ): regexp:STRING",documentation:"Produces a **R**egular **E**xpression **OPT**imized for **ALT**ernation from a list of STRINGs. Large alternations in regular expressions can lead to excessive backtracking and poor matching performance. In order to mitigate this, the `REOPTALT` function will produce a regular expression from a list of STRINGs which reduces the backtracking thus leading to better matching performance.\n\n@param `alternatives` List of STRINGs which should be used in the alternation.\n\n@param `regexp` Regular expression\n\n",tags:["strings"],since:"1.2.16",OPB64name:"REOPTALT"},{name:"REPLACE",detail:"REPLACE( original:ANY pattern:ANY replacement:ANY ): result:STRING",documentation:"Replaces the first occurrence of a pattern by its substitution.\n\nThe `REPLACE` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with the replaced value if it was found\n\n",tags:["strings"],since:"1.1.0",OPB64name:"REPLACE"},{name:"REPLACEALL",detail:"REPLACEALL( original:ANY pattern:ANY replacement:ANY ): result:STRING",documentation:"Replaces all occurrence of a pattern by its substitution.\n\nThe `REPLACEALL` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with all occurrences of pattern replaced by its value\n\n",tags:["strings"],since:"1.1.0",OPB64name:"REPLACEALL"},{name:"REPORT",detail:"REPORT( secret:STRING ): report:STRING",documentation:"The `REPORT` function pushes onto the stack a STRING containing configuration and usage informations which can be useful when investigating issues.\n\n@param `secret` Secret configured for using the `REPORT` function.\n\n@param `report` Actual report.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"REPORT"},{name:"RESET",detail:"RESET( depth:LONG ): ",documentation:"The `RESET` function resets the stack to the given depth, discarding any items above those 'depth' items.\n\n@param `depth` Depth at which the stack should be reset.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"RESET"},{name:"RESETS",detail:"RESETS( gts:GTS decreasingGTS:BOOLEAN ): result:GTS\nRESETS( lgts:LIST<GTS> decreasingGTS:BOOLEAN ): lresult:LIST<GTS>",documentation:"The `RESETS` functions transforms a numerical Geo Time Series™, shifting values so no offset (*i.e.* a decrease or increase of values) appears after the operation.\n\nThe parameter to `RESETS` determines if the Geo Time Series should be considered as decreasing instead of increasing.\n\n@param `decreasingGTS` Flag set to `true` to indicate the GTS is decreasing.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `lgts` List of Geo Time Series™ or list thereof to transform.\n\n@param `result` GTS with resets compensated.\n\n@param `lresult` List of GTS with resets compensated.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RESETS"},{name:"RESHAPE",detail:"RESHAPE( input:LIST shape:LIST<LONG> ): output:LIST",documentation:"The `RESHAPE` function modifies the shape of a list.\n\nThe new shape is specified using a list of dimensions, the first being the outer dimension. Such a shape can be produced by `SHAPE`.\n\nNote that the number of elements in the array must be compatible with the requested shape, i.e. the product of the dimensions must match the number of elements in the input list.\n\n@param `input` List to reshape.\n\n@param `shape` Shape specification, list of dimensions, the first element being the outer list.\n\n@param `output` Reshaped list.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"RESHAPE"},{name:"RESTORE",detail:"RESTORE( context:CONTEXT ): ",documentation:"The `RESTORE` function resets the stack's symbol table to the state recorded in the context passed as parameter.\n\n@param `context` Stack context produced by [`SAVE`](doc/SAVE).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"RESTORE"},{name:"RETHROW",detail:"RETHROW(): ",documentation:"Inside the *catch* or *finally* macro of a [`TRY`](/doc/TRY), rethrows the last thrown error. If no error was previously thrown, `RETHROW` does nothing.\n\n",tags:["control"],since:"1.2.11",OPB64name:"RETHROW"},{name:"RETURN",detail:"RETURN(): ",documentation:"Returns immediately from the currently executing macro. If called outside a macro, `RETURN` will stop the execution of the current script, behaving like [`STOP`](/doc/STOP).\n\n",tags:["control"],since:"1.0.0",OPB64name:"RETURN"},{name:"REV",detail:"REV(): revision:STRING",documentation:"The `REV` function pushes onto the stack the revision of the Warp 10 instance.`\n\n@param `revision` Revision of the Warp 10 platform.\n\n",tags:["platform"],since:"1.0.0",OPB64name:"REV"},{name:"REVBITS",detail:"REVBITS( long:LONG ): gnol:LONG",documentation:"Reverses the order of the bits of a LONG value.\n\n@param `long` LONG value from which to revert the bits.\n\n@param `gnol` LONG value whose bits are in reverse order compared to those of `long`.\n\n",tags:["math"],since:"1.0.0",OPB64name:"REVBITS"},{name:"REVERSE",detail:"REVERSE( originalList:LIST ): reversedObj:LIST\nREVERSE( originalString:STRING ): reversedObj:STRING\nREVERSE( originalString:BYTES ): reversedObj:BYTES",documentation:"Reverses the order of the elements of the list or the string.\n\nThe `REVERSE` function inverts the order of the elements of the list or the string on the top of the stack.\nBeware, `REVERSE` do not create a new object. Use [`CLONEREVERSE`](/doc/CLONEREVERSE) if you want to keep input.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n\n@param `originalList` The list to reverse\n\n@param `originalString` The string to reverse\n\n@param `reversedObj` The original object with the elements in reverse order\n\n",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"REVERSE"},{name:"REXEC",detail:"REXEC( warpscript:STRING endpoint:STRING ): stack:ANY*",documentation:"The `REXEC` function executes some WarpScript code on a remote Warp 10 instance. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",tags:["extensions","stack"],since:"1.0.8",OPB64name:"REXEC"},{name:"REXECZ",detail:"REXECZ( warpscript:STRING endpoint:STRING ): stack:ANY*",documentation:"The `REXECZ` function executes some WarpScript code on a remote Warp 10 instance just like [`REXEC`](/doc/REXEC) does, but compresses the WarpScript code prior to sending it. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",tags:["extensions","stack"],since:"1.2.5",OPB64name:"REXECZ"},{name:"RINT",detail:"RINT( value:NUMBER ): result:DOUBLE\nRINT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `RINT` function consumes a numeric parameter from the top of the stack and pushes back the DOUBLE the closest to the parameter and equal to a mathematical integer.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `result` Closest floating-point value to a that is equal to a mathematical integer.\n\n@param `lvalue` List of Numeric values.\n\n@param `lresult` List of closest floating-point values to a that is equal to a mathematical integer.\n\n",tags:["math"],since:"1.0.0",OPB64name:"RINT"},{name:"RLOWESS",detail:"RLOWESS( gts:GTS q:LONG r:LONG d:LONG p:LONG ): result:GTS\nRLOWESS( gtsList:LIST<GTS> q:LONG r:LONG d:LONG p:LONG ): resultList:LIST<GTS>",documentation:"The `RLOWESS` function applies an iterative smoothing program on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is done via locally weighted regression, and is robust to outliers.\n\n> ### REFERENCE\n>\n> **Cleveland, W. S.** (1979) Robust locally weighted regression and smoothing scatterplots. J. American Statistical Association 74, 829–836.\n> **Cleveland, W. S.** (1981) LOWESS: A program for smoothing scatterplots by robust locally weighted regression. The American Statistician 35, 54.\n\n@param `p` The degree for the polynomial fit of the regression\n\n@param `d` The delta radius (in time units) whithin which the local regression is computed only once (other points are interpolated). For very large datasets, it can be wise to set `d` > 0 to speed up the computations.\n\n@param `r` The number of robustifying iterations. The higher the value of `r`, the better the program is robust to outliers.\n\n@param `q` The bandwidth of the local regression. To obtain a good smoothing, it is advised to choose an odd number of at least 5.\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RLOWESS"},{name:"ROLL",detail:"ROLL( eltN:ANY elt2:ANY elt1:ANY N:LONG ): elt2:ANY elt1:ANY eltN:ANY",documentation:"`ROLL` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element at level *N* to the top of the stack and moving the other elements up one level.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ROLL"},{name:"ROLLD",detail:"ROLLD( eltN:ANY elt2:ANY elt1:ANY N:LONG ): elt1:ANY eltN:ANY elt2:ANY",documentation:"`ROLLD` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element on top of the stack to level *N* and moving the other *N-1* elements down the stack.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ROLLD"},{name:"ROT",detail:"ROT( level3:ANY level2:ANY top:ANY ): level2:ANY top:ANY level3:ANY",documentation:"`ROT` cycles through the 3 topmost elements of the stack by moving the element at level 3 to the top of the stack and pushing the other 2 elements up the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n@param `level3` The element at the third level of the stack prior to the function execution\n\n",tags:["stack"],since:"1.0.0",OPB64name:"ROT"},{name:"ROTATIONQ",detail:"ROTATIONQ( x:DOUBLE y:DOUBLE z:DOUBLE angle:DOUBLE ): quaternion:QUATERNION",documentation:"The `ROTATIONQ` function consumes on the stack 4 doubles representing a rotation vector and pushes back [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long.\n\n@param `quaternion` The quaternion representation\n\n@param `angle` The angle of the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",tags:["quaternions"],since:"1.0.0",OPB64name:"ROTATIONQ"},{name:"ROUND",detail:"ROUND( input:NUMBER ): output:LONG",documentation:"The `ROUND` function consumes a numeric parameter from the top of the stack and pushes back the long number the closest to the parameter.\n\n@param `input` Input to round.\n\n@param `output` Input rounded to the nearest Long.\n\n",tags:["math"],since:"1.0.0",OPB64name:"ROUND"},{name:"RSADECRYPT",detail:"RSADECRYPT( cipher:BYTES key:KEY ): data:BYTES",documentation:"Decrypts content encrypted with an RSA key.\n\n@param `key` RSA key to use for decryption (a public key if content was encrypted with a private key, a private key otherwise).\n\n@param `cipher` Encrypted data.\n\n@param `data` Cleartext data.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSADECRYPT"},{name:"RSAENCRYPT",detail:"RSAENCRYPT( data:BYTES key:KEY ): encrypted:BYTES",documentation:"Encrypts a byte array using an RSA key (either public or private).\n\n@param `key` Instance of the RSA private or public key to use for encryption.\n\n@param `data` Data to encrypt.\n\n@param `encrypted` Ciphered version of `data`.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAENCRYPT"},{name:"RSAGEN",detail:"RSAGEN( publicExponent:LONG keylen:LONG ): privkeyparams:MAP pubkeyparams:MAP",documentation:"Generates an RSA public key pair.\n\n@param `keylen` Key length in bits.\n\n@param `publicExponent` RSA public exponent, typically 65537.\n\n@param `pubkeyparams` Parameters of the generated RSA public key. Can be converted to a public key using [`RSAPUBLIC`](/doc/RSAPUBLIC).\n\n@param `privkeyparams` Parameters of the generated RSA privsate key. Can be converted to a private key using [`RSAPRIVATE`](/doc/RSAPRIVATE)\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAGEN"},{name:"RSAPRIVATE",detail:"RSAPRIVATE( privkeyparams:MAP ): privkey:KEY",documentation:"Creates an RSA private key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `privkeyparams` Map of private key parameters.\n\n@param `privkey` RSA private key instance.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPRIVATE"},{name:"RSAPUBLIC",detail:"RSAPUBLIC( pubkeyparams:MAP ): pubkey:KEY",documentation:"Creates an RSA public key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `pubkeyparams` Map of public key parameters.\n\n@param `pubkey` RSA public key instance.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPUBLIC"},{name:"RSASIGN",detail:"RSASIGN( data:BYTES alg:STRING privkey:KEY ): signature:BYTES",documentation:"Signs a byte array with an RSA private key.\n\n@param `privkey` RSA private key to use for signing.\n\n@param `alg` Name of algorithm to use for computing the data fingerprint. Supported algorithms are those provided by [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `data` Data to sign.\n\n@param `signature` Computed signature.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSASIGN"},{name:"RSAVERIFY",detail:"RSAVERIFY( content:BYTES signature:BYTES alg:STRING pubkey:KEY ): verified:BOOLEAN",documentation:"The `RSAVERIFY` function verify a signature generated with [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) cryptosystem and a hash algorithm.\n\nAlgorithms are those supported by [BouncyCastle](http://stackoverflow.com/questions/8778531/bouncycastle-does-not-find-algorithms-that-it-provides).\n\n@param `pubkey` RSA public key to use for verifying the signature.\n\n@param `alg` Algorithm used for generating the signature. See [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `signature` Signature to verify.\n\n@param `content` Signed content.\n\n@param `verified` Status of the signature verification.\n\n",tags:["crypto"],since:"1.0.11",OPB64name:"RSAVERIFY"},{name:"RSORT",detail:"RSORT( gts:GTS ): result:GTS\nRSORT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"Sort Geo Time Series™ values (and associated locations/elevations) by reverse order of their ticks (i.e. most recent ticks first).\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RSORT"},{name:"RTFM",detail:"RTFM(): url:STRING",documentation:"The `RTFM` function pushes onto the stack the URL of the Warp 10 documentation, so whenever you are lost you can rapidly retrieve the URL you need to get back on track!\n\n@param `url` URL of the Warp 10 documentation.\n\n",tags:["misc","help"],since:"1.0.7",OPB64name:"RTFM"},{name:"RUN",detail:"RUN( macroName:STRING ): \nRUN( macroRegister:LONG ): ",documentation:"The `RUN` function attempts to execute the macro whose name is on top of the stack. It is equivalent to `@macro` if called with `macro` on top of the stack.\n\n@param `macroName` Name of macro to execute, without a leading '@'\n\n@param `macroRegister` Register number in which the macro is stored, without a leading '@'\n\n",tags:["platform"],since:"1.0.0",OPB64name:"RUN"},{name:"RUNNERNONCE",detail:"RUNNERNONCE( nonce:STRING ): time:LONG",documentation:"The `RUNNERNONCE` function decrypts the content of a runner *nonce* as generated when a script is executed by a Warp 10 runner instance.\n\nWhen a script is executed by a runner instance, the following symbols are defined when the script is invoked:\n\n| Symbol | Description |\n| --- | --- |\n| `runner.periodicity` | Periodicity at which the script is supposed to run, in ms. |\n| `runner.path` | Path of the script. |\n| `runner.scheduledat` | Time at which the current execution was scheduled, in ms since the [UNIX Epoch](). |\n| `runner.nonce` | Encrypted time of execution, in time units since the [UNIX Epoch](). |\n\nNote that if the runner pre-shared key is not configured via `runner.psk`, the `RUNNERNONCE` function will push `NULL` onto the stack. Note that in this case, the `runner.nonce` symbol will not be defined.\n\n@param `nonce` Runner *nonce* as stored in `runner.nonce`.\n\n@param `time` Time retrieved from the *nonce*.\n\n",tags:["stack"],since:"1.2.7",OPB64name:"RUNNERNONCE"},{name:"RUNR",detail:"RUNR(): ",documentation:"Run the macro currently contained in the designated register.\n\nThe `RUNR` function is really a family of functions named `RUNRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n",tags:["maps"],since:"2.7.0",OPB64name:"RUNR"},{name:"RVALUESORT",detail:"RVALUESORT( gts:GTS ): result:GTS\nRVALUESORT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"Sort Geo Time Series™ values (and associated locations/elevations) by by reverse order of their values.\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"RVALUESORT"},{name:"SAVE",detail:"SAVE(): context:CONTEXT",documentation:"The `SAVE` function pushes onto the stack a *context* object which contains all the symbols currently defined in the current stack. This context can be passed as a parameter to the [`RESTORE`](doc/RESTORE) function to later reset the symbol table to the state store in the context. Any symbol created after the context was saved and before it is restored will be discarded when `RESTORE` is called.\n\n@param `context` Stack context, suitable as a parameter to [`RESTORE`](doc/RESTORE).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"SAVE"},{name:"SCALB",detail:"SCALB( d:NUMBER scaleFactor:LONG ): result:TYPE",documentation:'The `SCALB` function consumes a scale factor *scaleFactor* and a numeric parameter *d* and pushes back <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo>&#xD7;</mo><msup><mn>2</mn><mi>scaleFactor</mi></msup></math>. The scale factor must fit into an INT.\n\n@param `scaleFactor` The scaling factor, must fit into an INT\n\n@param `d` The value to be scaled\n\n@param `result` The scaled value\n\n',tags:["math"],since:"1.2.23",OPB64name:"SCALB"},{name:"SECTION",detail:"SECTION( section:STRING ): ",documentation:"The `SECTION` function modifies the value of the *section* attribute of the stack. This value appears in the error messages and can therefore help you debug your WarpScript code. Typically, the `SECTION` function is used to separate your code in different logical units.\n\n@param `section` Name to assign to the *section* attribute.\n\n",tags:["stack","debug"],since:"1.2.7",OPB64name:"SECTION"},{name:"SECURE",detail:"SECURE( script:STRING ): encrypted:STRING",documentation:"The `SECURE` function encrypts a STRING representing a WarpScript code fragment using the platform's secure script cryptographic key and the current secret set via [`SECUREKEY`](doc/SECUREKEY).\n\nSecure scripts can also be created using the `<S .... S>` syntax.\n\n@param `script` Cleartext version of the WarpScript fragment to encrypt.\n\n@param `encrypted` Encrypted secure script.\n\n",tags:["crypto","stack"],since:"1.2.11",OPB64name:"SECURE"},{name:"SECUREKEY",detail:"SECUREKEY( key:STRING ): ",documentation:"The `SECUREKEY` function sets the secret which will be used to decrypt further secure scripts.\n\nSecure scripts are WarpScript fragments which are encrypted with a cryptographic key specific to the platform they were created on. They can be executed on a platform configured with the same cryptographic key.\n\n@param `key` Secret to use for unlocking the cleartext versions of future secure scripts.\n\n",tags:["crypto","stack"],since:"1.0.0",OPB64name:"SECUREKEY"},{name:"SENSISION.DUMP",detail:"SENSISION.DUMP( valueTimestamp:BOOLEAN ): dump:STRING",documentation:"The `SENSISION.DUMP` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) metrics in the JVM.\n\nThe STRING produced by `SENSISION.DUMP` can be parsed using `PARSE`.\n\n@param `valueTimestamp` Flag indicating whether to dump the Geo Time Series™ with the timestamp of last updates or the timestamp at which the value is read.\n\n@param `dump` Latest values of all Geo Time Series™ known to Sensision in Geo Time Series™ output input.\n\n",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMP"},{name:"SENSISION.DUMPEVENTS",detail:"SENSISION.DUMPEVENTS(): dump:STRING",documentation:"The `SENSISION.DUMPEVENTS` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) events in the events history.\n\nThe STRING produced by `SENSISION.DUMPEVENTS` can be parsed using `PARSE`.\n\nNote that if the system property `sensision.events.history` is not set to a value greater than 0, the function will always return an empty STRING.\n\nThe Sensision event history is a circular buffer.\n\n@param `dump` Latest values of all events in the Sensision event history.\n\n",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMPEVENTS"},{name:"SENSISION.EVENT",detail:"SENSISION.EVENT( [ value:LONG labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:STRING labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:BOOLEAN labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:LONG labels:MAP class:STRING ts:LONG ] ): \nSENSISION.EVENT( [ value:DOUBLE labels:MAP class:STRING ts:LONG ] ): \nSENSISION.EVENT( [ value:STRING labels:MAP class:STRING ts:LONG ] ): \nSENSISION.EVENT( [ value:BOOLEAN labels:MAP class:STRING ts:LONG ] ): ",documentation:"The `SENSISION.EVENT` function creates a [Sensision](https://github.com/senx/sensision) event.\n\n@param `class` Name of the class of the Sensision event to emit.\n\n@param `labels` Map of label names to values, both STRINGs of the Sensision event.\n\n@param `value` Value associated with the event.\n\n@param `ts` Optional timestamp for the event (in Sensision time units), if omitted, the current timestamp will be used.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.EVENT"},{name:"SENSISION.GET",detail:"SENSISION.GET( selector:STRING ): gts:GTS\nSENSISION.GET( class:STRING labels:MAP ): gts:GTS",documentation:"The `SENSISION.GET` function reads the current value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to read.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to read.\n\n@param `selector` Geo Time Series™ selector (`class{labels}`) of the Sensision metric to read.\n\n@param `gts` A Geo Time Series™ containing the current value of the Sensision metric. If the metric does not exist, the resulting GTS will be empty.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.GET"},{name:"SENSISION.SET",detail:"SENSISION.SET( [ value:LONG labels:MAP class:STRING ] ): \nSENSISION.SET( [ value:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.SET( [ value:STRING labels:MAP class:STRING ] ): \nSENSISION.SET( [ value:BOOLEAN labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:LONG labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:STRING labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:BOOLEAN labels:MAP class:STRING ] ): ",documentation:"The `SENSISION.SET` function sets a value for a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `value` Value to assign to the Sensision metric.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.SET"},{name:"SENSISION.UPDATE",detail:"SENSISION.UPDATE( [ delta:LONG labels:MAP class:STRING ] ): \nSENSISION.UPDATE( [ delta:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.UPDATE( [ ttl:LONG delta:LONG labels:MAP class:STRING ] ): \nSENSISION.UPDATE( [ ttl:LONG delta:DOUBLE labels:MAP class:STRING ] ): ",documentation:"The `SENSISION.UPDATE` function updates the numerical value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `delta` Delta to add to the current value of the Sensision metric. If the metric does not exist it will be created with this value.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.UPDATE"},{name:"SET",detail:"SET( inputlist:LIST item:ANY index:LONG ): outputlist:LIST\nSET( inputlist:LIST item:ANY index:LIST ): outputlist:LIST\nSET( array:BYTES bytevalue:LONG index:LONG ): outputarray:LIST",documentation:"The `SET` function replaces item at specified index in a list.\nIf the index is greater than the size of the list, it will raise an error.\n\nWhen used on a **BYTE ARRAY**, SET replaces the byte by the byte value. The byte value, signed or not, must be in the range of [-128,255].\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, SET can set an element in a nested list. In this case, the index is a list.\n\n@param `index` The index in the list, 0 for the first item.\n\n@param `inputlist` The input list to modified.\n\n@param `outputlist` The input list modified,  this is not a new list object.\n\n@param `item` The item to update in the inputlist at index, could be any type.\n\n@param `array` Byte array to which write a byte.\n\n@param `bytevalue` The value of the byte, signed or unsigned (from -128 to 255).\n\n@param `outputarray` The input byte array modified, this is not a new byte array.\n\n",tags:["lists","binary"],since:"1.0.0",OPB64name:"SET"},{name:"SET->",detail:"SET->( input:SET ): output:LIST",documentation:"The `SET->` function converts the set on top of the stack into a **LIST**.\n\n@param `input` Input set.\n\n@param `output` A list containing input elements.\n\n",tags:["sets"],since:"1.0.0",OPB64name:"JoKJAIs"},{name:"SETATTRIBUTES",detail:"SETATTRIBUTES( gts:GTS attributes:MAP ): gts:GTS\nSETATTRIBUTES( lgts:LIST<GTS> attributes:MAP ): lgts:LIST<GTS>\nSETATTRIBUTES( encoder:GTSENCODER attributes:MAP ): encoder:GTSENCODER\nSETATTRIBUTES( lencoder:LIST<GTS> attributes:MAP ): lencoder:LIST<GTS>",documentation:"Modifies the attributes of a Geo Time Series™, an encoder or a list thereof. The `SETATTRIBUTES` function expects a parameter MAP whose entries are attributes to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `SETATTRIBUTES` function will use the rest of the MAP as the actual attributes to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing attributes.\n\nAn entry with an empty STRING value will have the effect of removing the attribute from the attributes of the GTSs or encoders.   \n\n@param `attributes` Parameter map of attributes names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lencoder` List of Encoders.\n\n@param `encoder` Encoder to relabel\n\n",tags:["gts","encoder"],since:"1.0.0",OPB64name:"SETATTRIBUTES"},{name:"SETMACROCONFIG",detail:"SETMACROCONFIG( value:STRING key:STRING secret:STRING ): ",documentation:"The `SETMACROCONFIG` function allows you to set or modify the value of a configuration key accessible via the [`MACROCONFIG`](/doc/MACROCONFIG) or [`MACROCONFIGDEFAULT`](/doc/MACROCONFIGDEFAULT) functions or via the runner script variable expansion.\n\nThis function can only be used if the `warpscript.macroconfig.secret` is set in the Warp 10™ configuration.\n\nThe configuration keys which can be set using `SETMACROCONFIG` must have the format `key@path/tomacro` or `key@/path/to/runner/script`.\n\nSetting the value of a configuration key to `NULL` has the effect of removing the configuration key altogether.\n\n@param `key` Configuration key to set.\n\n@param `secret` Macro config secret.\n\n@param `value` String value to set for the key or `NULL`.\n\n",tags:["platform"],since:"2.1.0",OPB64name:"SETMACROCONFIG"},{name:"SETVALUE",detail:"SETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:STRING ): result:GTS\nSETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:BOOLEAN ): result:GTS\nSETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:DOUBLE ): result:GTS\nSETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:LONG ): result:GTS",documentation:"The `SETVALUE` function adds a value to a GTS or override an existing value. If the tick already exists, this function will overwrite the first one it encounters in the GTS. If the tick does not exist, it is appended. \nThe [`ADDVALUE`](/doc/ADDVALUE) function adds a value to a GTS but do not override an existing value.\n\nThe `SETVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `SETVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, using [`GET`](/doc/GET) for instance.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Serie\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `elevation` Elevation or NaN\n\n@param `result` modified Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"SETVALUE"},{name:"SHA1",detail:"SHA1( input:BYTES ): result:BYTES",documentation:"The `SHA1` function digests a byte array on the stack with the cryptographic hash function [SHA-1](https://en.wikipedia.org/wiki/SHA-1).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1"},{name:"SHA1HMAC",detail:"SHA1HMAC( message:BYTES secret:BYTES ): result:BYTES",documentation:"The `SHA1HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-1](https://en.wikipedia.org/wiki/SHA-1) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1HMAC"},{name:"SHA256",detail:"SHA256( input:BYTES ): result:BYTES",documentation:"The `SHA256` function digests a byte array on the stack with the cryptographic hash function [SHA-256](https://en.wikipedia.org/wiki/SHA-2).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256"},{name:"SHA256HMAC",detail:"SHA256HMAC( message:BYTES secret:BYTES ): result:BYTES",documentation:"The `SHA256HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-256](https://en.wikipedia.org/wiki/SHA-2) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256HMAC"},{name:"SHAPE",detail:"SHAPE( list:LIST ): shape:LIST\nSHAPE( { list:LIST fast:BOOLEAN  } ): shape:LIST",documentation:"Return the shape of an input list if it could be a tensor (or multidimensional array), or raise an Exception.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent and it returns a shape based on the first nested lists at each level. Default to false.\n\n@param `list` The input list.\n\n@param `shape` The shape of the input list.\n\n",tags:["lists","tensors"],since:"2.1.0",OPB64name:"SHAPE"},{name:"SHMLOAD",detail:"SHMLOAD( symbol:STRING ): object:ANY",documentation:"The `SHMLOAD` function loads data previously stored by [`SHMSTORE`](/doc/SHMSTORE) in shared memory, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the requested shared symbol is not known or if the calling script does not currently hold the mutex associated with the symbol.\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to retrieve.\n\n@param `object` Object currently stored under `symbol`.\n\n",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMLOAD"},{name:"SHMSTORE",detail:"SHMSTORE( object:ANY symbol:STRING ): ",documentation:"The `SHMSTORE` function stores an object in a named shared memory location, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the calling script is not currently holding a mutex (in a call to [`MUTEX`](/doc/MUTEX)). The call will have no effect if the named memory location was already set by a previous call to `SHMSTORE`.\n\nIn order to overwrite a shared memory location, its content must first be cleared by storing [`NULL`](/doc/NULL).\n\n\nIf the calling script currently holds a mutex, this mutex will be associated with the shared memory location, the same mutex will have to be held when retrieving the content of the memory location via [`SHMLOAD`](/doc/SHMLOAD).\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to store.\n\n@param `object` Object to store under `symbol` or `NULL` to clear its content.\n\n",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMSTORE"},{name:"SHOW",detail:"SHOW( levels:LONG ): ",documentation:"The `SHOW` function makes visible some levels of the stack which were previously hidden by a call to [`HIDE`](/doc/HIDE).\n\nThe levels made visible are the ones closest to the top of the stack. Depending on the `levels` parameter to the call to `SHOW`, the revealed levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there are at most a certain number ((*abs(`levels`)*) with `levels` < 0) of visible levels after the call.\n\nWhen called with `NULL` as parameter, `SHOW` wil reveal all levels currently hidden.\n\n@param `levels` Number of levels to reveal, or `NULL` to reveal them all.\n\n",tags:["stack"],since:"2.7.1",OPB64name:"SHOW"},{name:"SHRINK",detail:"SHRINK( gts:GTS size:LONG ): result:GTS",documentation:"Shrink the number of values of a Geo Time Series™ to `size`. The oldest values are kept if `size` is non negative. The earliest ones are kept in the other case.\n\nThis function has the side effect of sorting the Geo Time Series™. If the Geo Time Series™ has fewer than `size` values the function raises an error.\n\n@param `size` Size used to shrink the Geo Time Series™\n\n@param `gts` A Geo Time Series™\n\n@param `result` A shrinked Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"SHRINK"},{name:"SHUFFLE",detail:"SHUFFLE( input:LIST ): shuffled:LIST",documentation:"The `SHUFFLE` function shuffles a list.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `input` The reference of the list to shuffle\n\n@param `shuffled` The original list shuffled, this is not a new list object\n\n",tags:["lists"],since:"2.1.0",OPB64name:"SHUFFLE"},{name:"SIGNUM",detail:"SIGNUM( value:NUMBER ): result:DOUBLE\nSIGNUM( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `SIGNUM` function consumes a numeric parameter from the top of the stack and pushes back its signum.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Signum, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of signum for each given value, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n",tags:["operators","math"],since:"1.0.0",OPB64name:"SIGNUM"},{name:"SIN",detail:"SIN( value:NUMBER ): result:DOUBLE\nSIN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `SIN` function consumes a floating point number from the top of the stack and pushes back its sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Sine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of sine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SIN"},{name:"SINGLEEXPONENTIALSMOOTHING",detail:"SINGLEEXPONENTIALSMOOTHING( gts:GTS alpha:DOUBLE ): result:GTS",documentation:"The `SINGLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Simple Exponential Smoothing](https://www.otexts.org/fpp/7/1) formula.\n\nIt consumes two parameters from the top of the stack:\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** is pushed onto the stack.\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The smoothed Geo Time Series™\n\n",tags:["gts","statistics"],since:"1.0.0",OPB64name:"SINGLEEXPONENTIALSMOOTHING"},{name:"SINH",detail:"SINH( value:NUMBER ): result:DOUBLE\nSINH( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `SINH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic sine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic sine of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SINH"},{name:"SIZE",detail:"SIZE( input:LIST ): size:LONG\nSIZE( input:MAP ): size:LONG\nSIZE( input:GTS ): size:LONG\nSIZE( input:STRING ): size:LONG\nSIZE( input:BYTES ): size:LONG\nSIZE( input:GEOSHAPE ): size:LONG\nSIZE( input:GTSENCODER ): size:LONG\nSIZE( input:SET ): size:LONG",documentation:"Returns the size of the input parameter.\n\nThe `SIZE` function computes the size of a LIST, MAP, GTS or ENCODER (number of values), STRING, byte array of GEOSHAPE (number of cells).\n\n@param `input` The input parameter\n\n@param `size` The size of the input parameter\n\n",tags:["strings","lists","maps","gts","geo"],since:"1.0.0",OPB64name:"SIZE"},{name:"SKEWNESS",detail:"SKEWNESS( gts:GTS bessel:BOOLEAN ): skewness:DOUBLE\nSKEWNESS( lgts:LIST<GTS> bessel:BOOLEAN ): lskewness:LIST<DOUBLE>",documentation:"The `SKEWNESS` function computes the [skewness](https://en.wikipedia.org/wiki/Skewness) of a Geo Time Series™.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the skewness.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `skewness` Computed skewness of the Geo Time Series™ instance.\n\n@param `lskewness` List of computed skewness of the Geo Time Series™ instances.\n\n",tags:["statistics","gts"],since:"1.2.13",OPB64name:"SKEWNESS"},{name:"SMARTPARSE",detail:"SMARTPARSE( string:STRING regexp:STRING ): results:LIST<GTS>\nSMARTPARSE( gts:GTS regexp:STRING ): results:LIST<GTS>\nSMARTPARSE( lgts:LIST<GTS> regexp:STRING ): lresults:LIST<LIST<GTS>>",documentation:"The `SMARTPARSE` function parses STRING values, either from a single STRING parameter or from STRING Geo Time Series™, and produces a number of GTS from the parsed data.\n\nThe parsing is done according to a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) which contains [named capturing groups](https://www.regular-expressions.info/named.html) with the Java/.NET syntax, *i.e.* `(?<name>...)`.\n\nThe captured group is interpreted differently based on the syntax of the name.\n\n| Syntax | Interpretation |\n| --- | --- |\n| Lxxx | Captured content is used as the value of label `xxx` |\n| TU | Captured group is interpreted as a timestamp in unit `U` from the [UNIX Epoch](https://en.wikipedia.org/wiki/Unix_time) origin. Valid values for U are `s`, `ms`, `us`, `ns` |\n| lat | Captured group is interpreted as the latitude if another group named `lon` is also present |\n| lon | Captured group is interpreted as the longitude if another group named `lat` is also present |\n| elevU | Captured group is interpreted as the elevation in unit `U`, where `U` can be `m`, `cm`, `mm`, `ft`, `km`, `mi`, `nm` (Nautical Mile). The value is parsed as a DOUBLE and converted to a LONG in `mm` |\n| VTxxx | Captured group is interpreted as a value for a GTS with class `xxx`. The type of the value is determined by the value of `T` which can be `B`(oolean) `S`(tring) `L`(ong) or `D`(ouble) |\n\nThis function is ideally suited for parsing log messages and producing Geo Time Series™ from their content.\n\n@param `regexp` Regular expression to use for parsing. See the function description for the syntax to use.\n\n@param `string` String to parse\n\n@param `results` List of Geo Time Series™ created from the parsed data.\n\n@param `lresults` List of list of GTS created from the parsed data.\n\n@param `gts` STRING valued Geo Time Series™ whose values are to be parsed.\n\n@param `lgts` List of STRING valued GTS whose values are to be parsed.\n\n",tags:["gts","strings"],since:"1.2.13",OPB64name:"SMARTPARSE"},{name:"SNAPSHOT",detail:"SNAPSHOT( stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOT` functions produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOT` was called.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.6",OPB64name:"SNAPSHOT"},{name:"SNAPSHOTALL",detail:"SNAPSHOTALL( stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTALL` functions acts similarly as [`SNAPSHOT`](/doc/SNAPSHOT) and produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOTALL` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALL"},{name:"SNAPSHOTALLTOMARK",detail:"SNAPSHOTALLTOMARK( mark:MARK stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTALLTOMARK` functions acts similarly as [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) and produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTALLTOMARK` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALLTOMARK"},{name:"SNAPSHOTCOPY",detail:"SNAPSHOTCOPY( stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTCOPY` function behaves like [`SNAPSHOT`](/doc/SNAPSHOT) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPY` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPY"},{name:"SNAPSHOTCOPYALL",detail:"SNAPSHOTCOPYALL( stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTCOPYALL` function behaves like [`SNAPSHOTALL`](/doc/SNAPSHOTALL) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALL"},{name:"SNAPSHOTCOPYALLTOMARK",detail:"SNAPSHOTCOPYALLTOMARK( stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTCOPYALLTOMARK` function behaves like [`SNAPSHOTALLTOMARK`](/doc/SNAPSHOTALLTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALLTOMARK"},{name:"SNAPSHOTCOPYN",detail:"SNAPSHOTCOPYN( stack:ANY* n:LONG ): snapshot:STRING",documentation:"Performs a [`SNAPSHOTCOPY`](/doc/SNAPSHOTCOPY) on the top *N* elements of the stack.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTCOPYN"},{name:"SNAPSHOTCOPYTOMARK",detail:"SNAPSHOTCOPYTOMARK( stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTCOPYTOMARK` function behaves like [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYTOMARK"},{name:"SNAPSHOTN",detail:"SNAPSHOTN( stack:ANY* n:LONG ): snapshot:STRING",documentation:"Produces a WarpScript code fragment which will regenerate the *N* top levels of the stack. The content of those levels is consumed off the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTN"},{name:"SNAPSHOTTOMARK",detail:"SNAPSHOTTOMARK( mark:MARK stack:ANY* ): snapshot:STRING",documentation:"The `SNAPSHOTTOMARK` functions produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTTOMARK` was called.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTTOMARK"},{name:"SORT",detail:"SORT( gts:GTS ): sgts:GTS\nSORT( lgts:LIST<GTS> ): slist:LIST<GTS>",documentation:"Sorts a Geo Time Series™ or each GTS of a list of GTS in ascending tick order.\n\n@param `gts` Single Geo Time Series™ instance to sort.\n\n@param `sgts` Sorted Geo Time Series™, this is the same instance as `gts`.\n\n@param `lgts` List of Geo Time Series™ instances to sort.\n\n@param `slist` List of sorted Geo Time Series™. Each instance is the same as the input one.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"SORT"},{name:"SORTBY",detail:"SORTBY( list:LIST macro:MACRO ): lsorted:LIST\nSORTBY( map:MAP macro:MACRO ): msorted:MAP",documentation:"The `SORTBY` function sorts a **LIST** or a **MAP** according to a value returned by a macro. The macro must return a value of the same type (LONG, DOUBLE or STRING) for each element.\n\nOnly **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nBefore release `1.2.22`, the `SORTBY` function could only sort lists of Geo Time Series™.\n\nBefore release `2.7.0`, the `SORTBY` function could only sort lists but not maps.\n\n@param `macro` Macro used for sorting, consumes a list element off the stack and produces a LONG, DOUBLE or STRING value.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",tags:["lists","gts"],since:"1.0.11",OPB64name:"SORTBY"},{name:"SORTWITH",detail:"SORTWITH( list:LIST macro:MACRO ): lsorted:LIST\nSORTWITH( map:MAP macro:MACRO ): msorted:MAP",documentation:"The `SORTWITH` function sorts a **LIST** or a **MAP** according to a value returned by a comparison macro. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nIn used a on **LIST**, the comparison macro is given 2 elements of the **LIST** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest element in the stack is respectively strictly less than, equal to or strictly more than than the element on the stack.\n\nIn used a on **MAP**, the comparison macro is given 2 entries (key deepest, value shallowest) of the **MAP** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest entry in the stack is respectively strictly less than, equal to or strictly more than than the shallowest entry on the stack.\n\nBefore release `2.7.0`, the `SORTWITH` function could only sort lists but not maps.\n\n@param `macro` Macro used for comparison, must consume two elements of the stack and produces a LONG.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",tags:["lists","gts"],since:"2.2.0",OPB64name:"SORTWITH"},{name:"SPLIT",detail:"SPLIT( s:STRING delimiter:STRING ): result:LIST<STRING>",documentation:"The SPLIT function split a string in segments given a delimiter.\n\n\nIt consumes two parameters from the top of the stack: the delimiter and the string to test matching with. The delimiter must be a string of length 1, i.e. only one character.\n\n\nThe function will return a list with all the segments. If delimiter is not found, the output list contains the input string.\n\n@param `delimiter` One character delimiter.\n\n@param `s` The string to split\n\n@param `result` List of strings.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"SPLIT"},{name:"SQRT",detail:"SQRT( value:NUMBER ): result:DOUBLE\nSQRT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `SQRT` function consumes a numeric parameter from the top of the stack and pushes back its square root.\n\nFor negative numbers, SQRT returns NaN.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Square root of the given value, NaN if it is negative.\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of square root of each given value, NaN if it is negative.\n\n",tags:["math"],since:"1.0.0",OPB64name:"SQRT"},{name:"SRAND",detail:"SRAND(): num:DOUBLE",documentation:"The `SRAND` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThe seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",tags:["math"],since:"1.2.9",OPB64name:"SRAND"},{name:"SRANDPDF",detail:"SRANDPDF( valueHistogram:MAP ): result:STRING",documentation:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe randomization is seeded. The seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThe result is a function. This function does not have any arguments.\n\nTo use the function pushed by `SRANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",tags:["math","statistics"],since:"2.2.1",OPB64name:"SRANDPDF"},{name:"STACKATTRIBUTE",detail:"STACKATTRIBUTE( name:STRING ): value:ANY",documentation:"Retrieves the value of a stack attribute.\n\n@param `name` Name of the stack attribute to retrieve.\n\n@param `value` Associated value or null if attribute is not set.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"STACKATTRIBUTE"},{name:"STACKPSSECRET",detail:"STACKPSSECRET( newsecret:STRING secret:STRING ): ",documentation:"Modifies the secret needed for using functions such as `WSPS`, `WSSTOP` and `WSKILL`.\n\nThis function is only useable if a secret was configured using `stackps.secret`.\n\n@param `secret` Current secret for process status operations, initially the value configured via `stackps.secret`.\n\n@param `newsecret` New secret to set for process status operations.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"STACKPSSECRET"},{name:"STACKTOLIST",detail:"STACKTOLIST( stack:ANY* ): list:LIST",documentation:"Converts the whole stack into a list and pushes this list on top of the stack. The elements are consumed off the stack in the way [`->LIST`](/doc/AItBHKCJ) does it.\n\n@param `stack` Content of the stack.\n\n@param `list` List containing the elements of the stack.\n\n",tags:["stack"],since:"1.0.14",OPB64name:"STACKTOLIST"},{name:"STANDARDIZE",detail:"STANDARDIZE( gts:GTS ): result:GTS\nSTANDARDIZE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",documentation:"Standardizes a single (or a list of) numeric Geo Time Series™ (i.e. it replaces X by (X-mu)/sd).\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"STANDARDIZE"},{name:"STDERR",detail:"STDERR( msg:STRING ): ",documentation:"The `STDERR` function prints text to the standard error stream.\n\nThe `STDERR` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"STDERR"},{name:"STDOUT",detail:"STDOUT( obj:ANY ): ",documentation:"The `STDOUT` function prints text to the standard output stream.\n\nThe `STDOUT` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `obj` The object to print. Its `.toString()` method is used to generate the outputed String.\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"STDOUT"},{name:"STL",detail:"STL( gts:GTS { p:LONG  } ): result:GTS\nSTL( gtsList:LIST<GTS> { p:LONG  } ): resultList:LIST<GTS>",documentation:'The `STL` function applies a Seasonal Trend decomposition on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is based on multiple calls of [`RLOWESS`](/doc/RLOWESS).\n\nThese Geo Time Series™ are the seasonal part and the trend part of the input Geo Time Series™. Their classnames are suffixed with "_seasonal" and "_trend".\n\nThis function can only be applied to [bucketized](/doc/BUCKETIZE) Geo Time Series™ of numeric type.\n\nThe **MAP** parameter must have at least the field `PERIOD`. You can provide additional optional parameters:\n\n## Optional parameters\n### Global\n- `ROBUST` if TRUE, set defaults of number of inner and outer loops to 1 and 15 instead of 2 and 0. Default is FALSE\n- `PRECISION` number of inner loops (a LONG). Default is 2 or 1\n- `ROBUSTNESS` number of outer loops (a LONG). Default is 0 or 15\n\n### Seasonal extract\n- `BANDWIDTH_S` the bandwidth (a LONG) of the local regression. Default is 7\n- `DEGREE_S` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_S` the number of values interpolated instead of estimated. Default is BANDWIDTH_S/10\n\n### Low frequency filtering\n- `BANDWIDTH_L` the bandwidth (a LONG) of the local regression. Default is nextOdd(PERIOD)\n- `DEGREE_L` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_L` the number of values interpolated instead of estimated. Default is BANDWIDTH_L/10\n\n### Trend extract\n- `BANDWIDTH_T` the bandwidth (a LONG) of the local regression. Default is nextOdd(ceiling(1.5*PERIOD/(1-(1.5/BANDWIDTH_S))))\n- `DEGREE_T` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_T` the number of values interpolated instead of estimated. Default is BANDWIDTH_T/10\n\n### Post seasonal smoothing\n- `BANDWIDTH_P` the bandwidth (a LONG) of the local regression. Default is 0 (i.e. no post smoothing)\n- `DEGREE_P` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_P` the number of values interpolated instead of estimated. Default is BANDWIDTH_P/10\n\n### Additional fields\n- `BANDWIDT` value of all BANDWIDTH_X fields that are not set\n- `DEGREE` value of all DEGREE_X fields that are not set\n- `SPEED` value of all SPEED_X fields that are not set\n\n> ### REFERENCE\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `p` The number of buckets that compose a period\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n',tags:["gts","bucketize"],since:"1.0.0",OPB64name:"STL"},{name:"STLESDTEST",detail:"STLESDTEST( gts:GTS p:LONG k:LONG alpha:DOUBLE STLOption:MAP ): result:LIST<LONG>\nSTLESDTEST( gts:GTS p:LONG k:LONG alpha:DOUBLE ): result:LIST<LONG>\nSTLESDTEST( gts:GTS p:LONG k:LONG STLOption:MAP ): result:LIST<LONG>\nSTLESDTEST( gts:GTS p:LONG k:LONG ): result:LIST<LONG>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG alpha:DOUBLE STLOption:MAP ): resultList:LIST<LIST<LONG>>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG alpha:DOUBLE ): resultList:LIST<LIST<LONG>>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG STLOption:MAP ): resultList:LIST<LIST<LONG>>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG ): resultList:LIST<LIST<LONG>>",documentation:'The \'STLESDTEST\' function detects outliers in a Geo Time Series™ (or a **LIST** of Geo Time Series™) which has a seasonal part.\n\nThe seasonal part and the trend part of the Geo Time Series™ are extracted using [`STL`](/doc/STL) decomposition, then an [`ESDTEST`](/doc/ESDTEST) is performed on the remainder.\n\nThis function only applies to [bucketized](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ### References\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n> **Rosner, Bernard (May 1983)**, "Percentage Points for a Generalized ESD Many-Outlier Procedure",Technometrics, 25(2), pp. 165-172.\n\n@param `STLOption` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `p` The number of buckets that compose a period\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `resultList` A **LIST** of ticks corresponding to the outliers\n\n@param `result` A **LIST** of LIST of ticks corresponding to the outliers\n\n',tags:["outlier","gts"],since:"1.0.0",OPB64name:"STLESDTEST"},{name:"STOP",detail:"",documentation:"The `STOP` function stops the current execution by throwing a `WarpScriptStopException`. This means that the current script execution will be aborted unless the call to `STOP` was in a macro invoked via [`TRY`](/doc/TRY).\n\n",tags:["stack","debug"],since:"1.0.0",OPB64name:"STOP"},{name:"STORE",detail:"STORE( value:ANY symbol:STRING ): \nSTORE( value:ANY register:LONG ): \nSTORE( values:ANY* symbols:LIST<STRING> ): ",documentation:"The `STORE` function stores a value in a symbol.\n\nSince 2.7, when the list of symbols contains duplicates only the last occurence in the list is assigned to its corresponding value.\n\n@param `symbol` Name of the symbol to modify.\n\n@param `register` Index of the register to modify.\n\n@param `symbols` List of symbols or registers to modify. The last element of the list will contain the top of the stack.\n\n@param `value` Value to store under `symbol`.\n\n@param `values` Multiple values to store in `symbols`.\n\n",tags:["stack"],since:"1.0.0",OPB64name:"STORE"},{name:"STRICTMAPPER",detail:"STRICTMAPPER( mapper:AGGREGATOR min:NUMBER max:NUMBER ): wrapped:AGGREGATOR",documentation:"Wraps a *mapper* in such a way that the mapper will only be called if the number of ticks in the window is in the specified range.\n\nSince 2.1 STRICTMAPPER can also take a timespan definition by inputing negative numbers. Number of ticks and timespan can also be mixed to specify, for instance, more than 2 points but less than 5 seconds.\n\n@param `max` If positive, maximum number of ticks in the window. If negative, maximum timespan of the window.\n\n@param `min` If positive, minimum number of ticks in the window. If negative, minimum timespan of the window.\n\n@param `mapper` Mapper to wrap.\n\n@param `wrapped` Wrapped mapper.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"STRICTMAPPER"},{name:"STRICTPARTITION",detail:"STRICTPARTITION( lgts:LIST<GTS> labels:LIST<STRING> ): result:MAP",documentation:"The `STRICTPARTITION` splits a Geo Time Series™ list in equivalence classes based on label values just like [`PARTITION`](/doc/PARTITION) but only retains in each equivalence class key the labels on which the partitioning was done.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels`.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"STRICTPARTITION"},{name:"STRICTREDUCER",detail:"STRICTREDUCER( reducer:AGGREGATOR ): wrapped:AGGREGATOR",documentation:"Wraps a *reducer* so it is only applied if there are values for all the Geo Time Series™ being reduced.\n\n@param `reducer` Reducer to wrap.\n\n@param `wrapped` Wrapped version of the reducer.\n\n",tags:["reducer"],since:"1.0.6",OPB64name:"STRICTREDUCER"},{name:"STRINGFORMAT",detail:"STRINGFORMAT( format:STRING args:LIST ): formattedString:STRING\nSTRINGFORMAT( format:STRING args:LIST locale:STRING ): formattedString:STRING",documentation:"The STRINGFORMAT function format a String in the same ways as Java [String.format](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.util.Locale-java.lang.String-java.lang.Object...-) does.\n\nThis fonction consumes an optional locale in [ISO 639](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry), a list of Objects to be used in the format string and a [format string](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax).\n\nIf no locale is specified, it defaults to the default JVM locale.\n\n@param `format` A format string.\n\n@param `args` Arguments referenced by the format specifiers in the format string.\n\n@param `locale` The locale to apply during formatting.\n\n@param `formattedString` A formatted string.\n\n",tags:["strings"],since:"2.2.0",OPB64name:"STRINGFORMAT"},{name:"STU",detail:"STU(): numberTimeUnits:LONG",documentation:"The `STU` function pushes onto the stack the number of platform time units in one second. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one second.\n\n",tags:["date","time","platform"],since:"1.0.0",OPB64name:"STU"},{name:"SUBLIST",detail:"SUBLIST( base:LIST<ANY> arguments:LIST<LONG> ): result:LIST<ANY>\nSUBLIST( base:LIST<ANY> start:NUMBER ): result:LIST<ANY>\nSUBLIST( base:LIST<ANY> start:NUMBER end:NUMBER ): result:LIST<ANY>\nSUBLIST( base:LIST<ANY> start:NUMBER end:NUMBER step:NUMBER ): result:LIST<ANY>",documentation:"It creates a new list with the elements of the base list whose indices are in the argument list.\n\nIf the argument list contains two indices [a,b] then `SUBLIST` returns the list of elements from index a to index b (included). If the argument list contains more than two indices, the result of `SUBLIST` contains all the elements at the specified indices, with possible duplicates.\n\nNegative indexing is allowed, with negative index effectively refering to index + size.\n\nSince 2.1 a new signature allowing the step to be defined has been introduced. Instead of specifying a list has range, you can put the start, end (optional) and step (optional) as **LONG** values.\n\n@param `arguments` List of indices. Negative indices are considered to be calculated from the end of the list.\n\n@param `base` Base list\n\n@param `result` Filtred list\n\n@param `start` The first index to consider, will be included.\n\n@param `end` The last index to consider, will be included. If not specified, defaults to -1.\n\n@param `step` The delta between two consecutive indexes to consider. If end is after start in the list, step must be strictly positive. If start is after end in the list, step must be strictly negative. If not specified, defaults to 1 or -1 depending on start and end.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"SUBLIST"},{name:"SUBMAP",detail:"SUBMAP( base:MAP arguments:LIST<STRING> ): result:MAP",documentation:"It creates a new map with the key-value pairs from the base map whose keys are in the argument list.\n\n@param `arguments` List of indices.\n\n@param `base` Base map\n\n@param `result` Filtred map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"SUBMAP"},{name:"SUBSTRING",detail:"SUBSTRING( str:STRING start:LONG len:LONG ): substr:STRING\nSUBSTRING( str:STRING start:LONG ): substr:STRING\nSUBSTRING( array:BYTES start:LONG len:LONG ): subarray:BYTES\nSUBSTRING( array:BYTES start:LONG ): subarray:BYTES",documentation:"Extract a substring from a **STRING** input, or a subarray from a **BYTE ARRAY** input.  \nIf the length is ommitted, it extracts until the end of the string or byte array. If length is greater than max length, extract stops at the input end.\n\nIf the start is greater than the input size, `SUBSTRING` raises an error.\n\nSince 2.1, the start index can be negative. In this case the effective index is index + size of the **STRING**.\n\n@param `len` Length of substring to extract.\n\n@param `start` First character to include in the substring (0 based).\n\n@param `str` String from which to extract a substring.\n\n@param `substr` Extracted substring.\n\n@param `array` Byte array from which to extract a sub array.\n\n@param `subarray` Extracted sub array.\n\n",tags:["strings","binary"],since:"1.0.0",OPB64name:"SUBSTRING"},{name:"SUBTRACTEXACT",detail:"SUBTRACTEXACT( x:NUMBER y:NUMBER ): diff:LONG\nSUBTRACTEXACT( list:LIST<NUMBER> ): sdiff:LONG\nSUBTRACTEXACT( lx:LIST<NUMBER> y:NUMBER ): ldiff:LIST<LONG>",documentation:"The `SUBTRACTEXACT` function consumes two LONGs from the top of the stack and puts back the difference between them. If the difference overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `diff` The difference of x and y\n\n@param `list` List of numeric values\n\n@param `sdiff` The first element of the list minus all the others\n\n@param `lx` List of numeric values\n\n@param `ldiff` List of **LONG** where each value is the difference of y and an element in lx\n\n",tags:["math"],since:"1.2.23",OPB64name:"SUBTRACTEXACT"},{name:"SWAP",detail:"SWAP( level2:ANY top:ANY ): top:ANY level2:ANY",documentation:"Exchanges the positions of the top two elements of the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n",tags:["stack"],since:"1.0.0",OPB64name:"SWAP"},{name:"SWITCH",detail:"SWITCH( cond1:MACRO exec1:MACRO condn:MACRO execn:MACRO default:MACRO n:LONG ): ",documentation:"Performs a [switch statement](https://en.wikipedia.org/wiki/Switch_statement) allowing to select a macro execution based on a series of condition macros or to fallback on to the execution of a default macro.\n\n@param `n` Number of cases to consider. The `SWITCH` function will expect `n` pairs of condition/execution macros plus a default macro on the stack.\n\n@param `default` Macro which will be executed if all condition macros returned false.\n\n@param `cond1` First condition macro. All condition macros are expected to push a boolean on the stack.\n\n@param `condn` `n`th condition macro.\n\n@param `exec1` First execution macro, this macro will be executed if `cond1` left `true` on the stack.\n\n@param `execn` `n`th execution macro.\n\n",tags:["control"],since:"1.0.0",OPB64name:"SWITCH"},{name:"SYMBOLS",detail:"SYMBOLS(): symbols:LIST",documentation:"The `SYMBOLS` function outputs the list of all defined symbols.\n\n@param `symbols` The list of the names of all defined symbols.\n\n",tags:["stack"],since:"2.2.1",OPB64name:"SYMBOLS"},{name:"SYNC",detail:"SYNC( macro:MACRO ): ",documentation:"Executes a macro in a synchronized way while in a parallel execution triggered by a call to [`CEVAL`](/doc/CEVAL). If `SYNC` is called outside of a parallel execution, it simply executes the macro.\n\nWhen called within a `CEVAL` execution, the use of `SYNC` guarantees that only one of the concurrently executing threads will execute the specified macro at any given time.\n\n@param `macro` Macro to execute in a synchronized way.\n\n",tags:["extensions"],since:"1.0.0",OPB64name:"SYNC"},{name:"T",detail:"T(): b:BOOLEAN",documentation:"`T` stand for `true`. It is a boolean constant.\n\n\n@param `b` true\n\n",tags:["logic","constants"],since:"1.0.0",OPB64name:"T"},{name:"TAN",detail:"TAN( value:NUMBER ): result:DOUBLE\nTAN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `TAN` function consumes a floating point number from the top of the stack and pushes back its tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Tangent of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of tangent of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TAN"},{name:"TANH",detail:"TANH( value:NUMBER ): result:DOUBLE\nTANH( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"The `TANH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic tangent of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic tangent of the given values.\n\n",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TANH"},{name:"TDESCRIBE",detail:"TDESCRIBE( object:ANY ): description:STRING",documentation:"The `TDESCRIBE` function is a recursive [`TYPEOF`](/doc/TYPEOF).\n\nWhen `TDESCRIBE` finds a LIST, it takes the first element of the list to look for his type. When `TDESCRIBE` finds a MAP, it takes a random key in the map to look for the type of the key and the type of the value.\n\n**By design, TDESCRIBE cannot describe heterogeneous lists or maps.**\n\nTDESCRIBE output is subject to change in the future. Do not try to parse it. This function is here to help you during Warpscript development.\n\n\nThe `TDESCRIBE` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `object` Any kind of reference\n\n@param `description` The description of the object\n\n",tags:["extensions","debug"],since:"1.2.19",OPB64name:"TDESCRIBE"},{name:"TEMPLATE",detail:"TEMPLATE( template:STRING dictionnary:MAP ): output:STRING\nTEMPLATE( template:STRING listofmaps:LIST<MAP> ): output:STRING",documentation:"`TEMPLATE` fills a template with values contained in a map. See example for syntax help.\n\nThe `TEMPLATE` function expects the map of values on top of the stack and will operate on the string template below it.\n\nValues speficied with `{{key}}` will be url-escaped. If you do not want that behavior, use `{{{key}}}`.\n\n@param `dictionnary` Each key will be replaced in a {{key}} template. Value could be string long, double, boolean, or a list of maps. If Value is a list of maps, each subkey/value will be replaced in a {{#key}}{{subkey}}{{/key}} template. \n\n@param `listofmaps` Contains a list of subkey/value map. Will be replaced in a {{#key}}{{subkey}}{{/key}} template.\n\n@param `template` Input template.\n\n@param `output` Result of substitution.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TEMPLATE"},{name:"THRESHOLDTEST",detail:"THRESHOLDTEST( gts:GTS threshold:DOUBLE ): ticks:LIST<LONG>\nTHRESHOLDTEST( lgts:LIST<GTS> threshold:DOUBLE ): lticks:LIST<LIST<LONG>>",documentation:"Analyzes Geo Time Series™, identifying ticks where values are outliers above the given threshold.\n\n@param `threshold` Threshold above which values are considered outliers.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `ticks` List of ticks where outliers were found.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lticks` List of lists of ticks where outliers were found.\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"THRESHOLDTEST"},{name:"TICKINDEX",detail:"TICKINDEX( gts:GTS ): indexed:GTS\nTICKINDEX( lgts:LIST<GTS> ): lindexed:LIST<GTS>\nTICKINDEX( encoder:GTSENCODER ): indexedenc:GTSENCODER\nTICKINDEX( lencoder:LIST<GTSENCODER> ): lindexedenc:LIST<GTSENCODER>",documentation:"Creates a clone of a Geo Time Series™, replacing each tick with the index (0 based) at which it appears at the moment of the call.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `encoder` Geo Time Series™ Encoder instance to transform.\n\n@param `indexed` Transformed GTS.\n\n@param `indexedenc` Transformed GTS Encoder.\n\n@param `lgts` List of Geo Time Series™ instances to transform.\n\n@param `lencoder` List of Geo Time Series™ Encoder instances to transform.\n\n@param `lindexed` List of indexed Geo Time Series™.\n\n@param `lindexedenc` List of indexed Geo Time Series™ Encoder.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TICKINDEX"},{name:"TICKLIST",detail:"TICKLIST( gts:GTS ): ticks:LIST<LONG>\nTICKLIST( lgts:LIST<GTS> ): lticks:LIST<LIST<LONG>>\nTICKLIST( encoder:GTSENCODER ): ticks:LIST<LONG>\nTICKLIST( lencoder:LIST<GTSENCODER> ): lticks:LIST<LIST<LONG>>",documentation:"Pushes onto the stack the list of ticks of a Geo Time Series™ or encoder. The ticks appear in the order in which they are found.\n\nIf a list of Geo Time Series™ is given, the result is a list of list of ticks as if the TICKLIST function was applied to each Geo Time Series™ separately.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n@param `encoder` Instance of encoder from which to extract the ticks.\n\n@param `lencoder` List of encoders.\n\n@param `ticks` List of extracted ticks.\n\n@param `lticks` List of lists of ticks.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TICKLIST"},{name:"TICKS",detail:"TICKS( gts:GTS ): ticks:LIST<LONG>\nTICKS( lgts:LIST<GTS> ): ticks:LIST<LONG>",documentation:"Pushes onto the stack the sorted list of **distinct** ticks of a Geo Time Series™. If a list of Geo Time Series™ is given, all the **distinct** ticks are returned in a single sorted list as if all Geo Time Series™ were merged.\n\nThis function is not to be confused with [`TICKLIST`](/doc/TICKLIST) as this function returns **distinct** ticks and acts as it merges Geo Time Series™.\n\n@param `ticks` List of extracted ticks.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TICKS"},{name:"TIMEBOX",detail:"TIMEBOX( macro:MACRO maxtime:LONG ): ",documentation:"The `TIMEBOX` executes a macro with a maximum execution time. If the maximum time is reached, an exception will be thrown which can be caught using [`TRY`](/doc/TRY).\n\n@param `maxtime` Maximum execution time, in platform time units.\n\n@param `macro` Macro to execute.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"TIMEBOX"},{name:"TIMECLIP",detail:"TIMECLIP( gts:GTS end:LONG duration:LONG ): clipped:GTS\nTIMECLIP( lgts:LIST<GTS> end:LONG duration:LONG ): lclipped:LIST<GTS>\nTIMECLIP( gts:GTS stop:STRING start:STRING ): clipped:GTS\nTIMECLIP( lgts:LIST<GTS> stop:STRING start:STRING ): lclipped:LIST<GTS>\nTIMECLIP( encoder:GTSENCODER end:LONG duration:LONG ): clippedEncoder:GTSENCODER\nTIMECLIP( lencoder:LIST<GTSENCODER> end:LONG duration:LONG ): lclippedEncoders:LIST<GTSENCODER>\nTIMECLIP( encoder:GTSENCODER stop:STRING start:STRING ): clippedEncoder:GTSENCODER\nTIMECLIP( lencoder:LIST<GTSENCODER> stop:STRING start:STRING ): lclippedEncoders:LIST<GTSENCODER>",documentation:"Clips Geo Time Series™ instances by restricting their ticks to those within a time interval.      \n\n@param `duration` Width of the time interval to retain, in time units.\n\n@param `end` Most recent timestamp to retain.\n\n@param `start` Start timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `stop` End timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `clipped` Clipped Geo Time Series™.\n\n@param `lclipped` List of clipped GTS.\n\n@param `encoder` Single GTS Encoder instance.\n\n@param `lencoder` List of GTS Encoder instances.\n\n@param `clippedEncoder` Clipped GST encoder.\n\n@param `lclippedEncoders` List of clipped GTS encoders.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMECLIP"},{name:"TIMED",detail:"TIMED( macro:MACRO name:STRING ): timedMacro:MACRO",documentation:"The `TIMED` function converts a macro to a timed macro, recording its execution time and its number of calls.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\n@param `name` A name identifying the macro.\n\n@param `macro` The macro you want to monitor.\n\n@param `timedMacro` A macro which, when called, will update the statitics associated with the given name.\n\n",tags:["debug"],since:"2.1.0",OPB64name:"TIMED"},{name:"TIMEMODULO",detail:"TIMEMODULO( gts:GTS modulus:LONG label:STRING ): splits:LIST<GTS>\nTIMEMODULO( lgts:LIST<GTS> modulus:LONG label:STRING ): lsplits:LIST<LIST<GTS>>",documentation:"Splits Geo Time Series™ into sub-GTS whose timestamps are the original timestamp modulo a given modulus value. Each sub-GTS will bear a label with the quotient of the original timestamps divided by the modulus. The output list order is not guaranteed, use [`SORTBY`](/doc/SORTBY) if you want to order the output by label.\n\nThis function can be used to generate for example one Geo Time Series™ per day with ticks from 0 to 86400 s (excluded).\n\n@param `label` Name of the label which will have the quotient value.\n\n@param `modulus` Value by which to divide the original timestamps.\n\n@param `gts` Geo Time Series™ to split.\n\n@param `splits` Resulting splits.\n\n@param `lgts` List of GTS to split.\n\n@param `lsplits` List of lists of resulting splits.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMEMODULO"},{name:"TIMEOFF",detail:"TIMEOFF(): ",documentation:"Turns off the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"TIMEOFF"},{name:"TIMEON",detail:"TIMEON(): ",documentation:"Turns on the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"TIMEON"},{name:"TIMESCALE",detail:"TIMESCALE( gts:GTS scale:DOUBLE ): scaled:GTS\nTIMESCALE( gts:GTS scale:LONG ): scaled:GTS\nTIMESCALE( lgts:LIST<GTS> scale:DOUBLE ): lscaled:LIST<GTS>\nTIMESCALE( lgts:LIST<GTS> scale:LONG ): lscaled:LIST<GTS>",documentation:"Modifies the ticks of Geo Time Series™ instances by multiplying each tick by a provided scale.      \n\nThe resulting tick will be converted to a LONG after multiplication by the scale.\n\nIf the Geo Time Series™ instance is bucketized, the `lastbucket` and `bucketspan` parameters will also be scaled. If the scale would incur a `bucketspan` of 0, the call will end with an error.\n\n@param `scale` Scale by which to multiply each tick.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `scaled` Geo Time Series™ result.\n\n@param `lscaled` List of Geo Time Series™ result.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMESCALE"},{name:"TIMESHIFT",detail:"TIMESHIFT( gts:GTS offset:LONG ): shifted:GTS\nTIMESHIFT( lgts:LIST<GTS> offset:LONG ): lshifted:LIST<GTS>",documentation:"Shifts the ticks of Geo Time Series™ instances by a given amount.\n\n@param `offset` Offset to apply to the ticks, in time units.\n\n@param `gts` Single Geo Time Series™ instance to shift.\n\n@param `lgts` List of GTS to shift.\n\n@param `shifted` Shifted Geo Time Series™.\n\n@param `lshifted` List of shifted Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMESHIFT"},{name:"TIMESPLIT",detail:"TIMESPLIT( gts:GTS quietperiod:LONG minvalues:LONG label:STRING ): splits:LIST<GTS>\nTIMESPLIT( lgts:LIST<GTS> quietperiod:LONG minvalues:LONG label:STRING ): lsplits:LIST<LIST<GTS>>",documentation:"The `TIMESPLIT` functions splits Geo Time Series™ instances based on *quiet periods*, *i.e.* periods during which the GTS has no values.\n\nWhenever a quiet period longer than a minimum duration is encountered, the Geo Time Series™ is split.\n\nIf input gts has no values or if 'label' is already part of the labels of 'gts', then the resulting list of GTS will only contain a clone of 'gts'. **Make sure to test your GTS split size if needed.**\n\n@param `label` Name of label in which to store the sequence number.\n\n@param `minvalues` Minimum number of values a split should contain. Splits with less than that many values will be discarded.\n\n@param `quietperiod` Minimum duration of the silent period (*i.e.* with no values) between splits.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TIMESPLIT"},{name:"TIMINGS",detail:"",documentation:"Turns on the collection of timing information for each line of the script. The collected timings can be put onto the stack by using [`ELAPSED`](/doc/ELAPSED).\n\n",tags:["stack"],since:"1.0.0",OPB64name:"TIMINGS"},{name:"TLTTB",detail:"TLTTB( gts:GTS samples:LONG ): downsampled:GTS\nTLTTB( lgts:LIST<GTS> samples:LONG ): ldownsampled:LIST<GTS>",documentation:"The `TLTTB` function performs downsampling of Geo Time Series™ by applying the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data. It differs from the [`LTTB`](doc/LTTB) function by the fact that it considers time based buckets instead of buckets based on a number of values.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",tags:["gts"],since:"1.0.11",OPB64name:"TLTTB"},{name:"TOBIN",detail:"TOBIN( param:LONG ): result:STRING",documentation:"Converts the long on top of the stack to its 64 bits binary representation.\n\n@param `param` value to convert\n\n@param `result` String converted binary representation of param\n\n",tags:["conversion","strings","binary"],since:"1.0.0",OPB64name:"TOBIN"},{name:"TOBITS",detail:"TOBITS( number:NUMBER ): bits:LONG\nTOBITS( gts:GTS ): longgts:GTS",documentation:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n**Deprecation notice** the `TOBITS` function will be removed, please use `->DOUBLEBITS` or `->FLOATBITS`.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",tags:["math","gts"],since:"1.0.0",OPB64name:"TOBITS"},{name:"TOBOOLEAN",detail:"TOBOOLEAN( value:BOOLEAN ): result:BOOLEAN\nTOBOOLEAN( value:NUMBER ): result:BOOLEAN\nTOBOOLEAN( value:STRING ): result:BOOLEAN",documentation:"Converts a value of primitive type into a boolean value.\n\nThe `TOBOOLEAN` function consumes a parameter from the top of the stack and pushes back its conversion to boolean.\nNumbers will be false if they are equal to 0 and true otherwise.\nStrings will be false if they are equals to '' and true otherwise.\n\n@param `value` The value of primitive type\n\n@param `result` The boolean conversion of the value\n\n",tags:["conversion"],since:"1.0.5",OPB64name:"TOBOOLEAN"},{name:"TODEGREES",detail:"TODEGREES( angle:NUMBER ): result:DOUBLE\nTODEGREES( langle:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"Converts an angle measured in radians to its equivalent in degrees.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from radians to degrees.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in radian to convert in degree\n\n@param `result` Result of the conversion from radians to degrees\n\n@param `langle` List of angles in radian to convert in degree\n\n@param `lresult` List of results of the conversion from radians to degrees\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TODEGREES"},{name:"TODOUBLE",detail:"TODOUBLE( value:BOOLEAN ): result:DOUBLE\nTODOUBLE( value:NUMBER ): result:DOUBLE\nTODOUBLE( value:STRING ): result:DOUBLE",documentation:"Converts a value of primitive type into a double value.\n\nThe `TODOUBLE` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to double.\n\n@param `value` The value of primitive type\n\n@param `result` The double conversion of the value\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TODOUBLE"},{name:"TOHEX",detail:"TOHEX( input:LONG ): output:STRING",documentation:"Converts a long to its 64 bits hexadecimal representation.\n\n@param `input` Signed long integer.\n\n@param `output` Hexadecimal string representation of input.\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TOHEX"},{name:"TOINTEXACT",detail:"TOINTEXACT( value:NUMBER ): result:LONG\nTOINTEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<LONG>",documentation:"The `TOINTEXACT` function consumes one LONG from the top of the stack and puts back the value. If the result overflows an INT, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be checked not to overflow an INT\n\n@param `result` The given value, converted to Long\n\n@param `lvalue` List of values to be checked not to overflow an INT\n\n@param `lresult` List of given values, converted to Long\n\n",tags:["math"],since:"1.2.23",OPB64name:"TOINTEXACT"},{name:"TOKENDUMP",detail:"TOKENDUMP( token:STRING ): map:MAP\nTOKENDUMP( token:STRING secret:STRING ): map:MAP",documentation:"Deciphers a token and outputs a map describing the various elements of the token.\n\nThe map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Original token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| params | MAP | Map of token parameters, can be used as input to [`TOKENGEN`](/doc/TOKENGEN) |\n\nThe `params` map contains the following entries for both `READ` and `WRITE` tokens:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| type  | STRING | `READ` or `WRITE` depending on the type of token |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in ms since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in ms since the Unix Epoch |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nAdditionally, for `READ` tokens, the map contains those entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, those will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nNote that the `TOKENDUMP` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration key was not set.\n\n\n@param `token` Token to decode.\n\n@param `map` Map with the extracted parameters, the original token and its *ident*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENDUMP` from Worf.\n\n",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENDUMP"},{name:"TOKENGEN",detail:"TOKENGEN( params:MAP ): result:MAP\nTOKENGEN( params:MAP secret:STRING ): result:MAP",documentation:"Generates a token given a map of parameters. The `TOKENGEN` function outputs a map.\n\nThe input parameter map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| id | STRING | Optional identifier that will be put verbatim in the result map |\n| type  | STRING | `READ` or `WRITE` depending on the type of token to generate |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in **milliseconds** since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in **milliseconds** since the Unix Epoch |\n| ttl | LONG | If `expiry` is not specified, a time to live can be set with this key. The TTL is expressed in **milliseconds**, the computed expiry timestamp will be the issuance timestamp plus the ttl |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nWhen generating a `READ` token, the following parameters are needed to ensure data isolation:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, they will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nIf one of these parameter key is not set or set to an empty list, then the generated `READ` token will be granted access to all the scope associated with the parameter key. For example, if `owners` is not set, data from all owners will be accessible to this token.\n\nThe `TOKENGEN` function outputs a map with the following keys:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Generated token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| id | STRING | Optional identifier if the `id` key was specified in the parameter map |\n\nNote that the `TOKENGEN` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration was not set.\n\n@param `params` Map of parameters used to generate the token.\n\n@param `result` Map containing the token, its *ident* and an optional *id*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENGEN` from Worf.\n\n",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENGEN"},{name:"TOKENINFO",detail:"TOKENINFO( token:STRING ): infos:MAP",documentation:"Retrieves information from token.\n\nThe `TOKENINFO` function consumes a token from the top of the stack and pushes back a map containing the token information:\n* type: type of token 'Read' or 'Write'\n* issuance: timestamp of token creation, in **milliseconds** since the Unix Epoch \n* expiry: timestamp of token expiration, in **milliseconds** since the Unix Epoch \n* application: name of the application accessing the data\n* apps: list of applications whose data can be accessed (usually limited to a single application)\n\n@param `token` Token to extract informations\n\n@param `infos` Token informations extract from the tokens\n\n",tags:["platform"],since:"1.0.0",OPB64name:"TOKENINFO"},{name:"TOKENSECRET",detail:"TOKENSECRET( newsecret:STRING secret:STRING ): ",documentation:"Modifies the secret needed for using `TOKENGEN` or `TOKENDUMP`.\n\nThis function is only useable if a secret was configured using `token.secret`.\n\n@param `secret` Current secret for token operations, initially the value configured via `token.secret`.\n\n@param `newsecret` New secret to set for token operations.\n\n",tags:["extensions","platform"],since:"2.0.3",OPB64name:"TOKENSECRET"},{name:"TOLONG",detail:"TOLONG( value:BOOLEAN ): result:LONG\nTOLONG( value:NUMBER ): result:LONG\nTOLONG( value:STRING ): result:LONG\nTOLONG( array:BYTES ): result:LONG",documentation:"Converts a value of primitive type or a **BYTE ARRAY** into a long value.\n\nThe `TOLONG` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to long.\n\n@param `value` The value of primitive type\n\n@param `result` The long conversion of the value\n\n@param `array` Maximum 8 bytes to convert to a LONG. Sign is kept.\n\n",tags:["conversion","binary"],since:"1.0.0",OPB64name:"TOLONG"},{name:"TOLOWER",detail:"TOLOWER( input:STRING ): output:STRING",documentation:"Converts the **STRING** on top of the stack to lower case.\n\n@param `input` input string\n\n@param `output` Lower case string\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TOLOWER"},{name:"TORADIANS",detail:"TORADIANS( angle:NUMBER ): result:DOUBLE\nTORADIANS( langle:LIST<NUMBER> ): lresult:LIST<DOUBLE>",documentation:"Converts an angle measured in degrees to its equivalent in radians.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from degrees to radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in degree to convert in radian\n\n@param `result` Result of the conversion from degree to radian\n\n@param `langle` List of angles in degree to convert in radian\n\n@param `lresult` List of results of the conversion from degree to radian\n\n",tags:["conversion"],since:"1.0.0",OPB64name:"TORADIANS"},{name:"TOSELECTOR",detail:"TOSELECTOR( gts:GTS ): selector:STRING\nTOSELECTOR( gtslist:LIST<GTS> ): selectorlist:LIST<STRING>\nTOSELECTOR( encoder:GTSENCODER ): selector:STRING\nTOSELECTOR( encoderlist:LIST<GTSENCODER> ): selectorlist:LIST<STRING>",documentation:"The `TOSELECTOR` function takes a Geo Time Series™ or Geo Time Series™ LIST from the top of the stack and, for each encountered GTS, replace it with a selector which would select it.\n\nThis selector can be used as input of [`PARSESELECTOR`](/doc/PARSESELECTOR) for a [`FETCH`](/doc/FETCH).\n\n@param `gts` The input Geo Time Series™.\n\n@param `gtslist` The input list of Geo Time Series™.\n\n@param `encoder` The input encoder.\n\n@param `encoderlist` The input list of encoders.\n\n@param `selector` The selector string.\n\n@param `selectorlist` The list of selector strings, one per GTS in gtslist.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"TOSELECTOR"},{name:"TOSTRING",detail:"TOSTRING( value:NUMBER ): result:STRING\nTOSTRING( value:BOOLEAN ): result:STRING\nTOSTRING( value:STRING ): result:STRING\nTOSTRING( value:GTS ): result:STRING",documentation:"Converts a value of primitive type into a string value.\n\nThe `TOSTRING` function consumes a parameter from the top of the stack and pushes back its conversion to string.\n\nNote that GTS are converted to input format and that the string ends with CRLF to follow HTTP recommendations.\n\n@param `value` The value of primitive type\n\n@param `result` The string conversion of the value\n\n",tags:["strings","conversion"],since:"1.0.0",OPB64name:"TOSTRING"},{name:"TOTIMESTAMP",detail:"TOTIMESTAMP( input:STRING ): result:LONG",documentation:"Converts a date in format ISO8601 into a timestamp in the platform's time unit.\n\nThe `TOTIMESTAMP` function consumes a string parameter (date + time + time zone) from the top of the stack and pushes back its conversion to a number of time units since the Unix Epoch.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nThe supported format is ISO8601 and are:\n* yyyy-mm-dddThh:mm:ss.ssssssZ\n* yyyy-mm-dddThh:mm:ss+hh:mm\n\nAs the string are URL encoded, the symbol + have to be replaced by %2B, otherwise a space will replace the + in the string.\n\n@param `input` ISO8601 string.\n\n@param `result` timestamp in the platform unit.\n\n",tags:["conversion","date"],since:"1.0.0",OPB64name:"TOTIMESTAMP"},{name:"TOUPPER",detail:"TOUPPER( input:STRING ): output:STRING",documentation:"Converts the **STRING** on top of the stack to upper case.\n\n@param `input` input string\n\n@param `output` Upper case string\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TOUPPER"},{name:"TR",detail:"TR( matrix:MATRIX ): trace:DOUBLE",documentation:"Computes the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a square matrix. If the input matrix is not square, an error is raised.\n\n@param `matrix` The square matrix for which to compute the trace.\n\n@param `trace` The computed trace.\n\n",tags:["math"],since:"1.0.6",OPB64name:"TR"},{name:"TRANSPOSE",detail:"TRANSPOSE( matrix:MATRIX ): transpose:MATRIX",documentation:"Computes the [transpose](https://en.wikipedia.org/wiki/Transpose) of a matrix.\n\n@param `matrix` Matrix to transpose.\n\n@param `transpose` The transpose of the original matrix.\n\n",tags:["math"],since:"1.0.6",OPB64name:"TRANSPOSE"},{name:"TRIM",detail:"TRIM( str:STRING ): trimmedstr:STRING",documentation:"Trims whitespaces from both ends of the string on top of the stack.\n\n@param `str` String to trim\n\n@param `trimmedstr` String trimmed\n\n",tags:["strings"],since:"1.0.0",OPB64name:"TRIM"},{name:"TRY",detail:"TRY( try:MACRO catch:MACRO finally:MACRO ): ",documentation:"The `TRY` function provides a way to execute a macro in a safety harness with [Exception handling](https://en.wikipedia.org/wiki/Exception_handling).\n\nIf an error is thrown, it is recorded and will be available via [`ERROR`](/doc/ERROR).\n\n@param `try` Macro whose execution is *attempted*.\n\n@param `catch` Macro which will be executed if an error is encountered while executing the `try` macro.\n\n@param `finally` Macro which will be executed unconditionally after either the `try` or `try`/`catch` execution.\n\n",tags:["control"],since:"1.2.11",OPB64name:"TRY"},{name:"TSELEMENTS",detail:"TSELEMENTS( timestamp:LONG ): dateAndTimeElements:LIST<LONG>\nTSELEMENTS( timestamp:LONG timezone:STRING ): dateAndTimeElements:LIST<LONG>",documentation:"Alias of [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nThe `TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",tags:["date","time"],since:"1.0.0",OPB64name:"TSELEMENTS"},{name:"TSELEMENTS->",detail:"TSELEMENTS->( dateAndTimeElements:LIST<LONG> ): timestamp:LONG\nTSELEMENTS->( dateAndTimeElements:LIST<LONG> timezone:STRING ): timestamp:LONG",documentation:"The `TSELEMENTS->` function consumes an optional **STRING** timezone and a **LIST** of **LONG** describing a time and date and pushes back the **LONG** timestamp. The **LIST** of **LONG** follows the format given by [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",tags:["date","time"],since:"1.2.0",OPB64name:"K4C4I3KCGJtJJmoy"},{name:"TYPEOF",detail:"TYPEOF( object:ANY ): type:STRING",documentation:"Gets the type of an element.\n\nThe `TYPEOF` function consumes the top element on the stack and pushes back a string containing the type. The output could be:\n+ AGGREGATOR\n+ BITSET\n+ BOOLEAN\n+ BYTES\n+ CONTEXT\n+ COUNTER\n+ DOUBLE\n+ FILLER\n+ FILTER\n+ GEOSHAPE\n+ GTS\n+ GTSENCODER\n+ KEY\n+ LIST\n+ LONG\n+ MACRO\n+ MAP\n+ MARK\n+ MATCHER\n+ MATRIX\n+ NULL\n+ OPERATOR\n+ PFONT\n+ PGRAPHICS\n+ PIMAGE\n+ PSHAPE\n+ REDUCER\n+ SET\n+ STRING\n+ VECTOR\n+ VLIST\n\nFor any object introduced by a WarpScript extension whose output of TYPEOF is not in the list thereof, the output would be preceded by \"X-\".\n\nNote: since revision 2.5.0, the TYPEOF output of bucketizers, mappers, reducers is changed from 'MAPPER' to 'AGGREGATOR'.\n\n\n@param `object` Any kind of reference\n\n@param `type` The type of the object\n\n",tags:["stack","debug"],since:"1.0.0",OPB64name:"TYPEOF"},{name:"UDF",detail:"UDF( class:STRING ): ",documentation:"The `UDF` function invokes a User Defined Function from a Jar. A new function instance is loaded at each invocation.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",tags:["control"],since:"1.0.0",OPB64name:"UDF"},{name:"ULP",detail:"ULP( value:NUMBER ): ulp:DOUBLE\nULP( lvalue:LIST<NUMBER> ): lulp:LIST<DOUBLE>",documentation:"Returns the size of the [ULP (Unit in the Last Place)](https://en.wikipedia.org/wiki/Unit_in_the_last_place) for the argument. The ulp for a DOUBLE is the positive distance between this floating-point value and the DOUBLE value next larger in magnitude.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `ulp` Computed ULP.\n\n@param `lvalue` List of numeric values.\n\n@param `lulp` List of computed ULPs.\n\n",tags:["math"],since:"1.0.0",OPB64name:"ULP"},{name:"UNBUCKETIZE",detail:"UNBUCKETIZE( gts:GTS ): gts:GTS\nUNBUCKETIZE( lgts:LIST<GTS> ): lgts:LIST<GTS>",documentation:"Transforms a bucketized Geo Time Series™ into a non bucketized one. Note that this function transforms the original GTS, it does not clone it.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™ instances.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"UNBUCKETIZE"},{name:"UNBUCKETIZE.CALENDAR",detail:"UNBUCKETIZE.CALENDAR( gts:GTS ): gts:GTS\nUNBUCKETIZE.CALENDAR( lgts:LIST<GTS> ): lgts:LIST<GTS>",documentation:"On a GTS that is calendar-bucketized, this function replaces the ticks with the timestamp end boundaries of each bucket, and unbucketize it.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `lgts` One or more lists of Geo Time Series™\n\n",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"UNBUCKETIZE.CALENDAR"},{name:"UNGZIP",detail:"UNGZIP( compressed:BYTES ): uncompressed:BYTES",documentation:"Decompresses a byte array containing data compressed by [`GZIP`](doc/GZIP).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",tags:["conversion"],since:"1.0.11",OPB64name:"UNGZIP"},{name:"UNION",detail:"UNION( setA:SET setB:SET ): output:SET",documentation:"Computes the union &#x222a; of two sets.\n\nThe `UNION` function consumes two sets from the top of the stack and pushes back its mathematical union.\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x222a; *B*\n\n",tags:["sets"],since:"1.0.0",OPB64name:"UNION"},{name:"UNIQUE",detail:"UNIQUE( input:LIST ): output:LIST",documentation:"The `UNIQUE` function eliminates duplicate elements on the LIST on the top of the stack.\nThe order of the resulting LIST is not the same than the original one.\n\nIt makes elements of a list unique by converting it to a set temporarily. See [()](/doc/91Z) for more informations.\n\n@param `input` The list to parse\n\n@param `output` The new list object, without any duplicates\n\n",tags:["lists"],since:"1.0.0",OPB64name:"UNIQUE"},{name:"UNLIST",detail:"UNLIST( list:LIST ): mark:MARK elts:ANY*",documentation:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`]`](/doc/MF).\n\n@param `list` List to expand.\n\n@param `elts` Elements of `list`.\n\n@param `mark` Instance of MARK.\n\n",tags:["lists"],since:"1.0.11",OPB64name:"UNLIST"},{name:"UNMAP",detail:"UNMAP( map:MAP ): mark:MARK k1:ANY v1:ANY kN:ANY vN:ANY",documentation:"Unpacks a map, pushing its keys and values onto the stack along a mark as the deepest stack element such that one can use [`}`](/doc/UF) to rebuild the map.\n\n@param `k1` First map key.\n\n@param `v1` First map value.\n\n@param `kN` Nth map key.\n\n@param `vN` Nth map value.\n\n@param `map` Map to unpack.\n\n@param `mark` Mark indicating the deepest level to consider when building the map.\n\n",tags:["maps"],since:"1.0.11",OPB64name:"UNMAP"},{name:"UNPACK",detail:"UNPACK( list:BYTES format:STRING ): result:LIST<ANY>",documentation:"The `UNPACK` function unpacks a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n* **<**: No bigendian\n* **>**: Bigendian\n* **L**: Long\n* **B**: Boolean\n* **D**: Double length always equals 64.\n* **<L32**: No bigendian 32 bits Long\n\n@param `list` Pqcked list to unpack\n\n@param `format` Format used to unpack\n\n@param `result` Unpacked list\n\n",tags:["lists"],since:"1.0.7",OPB64name:"UNPACK"},{name:"UNSECURE",detail:"UNSECURE( secure:STRING ): script:STRING",documentation:"The `UNSECURE` function decrypts a secure script. The correct secret MUST have been set unsing [`SECUREKEY`](doc/SECUREKEY) prior to calling this function.\n\n@param `secure` STRING with the secure script to decode.\n\n@param `script` Decoded scripted.\n\n",tags:["crypto","stack"],since:"1.0.0",OPB64name:"UNSECURE"},{name:"UNSET",detail:"UNSET( set:SET ): mark:MARK elts:ANY*",documentation:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`)`](/doc/9F).\n\n@param `set` Set to expand.\n\n@param `elts` Elements of `set`.\n\n@param `mark` Instance of MARK.\n\n",tags:["sets"],since:"2.6.0",OPB64name:"UNSET"},{name:"UNTIL",detail:"UNTIL( code:MACRO condition:MACRO ): \nUNTIL( code:MACRO condition:MACRO index:BOOLEAN ): ",documentation:"The `UNTIL` function implements an until loop. It takes two macros as arguments from the stack: the code to execute until the condition is true and the condition to evaluate after every iteration.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force UNTIL to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `code` Macro executed on each loop\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",tags:["control"],since:"1.0.0",OPB64name:"UNTIL"},{name:"UNWRAP",detail:"UNWRAP( wrapped:STRING ): gts:GTS\nUNWRAP( wrappedbytes:BYTES ): gts:GTS\nUNWRAP( lwrapped:LIST<STRING> ): lgts:LIST<GTS>\nUNWRAP( lwrapped:LIST<BYTES> ): lgts:LIST<GTS>",documentation:"Unwraps packed Geo Time Series™ instances.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"UNWRAP"},{name:"UNWRAPEMPTY",detail:"UNWRAPEMPTY( wrapped:STRING ): gts:GTS\nUNWRAPEMPTY( wrappedbytes:BYTES ): gts:GTS\nUNWRAPEMPTY( lwrapped:LIST<STRING> ): lgts:LIST<GTS>\nUNWRAPEMPTY( lwrapped:LIST<BYTES> ): lgts:LIST<GTS>",documentation:"Unwraps wrapped Geo Time Series™ instances without unpacking the actual datapoints. This is handy to extract the metadata (class, labels, attributes) from a set of wrapped GTS.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPEMPTY"},{name:"UNWRAPENCODER",detail:"UNWRAPENCODER( wrapped:STRING ): encoder:GTSENCODER\nUNWRAPENCODER( wrappedbytes:BYTES ): encoder:GTSENCODER\nUNWRAPENCODER( lwrapped:LIST<STRING> ): lencoder:LIST<GTSENCODER>\nUNWRAPENCODER( lwrapped:LIST<BYTES> ): lencoder:LIST<GTSENCODER>",documentation:"Unwraps packed Geo Time Series™ into encoders.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `encoder` Encoder with decoded Geo Time Series™ datapoints.\n\n@param `lencoder` List of encoders with decoded Geo Time Series™.\n\n",tags:["gts"],since:"1.2.9",OPB64name:"UNWRAPENCODER"},{name:"UNWRAPSIZE",detail:"UNWRAPSIZE( wrapped:STRING ): size:LONG\nUNWRAPSIZE( wrappedbytes:BYTES ): size:LONG\nUNWRAPSIZE( lwrapped:LIST<STRING> ): lsize:LIST<LONG>\nUNWRAPSIZE( lwrapped:LIST<BYTES> ): lsize:LIST<LONG>",documentation:"Extracts the size (number of datapoints) of wrapped Geo Time Series™ instances.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `size` Decoded Geo Time Series™ size.\n\n@param `lsize` List of decoded Geo Time Series™ sizes.\n\n",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPSIZE"},{name:"UPDATE",detail:"UPDATE( gts:GTS token:STRING ): \nUPDATE( encoder:GTSENCODER token:STRING ): \nUPDATE( list:LIST<GTS> token:STRING ): \nUPDATE( list:LIST<GTSENCODER> token:STRING ): ",documentation:"Pushes Geo Time Series™ data to the Warp 10 instance.\n\nThe `UPDATE` function allows you to push data directly from your WarpScript code without having to retrieve the data and use the `/update` endpoint.\n\nThe GTS or Encoder instances to push *MUST* have a non empty name and in the case of Geo Time Series™ *MUST* have been renamed (to avoid pushing data by mistake which could override existing data you just retrieved).\n\n@param `token` Write token to use for pushing the data.\n\n@param `gts` Geo Time Series™ to push.\n\n@param `encoder` GTS Encoder to push.\n\n@param `list` List containing Geo Time Series™ and/or GTS Encoder instances to push.\n\n",tags:["gts","platform"],since:"1.0.0",OPB64name:"UPDATE"},{name:"UPDATEOFF",detail:"UPDATEOFF( message:STRING secret:STRING ): ",documentation:"Disables update operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when an update operation is attempted.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEOFF"},{name:"UPDATEON",detail:"UPDATEON( secret:STRING ): ",documentation:"Enables update operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEON"},{name:"URLDECODE",detail:"URLDECODE( encoded:STRING ): decoded:STRING",documentation:"Decodes a [URL encoded](https://en.wikipedia.org/wiki/Percent-encoding) STRING.\n\n@param `encoded` Encoded STRING to decode.\n\n@param `decoded` Decoded STRING.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"URLDECODE"},{name:"URLENCODE",detail:"URLENCODE( string:STRING ): encoded:STRING",documentation:"Encodes a STRING using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and replacing occurrences of '+' with '%20'.\n\nThe character set used is [UTF-8](https://en.wikipedia.org/wiki/UTF-8).\n\n@param `string` Input STRING to encode.\n\n@param `encoded` Encoded version of 'string' using the UTF-8 character set.\n\n",tags:["strings"],since:"1.0.0",OPB64name:"URLENCODE"},{name:"URLFETCH",detail:"URLFETCH( url:STRING ): result:LIST<LIST>\nURLFETCH( url:STRING headers:MAP ): result:LIST<LIST>\nURLFETCH( urls:LIST<STRING> ): result:LIST<LIST>\nURLFETCH( urls:LIST<STRING> headers:MAP ): result:LIST<LIST>",documentation:"The `URLFETCH` function sends HTTP(S) GET requests, waits for the responses and puts them on the stack.\n\nFor security reasons, the stack must be authenticated for this function to work, see [`AUTHENTICATE`](/doc/AUTHENTICATE).\n\nSince 2.7.0, this function also accepts a MAP of headers.\n\n@param `url` The URL to send the GET request to. Must begin with `http://` or `https://`.\n\n@param `urls` The list of URLs to send the GET requests to. Each URL must begin with `http://` or `https://`. \n\n@param `result` A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\n\n@param `headers` \n\n",tags:["extensions","web"],since:"1.0.2",OPB64name:"URLFETCH"},{name:"UUID",detail:"UUID(): uuid:STRING",documentation:"Pushes onto the stack a randomly generated [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n@param `uuid` Generated UUID string\n\n",tags:["misc"],since:"1.0.0",OPB64name:"UUID"},{name:"V->",detail:"V->( list:VLIST ): result:LIST",documentation:"The `V->` function converts a Vector (VLIST) on top of the stack into a list.\n\n@param `list` Input Vector.\n\n@param `result` Result list.\n\n",tags:["lists","conversion","pig"],since:"1.0.11",OPB64name:"KXoy"},{name:"VALUEDEDUP",detail:"VALUEDEDUP( gts:GTS order:BOOLEAN ): dedupgts:GTS\nVALUEDEDUP( lgts:LIST<GTS> order:BOOLEAN ): ldedupgts:LIST<GTS>",documentation:"Deletes duplicated values of the Geo Time Series™.\n\nThe `VALUEDEDUP` function takes as parameter a **GTS** or a **LIST** of **GTS** and it removes its duplicate values.\n\nExpects a boolean indicating whether we keep the oldest or most recent datapoint for a given value.\n\n@param `order` Boolean value, true for keeping the oldest datapoint for a given value, false otherwise.\n\n@param `gts` Geo Time Series™ for which to remove the duplicated values.\n\n@param `lgts` List of Geo Time Series™ for which to remove the duplicated values.\n\n@param `dedupgts` Geo Time Series™ with unique values.\n\n@param `ldedupgts` List of Geo Time Series™ with unique values.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUEDEDUP"},{name:"VALUEHISTOGRAM",detail:"VALUEHISTOGRAM( gts:GTS ): histogram:MAP\nVALUEHISTOGRAM( encoder:GTSENCODER ): histogram:MAP\nVALUEHISTOGRAM( list:LIST<GTS> ): lhistogram:LIST<MAP>",documentation:"Produces the value histogram of a Geo Time Series™ or (since 2.2.0) of a GTS Encoder.\n\nThe histogram is a map with an entry for each value (used as the map key), with an associated value equal to the number of occurrences of the value in the series.\n\nIf the input is a bucketized Geo Time Series™, the `NULL` key will have an associated value which is the number of buckets without values (assuming no datapoints were added at timestamps other than those of buckets).\n\nWhen the input is a GTS Encoder, keys may be BigDecimal, LONG, DOUBLE, BOOLEAN or STRING, binary values are not used as keys, their STRING representation (in ISO-8859-1) is used.\n\n@param `gts` Geo Time Series™ for which to compute the histogram\n\n@param `encoder` GTS Encoder for which to compute the histogram\n\n@param `histogram` The value histogram for the input Geo Time Series™ or GTS Encoder\n\n@param `list` List of Geo Time Series™ or GTS Encoders\n\n@param `lhistogram` The list of value histogram maps\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUEHISTOGRAM"},{name:"VALUELIST",detail:"VALUELIST( map:MAP ): values:LIST",documentation:"Gets values from a **MAP**.\n\nThe function `VALUELIST` extracts the values of a **MAP** on the top of the stack and pushes on the stack a list with those values. The **MAP** is consumed.\n\n\n@param `map` Map for which to get the values.\n\n@param `values` List of values for the input MAP.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"VALUELIST"},{name:"VALUES",detail:"VALUES( gts:GTS ): values:LIST\nVALUES( lgts:LIST<GTS> ): lvalues:LIST<LIST>\nVALUES( encoder:GTSENCODER ): values:LIST\nVALUES( lencoder:LIST<GTSENCODER> ): lvalues:LIST<LIST>",documentation:"Gets the values of Geo Time Series™ or encoders.\n\nThe `VALUES` function consumes a Geo Time Series™, an encoder or a list thereof from the stack, and it replaces each instance of Geo Time Series™ or encoder by a list of its values.\n\n@param `gts` Geo Time Series™ for which to get the values.\n\n@param `lgts` List of Geo Time Series™ for which to get the values.\n\n@param `encoder` Encoder for which to get the values.\n\n@param `lencoder` List of encoders for which to get the values.\n\n@param `values` List of values from the input Geo Time Series™.\n\n@param `lvalues` List of list of values from the input Geo Time Series™ list.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUES"},{name:"VALUESORT",detail:"VALUESORT( gts:GTS ): sortedgts:GTS\nVALUESORT( lgts:LIST<GTS> ): lsortedgts:LIST<GTS>",documentation:"Sorts values of the Geo Time Series™ in ascending order.\n\nThe function `VALUESORT` takes the **GTS** on top of the stack and sort its values (and associated locations/elevations) in ascending order.\n\n@param `gts` Geo Time Series™ for which to sort the values.\n\n@param `sortedgts` Geo Time Series™ with sorted values.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lsortedgts` List of Geo Time Series™ with sorted values.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUESORT"},{name:"VALUESPLIT",detail:"VALUESPLIT( gts:GTS label:STRING ): splitedgts:LIST<GTS>\nVALUESPLIT( lgts:LIST<GTS> label:STRING ): lsplitedgts:LIST<LIST<GTS>>",documentation:"Splits Geo Time Series™ by values.\n\nThe function `VALUESPLIT` takes one **STRING** on top of the stack plus one **GTS** or a list of **GTS**. It splits **GTS** by values and creates a **GTS** for each different value. For each new **GTS**, the label specified in parameter will be added.\n\nThe new **GTS** will be sorted by value with `VALUESORT`.\n\n@param `label` Label to add to the new Geo Time Series™.\n\n@param `gts` Geo Time Series™ to split by value.\n\n@param `splitedgts` List of Geo Time Series™ splited by value.\n\n@param `lgts` List of Geo Time Series™ to split by value.\n\n@param `lsplitedgts` List of Geo Time Series™ splited by value.\n\n",tags:["gts"],since:"1.0.0",OPB64name:"VALUESPLIT"},{name:"VARINT->",detail:"VARINT->( encoded:BYTES ): numbers:LIST<LONG>\nVARINT->( encoded:BYTES count:LONG ): numbers:LIST<LONG> processed:LONG",documentation:"The `VARINT` function decodes [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoded numbers.\n\n@param `numbers` List of decoded numbers.\n\n@param `encoded` Byte array containing the encoded number(s) to decode.\n\n@param `count` Maximum number of `LONG`s to decode.\n\n@param `processed` Number of bytes which were processed to decode the numbers.\n\n",tags:["conversion","binary"],since:"2.6.0",OPB64name:"KZ4HHJtJAIs"},{name:"VARS",detail:"VARS( macro:MACRO ): vars:LIST<STRING>\nVARS( macro:MACRO onlyPoprAndStore:BOOLEAN ): vars:LIST<STRING>",documentation:"Extracts all variables used in a macro. The `VARS` function scans the macro for occurrences of `LOAD`, `STORE` or `CSTORE` functions and inspects the associated variable name. If such a name is not an explicit STRING, the call to `VARS` will fail with an error.\n\nThe list of symbols is sorted according to the number of occurrences encountered, decreasing.\n\n@param `macro` Macro to inspect.\n\n@param `vars` List of encountered symbols.\n\n@param `onlyPoprAndStore` Returns only variables used by POPR, CPOPR and STORE. Defaults to false.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"VARS"},{name:"VEC->",detail:"VEC->( input:VECTOR ): result:LIST",documentation:"The `VEC->` function converts a Vector into a list.\n\n\n@param `input` Vector to convert\n\n@param `result` list\n\n",tags:["lists","conversion","math"],since:"1.0.6",OPB64name:"KZK2AIs"},{name:"WEBCALL",detail:"WEBCALL( token:STRING method:STRING url:STRING headers:MAP body:STRING ): uuid:STRING",documentation:"Makes an outbound HTTP call.\n\nNote that the hosts which may be reached via `WEBCALL` might have been restricted through the use of the `webcall.host.patterns` Warp&nbsp;10 configuration parameter.\n\nThe write token is here to check you have the right to send a webcall. If the write token is valid, then the request is sent. It will never be sent in the request.\n\nThe call to `WEBCALL` returns a UUID on the stack. The actual request is performed asynchronously, the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`.\n\n@param `body` body of the request.\n\n@param `headers` map of additionnal http headers.\n\n@param `url` supported schemes are http and https.\n\n@param `method` `GET` or `POST` string.\n\n@param `token` valid write token\n\n@param `uuid` the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`\n\n",tags:["web"],since:"1.0.0",OPB64name:"WEBCALL"},{name:"WF.ADDREPO",detail:"WF.ADDREPO( url:STRING ): ",documentation:"The `WF.ADDREPO` function allows you to add a repository to the list of repositories taken into account by the WarpFleet™ macro resolver.\n\nIf the URL is valid (syntaxically), then it will be added at the end of the current list of repositories scanned by the resolver. All repository URLs will then be validated by the `validator` macro defined in the configuration (`warpfleet.macros.validator`). Those URLs for which the `validator` macro returned true will be retained.\n\nNote that the repository is only added in the scope of the current stack.\n\n@param `url` URL to add to the list of repositories.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"WF.ADDREPO"},{name:"WF.GETREPOS",detail:"WF.GETREPOS(): repos:LIST<STRING>",documentation:"Retrieves the current list of repositories used by the WarpFleet™ resolver.\n\nNote that if the configuration disabled the use of this function (via `warpfleet.getrepos.disable`), the returned list will be empty even though it contains repositories.\n\n@param `repos` Current list of repository URLs.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"WF.GETREPOS"},{name:"WF.SETREPOS",detail:"WF.SETREPOS( repos:LIST<STRING> ): ",documentation:"Sets the list of repositories used by the WarpFleet™ resolver to the given value (list of valid URLs).\n\nEach URL is tested against WarpFleet™ validator macro to check if it is allowed. Non-valid ones are discarded.\n\nNote that this changes the list only for the scope of the current WarpScript execution.\n\n@param `repos` List of URLs to use for the WarpFleet™ resolver.\n\n",tags:["stack"],since:"2.0.3",OPB64name:"WF.SETREPOS"},{name:"WFOFF",detail:"WFOFF(): ",documentation:"The `WFOFF` function disables the WarpFleet™ Resolver. It can be re-enabled using `WFON`.\n\nThis is useful when you want to ensure that a macro call only looks it up locally.\n\n",tags:["stack"],since:"2.1.0",OPB64name:"WFOFF"},{name:"WFON",detail:"WFON(): ",documentation:"The `WFON` function enables the WarpFleet™ Resolver after it has been disabled by `WFOFF`.\n\n",tags:["stack"],since:"2.1.0",OPB64name:"WFON"},{name:"WHILE",detail:"WHILE( condition:MACRO code:MACRO ): \nWHILE( condition:MACRO code:MACRO index:BOOLEAN ): ",documentation:"The `WHILE` function implements a while loop. It takes two macros as arguments from the stack: the condition macro to evaluate and the macro to execute while the condition is true.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force WHILE to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `code` Macro executed on each loop\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",tags:["control"],since:"1.0.0",OPB64name:"WHILE"},{name:"WRAP",detail:"WRAP( encoder:GTSENCODER ): wrapped:STRING\nWRAP( lencoder:GTSENCODER ): lwrapped:LIST<STRING>\nWRAP( gts:GTS ): wrapped:STRING\nWRAP( lgts:LIST<GTS> ): lwrapped:LIST<STRING>",documentation:"The `WRAP` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a STRING.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"1.0.0",OPB64name:"WRAP"},{name:"WRAPFAST",detail:"WRAPFAST( encoder:GTSENCODER ): wrapped:BYTES\nWRAPFAST( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPFAST( gts:GTS ): wrapped:BYTES\nWRAPFAST( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",documentation:"The `WRAPFAST` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a byte array. For fast execution, the content of the GTS is not compressed, so the resulting byte array will be larger than that produced by `WRAPRAW`.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"2.1.0",OPB64name:"WRAPFAST"},{name:"WRAPMV",detail:"WRAPMV( encoder:GTSENCODER ): wrapped:BYTES\nWRAPMV( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPMV( gts:GTS ): wrapped:BYTES\nWRAPMV( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPRAWOPT`, `WRAPMV` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"WRAPMV"},{name:"WRAPMV!",detail:"WRAPMV!( encoder:GTSENCODER ): wrapped:BYTES\nWRAPMV!( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPMV!( gts:GTS ): wrapped:BYTES\nWRAPMV!( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPMV`, `WRAPMV!` attempts to optimize the representation of DOUBLE values for Geo Time Series™ but unlike `WARPMV`, it does not increase the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder","multivariate"],since:"2.6.0",OPB64name:"Kp80J3pL7F"},{name:"WRAPOPT",detail:"WRAPOPT( encoder:GTSENCODER ): wrapped:STRING\nWRAPOPT( lencoder:GTSENCODER ): lwrapped:LIST<STRING>\nWRAPOPT( gts:GTS ): wrapped:STRING\nWRAPOPT( lgts:LIST<GTS> ): lwrapped:LIST<STRING>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a STRING. The packing performed by `WRAPOPT` differs from that of [`WRAP`](/doc/WRAP) only by the fact that `WRAPOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",tags:["gts"],since:"1.2.3",OPB64name:"WRAPOPT"},{name:"WRAPRAW",detail:"WRAPRAW( encoder:GTSENCODER ): wrapped:BYTES\nWRAPRAW( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPRAW( gts:GTS ): wrapped:BYTES\nWRAPRAW( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",documentation:"The `WRAPRAW` function packs a Geo Time Series™ into a byte array.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"1.0.7",OPB64name:"WRAPRAW"},{name:"WRAPRAWOPT",detail:"WRAPRAWOPT( encoder:GTSENCODER ): wrapped:BYTES\nWRAPRAWOPT( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPRAWOPT( gts:GTS ): wrapped:BYTES\nWRAPRAWOPT( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",documentation:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES. The packing performed by `WRAPRAWOPT` differs from that of [`WRAPRAW`](/doc/WRAPRAW) only by the fact that `WRAPRAWOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",tags:["gts","encoder"],since:"1.2.3",OPB64name:"WRAPRAWOPT"},{name:"WSINFO",detail:"WSINFO( session:STRING ): infos:LIST<MAP>",documentation:"Displays informations about WarpScript environments with a given session id. The informations are returned as a map identical to that returned by [`WSPS`](/doc/WSPS):\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `session` Session of the environments to inspect.\n\n@param `infos` List of informations about each WarpScript execution environment with 'session' as their session name.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSINFO"},{name:"WSKILL",detail:"WSKILL( uuid:STRING secret:STRING ): status:BOOLEAN",documentation:"Kills the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP) and marking the environment as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to kill.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILL"},{name:"WSKILLSESSION",detail:"WSKILLSESSION( session:STRING ): count:LONG",documentation:"Kills the execution WarpScript programs by forcing a call to [`STOP`](/doc/STOP) and marking the environments as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `session` Session id of the WarpScript execution environments to kill.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILLSESSION"},{name:"WSNAME",detail:"WSNAME( name:STRING ): current:STRING",documentation:"Modifies the name associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stack.name` in the attributes map.\n\nName size is limited to 128 characters.\n\n@param `name` Name to assign to the calling execution environment, or `NULL` to simply read the current name.\n\n@param `current` Name assigned to the execution environment.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSNAME"},{name:"WSPS",detail:"WSPS( secret:STRING ): procs:LIST<MAP>",documentation:"Lists all the registers WarpScript execution environments. For each environment a map is returned with the following fields:\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `secret` Secret for process status operations.\n\n@param `procs` List of informations about each registered WarpScript execution environment.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSPS"},{name:"WSSESSION",detail:"WSSESSION( session:STRING ): current:STRING",documentation:"Modifies the session id associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stackps.session` in the attributes map.\n\nSession id size is limited to 128 characters.\n\nSession can also be set by setting the `X-Warp10-WarpScriptSession` header.\n\nOnce the session has been set it cannot be modified.\n\n@param `session` Session id to assign to the calling execution environment, or NULL to simply read the current session id.\n\n@param `current` The session id assigned to the execution environment.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSESSION"},{name:"WSSTACK",detail:"WSSTACK(): ",documentation:"Select the WarpScript™ (*i.e.* SNAPSHOT) format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",tags:["stack"],since:"2.0.0",OPB64name:"WSSTACK"},{name:"WSSTOP",detail:"WSSTOP( uuid:STRING secret:STRING ): status:BOOLEAN",documentation:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to stop.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOP"},{name:"WSSTOPSESSION",detail:"WSSTOPSESSION( session:STRING ): count:LONG",documentation:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\nThe environments to stop are identified by a session id.\n\n@param `session` Session of the WarpScript execution environments to stop.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOPSESSION"},{name:"Z->",detail:"Z->( z:BYTES n:LONG bitwidth:LONG ): longs:LIST<LONG>",documentation:"Unpacks LONG values from a [Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) stored in a byte array.\n\n@param `bitwidth` Size in bits of the LONG values to extract, from 1 to 63.\n\n@param `n` Number of LONG values to extract.\n\n@param `z` Byte array containing the Morton Code to unpack.\n\n@param `longs` List of extracted LONG values.\n\n",tags:["conversion"],since:"1.0.6",OPB64name:"LXoy"},{name:"ZDISCORDS",detail:"ZDISCORDS( window_size:LONG maximum:LONG overlapping:BOOLEAN distance:DOUBLE ): result:GTS",documentation:"The `ZDISCORDS` function detects discords in a standardized ([`STANDARDIZE`](/doc/STANDARDIZE) Geo Time Series™. The discord detection\n algorithm is based on identifying outlier patterns in the Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `ZDISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\nGiven the `ZDISCORDS` expects the Geo Time Series™ it operates on to be standardized ([`STANDARDIZE`](/doc/STANDARDIZE), the discord detection \nalgorithm is more sensitive than that of [`DISCORDS`](/doc/DISCORDS).\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0.\n\n@param `overlapping` Flag indicating whether or not the `ZDISCORDS` function should report overlapping discords.\n\n@param `maximum` The maximum number of discords to identify.\n\n@param `window_size` Window size which is the width of each interval on which the pattern extraction should be performed, a pattern length which will determine how the window is segmented, and lastly a quantization scale which will determine how many different buckets will be used to ventilate the series values. (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `result` Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™.\n\n",tags:["gts","outlier"],since:"1.0.13",OPB64name:"ZDISCORDS"},{name:"ZDTW",detail:"ZDTW( gts1:GTS gts2:GTS threshold:DOUBLE ): dtw:DOUBLE",documentation:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be Z-normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",tags:["gts","distance"],since:"1.2.11",OPB64name:"ZDTW"},{name:"ZIP",detail:"ZIP( input:LIST<LIST> ): output:LIST<LIST>",documentation:"The function ZIP takes a list of lists as parameters. Each list which are not singletons must be of same size.\n\nIt returns a list of lists where the i-th list contains the i-th elements of each input list in the same order.\n\nAlso, it considers singletons as a list of the same size with a duplicated value.\n\n@param `input` List of lists\n\n@param `output` List of lists\n\n",tags:["lists"],since:"1.0.0",OPB64name:"ZIP"},{name:"ZPATTERNDETECTION",detail:"ZPATTERNDETECTION( gts:GTS patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nZPATTERNDETECTION( lgts:LIST<GTS> patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",documentation:"The `ZPATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`ZPATTERNS`](/doc/ZPATTERNS) or [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe `ZPATTERNDETECTION` does not standardize the datapoints in the sliding window, assuming (wrongly) they already are.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `ZPATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform.\n\n@param `gts` The single GTS to transform.\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it.\n\n@param `lresult` The list of result GTS.\n\n",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNDETECTION"},{name:"ZPATTERNS",detail:"ZPATTERNS( gts:GTS wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nZPATTERNS( lgts:LIST<GTS> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",documentation:"Extracts symbolic patterns from Geo Time Series™ as [`PATTERNS`](/doc/PATTERNS) does, but does not standardize each window, assuming (wrongly) the GTS windows are already standardized.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNS"},{name:"ZSCORE",detail:"ZSCORE( gts:GTS flag:BOOLEAN ): result:GTS\nZSCORE( gtsList:LIST<GTS> flag:BOOLEAN ): resultList:LIST<GTS>",documentation:"The 'ZSCORE' function consumes a flag, then normalizes a Geo Time Series™ or a **LIST** of Geo Time Series™ that are below by replacing their values by their [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe flag indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median).\n\nIf the GTS isn’t of type **DOUBLE** or if the deviation equals 0, an exception is raised.\n\n@param `flag` Indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",tags:["gts"],since:"1.0.0",OPB64name:"ZSCORE"},{name:"ZSCORETEST",detail:"ZSCORETEST( gts:GTS mad:BOOLEAN ): result:LIST<LONG>\nZSCORETEST( lgts:LIST<GTS> mad:BOOLEAN ): lresult:LIST<LIST<LONG>>\nZSCORETEST( gts:GTS mad:BOOLEAN trigger:DOUBLE ): result:LIST<LONG>\nZSCORETEST( lgts:LIST<GTS> mad:BOOLEAN trigger:DOUBLE ): lresult:LIST<LIST<LONG>>",documentation:"The ZSCORETEST function detects outliers in a GTS by comparing the Z-score of its values with a given threshold.\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median). If this value is greater than the given threshold, it is flagged as an outlier.\n\nA LIST of ticks, corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n@param `gts` The Geo Time Series™ to test\n\n@param `result` List of the detected outliers timestamps\n\n@param `lgts` The list of Geo Time Series™ to test\n\n@param `lresult` List of list of the detected outliers timestamps\n\n@param `mad` False: use the mean/sigma, true: use the median/mad to calculate the Z-score\n\n@param `trigger` Optional threshold. Default value is 3.5\n\n",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ZSCORETEST"},{name:"[",detail:"[(): mark:MARK",documentation:"Starts a list creation.\n\nThe `[` function creates a list by pushing a mark onto the stack. This is a syntactic help to better present list constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",tags:["lists","stack"],since:"1.0.0",OPB64name:"Lk"},{name:"[[",detail:"[[(): mark:MARK",documentation:"Pushes a MARK on the stack. This is a syntaxic help to better present Vector (VLIST) constructions.\n \n\n@param `mark` A MARK instance.\n\n",tags:["pig"],since:"1.2.13",OPB64name:"Lpg"},{name:"[[]]",detail:"[[]](): vector:VLIST",documentation:"Pushes an empty Vector onto the stack.\n\n@param `vector` Empty Vector.\n\n",tags:["lists"],since:"1.2.13",OPB64name:"LphSMF"},{name:"[]",detail:"[]( content:ANY ): newlist:LIST",documentation:"The [] function creates an empty LIST on the top of the stack.\n\n\n@param `content` 0 to n elements.\n\n@param `newlist` list instance, initialized with content.\n\n",tags:["lists"],since:"1.0.0",OPB64name:"Lpo"},{name:"]",detail:"]( mark:MARK v1:ANY vN:ANY ): list:LIST",documentation:"Closes a currently open list and pushes it onto the stack.\n\n  The `]` function pops from the stack the elements of the list up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",tags:["lists"],since:"1.0.0",OPB64name:"MF"},{name:"]]",detail:"]]( mark:MARK v1:ANY vN:ANY ): list:VLIST",documentation:"Closes a currently open Vector (VLIST) and pushes it onto the stack. The elements on the stack are those up to the first mark encountered. The mark is discarded.\n\nVLIST are represented as lists on the stack.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",tags:["pig"],since:"1.2.13",OPB64name:"MKo"},{name:"^",detail:"^( p1:LONG p2:LONG ): result:LONG\n^( inputgts:GTS mask:LONG ): maskedgts:GTS\n^( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Performs a bitwise **XOR** operation.\n\nThe `^` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **XOR**.\n\nSince Warp 10™ 2.1, `^` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be XOR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with XOR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts XOR with mask\n\n",tags:["binary","operators"],since:"1.0.0",OPB64name:"MV"},{name:"bucketizer.and",detail:"bucketizer.and(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.and` function applies the logical operator **AND** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.and"},{name:"bucketizer.count",detail:"bucketizer.count(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.count` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count"},{name:"bucketizer.count.exclude-nulls",detail:"bucketizer.count.exclude-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.count.exclude-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.exclude-nulls` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.exclude-nulls"},{name:"bucketizer.count.include-nulls",detail:"bucketizer.count.include-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.count.include-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.include-nulls function computes the number of values, including null values, found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.include-nulls"},{name:"bucketizer.count.nonnull",detail:"bucketizer.count.nonnull(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.count.nonnull` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.nonnull"},{name:"bucketizer.first",detail:"bucketizer.first(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.first` function returns the first value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.first` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.first"},{name:"bucketizer.join",detail:"bucketizer.join( separator:STRING ): bucketizer:AGGREGATOR",documentation:"The `bucketizer.join` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join"},{name:"bucketizer.join.forbid-nulls",detail:"bucketizer.join.forbid-nulls( separator:STRING ): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.join.forbid-nulls` has the same behavior as `bucketizer.join`, use `bucketizer.join` instead.\n\nThe `bucketizer.join.forbid-nulls` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join.forbid-nulls"},{name:"bucketizer.last",detail:"bucketizer.last(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.last` function returns the last value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.last` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.last"},{name:"bucketizer.mad",detail:"bucketizer.mad(): bucketizer:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) of each bucket.\n\nThe returned location is the median of all the locations in the bucket, and the returned elevation is the median of all the elevations in the bucket.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.2.0",OPB64name:"bucketizer.mad"},{name:"bucketizer.max",detail:"bucketizer.max(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.max` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max"},{name:"bucketizer.max.forbid-nulls",detail:"bucketizer.max.forbid-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.max.forbid-nulls` has the same behavior as `bucketizer.max`, use `bucketizer.max` instead.\n\nThe `bucketizer.max.forbid-nulls` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\nThe `bucketizer.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max.forbid-nulls"},{name:"bucketizer.mean",detail:"bucketizer.mean(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.mean` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean"},{name:"bucketizer.mean.circular",detail:"bucketizer.mean.circular( modulo:NUMBER ): bucketizer:AGGREGATOR",documentation:"The `bucketizer.mean.circular` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`bucketizer.mean.circular.exclude-nulls`](/doc/bucketizer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `bucketizer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular"},{name:"bucketizer.mean.circular.exclude-nulls",detail:"bucketizer.mean.circular.exclude-nulls( modulo:NUMBER ): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.mean.circular.exclude-nulls` has the same behavior as `bucketizer.mean.circular`, use `bucketizer.mean.circular` instead.\n        \nThe `bucketizer.mean.circular.exclude-nulls` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned.\n\nThe `bucketizer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular.exclude-nulls"},{name:"bucketizer.mean.exclude-nulls",detail:"bucketizer.mean.exclude-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.mean.exclude-nulls` has the same behavior as `bucketizer.mean`, use `bucketizer.mean` instead.\n \nThe `bucketizer.mean.exclude-nulls` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.exclude-nulls"},{name:"bucketizer.median",detail:"bucketizer.median(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.median` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.median"},{name:"bucketizer.median.forbid-nulls",detail:"bucketizer.median.forbid-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.median.forbid-nulls` has the same behavior as `bucketizer.median`, use `bucketizer.median` instead.\n\nThe `bucketizer.median.forbid-nulls` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"2.4.0",OPB64name:"bucketizer.median.forbid-nulls"},{name:"bucketizer.min",detail:"bucketizer.min(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.min` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min"},{name:"bucketizer.min.forbid-nulls",detail:"bucketizer.min.forbid-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.min.forbid-nulls` has the same behavior as `bucketizer.min`, use `bucketizer.min` instead.\n\nThe `bucketizer.min.forbid-nulls` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min.forbid-nulls"},{name:"bucketizer.or",detail:"bucketizer.or(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.or` function applies the logical operator **OR** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.or"},{name:"bucketizer.percentile",detail:"bucketizer.percentile( percentile:NUMBER ): bucketizer:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the bucket.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `percentile` Percentile to consider\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.percentile"},{name:"bucketizer.rms",detail:"bucketizer.rms(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.rms` function returns the root mean square of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are the last one encountered for each bucket.\n\nThe `bucketizer.rms` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.2.18",OPB64name:"bucketizer.rms"},{name:"bucketizer.sd",detail:"bucketizer.sd( bessel:BOOLEAN ): result:AGGREGATOR",documentation:"This bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Bucketizer to apply\n\n",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd"},{name:"bucketizer.sd.forbid-nulls",detail:"bucketizer.sd.forbid-nulls( bessel:BOOLEAN ): result:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.sd.forbid-nulls` has the same behavior as `bucketizer.sd`, use `bucketizer.sd` instead.\n\nThis bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd.forbid-nulls"},{name:"bucketizer.sum",detail:"bucketizer.sum(): bucketizer:AGGREGATOR",documentation:"The `bucketizer.sum` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum"},{name:"bucketizer.sum.forbid-nulls",detail:"bucketizer.sum.forbid-nulls(): bucketizer:AGGREGATOR",documentation:"**Deprecated**: `bucketizer.sum.forbid-nulls` has the same behavior as `bucketizer.sum`, use `bucketizer.sum` instead.\n\nThe `bucketizer.sum.forbid-nulls` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum.forbid-nulls"},{name:"d",detail:"d( input:NUMBER ): output:LONG",documentation:"Converts a number of days (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of days from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of days to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of days\n\n",tags:["date"],since:"1.0.0",OPB64name:"d"},{name:"e",detail:"e(): eValue:DOUBLE",documentation:"Alias of [E](/doc/GF).\n\nThe `e` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"OF"},{name:"filler.interpolate",detail:"filler.interpolate(): filler:FILLER",documentation:"Pushes onto the stack a *filler* function which fills missing values with a linear interpolation of enclosing values in a Geo Time Series™.\n\nNote that this function will not fill missing leading or trailing ticks as there is no possible interpolation.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.interpolate"},{name:"filler.next",detail:"filler.next(): filler:FILLER",documentation:"Pushes onto the stack a *filler* function which fills missing values with the next value in a Geo Time Series™.\n\nNote that this function will not fill missing trailing ticks as there is no next value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.next"},{name:"filler.previous",detail:"filler.previous(): filler:FILLER",documentation:"Pushes onto the stack a *filler* function which fills missing values with the previous value in a Geo Time Series™.\n\nNote that this function will not fill missing leading ticks as there is no previous value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.previous"},{name:"filler.trend",detail:"filler.trend(): filler:FILLER",documentation:"Pushes onto the stack a *filler* function which fills missing values with the centroid of the points computed by projecting trends from both sides of the missing point.\n\nNote that this function will fill all missing points.\n\n@param `filler` Filler function to use for filling missing values.\n\n",tags:["filler"],since:"2.0.0",OPB64name:"filler.trend"},{name:"filter.all.eq",detail:"filter.all.eq( filter-value:LONG ): result:FILTER\nfilter.all.eq( filter-value:DOUBLE ): result:FILTER\nfilter.all.eq( filter-value:BOOLEAN ): result:FILTER\nfilter.all.eq( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose every value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.eq"},{name:"filter.all.ge",detail:"filter.all.ge( filter-value:LONG ): result:FILTER\nfilter.all.ge( filter-value:DOUBLE ): result:FILTER\nfilter.all.ge( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose every value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ge"},{name:"filter.all.gt",detail:"filter.all.gt( filter-value:LONG ): result:FILTER\nfilter.all.gt( filter-value:DOUBLE ): result:FILTER\nfilter.all.gt( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose every value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.gt"},{name:"filter.all.le",detail:"filter.all.le( filter-value:LONG ): result:FILTER\nfilter.all.le( filter-value:DOUBLE ): result:FILTER\nfilter.all.le( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose every value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.le"},{name:"filter.all.lt",detail:"filter.all.lt( filter-value:LONG ): result:FILTER\nfilter.all.lt( filter-value:DOUBLE ): result:FILTER\nfilter.all.lt( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose every value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.lt"},{name:"filter.all.ne",detail:"filter.all.ne( filter-value:LONG ): result:FILTER\nfilter.all.ne( filter-value:DOUBLE ): result:FILTER\nfilter.all.ne( filter-value:BOOLEAN ): result:FILTER\nfilter.all.ne( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose every value does not equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ne"},{name:"filter.any.eq",detail:"filter.any.eq( filter-value:LONG ): result:FILTER\nfilter.any.eq( filter-value:DOUBLE ): result:FILTER\nfilter.any.eq( filter-value:BOOLEAN ): result:FILTER\nfilter.any.eq( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose at least one value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.eq"},{name:"filter.any.ge",detail:"filter.any.ge( filter-value:LONG ): result:FILTER\nfilter.any.ge( filter-value:DOUBLE ): result:FILTER\nfilter.any.ge( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ge"},{name:"filter.any.gt",detail:"filter.any.gt( filter-value:LONG ): result:FILTER\nfilter.any.gt( filter-value:DOUBLE ): result:FILTER\nfilter.any.gt( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.gt"},{name:"filter.any.le",detail:"filter.any.le( filter-value:LONG ): result:FILTER\nfilter.any.le( filter-value:DOUBLE ): result:FILTER\nfilter.any.le( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.le"},{name:"filter.any.lt",detail:"filter.any.lt( filter-value:LONG ): result:FILTER\nfilter.any.lt( filter-value:DOUBLE ): result:FILTER\nfilter.any.lt( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose at least one value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.lt"},{name:"filter.any.ne",detail:"filter.any.ne( filter-value:LONG ): result:FILTER\nfilter.any.ne( filter-value:DOUBLE ): result:FILTER\nfilter.any.ne( filter-value:BOOLEAN ): result:FILTER\nfilter.any.ne( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose at least one value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ne"},{name:"filter.byattr",detail:"filter.byattr( filter:MAP ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose attributes match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.11",OPB64name:"filter.byattr"},{name:"filter.byclass",detail:"filter.byclass( filter:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose class name matches the filter parameter.\n\n@param `filter` The filter parameter is a **STRING**, if it starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.byclass"},{name:"filter.bylabels",detail:"filter.bylabels( filter:MAP ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.bylabels"},{name:"filter.bylabelsattr",detail:"filter.bylabelsattr( filter:MAP ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose attributes or labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes or labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"1.0.11",OPB64name:"filter.bylabelsattr"},{name:"filter.bymetadata",detail:"filter.bymetadata( lgts:LIST<GTS> ): filter:FILTER",documentation:"Filter GTSs by retaining those whose metadata **exactly** match at least one metadata from the given GTS list. \n\nThe metadata consists of the classname and labels.\n\n@param `lgts` List of GTSs to extract the metadata from.\n\n@param `filter` Filter to apply which will keep only GTSs with exact metadata matching.\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.bymetadata"},{name:"filter.byselector",detail:"filter.byselector( selector:STRING ): result:FILTER",documentation:"This filter allow to select GTS with a standard or an extended selector.\n###### Standard selector: `classname{labelOrAttribute=x}`\n- If classname match, `filter.byselector` looks into input labels to check if labelOrAttribute exists and equals x. If labelOrAttribute is not found among input labels, it looks into input attributes if the label exists and equals x.\n###### Extended selector: `classname{labelname=x}{attributename=y}` matches if:\n- classname matches\n- input have labelname in its labels, and label value matches\n- input have attributename in its labels, and attribute value matches\n\n###### Selectors example:\n- `~.*{}` matches everything.\n- `={}` matches only emtpy classnames, whatever the labels and attributes.\n- `~.*{label=value}{} filter.byselector` is equivalent to `{ 'label' 'value' } filter.bylabels`.\n- `~.*{}{attribute~value} filter.byselector` is equivalent to `{ 'attribute' '~value' } filter.byattr`.\n\n\n@param `selector` The selector parameter. It could be a standard or an extended selector.\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.byselector"},{name:"filter.bysize",detail:"filter.bysize( min:LONG max:LONG ): result:FILTER",documentation:"Filter GTSs by retaining those whose size is contained between specified bounds (inclusive).\n\n@param `min` The minimum size\n\n@param `max` The maximum size\n\n@param `result` The filter to apply\n\n",tags:["filter"],since:"2.4.0",OPB64name:"filter.bysize"},{name:"filter.last.eq",detail:"filter.last.eq( filter-value:LONG ): result:FILTER\nfilter.last.eq( filter-value:DOUBLE ): result:FILTER\nfilter.last.eq( filter-value:BOOLEAN ): result:FILTER\nfilter.last.eq( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose last value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.eq"},{name:"filter.last.ge",detail:"filter.last.ge( filter-value:LONG ): result:FILTER\nfilter.last.ge( filter-value:DOUBLE ): result:FILTER\nfilter.last.ge( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose last value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ge"},{name:"filter.last.gt",detail:"filter.last.gt( filter-value:LONG ): result:FILTER\nfilter.last.gt( filter-value:DOUBLE ): result:FILTER\nfilter.last.gt( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose last value is greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.gt"},{name:"filter.last.le",detail:"filter.last.le( filter-value:LONG ): result:FILTER\nfilter.last.le( filter-value:DOUBLE ): result:FILTER\nfilter.last.le( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose last value is less or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.le"},{name:"filter.last.lt",detail:"filter.last.lt( filter-value:LONG ): result:FILTER\nfilter.last.lt( filter-value:DOUBLE ): result:FILTER\nfilter.last.lt( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose last value is less than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.lt"},{name:"filter.last.ne",detail:"filter.last.ne( filter-value:LONG ): result:FILTER\nfilter.last.ne( filter-value:DOUBLE ): result:FILTER\nfilter.last.ne( filter-value:BOOLEAN ): result:FILTER\nfilter.last.ne( filter-value:STRING ): result:FILTER",documentation:"This filter function only selects the Geo Time Series™ whose last value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ne"},{name:"filter.latencies",detail:"filter.latencies( minLatency:LONG maxLatency:LONG options:LIST<STRING> ): filter:FILTER",documentation:"Pushes onto the stack a *pseudo* FILTER which computes latencies in a network. It uses the [`FILTER`](/doc/FILTER) framework for conveniency but really returns new GTS.\n\nThe input Geo Time Series™ are assumed to have values which are fingerprints of packet payloads. The first GTS is assumed to be the *uplink* and all the other GTS the *downlinks*.\n\nThe ticks are the time at which a packet with the given fingerprint was observed.\n\nThe generated Geo Time Series™ will have the same ticks as the uplink one, except the values will be latencies instead of packet fingerprints.\n\nThe `filter.latencies` function accepts a number of options:\n\n| Option | Description |\n|--------|-------------|\n| uplink.latency.min | Compute minimum latency on the uplink. |\n| uplink.latency.max | Compute maximum latency on the uplink. |\n| downlink.latency.min | Compute minimum latency on each downlink. |\n| downlink.latency.max | Compute maximum latency on each downlink. |\n| downlink.matches | Compute the number of matches for each downlink. |\n| downlinks.totalmatches | Computes the total number of matches across downlinks. |\n| downlinks.bitsets | Computes a bitset of downlinks which saw the packet (limited to 64 downlinks). |\n| downlinks.withmatches | Computes the number of downlinks with matches for the given packet. |\n\nThis pseudo FILTER is very specific to a networking use case, but it is a good demonstration of the power of WarpScript and its frameworks.\n\n@param `options` List of options, see above for their description.\n\n@param `maxLatency` Maximum allowable latency, packets with latency above this threshold are ignored.\n\n@param `minLatency` Minimum latency, packets with a latency below this threshold are ignored.\n\n@param `filter` Instance of `filter.latencies`.\n\n",tags:["filter","gts"],since:"1.0.0",OPB64name:"filter.latencies"},{name:"h",detail:"h( input:NUMBER ): output:LONG",documentation:"Converts a number of hours (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of hours from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of hours to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of hours\n\n",tags:["date"],since:"1.0.0",OPB64name:"h"},{name:"m",detail:"m( input:NUMBER ): output:LONG",documentation:"Converts a number of minutes (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of minutes from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of minutes to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of minutes\n\n",tags:["date"],since:"1.0.0",OPB64name:"m"},{name:"mapper.abs",detail:"mapper.abs(): result:AGGREGATOR",documentation:"This mapper function returns the absolute value of single value in a sliding window.\n\nThe `mapper.abs` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.abs"},{name:"mapper.add",detail:"mapper.add( constant:DOUBLE ): result:AGGREGATOR\nmapper.add( constant:LONG ): result:AGGREGATOR",documentation:"This mapper function adds a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.add` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.add` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Value to add\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.add"},{name:"mapper.and",detail:"mapper.and(): result:AGGREGATOR",documentation:"This mapper function applies the logical operator **AND** on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.and"},{name:"mapper.ceil",detail:"mapper.ceil(): result:AGGREGATOR",documentation:"This mapper function rounds the single value in a sliding window to the closests greater **LONG**.\n\nThe `mapper.ceil` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.ceil"},{name:"mapper.count",detail:"mapper.count(): result:AGGREGATOR",documentation:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count"},{name:"mapper.count.exclude-nulls",detail:"mapper.count.exclude-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.count.exclude-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.exclude-nulls"},{name:"mapper.count.include-nulls",detail:"mapper.count.include-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.count.include-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.include-nulls"},{name:"mapper.count.nonnull",detail:"mapper.count.nonnull(): result:AGGREGATOR",documentation:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.nonnull"},{name:"mapper.day",detail:"mapper.day( timezone:STRING ): result:AGGREGATOR\nmapper.day( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the day of the tick for which it is computed.\n\nThe `mapper.day` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n@param `timezone` Timezone to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.day"},{name:"mapper.delta",detail:"mapper.delta(): result:AGGREGATOR",documentation:"This mapper function computes the delta between the last and first values (delta = last - first) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.delta` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does \nnot return any value.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.delta"},{name:"mapper.dotproduct",detail:"mapper.dotproduct( vector:LIST ): result:AGGREGATOR",documentation:"The `mapper.dotproduct` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct"},{name:"mapper.dotproduct.positive",detail:"mapper.dotproduct.positive( vector:LIST ): result:AGGREGATOR",documentation:"The `mapper.dotproduct.positive` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it sets all negative results to 0.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.positive"},{name:"mapper.dotproduct.sigmoid",detail:"mapper.dotproduct.sigmoid( vector:LIST ): result:AGGREGATOR",documentation:"The `mapper.dotproduct.sigmoid` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the sigmoid of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.sigmoid"},{name:"mapper.dotproduct.tanh",detail:"mapper.dotproduct.tanh( vector:LIST ): result:AGGREGATOR",documentation:"The `mapper.dotproduct.tanh` function consumes a vector as parameter (a **LIST* of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the \n[hyperbolic tangent](https://en.wikipedia.org/wiki/Hyperbolic_function) of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.tanh"},{name:"mapper.eq",detail:"mapper.eq( parameter:LONG ): result:AGGREGATOR\nmapper.eq( parameter:DOUBLE ): result:AGGREGATOR\nmapper.eq( parameter:BOOLEAN ): result:AGGREGATOR\nmapper.eq( parameter:STRING ): result:AGGREGATOR",documentation:"This mapper function returns the first value in a sliding window which is equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.eq` function can be applied to data of any type.\n\nThe `mapper.eq` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.eq"},{name:"mapper.eq.elev",detail:"mapper.eq.elev( parameter:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first elevation in a sliding window which is equal to a given value.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.eq.elev` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.elev"},{name:"mapper.eq.hhcode",detail:"mapper.eq.hhcode( parameter:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is equal to a given value.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.eq.hhcode` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.hhcode"},{name:"mapper.eq.lat",detail:"mapper.eq.lat( parameter:LONG ): result:AGGREGATOR\nmapper.eq.lat( parameter:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first latitude in a sliding window which is equal to a given value.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.eq.lat` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lat"},{name:"mapper.eq.lon",detail:"mapper.eq.lon( parameter:LONG ): result:AGGREGATOR\nmapper.eq.lon( parameter:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first longitude in a sliding window which is equal to a given value.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.eq.lon` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lon"},{name:"mapper.eq.tick",detail:"mapper.eq.tick( parameter:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first tick in a sliding window which is equal to a given value.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.eq.tick` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.tick"},{name:"mapper.exp",detail:"mapper.exp( constant:LONG ): result:AGGREGATOR\nmapper.exp( constant:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function raises a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.exp` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.exp` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\n> ## Note\n> The `mapper.exp` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n>\n> So you are looking for a way to apply the exponential function, ex, to a series of Geo Time Series™. It’s very easy to do it using `mapper.exp` and the\n> [`e`](/doc/OF) constant.\n\n@param `result` Mapper to apply\n\n@param `constant` Constant to use\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.exp"},{name:"mapper.finite",detail:"mapper.finite(): result:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which returns its input value only if it is finite (*i.e.* a non DOUBLE or a DOUBLE which is neither NaN nor Infinity).\n\n@param `result` Instance of mapper.finite.\n\n",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.finite"},{name:"mapper.first",detail:"mapper.first(): result:AGGREGATOR",documentation:"This mapper function returns the first value of each sliding window with its associated location and elevation.\n\nThe `mapper.first` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.first"},{name:"mapper.floor",detail:"mapper.floor(): result:AGGREGATOR",documentation:"This mapper function rounds the *single value* in a sliding window to the closests lower **LONG**.\n\nThe `mapper.floor` function can be applied to data of type **LONG** or **DOUBLE**.      \n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.floor"},{name:"mapper.ge",detail:"mapper.ge( threshold:LONG ): result:AGGREGATOR\nmapper.ge( threshold:STRING ): result:AGGREGATOR\nmapper.ge( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first value in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ge` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.ge` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ge"},{name:"mapper.ge.elev",detail:"mapper.ge.elev( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first elevation in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ge.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.elev"},{name:"mapper.ge.hhcode",detail:"mapper.ge.hhcode( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ge.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.hhcode"},{name:"mapper.ge.lat",detail:"mapper.ge.lat( threshold:LONG ): result:AGGREGATOR\nmapper.ge.lat( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first latitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ge.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lat"},{name:"mapper.ge.lon",detail:"mapper.ge.lon( threshold:LONG ): result:AGGREGATOR\nmapper.ge.lon( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first longitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ge.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lon"},{name:"mapper.ge.tick",detail:"mapper.ge.tick( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first tick in a sliding window which is greater or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ge.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.tick"},{name:"mapper.geo.approximate",detail:"mapper.geo.approximate( resolution:LONG ): result:AGGREGATOR",documentation:"Pushes onto the stack a mapper instance which will transform the input Geo Time Series™ by approximating the location to the givnen resolution.\n\nApproximation is done by clearing lower bits of the location [HHCode](https://en.wikipedia.org/wiki/HHCode). At resolution `R`, the lower `64 - 2R` bits are cleared.\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\n\n\n@param `resolution` HHCode resolution at which to approximate the locations. Resoluion is an even number between 2 (coarsest) and 32 (finest).\n\n@param `result` Instance of mapper.\n\n",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.approximate"},{name:"mapper.geo.clear",detail:"mapper.geo.clear(): result:AGGREGATOR",documentation:"Pushes onto the stack a mapper which will discard location and elevation information when applied to a Geo Time Series™.\n\nThis mapper can only be applied to single values\n\n@param `result` Instance of the `mapper.geo.clear` mapper.\n\n",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.geo.clear"},{name:"mapper.geo.fence",detail:"mapper.geo.fence( zone:GEOSHAPE ): result:AGGREGATOR",documentation:"This function produces a `mapper` which outputs a `BOOLEAN` for each point with an associated location. The value of the output is `true` if the location is inside the provided `GEOSHAPE` and `false` otherwise.\nThe geo zone can be defined in [WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using [`GEO.WKT`](/doc/GEO.WKT) or in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) using [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `zone` Geographical zone.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","geo"],since:"2.7.1",OPB64name:"mapper.geo.fence"},{name:"mapper.geo.outside",detail:"mapper.geo.outside( geoZone:GEOSHAPE ): result:AGGREGATOR",documentation:"This mapper filters the Geo Time Series™, keeping only the points outside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.outside"},{name:"mapper.geo.within",detail:"mapper.geo.within( geoZone:GEOSHAPE ): result:AGGREGATOR",documentation:"This mapper filters the Geo Time Series™, keeping only the points inside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.within"},{name:"mapper.gt",detail:"mapper.gt( threshold:LONG ): result:AGGREGATOR\nmapper.gt( threshold:STRING ): result:AGGREGATOR\nmapper.gt( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first value in a sliding window which is greater than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.gt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.gt` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.gt"},{name:"mapper.gt.elev",detail:"mapper.gt.elev( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first elevation in a sliding window which is greater than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.gt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.elev"},{name:"mapper.gt.hhcode",detail:"mapper.gt.hhcode( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.gt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.hhcode"},{name:"mapper.gt.lat",detail:"mapper.gt.lat( threshold:LONG ): result:AGGREGATOR\nmapper.gt.lat( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first latitude in a sliding window which is greater than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.gt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lat"},{name:"mapper.gt.lon",detail:"mapper.gt.lon( threshold:LONG ): result:AGGREGATOR\nmapper.gt.lon( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first longitude in a sliding window which is greater than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.gt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lon"},{name:"mapper.gt.tick",detail:"mapper.gt.tick( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first tick in a sliding window which is greater than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.gt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.tick"},{name:"mapper.hdist",detail:"mapper.hdist(): hdistMapper:AGGREGATOR",documentation:"The `mapper.hdist` function computes the total distance traveled while going through the points in the sliding window in chronological order. This distance is in meters.\n\nThe distance used is the loxodromic distance aka rhumb line. As a consequence, elevation is not taken into account in the distance.\n\nIf a point has no position in the sliding window, it is ignored.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe `mapper.hdist` function can be applied to data of any type since it only considers locations.\n\n@param `hdistMapper` A function which can be used in a mapper.\n\n",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.hdist"},{name:"mapper.highest",detail:"mapper.highest(): result:AGGREGATOR",documentation:"This mapper function returns the value associated with the highest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the most recent is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.highest"},{name:"mapper.hour",detail:"mapper.hour( timezone:STRING ): result:AGGREGATOR\nmapper.hour( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the hour of the tick for which it is computed.\n\nThe `mapper.hour` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.hour"},{name:"mapper.hspeed",detail:"mapper.hspeed(): result:AGGREGATOR",documentation:"This mapper function computes the horizontal speed along the path traveled in the sliding window.\n\nThe distance is computed by summing the distances along the rhumb line between two consecutive locations.\n\nIf there is only one tick in the sliding window, the speed is 0.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.hspeed` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.hspeed"},{name:"mapper.join",detail:"mapper.join( separator:STRING ): result:AGGREGATOR",documentation:"This mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join"},{name:"mapper.join.forbid-nulls",detail:"mapper.join.forbid-nulls( separator:STRING ): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.join.forbid-nulls` has the same behavior as `mapper.join`, use `mapper.join` instead.\n\nThis mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join.forbid-nulls"},{name:"mapper.kernel.cosine",detail:"mapper.kernel.cosine( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [cosine kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics.\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.cosine"},{name:"mapper.kernel.epanechnikov",detail:"mapper.kernel.epanechnikov( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using an [epanechnikov kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.epanechnikov"},{name:"mapper.kernel.gaussian",detail:"mapper.kernel.gaussian( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [gaussian kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.gaussian"},{name:"mapper.kernel.logistic",detail:"mapper.kernel.logistic( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [logistic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.logistic"},{name:"mapper.kernel.quartic",detail:"mapper.kernel.quartic( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [quartic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.quartic"},{name:"mapper.kernel.silverman",detail:"mapper.kernel.silverman( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [silverman kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.silverman"},{name:"mapper.kernel.triangular",detail:"mapper.kernel.triangular( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triangular kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triangular"},{name:"mapper.kernel.tricube",detail:"mapper.kernel.tricube( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [tricube kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.tricube"},{name:"mapper.kernel.triweight",detail:"mapper.kernel.triweight( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triweight kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triweight"},{name:"mapper.kernel.uniform",detail:"mapper.kernel.uniform( bandwidth:LONG step:LONG ): result:AGGREGATOR",documentation:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [uniform kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.uniform"},{name:"mapper.last",detail:"mapper.last(): result:AGGREGATOR",documentation:"This [`mapper`](/doc/MAP) function returns the last value of each sliding window with its associated location and elevation.\n\nThe `mapper.last` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.last"},{name:"mapper.le",detail:"mapper.le( threshold:DOUBLE ): result:AGGREGATOR\nmapper.le( threshold:LONG ): result:AGGREGATOR\nmapper.le( threshold:STRING ): result:AGGREGATOR",documentation:"This mapper function returns the first value in a sliding window which is less or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.le` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.le` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.le"},{name:"mapper.le.elev",detail:"mapper.le.elev( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first elevation in a sliding window which is less or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.le.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.elev"},{name:"mapper.le.hhcode",detail:"mapper.le.hhcode( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.le.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.hhcode"},{name:"mapper.le.lat",detail:"mapper.le.lat( threshold:LONG ): result:AGGREGATOR\nmapper.le.lat( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first latitude in a sliding window which is less or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.le.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lat"},{name:"mapper.le.lon",detail:"mapper.le.lon( threshold:LONG ): result:AGGREGATOR\nmapper.le.lon( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first longitude in a sliding window which is less or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.le.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lon"},{name:"mapper.le.tick",detail:"mapper.le.tick( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first tick in a sliding window which is less or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.le.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.tick"},{name:"mapper.log",detail:"mapper.log( constant:DOUBLE ): result:AGGREGATOR\nmapper.log( constant:LONG ): result:AGGREGATOR",documentation:"This mapper function takes the log of the **single value** in a sliding window in the base used as parameter to `mapper.log`.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.log` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.log` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\nThe `mapper.log` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n\n@param `constant` Constant parameter\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.log"},{name:"mapper.lowest",detail:"mapper.lowest(): result:AGGREGATOR",documentation:"This mapper function returns the value associated with the lowest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the one appearing first chronologically is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.lowest"},{name:"mapper.lt",detail:"mapper.lt( threshold:DOUBLE ): result:AGGREGATOR\nmapper.lt( threshold:LONG ): result:AGGREGATOR\nmapper.lt( threshold:STRING ): result:AGGREGATOR",documentation:"This mapper function returns the first value in a sliding window which is less than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.lt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.lt` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.lt"},{name:"mapper.lt.elev",detail:"mapper.lt.elev( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first elevation in a sliding window which is less than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.lt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.elev"},{name:"mapper.lt.hhcode",detail:"mapper.lt.hhcode( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.lt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.hhcode"},{name:"mapper.lt.lat",detail:"mapper.lt.lat( threshold:LONG ): result:AGGREGATOR\nmapper.lt.lat( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first latitude in a sliding window which is less than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.lt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lat"},{name:"mapper.lt.lon",detail:"mapper.lt.lon( threshold:LONG ): result:AGGREGATOR\nmapper.lt.lon( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first longitude in a sliding window which is less than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.lt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lon"},{name:"mapper.lt.tick",detail:"mapper.lt.tick( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first tick in a sliding window which is less than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.lt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.tick"},{name:"mapper.mad",detail:"mapper.mad(): result:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) over each sliding window.\n\nThe returned location is the median of all the locations in the sliding window, and the returned elevation is the median of all the elevations in the window.\n\n@param `result` Instance of `mapper.mad`.\n\n",tags:["mapper"],since:"1.2.0",OPB64name:"mapper.mad"},{name:"mapper.max",detail:"mapper.max(): result:AGGREGATOR",documentation:"This mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max"},{name:"mapper.max.forbid-nulls",detail:"mapper.max.forbid-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.max.forbid-nulls` has the same behavior as `mapper.max`, use `mapper.max` instead.\n\nThis mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max.forbid-nulls"},{name:"mapper.max.x",detail:"mapper.max.x( constant:DOUBLE ): result:AGGREGATOR\nmapper.max.x( constant:LONG ): result:AGGREGATOR\nmapper.max.x( constant:STRING ): result:AGGREGATOR\nmapper.max.x( constant:BOOLEAN ): result:AGGREGATOR",documentation:"This mapper function returns the max between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.max.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.max.x"},{name:"mapper.mean",detail:"mapper.mean(): result:AGGREGATOR",documentation:"This mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean"},{name:"mapper.mean.circular",detail:"mapper.mean.circular( modulo:NUMBER ): result:AGGREGATOR",documentation:"This function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`mapper.mean.circular.exclude-nulls`](/doc/mapper.mean.circular.exclude-nulls) if your sliding windows may contain nulls.\n\nThe `mapper.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular"},{name:"mapper.mean.circular.exclude-nulls",detail:"mapper.mean.circular.exclude-nulls( modulo:NUMBER ): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.mean.circular.exclude-nulls` has the same behavior as `mapper.mean.circular`, use `mapper.mean.circular` instead.\n\nThis function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular.exclude-nulls` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `mapper.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular.exclude-nulls"},{name:"mapper.mean.exclude-nulls",detail:"mapper.mean.exclude-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.mean.exclude-nulls` has the same behavior as `mapper.mean`, use `mapper.mean` instead.\n        \nThis mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.exclude-nulls"},{name:"mapper.median",detail:"mapper.median(): result:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median`.\n\n",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.median"},{name:"mapper.median.forbid-nulls",detail:"mapper.median.forbid-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.median.forbid-nulls` has the same behavior as `mapper.median`, use `mapper.median` instead.\n\nPushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median.forbid-nulls`.\n\n",tags:["mapper","gts"],since:"2.4.0",OPB64name:"mapper.median.forbid-nulls"},{name:"mapper.min",detail:"mapper.min(): result:AGGREGATOR",documentation:"This mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min"},{name:"mapper.min.forbid-nulls",detail:"mapper.min.forbid-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.min.forbid-nulls` has the same behavior as `mapper.min`, use `mapper.min` instead.\n\nThis mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min.forbid-nulls"},{name:"mapper.min.x",detail:"mapper.min.x( constant:DOUBLE ): result:AGGREGATOR\nmapper.min.x( constant:LONG ): result:AGGREGATOR\nmapper.min.x( constant:STRING ): result:AGGREGATOR\nmapper.min.x( constant:BOOLEAN ): result:AGGREGATOR",documentation:"This mapper function returns the min between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.min.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.min.x"},{name:"mapper.minute",detail:"mapper.minute( timezone:STRING ): result:AGGREGATOR\nmapper.minute( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the minute of the tick for which it is computed.\n\nThe `mapper.minute` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.minute"},{name:"mapper.mod",detail:"mapper.mod( modulus:NUMBER ): result:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which computes the remainder of a value given a modulus.\n\nThis MAPPER can only be applied to a single value.\n\n@param `modulus` Modulus to consider when computing the remainder.\n\n@param `result` Instance of `mapper.mod`.\n\n",tags:["mapper","gts"],since:"1.2.3",OPB64name:"mapper.mod"},{name:"mapper.month",detail:"mapper.month( timezone:STRING ): result:AGGREGATOR\nmapper.month( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the month of the tick for which it is computed.\n\nThe `mapper.month` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.month"},{name:"mapper.mul",detail:"mapper.mul( constant:LONG ): result:AGGREGATOR\nmapper.mul( constant:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function multiplies by a constant the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.mul` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.mul` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.mul"},{name:"mapper.ne",detail:"mapper.ne( parameter:LONG ): result:AGGREGATOR\nmapper.ne( parameter:DOUBLE ): result:AGGREGATOR\nmapper.ne( parameter:BOOLEAN ): result:AGGREGATOR\nmapper.ne( parameter:STRING ): result:AGGREGATOR",documentation:"This mapper function returns the first value in a sliding window which is not equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ne` function can be applied to data of any type.\n\nThe `mapper.ne` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ne"},{name:"mapper.ne.elev",detail:"mapper.ne.elev( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first elevation in a sliding window which is not equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ne.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.elev"},{name:"mapper.ne.hhcode",detail:"mapper.ne.hhcode( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first location expressed as a hhcode in a sliding window which is not equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ne.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.hhcode"},{name:"mapper.ne.lat",detail:"mapper.ne.lat( threshold:LONG ): result:AGGREGATOR\nmapper.ne.lat( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first latitude in a sliding window which is not equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ne.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lat"},{name:"mapper.ne.lon",detail:"mapper.ne.lon( threshold:LONG ): result:AGGREGATOR\nmapper.ne.lon( threshold:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function returns the first longitude in a sliding window which is not equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ne.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lon"},{name:"mapper.ne.tick",detail:"mapper.ne.tick( threshold:LONG ): result:AGGREGATOR",documentation:"This mapper function returns the first tick in a sliding window which is not equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ne.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.tick"},{name:"mapper.npdf",detail:"mapper.npdf( mu:DOUBLE sigma:DOUBLE ): result:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which returns the probability of a value given a normal distribution.\n\n@param `mu` Mean of the normal (Gaussian) distribution to consider.\n\n@param `sigma` Standard deviation of the normal (Gaussian) distribution to consider.\n\n@param `result` Instance of `mapper.npdf`.\n\n",tags:["gts","mapper"],since:"1.0.0",OPB64name:"mapper.npdf"},{name:"mapper.or",detail:"mapper.or(): result:AGGREGATOR",documentation:"This mapper function applies the logical operator OR on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.or"},{name:"mapper.parsedouble",detail:"mapper.parsedouble( tag:STRING ): result:AGGREGATOR",documentation:"This mapper function converts a **STRING** single value in a sliding window to **DOUBLE**.\n\nThe `mapper.parsedouble` function can be applied to data of type **STRING**.\n\nThis function expects a [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) \nparameter in top of the mapper. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `tag` [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) parameter. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.2.5",OPB64name:"mapper.parsedouble"},{name:"mapper.percentile",detail:"mapper.percentile( percentile:NUMBER ): result:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the sliding window.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `percentile` Percentile to consider.\n\n@param `result` Instance of `mapper.percentile`.\n\n",tags:["mapper","gts"],since:"1.0.0",OPB64name:"mapper.percentile"},{name:"mapper.pow",detail:"mapper.pow( constant:LONG ): result:AGGREGATOR\nmapper.pow( constant:DOUBLE ): result:AGGREGATOR",documentation:"This mapper function raises the single value in a sliding window to a constant power.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.pow` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.pow` function must be parameterized with the constant.\n\nThe result is always of type DOUBLE.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.pow"},{name:"mapper.product",detail:"mapper.product(): result:AGGREGATOR",documentation:"This mapper function computes the product of all the values found in the sliding window.\n\nThe `mapper.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\nOn [bucketized](/doc/BUCKETIZE) Geo Time Series™, it is necessary to fill gaps with [`FILLVALUE`](/doc/FILLVALUE)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.product"},{name:"mapper.rate",detail:"mapper.rate(): result:AGGREGATOR",documentation:"This mapper function computes the rate of change between the first and last values (rate = (last - first) / (lastick - firsttick)) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.rate` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value. If the\nsliding window contains less than 2 values, the rate of change will be 0.0.\n\nThe rate of change is expressed in units per second.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.rate"},{name:"mapper.replace",detail:"mapper.replace( constant:LONG ): result:AGGREGATOR\nmapper.replace( constant:DOUBLE ): result:AGGREGATOR\nmapper.replace( constant:STRING ): result:AGGREGATOR\nmapper.replace( constant:BOOLEAN ): result:AGGREGATOR",documentation:"This mapper function replaces windows with at least one value with a constant. The location and elevation returned are those associated with the most \nrecent value in the sliding window.\n\n@param `constant` constant used for replacement\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.replace"},{name:"mapper.rms",detail:"mapper.rms(): result:AGGREGATOR",documentation:"This mapper function returns the root mean square of all the values found in each sliding window. The associated location is the last one of the window.\n\nThe `mapper.rms` function can only be applied to values of type **LONG** or **DOUBLE**.\n\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.2.18",OPB64name:"mapper.rms"},{name:"mapper.round",detail:"mapper.round(): result:AGGREGATOR",documentation:"This mapper function rounds the *single value* in a sliding window to the closests **LONG**.\n\nThe `mapper.round` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.round"},{name:"mapper.sd",detail:"mapper.sd( bessel:BOOLEAN ): result:AGGREGATOR",documentation:"This mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd"},{name:"mapper.sd.forbid-nulls",detail:"mapper.sd.forbid-nulls( bessel:BOOLEAN ): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.sd.forbid-nulls` has the same behavior as `mapper.sd`, use `mapper.sd` instead.\n\nThis mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd.forbid-nulls"},{name:"mapper.second",detail:"mapper.second( timezone:STRING ): result:AGGREGATOR\nmapper.second( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the second of the tick for which it is computed.\n\nThe `mapper.second` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.second"},{name:"mapper.sigmoid",detail:"mapper.sigmoid(): result:AGGREGATOR",documentation:"This mapper function returns the sigmoid of *single value* in a sliding window.\n\nThe `mapper.sigmoid` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sigmoid"},{name:"mapper.sqrt",detail:"mapper.sqrt(): result:AGGREGATOR",documentation:"This mapper function computes the square root of the single value in a sliding window.\n\nFor negative numerics, this mapper returns **NaN**. For string values, this mapper returns 0.\n\nThe associated location and elevation are those of the single value.\n\n> ### Note\n> The `mapper.sqrt` mapper needs a single value sliding window, i.e. pre-window and post-window to 0\n\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.2.11",OPB64name:"mapper.sqrt"},{name:"mapper.sum",detail:"mapper.sum(): result:AGGREGATOR",documentation:"This mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum"},{name:"mapper.sum.forbid-nulls",detail:"mapper.sum.forbid-nulls(): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.sum.forbid-nulls` has the same behavior as `mapper.sum`, use `mapper.sum` instead.\n\nThis mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum.forbid-nulls"},{name:"mapper.tanh",detail:"mapper.tanh(): result:AGGREGATOR",documentation:"This mapper function returns the hyperbolic tangent of *single value* in a sliding window.\n\nThe `mapper.tanh` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tanh"},{name:"mapper.tick",detail:"mapper.tick(): result:AGGREGATOR",documentation:"This mapper function returns the tick for which it is computed. The associated location and elevation are those of the selected value.\n\nThe `mapper.tick` function can be applied to values of any type.        \n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.tick"},{name:"mapper.toboolean",detail:"mapper.toboolean(): result:AGGREGATOR",documentation:"This mapper function converts the single value in a sliding window to **BOOLEAN**.\n\nThe `mapper.toboolean` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.toboolean"},{name:"mapper.todouble",detail:"mapper.todouble(): result:AGGREGATOR",documentation:"This mapper function converts the single value in a sliding window to **DOUBLE**.\n\nThe `mapper.todouble` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.todouble"},{name:"mapper.tolong",detail:"mapper.tolong(): result:AGGREGATOR",documentation:"This mapper function converts the single value in a sliding window to **LONG**.\n\nThe `mapper.tolong` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tolong"},{name:"mapper.tostring",detail:"mapper.tostring(): result:AGGREGATOR",documentation:"This mapper function converts the single value in a sliding window to **STRING**.\n\nThe `mapper.tostring` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tostring"},{name:"mapper.truecourse",detail:"mapper.truecourse(): result:AGGREGATOR",documentation:"Pushes onto the stack a mapper which will compute the initial [true course]http://www.edwilliams.org/avform.htm#Crs) on a great circle from the first to the last datapoint in the sliding window.\n\nThe location and elevation of the result is that of the tick being considered.\n\n@param `result` Instance of mapper.truecourse.\n\n",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.truecourse"},{name:"mapper.var",detail:"mapper.var( bessel:BOOLEAN ): result:AGGREGATOR",documentation:"This mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var"},{name:"mapper.var.forbid-nulls",detail:"mapper.var.forbid-nulls( bessel:BOOLEAN ): result:AGGREGATOR",documentation:"**Deprecated**: `mapper.var.forbid-nulls` has the same behavior as `mapper.var`, use `mapper.var` instead.\n\nThis mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var.forbid-nulls"},{name:"mapper.vdist",detail:"mapper.vdist(): result:AGGREGATOR",documentation:"This mapper function computes the total distance traveled in the vertical plane in the sliding window.\n\nThe distance is computed by summing the distances between consecutive elevations (this differs from the computation done in [`mapper.vspeed`](/doc/mapper.vspeed))\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed distance is expressed in meters.\n\nThe `mapper.vdist` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vdist"},{name:"mapper.vspeed",detail:"mapper.vspeed(): result:AGGREGATOR",documentation:"This mapper function computes the vertical speed between the first and last readings of the sliding window. It does not compute the speed based on the total\nvertical distance traveled in the sliding window, it only considers its extrema (it differs significantly of what is done for horizontal speed in\n[`mapper.hspeed`](/doc/mapper.hspeed)), thus the result can be positive or negative.\n\nIf one of the extrema of the sliding window has no elevation, no value is returned.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.vspeed` function can be applied to data of any type since it only considers elevations.\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vspeed"},{name:"mapper.weekday",detail:"mapper.weekday( timezone:STRING ): result:AGGREGATOR\nmapper.weekday( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the day of the week of the tick for which it is computed.\n\nThe `mapper.weekday` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.weekday"},{name:"mapper.year",detail:"mapper.year( timezone:STRING ): result:AGGREGATOR\nmapper.year( offset:NUMBER ): result:AGGREGATOR",documentation:"This mapper function returns the year of the tick for which it is computed.\n\nThe `mapper.year` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.year"},{name:"max.tick.sliding.window",detail:"max.tick.sliding.window(): max:LONG",documentation:"Pushes onto the stack [`MAXLONG`](/doc/MAXLONG) divided by 2, to serve as the maximum number of ticks left or right of the current tick in a [`MAP`](/doc/MAP) sliding window.\n\nGiven that a Geo Time Series™ can have no more than 2**32 datapoints, this value is sufficient to cover the whole GTS left or right of the current tick.\n\n@param `max` Value pushed onto the stack.\n\n",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.tick.sliding.window"},{name:"max.time.sliding.window",detail:"max.time.sliding.window(): max:LONG",documentation:"Pushes onto the stack half of the minimum LONG value, to serve as a *pre* or *post* extension of a [`MAP`](/doc/MAP) sliding window in time units.\n\nThis value spans a lot of time but may not be enough to cover the entirety of a GTS.\n\n@param `max` Value pushed onto the stack.\n\n",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.time.sliding.window"},{name:"ms",detail:"ms( input:NUMBER ): output:LONG",documentation:"Converts a number of milliseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of milliseconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of milliseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of milliseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"ms"},{name:"ns",detail:"ns( input:NUMBER ): output:LONG",documentation:"Converts a number of nanoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of nanoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of nanoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of nanoseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"ns"},{name:"op.add",detail:"op.add(): op:OPERATOR",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter Geo Time Series™.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator forbids null values, *i.e.* if a `null` is encountered, then there will be no result for the given tick.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.add"},{name:"op.add.ignore-nulls",detail:"op.add.ignore-nulls(): op:OPERATOR",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter GTS.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.2.4",OPB64name:"op.add.ignore-nulls"},{name:"op.and",detail:"op.and(): op:OPERATOR",documentation:"To apply an `op.and` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.and"},{name:"op.and.ignore-nulls",detail:"op.and.ignore-nulls(): op:OPERATOR",documentation:"To apply an `op.and.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and.ignore-nulls` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.and.ignore-nulls"},{name:"op.div",detail:"op.div(): op:OPERATOR",documentation:"To apply an `op.div` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.div is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.div` operation can only operate on equivalence classes which have two GTS (if the equivalence class has more than two GTS, there is no result guaranted). It will divide at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.div"},{name:"op.eq",detail:"op.eq(): op:OPERATOR",documentation:"To apply an `op.eq` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.eq is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.eq` operation will check for equality at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.eq"},{name:"op.ge",detail:"op.ge(): op:OPERATOR",documentation:"To apply an `op.ge` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ge` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ge` operation will check at each tick if the value of the current GTS is greater or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.ge"},{name:"op.gt",detail:"op.gt(): op:OPERATOR",documentation:"To apply an `op.gt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.gt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.gt` operation will check at each tick if the value of the current GTS is greater than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.gt"},{name:"op.le",detail:"op.le(): op:OPERATOR",documentation:"To apply an `op.le` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.le` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.le` operation will check at each tick if the value of the current GTS is lesser or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.le"},{name:"op.lt",detail:"op.lt(): op:OPERATOR",documentation:"To apply an `op.lt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.lt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.lt` operation will check at each tick if the value of the current GTS is lesser than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.lt"},{name:"op.mask",detail:"op.mask(): op:OPERATOR",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), retains datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.mask"},{name:"op.mul",detail:"op.mul(): op:OPERATOR",documentation:"To apply an `op.mul` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.mul"},{name:"op.mul.ignore-nulls",detail:"op.mul.ignore-nulls(): op:OPERATOR",documentation:"To apply an `op.mul.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul.ignore-nulls` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.2.4",OPB64name:"op.mul.ignore-nulls"},{name:"op.ne",detail:"op.ne(): op:OPERATOR",documentation:"To apply an `op.ne` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ne` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ne` operation will check for inequality at each tick all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.ne"},{name:"op.negmask",detail:"op.negmask(): op:OPERATOR",documentation:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), removes datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The operator instance.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.negmask"},{name:"op.or",detail:"op.or(): op:OPERATOR",documentation:"To apply an `op.or` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.or"},{name:"op.or.ignore-nulls",detail:"op.or.ignore-nulls(): op:OPERATOR",documentation:"To apply an `op.or.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or.ignore-nulls` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.or.ignore-nulls"},{name:"op.sub",detail:"op.sub(): op:OPERATOR",documentation:"To apply an `op.sub` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.sub` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe sub operator can only operate on equivalence classes which have **exactly two GTS**. It will substract at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",tags:["op"],since:"1.0.11",OPB64name:"op.sub"},{name:"pi",detail:"pi(): pi:DOUBLE",documentation:"Alias of [PI](/doc/J3Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",tags:["math","constants"],since:"1.0.0",OPB64name:"R5Z"},{name:"ps",detail:"ps( input:NUMBER ): output:LONG",documentation:"Converts a number of picoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of picoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of picoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of picoseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"ps"},{name:"reducer.and",detail:"reducer.and(): reducer:AGGREGATOR",documentation:"The `reducer.and` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and"},{name:"reducer.and.exclude-nulls",detail:"reducer.and.exclude-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.and.exclude-nulls` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ \nwhich are in the same equivalence class, excluding nulls from the computation.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, \nthe current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and.exclude-nulls"},{name:"reducer.argmax",detail:"reducer.argmax( label:STRING maximum:LONG ): reducer:AGGREGATOR",documentation:"The `reducer.argmax` function outputs for each tick, the tick and the concatenation separated by ‘,’ of the values of the labels for which the\nvalue is the maximum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the maximum to report (use 0 to report all), and a **STRING**\nparameter to choose on which label it operates.\n\n@param `maximum` Maximum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmax"},{name:"reducer.argmin",detail:"reducer.argmin( label:STRING minimum:LONG ): reducer:AGGREGATOR",documentation:"The `reducer.argmin` function outputs for each tick, the tick and the concatenation separated by ‘,’ \nwith the values of the labels for which the value is the minimum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the minimum to report (use 0 to report all), and a **STRING** \nparameter to choose on which label it operates.\n\n@param `minimum` Minimum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmin"},{name:"reducer.count",detail:"reducer.count(): reducer:AGGREGATOR",documentation:"The `reducer.count` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe include null version, [`reducer.count.include-nulls`](/doc/reducer.count.include-nulls), will include null values when computing the count. The exclude null version, \n[`reducer.count.exclude-nulls`](/doc/reducer.count.exclude-nulls), will exclude null values when computing the count.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count"},{name:"reducer.count.exclude-nulls",detail:"reducer.count.exclude-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.count.exclude-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.exclude-nulls"},{name:"reducer.count.include-nulls",detail:"reducer.count.include-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.count.include-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are included.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.include-nulls"},{name:"reducer.count.nonnull",detail:"reducer.count.nonnull(): reducer:AGGREGATOR",documentation:"The `reducer.count.nonnull` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.nonnull"},{name:"reducer.join",detail:"reducer.join( separator:STRING ): reducer:AGGREGATOR",documentation:"The 'reducer.join' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will exclude all null values when computing the join.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join"},{name:"reducer.join.forbid-nulls",detail:"reducer.join.forbid-nulls( separator:STRING ): reducer:AGGREGATOR",documentation:"Alias of [`reducer.join.nonnull`](/doc/reducer.join.nonnull).\n\nThe 'reducer.join.forbid-nulls' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.forbid-nulls"},{name:"reducer.join.nonnull",detail:"reducer.join.nonnull( separator:STRING ): reducer:AGGREGATOR",documentation:"Alias of [`reducer.join.forbid-nulls`](/doc/reducer.join.forbid-nulls).\n\nThe 'reducer.join.nonnull' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.nonnull"},{name:"reducer.join.urlencoded",detail:"reducer.join.urlencoded( separator:STRING ): reducer:AGGREGATOR",documentation:"The 'reducer.join.urlencoded' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) charset.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.urlencoded"},{name:"reducer.mad",detail:"reducer.mad(): reducer:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) for each ticks. Null values are removed before computing the MAD for each ticks.\n\nThe returned location is the median of all the locations and the returned elevation is the median of all the elevations.\n\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.2.0",OPB64name:"reducer.mad"},{name:"reducer.max",detail:"reducer.max(): reducer:AGGREGATOR",documentation:"The `reducer.max` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will exclude all null values when computing the maximum.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max"},{name:"reducer.max.forbid-nulls",detail:"reducer.max.forbid-nulls(): reducer:AGGREGATOR",documentation:"Alias of [`reducer.max.nonnull`](/doc/reducer.max.nonnull).\n\nThe `reducer.max.forbid-nulls` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.forbid-nulls"},{name:"reducer.max.nonnull",detail:"reducer.max.nonnull(): reducer:AGGREGATOR",documentation:"Alias of [`reducer.max.forbid-nulls`](/doc/reducer.max.forbid-nulls).\n\nThe `reducer.max.nonnull` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.nonnull"},{name:"reducer.mean",detail:"reducer.mean(): reducer:AGGREGATOR",documentation:"The `reducer.mean` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean"},{name:"reducer.mean.circular",detail:"reducer.mean.circular( modulo:NUMBER ): reducer:AGGREGATOR",documentation:"The `reducer.mean.circular` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`reducer.mean.circular.exclude-nulls`](/doc/reducer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `reducer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular"},{name:"reducer.mean.circular.exclude-nulls",detail:"reducer.mean.circular.exclude-nulls( modulo:NUMBER ): reducer:AGGREGATOR",documentation:"The `reducer.mean.circular.exclude-nulls` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `reducer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular.exclude-nulls"},{name:"reducer.mean.exclude-nulls",detail:"reducer.mean.exclude-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.mean.exclude-nulls` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will exclude all null values when computing the mean.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.exclude-nulls"},{name:"reducer.median",detail:"reducer.median(): reducer:AGGREGATOR",documentation:"The `reducer.median` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.median"},{name:"reducer.median.forbid-nulls",detail:"reducer.median.forbid-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.median.forbid-nulls` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value, ie ticks do not match between Geo Times Series™ in the same equivalence class, it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"2.4.0",OPB64name:"reducer.median.forbid-nulls"},{name:"reducer.min",detail:"reducer.min(): reducer:AGGREGATOR",documentation:"The `reducer.min` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will exclude all null values when computing the minimum.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min"},{name:"reducer.min.forbid-nulls",detail:"reducer.min.forbid-nulls(): reducer:AGGREGATOR",documentation:"Alias of [`reducer.min.nonnull`](/doc/reducer.min.nonnull).\n\nThe `reducer.min.forbid-nulls` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.forbid-nulls"},{name:"reducer.min.nonnull",detail:"reducer.min.nonnull(): reducer:AGGREGATOR",documentation:"Alias of [`reducer.min.forbid-nulls`](/doc/reducer.min.forbid-nulls).\n\nThe `reducer.min.nonnull` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.nonnull"},{name:"reducer.or",detail:"reducer.or(): reducer:AGGREGATOR",documentation:"The `reducer.or` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or"},{name:"reducer.or.exclude-nulls",detail:"reducer.or.exclude-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.or.exclude-nulls` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or.exclude-nulls"},{name:"reducer.percentile",detail:"reducer.percentile(): reducer:AGGREGATOR",documentation:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values for each tick.\n\nFor this reducer, GTS must be aligned and must have a value for each tick of each GTS. \n\nThe returned location and elevation are those of the chosen value.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.percentile"},{name:"reducer.product",detail:"reducer.product(): reducer:AGGREGATOR",documentation:"This reducer function computes the product of all the values for each tick.\n\nThe `reducer.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.product"},{name:"reducer.rms",detail:"reducer.rms(): reducer:AGGREGATOR",documentation:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIf one value is null, there won't be any result for the concerned tick.\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms"},{name:"reducer.rms.exclude-nulls",detail:"reducer.rms.exclude-nulls(): reducer:AGGREGATOR",documentation:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms. Even if input GTS are misaligned, there will be one result per tick.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms.exclude-nulls"},{name:"reducer.sd",detail:"reducer.sd( bessel:BOOLEAN ): reducer:AGGREGATOR",documentation:"The `reducer.sd` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd"},{name:"reducer.sd.forbid-nulls",detail:"reducer.sd.forbid-nulls( bessel:BOOLEAN ): reducer:AGGREGATOR",documentation:"The `reducer.sd.forbid-nulls` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd.forbid-nulls"},{name:"reducer.shannonentropy.0",detail:"reducer.shannonentropy.0(): reducer:AGGREGATOR",documentation:"The `reducer.shannonentropy.0` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 0 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.0"},{name:"reducer.shannonentropy.1",detail:"reducer.shannonentropy.1(): reducer:AGGREGATOR",documentation:"The `reducer.shannonentropy.1` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 1 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.1"},{name:"reducer.sum",detail:"reducer.sum(): reducer:AGGREGATOR",documentation:"The `reducer.sum` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum"},{name:"reducer.sum.forbid-nulls",detail:"reducer.sum.forbid-nulls(): reducer:AGGREGATOR",documentation:"Alias of [`reducer.sum.nonnull`](/doc/reducer.sum.nonnull).\n\nThe `reducer.sum.forbid-nulls` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.forbid-nulls"},{name:"reducer.sum.nonnull",detail:"reducer.sum.nonnull(): reducer:AGGREGATOR",documentation:"Alias of [`reducer.sum.forbid-nulls`](/doc/reducer.sum.forbid-nulls).\n\nThe `reducer.sum.nonnull` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.nonnull"},{name:"reducer.var",detail:"reducer.var( bessel:BOOLEAN ): reducer:AGGREGATOR",documentation:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var"},{name:"reducer.var.forbid-nulls",detail:"reducer.var.forbid-nulls( bessel:BOOLEAN ): reducer:AGGREGATOR",documentation:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var.forbid-nulls"},{name:"s",detail:"s( input:NUMBER ): output:LONG",documentation:"Converts a number of seconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of seconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of seconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of seconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"s"},{name:"us",detail:"us( input:NUMBER ): output:LONG",documentation:"Converts a number of microseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of microseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of microseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of microseconds\n\n",tags:["date"],since:"1.0.0",OPB64name:"us"},{name:"w",detail:"w( input:NUMBER ): output:LONG",documentation:"Converts a number of weeks (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of weeks from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of weeks to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of weeks\n\n",tags:["date"],since:"1.0.0",OPB64name:"w"},{name:"{",detail:"{(): mark:MARK",documentation:"Starts a map creation.\n\nThe `{` function creates a map by pushing a mark onto the stack. This is a syntactic help to better present map constructions. This function behaves like [`MARK`].\n\n@param `mark` A MARK object.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"Tk"},{name:"{}",detail:"{}(): newmap:MAP",documentation:"The {} function creates an empty MAP on the top of the stack.\n\n\n@param `newmap` Empty map instance.\n\n",tags:["maps"],since:"1.0.0",OPB64name:"Tro"},{name:"|",detail:"|( p1:LONG p2:LONG ): result:LONG\n|( inputgts:GTS mask:LONG ): maskedgts:GTS\n|( gts1:GTS gts2:GTS ): outputgts:GTS",documentation:"Performs a bitwise **OR** operation.\n\nThe `|` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **OR**.\n \nSince Warp 10™ 2.1, `|` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be OR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with OR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts OR with mask\n\n",tags:["binary","operators"],since:"1.0.0",OPB64name:"U."},{name:"||",detail:"||( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\n||( l:LIST ): result:BOOLEAN\n||( gts1:GTS gts2:GTS ): gtsresult:GTS",documentation:"The `||` operator is a synonymous for [`OR`](/doc/OR).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `||` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",tags:["operators","logic"],since:"1.0.0",OPB64name:"U6k"},{name:"}",detail:"}( mark:MARK k1:ANY v1:ANY kN:ANY vN:ANY ): map:MAP",documentation:"Closes a currently open map and pushes it onto the stack.\n\nThe `}` function pops from the stack the elements (key/value pairs) of the map up to the first mark. The marks are consumed.\n\n@param `k1` The first key\n\n@param `v1` The first value\n\n@param `kN` The Nth key\n\n@param `vN` The Nth value\n\n@param `map` The built map\n\n@param `mark` The mark indicating the deepest level to consider when building the map\n\n",tags:["maps"],since:"1.0.0",OPB64name:"UF"},{name:"~",detail:"~( param:LONG ): result:LONG",documentation:"Computes the unary bitwise complement of the long value on top of the stack.\n\n@param `param` Value to compute\n\n@param `result` Bitwise result\n\n",tags:["operators","binary","math"],since:"1.0.0",OPB64name:"UV"},{name:"~=",detail:"~=( p2:DOUBLE p1:DOUBLE lambda:DOUBLE ): result:BOOLEAN\n~=( p2:DOUBLE p1:LONG lambda:DOUBLE ): result:BOOLEAN\n~=( p2:LONG p1:DOUBLE lambda:DOUBLE ): result:BOOLEAN\n~=( p2:DOUBLE p1:COUNTER lambda:DOUBLE ): result:BOOLEAN\n~=( p2:COUNTER p1:DOUBLE lambda:DOUBLE ): result:BOOLEAN\n~=( p2:DOUBLE p1:DOUBLE lambda:LONG ): result:BOOLEAN\n~=( p2:DOUBLE p1:LONG lambda:LONG ): result:BOOLEAN\n~=( p2:LONG p1:DOUBLE lambda:LONG ): result:BOOLEAN\n~=( p2:DOUBLE p1:COUNTER lambda:LONG ): result:BOOLEAN\n~=( p2:COUNTER p1:DOUBLE lambda:LONG ): result:BOOLEAN\n~=( p2:DOUBLE p1:DOUBLE lambda:COUNTER ): result:BOOLEAN\n~=( p2:DOUBLE p1:LONG lambda:COUNTER ): result:BOOLEAN\n~=( p2:LONG p1:DOUBLE lambda:COUNTER ): result:BOOLEAN\n~=( p2:DOUBLE p1:COUNTER lambda:COUNTER ): result:BOOLEAN\n~=( p2:COUNTER p1:DOUBLE lambda:COUNTER ): result:BOOLEAN",documentation:"The `~=` operator consumes three parameters from the top of the stack, two operands p1 and p2 and a tolerance factor lambda, \nand pushes onto the stack true if *|p1-p2| < lambda*, i.e. the difference between the two operands is lesser than lambda.\n\nThe two parameters must be of numeric types.\n\nThe operator `~=` is useful when making comparaisons between doubles, where floating point operations generate rounding errors.\n\n@param `p1` First number\n\n@param `p2` Second number\n\n@param `lambda` Tolerance factor lambda\n\n@param `result` \n\n",tags:["math","operators"],since:"1.0.0",OPB64name:"UYo"}];var D=function(){};D.snippets={macro:{prefix:"macro (example)",body:["info = {","  'name': '${1:euclideanDivision}',","  'desc': \"","${2:This macro returns the quotient and the remainder of a/b.}",'  ",',"  'sig': [ [ [ ${3:'a:LONG', 'b:LONG'} ], [ ${4:'q:LONG', 'r:LONG'} ] ] ], // Signature","  'params': {","    // Signature params description","    ${5:'b': 'parameter b TOP of the stack',","    'a': 'parameter a just below on the stack',","    'q': 'the quotient of a/b, N-1 on the stack',","    'r': 'the remainder of a/b, on the TOP of the stack'}","  },","  'examples': [","    <'","${6:(q, r) = @mymacros/euclideanDivision(10 3);","return { ","  'quotient is  :': TOSTRING(q),","  'remainder is :': TOSTRING(r)","}","    '>","  ]","};","","macro =  ${7:(a, b) => {","  INFO(!info);","  context = SAVE();","  TRY(() => {","    // Code of the actual macro","    return ( TOLONG(a / b), a % b);","  },","  () => { // catch any exception","    RETHROW()","  },","  () => { // finally, restore the context","    RESTORE(context)","  })","};","","// Unit tests","${8:(q, r) = @macro(10 3)","ASSERT(q == 3)","ASSERT(r == 1)","ASSERT(TYPEOF(q) == LONG)","ASSERT(TYPEOF(r) == LONG)","","return macro"],description:"Macro"},"macro(empty)":{prefix:"macro (empty)",body:["info = {","  'name': '${1: }'","  'desc': \"","${2: }",'  ",',"  'sig': [ [ [   ], [   ] ] ], // Signature","  'params': {","    // Signature params description","  },","  'examples': [ \"","",'    " ]',"}","","macro = () => {","  !info INFO;","  context = SAVE();","  TRY(() => {","    // Code of the actual macro","    ${3:  }","  },","  () => { // catch any exception","    RETHROW()","  },","  () => { // finally, restore the context","    RESTORE(context)","  });","}","","// Unit tests","","return macro"],description:"Macro"},fetch:{prefix:"fetch",body:["gts = FETCH([ 'TOKEN', 'className',  { 'label0': '=value0',  'label1': '~val.' },  start, timespan ])"]},bucketize:{prefix:"bucketize",body:["bucketizedGts = BUCKETIZE([ ${1:gts}, ${2|MACROBUCKETIZER((data) => { return [tick\\, latitude\\, longitude\\, elevation\\, value]; }),bucketizer.and(),bucketizer.count(),bucketizer.count().exclude-nulls(),bucketizer.count.include-nulls(),bucketizer.count.nonnull(),bucketizer.first(),bucketizer.join(','),bucketizer.join.forbid-nulls(),bucketizer.last(),bucketizer.max(),bucketizer.max.forbid-nulls(),bucketizer.mean(),bucketizer.mean.circular(),bucketizer.mean.circular.exclude-nulls(),bucketizer.mean.exclude-nulls(),bucketizer.median(),bucketizer.min(),bucketizer.min.forbid-nulls(),bucketizer.or(),bucketizer.sum(),bucketizer.sum.forbid-nulls()|}, ${3:lastbucket}, ${4:bucketspan}, ${5:bucketcount} ])"]},filter:{prefix:"filter",body:["filtredGts = FILTER([ ${1:gts}, [${2:labels}], ${3|MACROFILTER((data) => { return gtslist\\, labels_equivalence_class_map; }),filter.byattr({}),filter.byclass(''),filter.bylabels({}),filter.bylabelsattr({}),filter.bymetadata([]),filter.last.eq(filterValue),filter.last.ge(filterValue),filter.last.gt(filterValue),filter.last.le(filterValue),filter.last.lt(filterValue),filter.last.ne(filterValue),filter.latencies(minLatency\\, maxLatency\\, [])|} ]"]},map:{prefix:"map",body:["mappedGts = MAP([ ${1:gts}, ${2|MACROMAPPER((data) => { return [tick\\, latitude\\, longitude\\, elevation\\, value]; }),mapper.abs(),mapper.add(constant),mapper.and(),mapper.ceil(),mapper.count(),mapper.count.exclude-nulls(),mapper.count.include-nulls(),mapper.count.nonnull(),mapper.day(timezone\\|offset),mapper.delta(),mapper.dotproduct([]),mapper.dotproduct.positive([]),mapper.dotproduct.sigmoid([]),mapper.dotproduct.tanh([]),mapper.eq(constant),mapper.exp(constant),mapper.finite(),mapper.first(),mapper.floor(),mapper.ge(threshold),mapper.geo.approximate(resolution),mapper.geo.clear(),mapper.geo.outside(geoZone),mapper.geo.within(geoZone),mapper.gt(threshold),mapper.hdist(),mapper.highest(),mapper.hour(timezone\\|offset),mapper.hspeed(),mapper.join(','),mapper.join.forbid-nulls(','),mapper.kernel.cosine(bandwidth\\, step),mapper.kernel.epanechnikov(bandwidth\\, step),mapper.kernel.gaussian(bandwidth\\, step),mapper.kernel.logistic(bandwidth\\, step),mapper.kernel.quartic(bandwidth\\, step),mapper.kernel.silverman(bandwidth\\, step),mapper.kernel.triangular(bandwidth\\, step),mapper.kernel.tricube(bandwidth\\, step),mapper.kernel.triweight(bandwidth\\, step),mapper.kernel.uniform(bandwidth\\, step),mapper.last(),mapper.le(threshold),mapper.log(constant),mapper.lowest(),mapper.lt(threshold),mapper.mad(),mapper.max(),mapper.max.forbid-nulls(),mapper.max.x(),mapper.mean(),mapper.mean.circular(),mapper.mean.circular.exclude-nulls(),mapper.mean.exclude-nulls(),mapper.median(),mapper.min(),mapper.min.forbid-nulls(),mapper.min.x(),mapper.minute(timezone\\|offset),mapper.mod(modulus),mapper.month(timezone\\|offset),mapper.mul(constant),mapper.ne(constant),mapper.npdf(mu\\, sigma),mapper.or(),mapper.parsedouble(),mapper.percentile(percentile),mapper.pow(constant),mapper.product(),mapper.rate(),mapper.replace(constant),mapper.round(),mapper.sd(bessel),mapper.sd.forbid-nulls(bessel),mapper.second(timezone\\|offset),mapper.sigmoid(),mapper.sqrt(),mapper.sum(),mapper.sum.forbid-nulls(),mapper.tanh(),mapper.tick(),mapper.toboolean(),mapper.todouble(),mapper.tolong(),mapper.tostring(),mapper.truecourse(),mapper.var(bessel),mapper.var.forbid-nulls(bessel),mapper.vdist(),mapper.vspeed(),mapper.weekday(timezone\\|offset),mapper.year(timezone\\|offset),max.tick.sliding.window(),max.time.sliding.window()|}, ${3:pre}, ${4:post}, ${5:occurrences} ])"]},reduce:{prefix:"reduce",body:["reducedGts = REDUCE([ ${1:gts}, [${2:labels}], ${3|MACROREDUCER((data) => { return [tick\\, latitude\\, longitude\\, elevation\\, value]; }),reducer.and(),reducer.and.exclude-nulls(),reducer.argmax(),reducer.argmin(),reducer.count(),reducer.count.exclude-nulls(),reducer.count.include-nulls(),reducer.count.nonnull(),reducer.join(),reducer.join.forbid-nulls(),reducer.join.nonnull(),reducer.join.urlencoded(),reducer.max(),reducer.max.forbid-nulls(),reducer.max.nonnull(),reducer.mean(),reducer.mean.circular(),reducer.mean.circular.exclude-nulls(),reducer.mean.exclude-nulls(),reducer.median(),reducer.min(),reducer.min.forbid-nulls(),reducer.min.nonnull(),reducer.or(),reducer.or.exclude-nulls(),reducer.sd(),reducer.sd.forbid-nulls(),reducer.shannonentropy.0(),reducer.shannonentropy.1(),reducer.sum(),reducer.sum.forbid-nulls(),reducer.sum.nonnull(),reducer.var(),reducer.var.forbid-nulls()|} ]"]},apply:{prefix:"apply",body:["transformedGts = APPLY([ ${1:gts}, [${2:labels}], ${3|op.add(),op.add.ignore-nulls(),op.and(),op.and.ignore-nulls(),op.div(),op.eq(),op.ge(),op.gt(),op.le(),op.lt(),op.mask(),op.mul(),op.mul.ignore-nulls(),op.ne(),op.negmask(),op.or(),op.or.ignore-nulls(),op.sub()|} ])"],description:"Apply framework"},ift:{prefix:"ift",body:["IFT(","  () => { return ${1:condition}; }, ","  () => { return ${2:action_if_true} }",");"],description:"If statement"},ifte:{prefix:"ifte",body:["IFTE(","  () => { return ${1:condition}; }, ","  () => { return ${2:action_if_true} },","  () => { return ${2:action_if_false} }",");"],description:"If then else statement"},switch:{prefix:"switch",body:["SWITCH(","  () => { return ${1:case_1}; }, { return ${2:action_1}; },","  () => { return ${3:case_2}; }, { return ${4:action_2}; },","  () => { return ${5:case_3}; }, { return ${6:action_3}; },","  () => { return ${7:default}; },","  ${8:number_of_cases}",");"],description:"Switch statement"},try:{prefix:"try",body:["TRY(","  () => { ${1:try} },","  () => { ${2:catch} },","  () => { ${3:finally} }",");"],description:"Try/Catch statement"},while:{prefix:"while",body:["WHILE(","  () => { return ${1:condition}; },","  () => { ${2:action_while_true} }",");"],description:"While loop"},until:{prefix:"until",body:["UNTIL(","  () => { ${1:action_until_true} },","  () => { return ${2:condition}; }",");"],description:"Until loop"},for:{prefix:"for",body:["FOR(${1:initial_value}, ${2:final_value},","  () => { ${3:action} }",");"],description:"For loop"},foreach:{prefix:"foreach",body:["FOREACH(${1:object}, ","  (key, value) => { // object is a map","  (value) => {      // object is a list","    ${2:action}","  }",");"],description:"Foreach loop"},forstep:{prefix:"forstep",body:["FORSTEP(${1:initial_value}, ${2:final_value}, () => { return ${3: + 1}; },","  () => { ${4:action} }",");"],description:"Forstep loop"},shm:{prefix:"shm",body:["MUTEX(() => { // prevent a concurrent execution on the same SHM data","  TRY(() => {","    // try to read data from SHared Memory","    SHMLOAD('gtsList')","  },","  () => {","    // when not found, store data in SHM","    SHMSTORE('gtsList', ${1:FETCH([ token 'classname' {\\} NOW() d(365) ]))}","  },","  () => {","    // finally, load the reference from SHM and store it ","    gtsList = SHMLOAD('gtsList')","  });","","  // analytics on gtsList","  ${2:gtsList}","","","","}, 'myMutex');"],description:"Keep fetched data in RAM. You need to enable the SHM extension."}};var U=function(e){function t(){return e.call(this,v.FLOWS_LANGUAGE)||this}return T(t,e),t.prototype.transformKeyWord=function(e){return e+"()"},t.prototype.provideCompletionItems=function(t,n,a,i){return e.prototype._provideCompletionItems.call(this,t,n,a,i,C.reference,D.snippets)},t}(N),M={"!":{description:"Negates a boolean.\n\nThe `!` function is synonymous for [`NOT`](/doc/NOT). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nSince Warp 10™ 2.1, `!` can be applied on a boolean GTS to flip all values.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gtsinput` Since 2.1, a GTS with boolean value.\n\n@param `gtsresult` Since 2.1, a GTS with negated boolean value. GTS is not sorted by the operation. Metadata are kept.\n\n",signature:"!( input:BOOLEAN ): result:BOOLEAN\n!( gtsinput:GTS ): gtsresult:GTS",tags:["logic","operators"],since:"1.0.0",OPB64name:"7F"},"!=":{description:"Tests if both parameters are different.\n\nThe `!=` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are different, false otherwise.\n\nThe two parameters must be homogeneous of numeric, boolean or string types.\n\nSince Warp 10™ 2.1, as every other comparison operators, `!=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 !=` is strictly equivalent of a `42 mapper.ne` MAP operation, with a simplified syntax.\n\n@param `p1` First parameter to compare, anything except a GTS.\n\n@param `p2` Second parameter to compare, anything except a GTS.\n\n@param `result` True if p1 and p2 are different, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values different from constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is different from gts2 value.\n\n",signature:"!=( p1:ANY p2:ANY ): result:BOOLEAN\n!=( inputgts:GTS constant:ANY ): outgts:GTS\n!=( constant:ANY inputgts:GTS ): outgts:GTS\n!=( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators"],since:"1.0.0",OPB64name:"7Io"},"%":{description:"The `%` operator consumes two parameters from the top of the stack and pushes back the remainder of the Euclidean division of the first one by the second one.\n\nThe two parameters must be of numeric types.\n\n@param `dividend` Number divided by divisor\n\n@param `divisor` Number used to divide dividend\n\n@param `modulo` Modulo of the two given parameters\n\n",signature:"%( divisor:LONG dividend:LONG ): modulo:LONG\n%( divisor:DOUBLE dividend:LONG ): modulo:DOUBLE\n%( divisor:LONG dividend:DOUBLE ): modulo:DOUBLE\n%( divisor:DOUBLE dividend:DOUBLE ): modulo:DOUBLE\n%( divisor:COUNTER dividend:COUNTER ): modulo:LONG\n%( divisor:DOUBLE dividend:COUNTER ): modulo:DOUBLE\n%( divisor:COUNTER dividend:DOUBLE ): modulo:DOUBLE\n%( divisor:LONG dividend:COUNTER ): modulo:LONG\n%( divisor:COUNTER dividend:LONG ): modulo:LONG",tags:["operators"],since:"1.0.0",OPB64name:"8F"},"&":{description:"Performs a bitwise **AND** operation.\n\nThe `&` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **AND**.\n\nSince Warp 10™ 2.1, `&` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be AND to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with AND between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts AND with mask\n\n",signature:"&( p1:LONG p2:LONG ): result:LONG\n&( inputgts:GTS mask:LONG ): maskedgts:GTS\n&( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["binary","operators"],since:"1.0.0",OPB64name:"8V"},"&&":{description:"The `&&` operator is a synonymous for [`AND`](/doc/AND).\n\nIt performs a logical **&&** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `&&` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical && applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with && between each common tick input values.\n\n",signature:"&&( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\n&&( l:LIST ): result:BOOLEAN\n&&( gts1:GTS gts2:GTS ): gtsresult:GTS",tags:["operators","logic"],since:"1.0.0",OPB64name:"8XN"},"(":{description:"Starts a set creation.\n\nThe `(` function creates a set by pushing a mark onto the stack. This is a syntactic help to better present set constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",signature:"((): mark:MARK",tags:["sets"],since:"1.2.13",OPB64name:"9."},"()":{description:"The `()` function creates an empty SET on the top of the stack.\nA Set is a collection that cannot contain duplicate elements.\n\nThis is an implementation of java [HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html). NULL object is permitted. It makes no guarantees as to the iteration order of the set.\n\nThe SET object could not be represented on the stack.\nIt has to be converted in a list to be displayed.\n\nStoring GTS into sets do not guarantee uniqueness. each GTS has a hidden id. see example.\n\n\n@param `content` 0 to n elements.\n\n@param `newset` set instance, initialized with content.\n\n",signature:"()( content:ANY ): newset:SET",tags:["sets"],since:"1.2.13",OPB64name:"91Z"},")":{description:"Closes a currently open set and pushes it onto the stack.\n\nThe `)` function pops from the stack the elements of the set up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `set` The built set\n\n@param `mark` The mark indicating the deepest level to consider when building the set\n\n",signature:")( mark:MARK v1:ANY vN:ANY ): set:SET",tags:["sets"],since:"1.2.13",OPB64name:"9F"},"*":{description:"The `*` operator consumes two parameters from the top of the stack and pushes back the result of multiplying both of them.\n\nIf you want to multiply two matrices together, they have to be of the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Multiplication result\n\n",signature:"*( p1:NUMBER p2:NUMBER ): result:NUMBER\n*( p1:VECTOR p2:NUMBER ): result:VECTOR\n*( p1:NUMBER p2:VECTOR ): result:VECTOR\n*( p1:MATRIX p2:NUMBER ): result:MATRIX\n*( p1:NUMBER p2:MATRIX ): result:MATRIX\n*( p1:MATRIX p2:VECTOR ): result:VECTOR\n*( p1:VECTOR p2:MATRIX ): result:VECTOR\n*( p1:MATRIX p2:MATRIX ): result:VECTOR\n*( p2:GTS p1:GTS ): result:GTS\n*( p2:GTS p1:NUMBER ): result:GTS\n*( p2:NUMBER p1:GTS ): result:GTS",tags:["operators"],since:"1.0.0",OPB64name:"9V"},"**":{description:'Returns the value of the first argument raised to the power of the second argument.\n\nThe `**` operator consumes two parameters from the top of the stack (a base **b** and an exponent **n**) and pushes back the result raising b to the power of n,\ni.e. b<sup>n</sup>. For special cases see [pow()](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#pow-double-double- "javadoc").\n\nThe two parameters must be of numeric types.\n\n@param `b` First parameter, the base\n\n@param `n` Second parameter, the exponent\n\n@param `result` The result of b<sup>n</sup>\n\n',signature:"**( b:LONG n:LONG ): result:LONG\n**( b:DOUBLE n:LONG ): result:DOUBLE\n**( b:LONG n:DOUBLE ): result:DOUBLE\n**( b:DOUBLE n:DOUBLE ): result:DOUBLE\n**( b:COUNTER n:COUNTER ): result:LONG\n**( b:DOUBLE n:COUNTER ): result:DOUBLE\n**( b:COUNTER n:DOUBLE ): result:DOUBLE\n**( b:COUNTER n:LONG ): result:LONG\n**( b:LONG n:COUNTER ): result:LONG",tags:["math","operators"],since:"1.0.0",OPB64name:"9Xc"},"+":{description:"The `+` operator consumes two parameters from the top of the stack and pushes back the result of adding them.\n\nThe meaning of adding depends on the type of parameter:\n\n- If both parameters are numbers, the result is the sum of both numbers.\n\n- If both parameters are strings, the result is the concatenation of both strings.\n- If both parameters are byte arrays, the result is the concatenation of both byte arrays (version 2.1+).\n\n- If the first parameter is a list, the + operator clones the list and appends the second parameter to the cloned list.\n\n- If the first parameter is a set, the + operator clones the set and appends the second parameter to the cloned set.\n\n- If both parameters are macros, the result is a macro concatenating the two others in any other case + with throw an exception.\n\n- If the first parameter is a vector, the + operator adds the second numeric parameter to each element of the vector.\n- If the second parameter is a vector, the + operator adds the first numeric parameter to each element of the vector.\n- If both parameters are vectors, the + operator adds each element of vectors which are on the same index. Vectors must be the same size.\n\n- If the first parameter is a matrix, the + operator adds the second numeric parameter to each element of the matrix.\n- If the second parameter is a matrix, the + operator adds the first numeric parameter to each element of the matrix.\n- If both parameters are matrices, the + operator adds each element of matrices which are on the same index. Matrices must be the same size.\n- If one of the parameters is a Geo Time Series™, the result will be a Geo Time Series™ of type DOUBLE.\n\n@param `param1` First parameter\n\n@param `param2` Second parameter\n\n@param `result` Result of the addition\n\n",signature:"+( param1:STRING param2:STRING ): result:STRING\n+( param1:LONG param2:LONG ): result:LONG\n+( param1:DOUBLE param2:LONG ): result:DOUBLE\n+( param1:COUNTER param2:LONG ): result:LONG\n+( param1:LONG param2:DOUBLE ): result:DOUBLE\n+( param1:DOUBLE param2:DOUBLE ): result:DOUBLE\n+( param1:COUNTER param2:DOUBLE ): result:DOUBLE\n+( param1:COUNTER param2:COUNTER ): result:LONG\n+( param1:DOUBLE param2:COUNTER ): result:DOUBLE\n+( param1:LONG param2:COUNTER ): result:LONG\n+( param1:LIST param2:ANY ): result:LIST\n+( param1:SET param2:ANY ): result:SET\n+( param1:VECTOR param2:NUMBER ): result:VECTOR\n+( param1:NUMBER param2:VECTOR ): result:VECTOR\n+( param1:VECTOR param2:VECTOR ): result:VECTOR\n+( param1:MACRO param2:MACRO ): result:MACRO\n+( param1:MATRIX param2:NUMBER ): result:MATRIX\n+( param1:NUMBER param2:MATRIX ): result:MATRIX\n+( param1:MATRIX param2:MATRIX ): result:MATRIX\n+( param2:GTS param1:GTS ): result:GTS\n+( param2:GTS param1:DOUBLE ): result:GTS\n+( param2:GTS param1:LONG ): result:GTS\n+( param2:GTS param1:STRING ): result:GTS\n+( param2:DOUBLE param1:GTS ): result:GTS\n+( param2:LONG param1:GTS ): result:GTS\n+( param2:STRING param1:GTS ): result:GTS\n+( param1:BYTES param2:BYTES ): result:BYTES",tags:["math","operators"],since:"1.0.0",OPB64name:"9k"},"+!":{description:"The +! operator adds the element on top of the stack to the set or list below it. \nThe element is added to the existing collection. \n\n\n@param `input` reference to the list or set to be modified\n\n@param `output` copy of input list or set reference.\n\n@param `item` the item to append to inputlist. Depending on list content, could be any type.\n\n",signature:"+!( input:LIST item:ANY ): output:LIST\n+!( input:SET item:ANY ): output:SET",tags:["lists","operators"],since:"1.2.0",OPB64name:"9m3"},"-":{description:"Subtracts two parameters.\n\nThe `-` operator consumes two parameters from the top of the stack and pushes back the result of subtracting the second one from the first one.\n\n- If both parameters are numbers, the result is the subtraction of both numbers.\n\n- If both parameters are vectors, the - operator subtracts each element of vectors which are on the same index. Vectors must be the same size.\n\n- If both parameters are matrices, the - operator subtracts each element of matrices which are on the same index. Matrices must be the same size.\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` Subtraction result\n\n",signature:"-( p1:LONG p2:LONG ): result:LONG\n-( p1:LONG p2:DOUBLE ): result:DOUBLE\n-( p1:DOUBLE p2:LONG ): result:DOUBLE\n-( p1:DOUBLE p2:DOUBLE ): result:DOUBLE\n-( p1:COUNTER p2:COUNTER ): result:LONG\n-( p1:COUNTER p2:DOUBLE ): result:DOUBLE\n-( p1:DOUBLE p2:COUNTER ): result:DOUBLE\n-( p1:LONG p2:COUNTER ): result:LONG\n-( p1:COUNTER p2:LONG ): result:LONG\n-( p1:MATRIX p2:MATRIX ): result:MATRIX\n-( p1:VECTOR p2:VECTOR ): result:VECTOR\n-( p2:GTS p1:GTS ): result:GTS\n-( p2:GTS p1:NUMBER ): result:GTS\n-( p2:NUMBER p1:GTS ): result:GTS",tags:["operators"],since:"1.0.0",OPB64name:"AF"},"->B64":{description:"Encodes the string on top of the stack in [base64](https://en.wikipedia.org/wiki/Base64).\n\n@param `input` String or byte array to encode\n\n@param `result` Base64 encoded string\n\n",signature:"->B64( input:STRING ): result:STRING\n->B64( input:BYTES ): result:STRING",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYF"},"->B64URL":{description:"Encodes the string on top of the stack in [base64url](https://en.wikipedia.org/wiki/Base64#Variants_summary_table).\n\n@param `input` String to encode\n\n@param `bytes` Byte array to encode\n\n@param `result` Base64url encoded string\n\n",signature:"->B64URL( input:STRING ): result:STRING\n->B64URL( bytes:BYTES ): result:STRING",tags:["strings","conversion"],since:"1.0.0",OPB64name:"AIt1CYGKJZk"},"->BIN":{description:"The ->BIN function converts the byte array or the string on top of the stack \nto its binary representation.\n\nApplied on a string, `->BIN` replaces ` 'utf-8' ->BYTES ->BIN `\n\nIf the encoded content is not a \nvalid UTF-8 representation, the resulting string will reflect that. \n\n@param `input` Any string or byte array.\n\n@param `output` Binary representation of the input.\n\n",signature:"->BIN( input:STRING ): output:STRING\n->BIN( input:BYTES ): output:STRING",tags:["conversion","binary"],since:"1.0.6",OPB64name:"AIt1HJs"},"->BYTES":{description:"->BYTES function converts a string into a bytes array given a charset\nand put the result on top of the stack.\n\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\nBytes array cannot be represented on the stack.\n\n\n@param `input` String input.\n\n@param `charset` Charset to use.\n\n@param `output` Byte array representation of input.\n\n",signature:"->BYTES( input:STRING charset:STRING ): output:BYTES",tags:["conversion"],since:"1.0.6",OPB64name:"AIt1LKG4Jk"},"->DOUBLEBITS":{description:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",signature:"->DOUBLEBITS( number:NUMBER ): bits:LONG\n->DOUBLEBITS( gts:GTS ): longgts:GTS",tags:["math","gts","binary"],since:"1.2.3",OPB64name:"AIt3IpK1I3K1HKGI"},"->ENCODER":{description:"The `->ENCODER` function takes a list of points and encode them in a single encoder. Each point is a list of ( timestamp, latitude, longitude, elevation, value ). Since 2.1.1, a point can also be a Geo Time Series™ or a wrapped one. In that case all the points of the Geo Time Series™ are added to the encoder.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `elements` List of list of ( timestamp, latitude, longitude, elevation, value ). See example to see which element(s) can be omitted.\n\n@param `lgts` A list of Geo Time Series™ instances.\n\n@param `lwrappedgts` A list of wrapped Geo Time Series™ instances, such as produced by [`WRAP`](/doc/WRAP).\n\n@param `lrawwrappedgts` A list of raw wrapped Geo Time Series™ instances, such as produced by [`WRAPRAW`](/doc/WRAPRAW).\n\n@param `output` Encoder\n\n",signature:"->ENCODER( elements:LIST ): output:GTSENCODER\n->ENCODER( lgts:LIST<GTS> ): output:GTSENCODER\n->ENCODER( lwrappedgts:LIST<STRING> ): output:GTSENCODER\n->ENCODER( lrawwrappedgts:LIST<BYTES> ): output:GTSENCODER",tags:["encoder","conversion"],since:"1.2.9",OPB64name:"AIt4IZCEG3KH"},"->ENCODERS":{description:"The `->ENCODERS` function converts an encoder into one encoder per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content, when a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder.\n\n",signature:"->ENCODERS( encoder:GTSENCODER ): output:MAP\n->ENCODERS( wrappedencoder:STRING ): output:MAP\n->ENCODERS( rawwrappedencoder:BYTES ): output:MAP",tags:["gts","encoder","conversion"],since:"2.1.0",OPB64name:"AIt4IZCEG3KHJk"},"->FLOATBITS":{description:"Converts a numeric value to a **FLOAT** then to a **LONG** value of the raw bits of its representation.\n\nOnly the lower 32 bits of the **LONG** value are significant.\n\n@param `input` Double to convert\n\n@param `result` Raw bits representation\n\n",signature:"->FLOATBITS( input:NUMBER ): result:LONG",tags:["math","binary"],since:"1.2.3",OPB64name:"AIt5I3x0K388K4B"},"->GEOCELL":{description:"The `->GEOCELL` function converts a **STRING** or a **BYTES** HHCode prefix to a **LONG** geocell. The length of the input implicitly specifies the resolution of the cell.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `hhPrefixS` A HHCode prefix representing a cell. Resolution is twice the length of the **STRING**.\n\n@param `hhPrefixB` A HHCode prefix representing a cell. Resolution is four times the length of the **BYTES**.\n\n@param `geocell` The geocell representation.\n\n",signature:"->GEOCELL( hhPrefixS:STRING ): geocell:LONG\n->GEOCELL( hhPrefixB:BYTES ): geocell:LONG",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJx2GJlB"},"->GEOHASH":{description:"The `->GEOHASH` function packs a latitude and a longitude into a STRING [Geohash](https://en.wikipedia.org/wiki/Geohash), converts a [HHCode](https://en.wikipedia.org/wiki/HHCode) into its Geohash counterpart, or converts a `GEOSHAPE` into a list of Geohashes covering the same geographical area.\n\n@param `lat` Latitude to pack.\n\n@param `lon` Longitude to pack.\n\n@param `geohash` Geohash string packing the specified latitude and longitude.\n\n@param `hhcode` HHCode to transform.\n\n@param `shape` `GEOSHAPE` to convert.\n\n@param `geohashes` List of Geohashes covering the same area as `shape`.\n\n",signature:"->GEOHASH( lat:DOUBLE lon:DOUBLE ): geohash:STRING\n->GEOHASH( hhcode:LONG ): geohash:STRING\n->GEOHASH( shape:GEOSHAPE ): geohashes:LIST<STRING>",tags:["geo"],since:"1.0.11",OPB64name:"AIt6GJx7FKC7"},"->GEOJSON":{description:"The `->GEOJSON` function translate the given GeoShape into a GeoJSON.\n\nThe resulting GeoJSON is a string representing a MultiPolygon geometry. By default, it defines the boundaries of the covered areas and any holes it these areas, if any.\n\nIt is also possible for this function to return a GeoJSON representing all the cells in the GeoShape.\n\n GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` The resulting GeoJSON.\n\n@param `wkt` A WKT string\n\n@param `wkb` WKB bytes\n\n",signature:"->GEOJSON( shape:GEOSHAPE ): geojson:STRING\n->GEOJSON( shape:GEOSHAPE allCells:BOOLEAN ): geojson:STRING\n->GEOJSON( wkt:STRING ): geojson:STRING\n->GEOJSON( wkb:BYTES ): geojson:STRING",tags:["geo"],since:"2.4.1",OPB64name:"AIt6GJx9JoxD"},"->GEOSHAPE":{description:"The `->GEOSHAPE` function converts a list of **LONG** geocells or HHCode prefixes (**STRING** or **BYTES**) to a **GEOSHAPE**.\n\n@param `geocells` List of geocells, as **LONGs**.\n\n@param `hhPrefixesS` List of HHCode prefixes, as **STRINGs**.\n\n@param `hhPrefixesB` List of HHCode prefixes, as **BYTESs**.\n\n@param `geoshape` The resulting **GEOSHAPE**.\n\n",signature:"->GEOSHAPE( geocells:LIST<LONG> ): geoshape:GEOSHAPE\n->GEOSHAPE( hhPrefixesS:LIST<STRING> ): geoshape:GEOSHAPE\n->GEOSHAPE( hhPrefixesB:LIST<BYTES> ): geoshape:GEOSHAPE",tags:["geo"],since:"2.6.0",OPB64name:"AIt6GJxIH34FGF"},"->GTS":{description:"The `->GTS` function converts an encoder into one GTS per type in the encoder. The result is a map, with key describing the type. If defined, name, labels and attributes are kept in the result.\nFunction also accepts wrapped or raw-wrapped encoders.\n\n###### Since 2.4.0:\n- `->GTS` function can also take a conversion MAP input. Using this conversion MAP, the output is always a list of GTS.\n- The conversion map can also take a list of selectors for each output type.\n- The conversion map can be empty: In this case, the GTS type is enforced by the type of the first element in the encoder input.\n- The first selector match stops the research. It means key order matters. See Examples.\n- A new '.type' label is added to each output GTS. This could be overriden with the 'label.type' parameter of the conversion MAP.\n- `->GTS` function can handle encoders, or list of encoders.\n\n###### What is an encoder ?\nA Geo Time Series™ is limited to the type of the first value stored.\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) and since 2.1 also BINARY content.\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n\n@param `encoder` Encoder input.\n\n@param `wrappedencoder` Encoder after WRAP.\n\n@param `rawwrappedencoder` Encoder after WRAPRAW.\n\n@param `output` Map with a key/value per type encountered in the input encoder. Values are GTS.\n\n@param `lencoder` List of encoders input (supported since 2.4.0).\n\n@param `lwrappedencoder` List of encoders after WRAP (supported since 2.4.0).\n\n@param `lrawwrappedencoder` List of encoders after WRAPRAW (supported since 2.4.0).\n\n@param `loutput` Map with a key/value per type encountered in the input encoder. Values are a list of GTS.\n\n@param `conversionmap` Map with type as keys, selectors or list of selectors as values. The special key `label` allow to change the default `.type` label. Set label to NULL to avoid any new label. The conversion map could be empty.\n\n@param `conversionoutput` A GTS, or a list of GTS.\n\n",signature:"->GTS( encoder:GTSENCODER ): output:MAP\n->GTS( wrappedencoder:STRING ): output:MAP\n->GTS( rawwrappedencoder:BYTES ): output:MAP\n->GTS( lencoder:LIST<GTSENCODER> ): loutput:MAP\n->GTS( lwrappedencoder:LIST<STRING> ): loutput:MAP\n->GTS( lrawwrappedencoder:LIST<BYTES> ): loutput:MAP\n->GTS( encoder:GTSENCODER conversionmap:MAP ): conversionoutput:GTS\n->GTS( wrappedencoder:STRING conversionmap:MAP ): conversionoutput:GTS\n->GTS( rawwrappedencoder:BYTES conversionmap:MAP ): conversionoutput:GTS\n->GTS( lencoder:LIST<GTSENCODER> conversionmap:MAP ): conversionoutput:LIST<GTS>\n->GTS( lwrappedencoder:LIST<STRING> conversionmap:MAP ): conversionoutput:LIST<GTS>\n->GTS( lrawwrappedencoder:LIST<BYTES> conversionmap:MAP ): conversionoutput:LIST<GTS>",tags:["gts","encoder","conversion","multivariate"],since:"1.2.9",OPB64name:"AIt6K4B"},"->GTSHHCODE":{description:"The `->GTSHHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",signature:"->GTSHHCODE( lat:NUMBER lon:NUMBER ): hhcode:STRING",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3J"},"->GTSHHCODELONG":{description:"The `->GTSHHCODE` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode). This function is very similar to [`->HHCODE`](/doc/AIt7H3CEG3J) except that when given `NaN NaN` it pushes back the internal value used by Geo Time Series™ for a missing location.\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",signature:"->GTSHHCODELONG( lat:NUMBER lon:NUMBER ): hhcode:STRING",tags:["geo"],since:"2.2.0",OPB64name:"AIt6K4C7H3CEG3KBIot6"},"->HEX":{description:"Decodes an hex encoded string or a byte array.\nFor different encodings, use bytes array conversion [`BYTES->`](/doc/F__JGKBhEV).\n\n\nApplied on a string, `->HEX` replaces ` 'utf-8' ->BYTES ->HEX `\n\nIf the encoded content is not a\nvalid UTF-8 representation, the resulting string will reflect that.\n\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Decoded string of input, assuming utf-8 encoding of input.\n\n",signature:"->HEX( input:STRING ): output:STRING\n->HEX( input:BYTES ): output:STRING",tags:["conversion"],since:"1.0.0",OPB64name:"AIt7GKV"},"->HHCODE":{description:"The `->HHCODE` function packs a latitude and a longitude into a STRING [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a string of 16 hexadecimal digits.\n\n",signature:"->HHCODE( lat:NUMBER lon:NUMBER ): hhcode:STRING",tags:["geo"],since:"1.0.11",OPB64name:"AIt7H3CEG3J"},"->HHCODELONG":{description:"The `->HHCODELONG` function packs a latitude and a longitude into a LONG [HHCode](https://en.wikipedia.org/wiki/HHCode).\n\nThe packed HHCode uses 32 bits for each the latitude and longitude.\n\n@param `lon` Longitude to pack.\n\n@param `lat` Latitude to pack.\n\n@param `hhcode` Resulting HHCode, as a 64 bits LONG.\n\n",signature:"->HHCODELONG( lat:NUMBER lon:NUMBER ): hhcode:LONG",tags:["geo"],since:"1.2.5",OPB64name:"AIt7H3CEG3KBIot6"},"->JSON":{description:"The `->JSON` functions serialize structures containing numbers, strings, booleans, lists, vlists and maps which do not reference the same list/map multiple times.\n\n@param `object` Object to serialize\n\n@param `output` JSON formatted string\n\n",signature:"->JSON( object:ANY ): output:STRING",tags:["conversion"],since:"1.0.0",OPB64name:"AIt9JoxD"},"->LIST":{description:"The `->LIST` function create a list from N elements on the stack.\nN and the N next elements on the stack are consumed.\n\nIf N is greater than current stack depth, the function raises an error.\n\n@param `N` The number of elements to take on the top of the stack to build the list.\n\n@param `newlist` The list of N elements. [deepest in stack ... TOP-1 ]\n\n@param `content` 0 to n elements\n\n",signature:"->LIST( content:ANY* N:LONG ): newlist:LIST",tags:["lists","conversion"],since:"1.0.0",OPB64name:"AItBHKCJ"},"->LONGBYTES":{description:"`->LONGBYTES` converts a LONG to a byte array. It expects a number of bytes on the top of the stack.\n\nSince Warp 10™ 2.1, `->LONGBYTES` can also convert a list of LONG.\n\n@param `nbbytes` Number of bytes for number conversion: nbbytes could be 1 to 8. If less than 8, most significant bytes will be truncated.\n\n@param `number` must be a LONG\n\n@param `output` byte array, from 1 to 8 bytes per number\n\n@param `numberList` Since Warp 10 2.1, a list of LONG\n\n",signature:"->LONGBYTES( number:LONG nbbytes:LONG ): output:BYTES\n->LONGBYTES( numberList:LIST<LONG> nbbytes:LONG ): output:BYTES",tags:["binary","conversion"],since:"2.1.0",OPB64name:"AItBIot6F__JGKB"},"->MAP":{description:"The ->MAP function creates a MAP from an even number N of elements on the stack. \nN is consumed off the top of the stack. For each pair, the deepest element is the key, the shallowest is the value.\n\n\n@param `content` 0 to n pairs of key-value elements. Keys must be different.\n\n@param `N` Number of content elements to consume on the stack. It must be even.\n\n@param `newmap` map instance, initialized with content.\n\n",signature:"->MAP( N:LONG content:ANY* content:ANY* ): newmap:MAP",tags:["maps","conversion"],since:"1.0.0",OPB64name:"AItCFK."},"->MAT":{description:"The `->MAT` function converts nested lists of numbers (2D array with same number of columns) into a Matrix.\n\nMATRIX objects cannot be represented on the stack. \n\nMatrix entries must be numbers.\n\n\n@param `input` List of lists of values\n\n@param `result` A MATRIX object\n\n",signature:"->MAT( [ input:LIST ] ): result:MATRIX",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItCFKF"},"->MVSTRING":{description:"The `->MVSTRING` function generates a STRING representation of an ENCODER in the format expected by the `/update` endpoint for multi values.\n\nWhen encountering a binary element, the function attempts to interpret it as a wrapped encoder, if that fails then it will output the element as a binary (`b64:...`) value.\n\n@param `input` Wrapped or unwrapped Geo Time Series™ or ENCODER.\n\n@param `mvstring` MultiValue format representation of the wrapped encoder/GTS.\n\n",signature:"->MVSTRING( input:STRING ): mvstring:STRING\n->MVSTRING( input:BYTES ): mvstring:STRING\n->MVSTRING( input:GTS ): mvstring:STRING\n->MVSTRING( input:GTSENCODER ): mvstring:STRING",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"AItCK_CJJZ_DGk"},"->OPB64":{description:"Encode a String in order preserving base64. OPB64 is a Base64 like encoding which preserves the lexicographic order of\nthe original byte arrays in the encoded ones. This is useful to compare encoded byte arrays without having to first decode them.\n\n@param `input` Could be a string or a byte array.\n\n@param `output` OPB64 of input.\n\n",signature:"->OPB64( input:STRING ): output:STRING\n->OPB64( input:BYTES ): output:STRING",tags:["conversion"],since:"1.0.6",OPB64name:"AItEJ37qC."},"->PICKLE":{description:"The `->PICKLE` function converts the object on top of the stack to a Python object and serializes it using Pickle protocol version 2.\nThe conversion table used is as follow:\n\n| WarpScript | Python |\n|------------|--------|\n| NULL | None |\n| BOOLEAN | bool |\n| BYTES | bytearray |\n| STRING | str/unicode |\n| DOUBLE | float |\n| LONG | int |\n| LIST | list |\n| MAP | dict |\n| SET | set |\n| GTS | dict |\n| ENCODER | dict |\n\nOther types are unsupported.\n\nPython example with `->PICKLE ->HEX` output:\n```python\n>>> s=\"80025d71002858060000005049434b4c4571015806000000535452494e4771025d7103284b0547400921fb54442d1865652e\"\n>>> import pickle\n>>> pickle.loads(s.decode(\"hex\"))\n[u'PICKLE', u'STRING', [5, 3.141592653589793]]\n```\n\n@param `input` A serializable object\n\n@param `output` Pickle encoded content\n\n",signature:"->PICKLE( input:ANY ): output:BYTES",tags:["platform"],since:"1.0.7",OPB64name:"AItFHJCAI3J"},"->Q":{description:"The `->Q` function consumes on the stack 4 doubles (w, x, y, z, with z being on top) representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion)\nand push back quaternion representation into a **LONG**.\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `result` Quaternion representation\n\n",signature:"->Q( w:DOUBLE x:DOUBLE y:DOUBLE z:DOUBLE ): result:LONG",tags:["quaternions"],since:"1.0.0",OPB64name:"AItG"},"->SET":{description:"The -`>SET` function converts a **LIST** on top of the stack into a **SET**.\n\nSETs are not viewable, null will be return if it remains on the stack.\n\nThe order in the SET is not garanteed, see [`()`](/doc/91Z).\n\n\n@param `input` The input list\n\n@param `newset` The new set reference. SETs are not viewable, null remains on the stack.\n\n",signature:"->SET( input:LIST ): newset:SET",tags:["sets"],since:"1.0.0",OPB64name:"AItIGKF"},"->TSELEMENTS":{description:"The `->TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",signature:"->TSELEMENTS( timestamp:LONG ): dateAndTimeElements:LIST<LONG>\n->TSELEMENTS( timestamp:LONG timezone:STRING ): dateAndTimeElements:LIST<LONG>",tags:["date","time"],since:"1.2.0",OPB64name:"AItJJoKBGJp4I_GI"},"->V":{description:"The `->V` function converts a list of objects into a Pig Vector (VLIST).\n\nVLIST are represented as lists on the stack.\n\n@param `list` Input list\n\n@param `set` Input set\n\n@param `result` Result list\n\n",signature:"->V( list:LIST ): result:VLIST\n->V( set:SET ): result:VLIST",tags:["conversion","pig"],since:"1.0.11",OPB64name:"AItL"},"->VARINT":{description:"The `->VARINT` function encodes a `LONG` or a list of `LONG`s using [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoding. The result is a byte array containing the concatenation of the encoded numbers.\n\nThe `->VARINT` function is optimized for encoding unsigned `LONG`s, this means that negative numbers (with the most significant bit set to 1) will be encoded on 10 bytes. In order to reduce this footprint you can pre-process the numbers to encode so they are encoded unsing [ZigZag VarInt](https://developers.google.com/protocol-buffers/docs/encoding#types) encoding. The simple trick is to compute\n\n```\n$value 1 << $value 63 >> ^\n```\n\nthis will have the effect of alternatively encoding positive and negative numbers thus leading to a more efficient footprint for negative numbers.\n\nAt decoding time using `VARINT->`, simply undo the *Zig-Zag* trick:\n\n```\n$unsigned 63 << 63 >> $unsigned ^ 1 >>\n// Flip the top bit\n$unsigned 1 63 << & ^\n```\n\n@param `number` Single number to encode.\n\n@param `numbers` List of numbers to encode.\n\n@param `encoded` Byte array containing the encoded number(s).\n\n",signature:"->VARINT( number:LONG ): encoded:BYTES\n->VARINT( numbers:LIST<LONG> ): encoded:BYTES",tags:["conversion","binary"],since:"2.6.0",OPB64name:"AItLFK88I_F"},"->VEC":{description:"The `->VEC` function converts a list of numbers into a Vector.\n\nVectors objects cannot be represented on the stack. \n\nVectors entries must be numbers.\n\n@param `list` List to convert\n\n@param `matrix` Matrix with a single column\n\n@param `result` Vector\n\n",signature:"->VEC( list:LIST ): result:VECTOR\n->VEC( matrix:MATRIX ): result:VECTOR",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"AItLGJB"},"->WKB":{description:"The `->WKB` function converts a GeoJSON **STRING**, a WKT **STRING** or a **SHAPE** to WKB **BYTES**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` A WKT string\n\n@param `wkb` The resulting WKB.\n\n",signature:"->WKB( shape:GEOSHAPE ): wkb:BYTES\n->WKB( shape:GEOSHAPE allCells:BOOLEAN ): wkb:BYTES\n->WKB( wkt:STRING ): wkb:BYTES\n->WKB( geojson:STRING ): wkb:BYTES",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHo7"},"->WKT":{description:"The `->WKT` function converts a GeoJSON **STRING**, a WKB **BYTES** or a **SHAPE** to WKT **STRING**.\n\nThis function accepts an optional boolean on top of the **SHAPE** to choose whether all cells are outputted or not. Defaults to false.\n\n@param `shape` The GeoShape to be translated.\n\n@param `allCells` Optional parameter specifying if all the cells (true) or only the boundaries of the overall shape (false) must be represented in the GeoJSON. Defaults to false.\n\n@param `geojson` A GeoJSON string.\n\n@param `wkt` The resulting  WKT.\n\n@param `wkb` WKB bytes.\n\n",signature:"->WKT( shape:GEOSHAPE ): wkt:STRING\n->WKT( shape:GEOSHAPE allCells:BOOLEAN ): wkt:STRING\n->WKT( geojson:STRING ): wkt:STRING\n->WKT( wkb:BYTES ): wkt:STRING",tags:["geo","conversion"],since:"2.7.0",OPB64name:"AItMHpF"},"->Z":{description:"The `->Z` function packs multiple **LONG** arguments into a byte array by interleaving the bits of the arguments. This produces a \n[Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) value encoding the original arguments. The value might be right padded with bits set to 0 to reach a multiple of 8 bits.\n\n@param `bitwidth` Number of bits to consider for each LONG in 'longs', from 1 to 63.\n\n@param `longs` List of LONGs to pack. Each LONG *MUST* be positive, i.e. with bit 63 set to 0.\n\n@param `z` Byte array containing the packed values.\n\n",signature:"->Z( longs:LIST<LONG> bitwidth:LONG ): z:BYTES",tags:["conversion"],since:"1.0.6",OPB64name:"AItP"},"/":{description:"The `/` operator consumes two parameters from the top of the stack and pushes back the result of dividing the first one by the second one.\n\nYou can't devide by zero.\n\nThe two parameters must be of numeric types, or Geo Time Series™, or a mix of the two.\n\n@param `long` Numeric integer\n\n@param `long-result` Numeric floor-rounded integer\n\n@param `double` Numeric floating point number\n\n@param `double-result` Numeric floating point number\n\n@param `counter` Numeric counter\n\n@param `param1` First parameter of the division.\n\n@param `param2` Second parameter of the division.\n\n@param `result` Resulting GTS, of type DOUBLE.\n\n",signature:"/( long:LONG long:LONG ): long-result:LONG\n/( double:DOUBLE long:LONG ): double-result:DOUBLE\n/( long:LONG double:DOUBLE ): double-result:DOUBLE\n/( double:DOUBLE double:DOUBLE ): double-result:DOUBLE\n/( counter:COUNTER counter:COUNTER ): long-result:LONG\n/( double:DOUBLE counter:COUNTER ): long-result:DOUBLE\n/( counter:COUNTER double:DOUBLE ): long-result:DOUBLE\n/( counter:COUNTER long:LONG ): long-result:LONG\n/( long:LONG counter:COUNTER ): long-result:LONG\n/( double:VECTOR double:NUMBER ): double-result:VECTOR\n/( param2:GTS param1:GTS ): result:GTS\n/( param2:GTS param1:NUMBER ): result:GTS\n/( param2:NUMBER param1:GTS ): result:GTS",tags:["operators","math"],since:"1.0.0",OPB64name:"Ak"},"<":{description:"The `<` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 < p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <` is strictly equivalent of a `42 mapper.lt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 < p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less than gts2 value.\n\n",signature:"<( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n<( p1:STRING p2:STRING ): result:BOOLEAN\n<( inputgts:GTS constant:ANY ): outgts:GTS\n<( constant:ANY inputgts:GTS ): outgts:GTS\n<( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators","math"],since:"1.0.0",OPB64name:"E."},"<<":{description:"Shifts the bits of a long by a number of positions to the left. The least significant bit is filled with 0 after each shift.\n\nSince Warp 10™ 2.1, `<<` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",signature:"<<( number:LONG shift:LONG ): result:LONG\n<<( inputgts:GTS number:LONG ): maskedgts:GTS\n<<( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators"],since:"1.0.0",OPB64name:"E2k"},"<=":{description:"The `<=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 <= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically.\n\nSince Warp 10™ 2.1, as every other comparison operators, `<=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 <=` is strictly equivalent of a `42 mapper.le` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 <= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values less or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is less or equal than gts2 value.\n\n",signature:"<=( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n<=( p1:STRING p2:STRING ): result:BOOLEAN\n<=( inputgts:GTS constant:ANY ): outgts:GTS\n<=( constant:ANY inputgts:GTS ): outgts:GTS\n<=( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators","math"],since:"1.0.0",OPB64name:"E2o"},"==":{description:"Tests if both parameters are equal.\n\nThe `==` operator consumes two parameters from the top of the stack and pushes onto the stack true if they are equal, false otherwise.\n\nThe two parameters must be of numeric, boolean, vector, matrix or string types.\nFor vector or matrix, the parameters must be the same size.\n\nSince 2.1.0, as every other comparison operators, `==` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 ==` is strictly equivalent of a `42 mapper.eq` MAP operation, with a simplified syntax.\n\nSince 2.1.1, `==` can be use to check equality between Lists, Maps and Sets. For for details about how this is defined, check the [java documentation](https://docs.oracle.com/en/java/javase/index.html).\n\n@param `p1` First parameter to compare\n\n@param `p2` Second parameter to compare\n\n@param `result` True if p1 and p2 are equal, false otherwise\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values equal to constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value equals gts2 value.\n\n",signature:"==( p1:ANY p2:ANY ): result:BOOLEAN\n==( inputgts:GTS constant:ANY ): outgts:GTS\n==( constant:ANY inputgts:GTS ): outgts:GTS\n==( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators","math"],since:"1.0.0",OPB64name:"EIo"},">":{description:"The `>` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 > p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >` is strictly equivalent of a `42 mapper.gt` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 > p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater than gts2 value.\n\n",signature:">( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n>( p1:STRING p2:STRING ): result:BOOLEAN\n>( inputgts:GTS constant:ANY ): outgts:GTS\n>( constant:ANY inputgts:GTS ): outgts:GTS\n>( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators","math"],since:"1.0.0",OPB64name:"EV"},">=":{description:"The `>=` operator consumes two parameters p1 and p2 from the top of the stack and pushes onto the stack true if p1 >= p2, else it pushes false.\n\nThe two parameters must be of numeric or string types.\n\nStrings are compared lexicographically. \n\nSince Warp 10™ 2.1, as every other comparison operators, `>=` can also be used between two GTS or a GTS and a constant.\n\n`$gts 42 >=` is strictly equivalent of a `42 mapper.ge` MAP operation, with a simplified syntax.\n\n\n@param `p1` First parameter\n\n@param `p2` Second parameter\n\n@param `result` True if p1 >= p2\n\n@param `constant` Since Warp 10™ 2.1, a string or a number to compare with.\n\n@param `inputgts` Since Warp 10™ 2.1, a GTS with numbers or strings.\n\n@param `outgts` Since Warp 10™ 2.1, a new GTS containing only values greater or equal than constant.\n\n@param `gts1` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `gts2` Since Warp 10™ 2.1, an input GTS with numbers or strings.\n\n@param `outputgts` Since Warp 10™ 2.1, for each common ticks between gts1 and gts2, outputgts contains gts1 value and locations when gts1 value is greater or equal than gts2 value.\n\n",signature:">=( p1:NUMBER p2:NUMBER ): result:BOOLEAN\n>=( p1:STRING p2:STRING ): result:BOOLEAN\n>=( inputgts:GTS constant:ANY ): outgts:GTS\n>=( constant:ANY inputgts:GTS ): outgts:GTS\n>=( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators","math"],since:"1.0.0",OPB64name:"EYo"},">>":{description:"Shifts the bits of a long by a number of positions to the right. The most significant bit after shifting depends on the sign of the unshifted long.\n\nSince Warp 10™ 2.1, `>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",signature:">>( number:LONG shift:LONG ): result:LONG\n>>( inputgts:GTS number:LONG ): maskedgts:GTS\n>>( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators"],since:"1.0.0",OPB64name:"EYs"},">>>":{description:"Shifts the bits of a long by a number of positions to the right. The most significant bit after each shift is set to 0, regardless of the sign of \nthe unshifted long.\n\nSince Warp 10™ 2.1, `>>>` can be applied on two long GTS, or on one long GTS and a long mask.\n\n\n@param `shift` Number of positions\n\n@param `number` Long to shift\n\n@param `result` Shifted long\n\n@param `inputgts` Since 2.1, GTS with long values\n\n@param `maskedgts` Since 2.1, a new GTS with every values shifted by number\n\n@param `gts1` Since 2.1, GTS with long values\n\n@param `gts2` Since 2.1, GTS with long values\n\n@param `outputgts` Since 2.1, for each common ticks between gts1 and gts2, gts1 value is shifted by gts2 value\n\n",signature:">>>( number:LONG shift:LONG ): result:LONG\n>>>( inputgts:GTS number:LONG ): maskedgts:GTS\n>>>( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["operators"],since:"1.0.0",OPB64name:"EYsy"},ABS:{description:"Computes the absolute value of a number value.\n\nThe `ABS` function consumes a numeric value from the top of the stack and pushes back its absolute value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` A numeric value\n\n@param `result` The absolute value of the given numeric value.\n\n@param `lvalue` A list of numeric values\n\n@param `lresult` A list of the absolute values of the given values.\n\n",signature:"ABS( value:LONG ): result:LONG\nABS( value:COUNTER ): result:LONG\nABS( value:DOUBLE ): result:DOUBLE\nABS( lvalue:LIST<LONG> ): lresult:LIST<LONG>\nABS( lvalue:LIST<COUNTER> ): lresult:LIST<LONG>\nABS( lvalue:LIST<DOUBLE> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"ABS"},"ACCEL.CACHE":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.CACHE` function will enable accessing the in-memory data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.CACHE"},"ACCEL.NOCACHE":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOCACHE` function will disable accessing the in-memory data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOCACHE"},"ACCEL.NOPERSIST":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.NOPERSIST` function will disable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.NOPERSIST"},"ACCEL.PERSIST":{description:"When the Warp 10 Accelerator is enabled, the `ACCEL.PERSIST` function will enable accessing the persistent (disk based) data for update, fetch and delete operations.\n\n",signature:"",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.PERSIST"},"ACCEL.REPORT":{description:"The `ACCEL.REPORT` function will produce a map containing informations related to the Warp 10 Accelerator. The following table describes the various keys present in this map:\n\n| Key | Description |\n|-----|-------------|\n| `accelerated` | Boolean indicating whether or not the last [`FETCH`](/doc/FETCH) accessed the in-memory data managed by the Warp 10 Accelerator. |\n| `status` | Boolean indicating whether or not the Warp 10 Accelerator is enabled. |\n| `cache` | Boolean indicating if the in-memory data will be considered for update, fetch and delete operations. |\n| `persist` | Boolean indicating if the persistent data will be considered for update, fetch and delete operations. |\n| `chunkcount` | Number of chunks managed by the accelerator for its in-memory data. |\n| `chunkspan` | Length of each chunk expressed in platform time units. |\n\n@param `report` Map containing informations related to the Warp 10 Accelerator\n\n",signature:"ACCEL.REPORT(): report:MAP",tags:["platform"],since:"2.5.0",OPB64name:"ACCEL.REPORT"},ACOS:{description:"The `ACOS` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arccosine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arccosine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arccosine in radians of the given values.\n\n",signature:"ACOS( value:NUMBER ): result:DOUBLE\nACOS( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ACOS"},ADDDAYS:{description:'Adds days to a timestamp or a tselements.\n\nThe `ADDDAYS` function consumes from the top of the stack a number (positive or negative) of days, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the days and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `days` The number of days to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',signature:"ADDDAYS( timestamp:LONG timezone:STRING days:LONG ): result:LONG\nADDDAYS( timestamp:LONG days:LONG ): result:LONG\nADDDAYS( tselements:LIST<LONG> days:LONG ): tselementsresult:LIST<LONG>",tags:["date"],since:"1.2.0",OPB64name:"ADDDAYS"},ADDDURATION:{description:"Adds an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) to a timestamp or a tselements.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `duration` The duration\n\n@param `factor` The number of durations to add. Can be negative. Default to 1 if not set.\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n",signature:"ADDDURATION( timestamp:LONG timezone:STRING duration:STRING ): result:LONG\nADDDURATION( timestamp:LONG timezone:STRING duration:STRING factor:LONG ): result:LONG\nADDDURATION( timestamp:LONG duration:STRING ): result:LONG\nADDDURATION( timestamp:LONG duration:STRING factor:LONG ): result:LONG\nADDDURATION( tselements:LIST<LONG> duration:STRING ): tselementsresult:LIST<LONG>\nADDDURATION( tselements:LIST<LONG> duration:STRING factor:LONG ): tselementsresult:LIST<LONG>",tags:["date"],since:"2.4.0",OPB64name:"ADDDURATION"},ADDEXACT:{description:"The `ADDEXACT` function consumes two LONGs from the top of the stack and puts back the sum. If the sum overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `sum` The sum of x and y\n\n@param `list` List of numeric values\n\n@param `ssum` The sum of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lsum` List of **LONG** where each value is the sum of y and an element in lx\n\n",signature:"ADDEXACT( x:NUMBER y:NUMBER ): sum:LONG\nADDEXACT( list:LIST<NUMBER> ): ssum:LONG\nADDEXACT( lx:LIST<NUMBER> y:NUMBER ): lsum:LIST<LONG>",tags:["math"],since:"1.2.23",OPB64name:"ADDEXACT"},ADDMONTHS:{description:'Adds months to a timestamp or a tselements.\n\nThe `ADDMONTHS` function consumes from the top of the stack a number (positive or negative) of months, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the months and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `months` The number of months to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',signature:"ADDMONTHS( timestamp:LONG timezone:STRING months:LONG ): result:LONG\nADDMONTHS( timestamp:LONG months:LONG ): result:LONG\nADDMONTHS( tselements:LIST<LONG> months:LONG ): tselementsresult:LIST<LONG>",tags:["date"],since:"1.2.0",OPB64name:"ADDMONTHS"},ADDVALUE:{description:"The `ADDVALUE` function adds a value to a GTS, without checking for tick duplicates. The added data point is appended to the GTS.\nThe [`SETVALUE`](/doc/SETVALUE) overrides an existing value.\n\nThe `ADDVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `ADDVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, for example by using [`GET`](/doc/GET)\nwith value 0 as parameter.\n\nIf latitude or longitude are NaN (not a number), value has only timestamp, elevation, value.\nIf elevation is NaN (not a number), value has only timestamp, latitude, longitude, value.\nIf elevation is NaN and longitude or latitude are NaN, value has only timestamp, value.\n\nWhen adding a Geo Time Series™ or GTS Encoder value, the value will be wrapped (as when using `WRAPRAW`) and added as a binary value.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Series™\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `result` The Geo Time Series™ with the new datapoint added\n\n@param `elevation` Elevation or NaN\n\n",signature:"ADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:STRING ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:BYTES ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:BOOLEAN ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:DOUBLE ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:LONG ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:GTSENCODER ): result:GTS\nADDVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:GTS ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"ADDVALUE"},ADDYEARS:{description:'Adds years to a timestamp or a tselements.\n\nThe `ADDYEARS` function consumes from the top of the stack a number (positive or negative) of years, a time parameter (timestamp or tselements) and optionally a timezone parameter.\nIt adds the years and when an optional timezone is specified the computation is performed using it instead of `UTC`.\nTimezone names are the ones defined in [Joda Time](http://joda-time.sourceforge.net/timezones.html "Joda Time").\n\nThis function will take into account leap years and, when working with timestamps, possible daylight saving time change.\n\n@param `timestamp` The timestamp to modify\n\n@param `tselements` The date in [TSELEMENTS](doc/TSELEMENTS) format\n\n@param `timezone` The timezone\n\n@param `years` The number of years to add\n\n@param `result` The new date\n\n@param `tselementsresult` The new date in [TSELEMENTS](doc/TSELEMENTS) format\n\n',signature:"ADDYEARS( timestamp:LONG timezone:STRING years:LONG ): result:LONG\nADDYEARS( timestamp:LONG years:LONG ): result:LONG\nADDYEARS( tselements:LIST<LONG> years:LONG ): tselementsresult:LIST<LONG>",tags:["date"],since:"1.2.0",OPB64name:"ADDYEARS"},AESUNWRAP:{description:'Unwraps a byte array with the [AES WRAP](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") and pushes back the decrypted data into an bytes array.\n\n`AESUNWRAP` removes the a 64bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) added by [`AESWRAP`](/doc/AESWRAP) WarpScript function\n\n@param `data` Encoded Byte array.\n\n@param `key` Byte array, 128, 192 or 256 bits key.\n\n@param `decoded` Decoded Byte array.\n\n',signature:"AESUNWRAP( key:BYTES data:BYTES ): decoded:BYTES",tags:["crypto"],since:"1.0.11",OPB64name:"AESUNWRAP"},AESWRAP:{description:'Wraps a byte array or String with the [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt) algorithm and pushes a byte array containing the encrypted data onto the stack.\n\n`AESWRAP` adds a 64 bits [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) prefix to the input in order to protect the encrypted data against AES block determinism as [`AES WRAP`](https://www.ietf.org/rfc/rfc3394.txt "rfc3394") uses a fixed Initialization Vector.\n\n@param `key` 128, 192 or 256 bits key to use for encryption.\n\n@param `string` String data to encrypt.\n\n@param `bytes` Byte array to encrypt.\n\n@param `encrypted` Encrypted result.\n\n',signature:"AESWRAP( string:STRING key:BYTES ): encrypted:BYTES\nAESWRAP( bytes:BYTES key:BYTES ): encrypted:BYTES",tags:["crypto"],since:"1.0.11",OPB64name:"AESWRAP"},AGO:{description:"The `AGO` function is a shortcut which enables you to compute timestamps by specifying an offset from the current time.\n\n@param `offset` The numbers of ticks in platform time unit to subtract, truncated if floating-point.\n\n@param `timestamp` The computed timestamp\n\n",signature:"AGO( offset:NUMBER ): timestamp:LONG",tags:["date"],since:"1.2.0",OPB64name:"AGO"},AND:{description:"The `AND` operator is a synonymous for [`&&`](/doc/8XN).\n\nIt performs a logical **AND** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `false` value encountered.\n\nSince Warp 10™ 2.1, `AND` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical AND applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with AND between each common tick input values.\n\n",signature:"AND( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\nAND( l:LIST ): result:BOOLEAN\nAND( gts1:GTS gts2:GTS ): gtsresult:GTS",tags:["operators","logic"],since:"1.0.0",OPB64name:"AND"},APPEND:{description:"The `APPEND` function consumes two paramters from the top of the stack and appends the LIST, MAP or GTS on top of the stack to the one just below.\nThe augmented LIST, MAP or GTS is then pushed back on the stack.\n\n@param `newitems` items to append to input.\n\n@param `inputlist` LIST to be modified.\n\n@param `outputlist` The LIST that has been modified\n\n@param `inputmap` MAP to be modified.\n\n@param `outputmap` The AP that has been modified \n\n@param `inputGTS` GTS to be modified.\n\n@param `outputGTS` The GTS that has been modified\n\n",signature:"APPEND( inputlist:LIST newitems:LIST ): outputlist:LIST\nAPPEND( inputmap:MAP newitems:MAP ): outputmap:MAP\nAPPEND( inputGTS:GTS newitems:GTS ): outputGTS:MAP",tags:["lists","maps"],since:"1.0.0",OPB64name:"APPEND"},APPLY:{description:"The `APPLY` framework provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can do. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` List of resulting GTS, one per equivalence class.\n\n@param `op` Operation to perform.\n\n",signature:"APPLY( [ gts:LIST<GTS>+ labels:LIST op:OPERATOR ] ): result:LIST<GTS>",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"APPLY"},ASENCODERS:{description:"The `ASENCODERS` function consumes a Geo Time Series™, a wrap or a raw wrap, or a list thereof and convert each one into an encoder.\n\n@param `gts` Geo Time Series™ to be converted.\n\n@param `lgts` List of Geo Time Series™ to be converted.\n\n@param `wrappedgts` Wrapped Geo Time Series™ to be converted.\n\n@param `lwrappedgts` List of wrapped Geo Time Series™ to be converted.\n\n@param `rawwrappedgts` Raw wrapped Geo Time Series™ to be converted.\n\n@param `lrawwrappedgts` List of raw wrapped Geo Time Series™ to be converted.\n\n@param `encoder` Encoder of the given Geo Time Series™.\n\n@param `lencoder` List of encoder, one for each given Geo Time Series™.\n\n",signature:"ASENCODERS( gts:GTS ): encoder:GTSENCODER\nASENCODERS( lgts:LIST<GTS> ): lencoder:LIST<GTSENCODER>\nASENCODERS( wrappedgts:STRING ): encoder:GTSENCODER\nASENCODERS( lwrappedgts:LIST<STRING> ): lencoder:LIST<GTSENCODER>\nASENCODERS( rawwrappedgts:BYTES ): encoder:GTSENCODER\nASENCODERS( lrawwrappedgts:LIST<BYTES> ): lencoder:LIST<GTSENCODER>\nASENCODERS( encoder:GTSENCODER ): encoder:GTSENCODER\nASENCODERS( lencoder:LIST<GTSENCODER> ): lencoder:LIST<GTSENCODER>",tags:["encoder","conversion"],since:"2.2.0",OPB64name:"ASENCODERS"},ASIN:{description:"The `ASIN` function consumes a floating point number between -1 and 1 from the top of the stack and pushes back its arcsine in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arcsine in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arcsine in radians of the given values.\n\n",signature:"ASIN( value:NUMBER ): result:DOUBLE\nASIN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ASIN"},ASREGS:{description:"Replaces in a macro the uses of the given symbols by the use of registers.\n\nIf there are not enough registers available, replace each of the symbols from the start of the list until all registers are used.\n\nSince 2.6.0, the list of symbols is optional. In that case, `ASREGS` first recursively extracts all the symbols from given the macro and uses that list to do the replacement.\n\n@param `macro` Macro to transform.\n\n@param `vars` List of symbols.\n\n",signature:"ASREGS( macro:MACRO vars:LIST<STRING> ): macro:MACRO\nASREGS( macro:MACRO ): macro:MACRO",tags:["stack"],since:"2.0.0",OPB64name:"ASREGS"},ASSERT:{description:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise.\n\nThe `ASSERT` function consumes a **BOOLEAN** parameter from the top of the stack. If the boolean is **true** the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception.\n\n`ASSERT` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n",signature:"ASSERT( condition:BOOLEAN ): ",tags:["debug"],since:"1.0.0",OPB64name:"ASSERT"},ASSERTMSG:{description:"Evaluates a boolean expression, continues the execution if it is **true**, stops otherwise and displays a message.\n\nThe `ASSERTMSG` function consumes a **BOOLEAN** parameter and a **STRING** parameter from the top of the stack. If the boolean is **true**, the execution of\nthe WarpScript script continues, else it stops the execution by throwing an exception with a message displaying the **STRING** parameter.\n\n`ASSERTMSG` is usually used in WarpScript unit tests.\n\n@param `condition` The boolean expression to evaluate\n\n@param `message` The exception message to display if the test fails\n\n",signature:"ASSERTMSG( condition:BOOLEAN message:STRING ): ",tags:["debug"],since:"1.2.13",OPB64name:"ASSERTMSG"},ATAN:{description:"The `ATAN` function consumes a floating point number between -1 et 1 from the top of the stack and pushes back its arctangent in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, between -1 and 1, inclusive.\n\n@param `result` Arctangent in radians of the given value.\n\n@param `lvalue` List of values, between -1 and 1, inclusive.\n\n@param `lresult` List of arctangent in radians of the given values.\n\n",signature:"ATAN( value:NUMBER ): result:DOUBLE\nATAN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"ATAN"},ATAN2:{description:"ATAN2 function returns the polar angle theta (azimut) from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta). This method computes the phase theta by computing an arc tangent of y/x in the range of `] -pi  pi ]`.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `result` theta in polar coordinates\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `lresult` List of thetas in polar coordinates\n\n",signature:"ATAN2( y:NUMBER x:NUMBER ): result:DOUBLE\nATAN2( y:NUMBER lx:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nATAN2( ly:LIST<NUMBER> x:NUMBER ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.2.13",OPB64name:"ATAN2"},ATBUCKET:{description:"The `ATBUCKET` function consumes a bucketized GTS from the stack, looks at its `index`-th bucket and puts on the stack a\nlist with the timestamp, latitude, longitude, elevation and value for this bucket.\n\n@param `gts` Bucketized Geo Time Series™\n\n@param `index` Index of the bucket\n\n@param `result` List with the timestamp, latitude, longitude, elevation and value for the index-th bucket of the GTS\n\n",signature:"ATBUCKET( gts:GTS index:LONG ): result:LIST",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"ATBUCKET"},ATINDEX:{description:"The `ATINDEX` function consumes a Geo Time Series™ or a list thereof from the stack, looks at its index-th point and put on the stack a list with the timestamp, longitude, \nlatitude, elevation and value for the `index`-th point of the GTS.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the GTS.\n\n@param `index` Index of the tick, truncated if floating-point.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",signature:"ATINDEX( gts:GTS index:NUMBER ): data:LIST\nATINDEX( lgts:LIST<GTS> index:NUMBER ): ldata:LIST<LIST>",tags:["gts"],since:"1.0.0",OPB64name:"ATINDEX"},ATTICK:{description:"The `ATTICK` function consumes a Geo Time Series™ from the stack, looks at its tick-th tick (the data point with a timestamp tick) and put on the \nstack a list with the timestamp, latitude, longitude, elevation and value for that data point.\n\nIf there is no data point with tick timestamp, it return a list with timestamp, latitude, longitude and elevation at **NaN** and value at **null**.\n\n@param `timestamp` Timestamp at which to take the data, if it is a floating-point value, it is truncated.\n\n@param `gts` The Geo Time Series™ from which to take the data\n\n@param `lgts` The list of Geo Time Series™ from which to take the data\n\n@param `data` A list containing timestamp, latitude, longitude, elevation and value\n\n@param `ldata` A list of lists, each of them containing timestamp, latitude, longitude, elevation and value\n\n",signature:"ATTICK( gts:GTS timestamp:LONG ): data:LIST\nATTICK( lgts:LIST<GTS> timestamp:LONG ): ldata:LIST<LIST>\nATTICK( gts:GTS timestamp:COUNTER ): data:LIST\nATTICK( lgts:LIST<GTS> timestamp:COUNTER ): ldata:LIST<LIST>\nATTICK( gts:GTS timestamp:DOUBLE ): data:LIST\nATTICK( lgts:LIST<GTS> timestamp:DOUBLE ): ldata:LIST<LIST>",tags:["gts"],since:"1.0.0",OPB64name:"ATTICK"},ATTRIBUTES:{description:"Retrieves the attributes of a Geo Time Series™.\n\nThe `ATTRIBUTES` function takes a **GTS** on top of the stack and push back a **MAP** including all its attributes.\n\nAn attribute corresponds to a tag for a specific series.\nThe attribute system allows the user to add some information that can change in a series.\n\n@param `gts` The input Geo Time Series™\n\n@param `encoder` The input Geo Time Series™ Encoder\n\n@param `return` The attributes MAP of the input Geo Time Series™\n\n",signature:"ATTRIBUTES( gts:GTS ): return:MAP\nATTRIBUTES( encoder:GTSENCODER ): return:MAP",tags:["gts"],since:"1.0.0",OPB64name:"ATTRIBUTES"},AUTHENTICATE:{description:"The `AUTHENTICATE` function authenticates the current stack with the **read token** on top of the stack. This function removes the token from the stack.\n\nInside a WarpScript, the stack could be authenticated only once. An exception is thrown when the stack is already authenticated.\n\n@param `token` Read token\n\n",signature:"AUTHENTICATE( token:STRING ): ",tags:["stack"],since:"1.0.0",OPB64name:"AUTHENTICATE"},"B64->":{description:"Decodes the [base64](http://tools.ietf.org/html/rfc4648#section-4) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",signature:"B64->( content:STRING ): result:BYTES",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoAIs"},B64TOHEX:{description:"Decodes the  [base64](http://tools.ietf.org/html/rfc4648#section-4) content on top of the stack and immediately re-encode it in hexadecimal.\nThis enables you to convert encoded content which would not be valid UTF-8 encoding from base64 to hexadecimal. \nAs the string are URL encoded, the symbol `+` have to be replaced by `%2B`, otherwise a space will replace the `+` in the string.\n\n@param `content` String to convert\n\n@param `result` Hexadecimal converted string\n\n",signature:"B64TOHEX( content:STRING ): result:STRING",tags:["strings","conversion"],since:"1.0.0",OPB64name:"B64TOHEX"},"B64URL->":{description:"Decodes the [base64url](http://tools.ietf.org/html/rfc4648#section-5) **STRING** content on top of the stack.\n\n@param `content` String to decode\n\n@param `result` Bytes array\n\n",signature:"B64URL->( content:STRING ): result:BYTES",tags:["strings","conversion"],since:"1.0.0",OPB64name:"FYNoKK8BAIs"},BBOX:{description:"The `BBOX` function computes the bounding box of a Geo Time Series™ or a list thereof. It returns a list with extremas, or a list of list of extremas.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `minlat` Latitude of lower left of bounding box.\n\n@param `minlon` Longitude of lower left of bounding box.\n\n@param `maxlat` Latitude of upper right of bounding box.\n\n@param `maxlon` Longitude of upper right of bounding box.\n\n@param `extremas` List of list containing minlat, minlon, maxlat, maxlon, for every GTS in lgts.\n\n",signature:"BBOX( gts:GTS ): [  minlat:DOUBLE  minlon:DOUBLE  maxlat:DOUBLE  maxlon:DOUBLE  ]\nBBOX( lgts:LIST<GTS> ): extremas:LIST<LIST<DOUBLE>>",tags:["geo","gts"],since:"1.0.0",OPB64name:"BBOX"},"BIN->":{description:"The `->BIN` function decodes a binary string representation into a bytes array.\n\n@param `binary` The binary string representation\n\n@param `result` The bytes array\n\n",signature:"BIN->( binary:STRING ): result:BYTES",tags:["strings","conversion","binary"],since:"1.0.6",OPB64name:"FZ_DAIs"},BINTOHEX:{description:"Converts a string representing a binary number into a string representing a hexadecimal number.\n\nThe `BINTOHEX` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from binary to hexadecimal.\n\n@param `content` The string representing a binary number\n\n@param `result` The string representing a hexadecimal number\n\n",signature:"BINTOHEX( content:STRING ): result:STRING",tags:["strings","conversion","binary"],since:"1.0.0",OPB64name:"BINTOHEX"},BITCOUNT:{description:"Returns the logical size and the cardinality of a [BitSet](https://docs.oracle.com/javase/8/docs/api/java/util/BitSet.html).\n\nThe `BITCOUNT` function consumes a bitset on the top of the stack and push back its logical size and its cardinality.\n  * The logical size is the index of the highest bit set to true plus one.\n  * The cardinality is the number of bit set to true.\n\n@param `bitset` The BitSet to count\n\n@param `length` The logical size of the BitSet\n\n@param `cardinality` The number of bits set to true\n\n",signature:"BITCOUNT( bitset:BITSET ): cardinality:LONG length:LONG",tags:["bitset","binary"],since:"1.0.6",OPB64name:"BITCOUNT"},BITGET:{description:"Returns the value of the bit with the specified index.\n\nThe `BITGET` function consumes a bitset and a long on the top of the stack. It returns the value of the bit with the specified index. The bit index starts at 0 from the right.\n\n@param `index` The bit index\n\n@param `bitset` The bitset\n\n@param `return` The value of the bit with the specified index\n\n",signature:"BITGET( bitset:BITSET index:LONG ): return:BOOLEAN",tags:["bitset","binary"],since:"1.0.5",OPB64name:"BITGET"},BITSTOBYTES:{description:"Converts a bitset into a bytes array.\n\n@param `bitset` Bitset\n\n@param `result` Bytes array\n\n",signature:"BITSTOBYTES( bitset:BITSET ): result:BYTES",tags:["bitset","binary","conversion"],since:"1.0.6",OPB64name:"BITSTOBYTES"},BOOTSTRAP:{description:"This function is executed systematically before the WarpScript stack is available for anything else. By default this function does nothing, it is equivalent \nto [`NOOP`](/doc/NOOP).\n\nIf bootstrap code was specified in the Warp 10 platform configuration, for either or all of `egress`, `mobius` or `runner`, the `BOOTSTRAP` function might\nhave been redefined and actual code could be executed.\n\nThis function is not meant to be used in user provided scripts.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"BOOTSTRAP"},BREAK:{description:"The `BREAK` function breaks out of the current loop. It takes no argument.\n\n> If used outside a loop, an error is thown\n\n",signature:"",tags:["logic","control"],since:"1.0.0",OPB64name:"BREAK"},BUCKETCOUNT:{description:"The function `BUCKETCOUNT` consumes a GTS off the stack and pushes its bucketcount onto the stack.\n\n> Note: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Number of buckets\n\n",signature:"BUCKETCOUNT( gts:GTS ): result:LONG",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETCOUNT"},BUCKETIZE:{description:"The Geo Time Series™ kept in the Warp 10 platform grow over time as more measurements are added. Some series have very regular measurements,\nothers more sporadic ones. But when it comes to manipulating the data, it might be handy to be able to impose some kind of regularity to measurements.\nThis is exactly what the [`BUCKETIZE`](/doc/BUCKETIZE) framework does, it provides the tooling for putting the data of a Geo Time Series™ into regularly spaced\n**buckets**.\n\nA **bucket** is a time interval which spans a certain number of time units called the **bucketspan**, ending at a tick called the **lastbucket**.\n\nAs an example, the bucket spanning 10 time units and ending at time units 20 will contain all measurements taken at the following times:\n\n20, 19, 18, 17, 16, 15, 14, 13, 12, 11\n\nthe previous bucket with the same bucketspan ends at 10 and covers ticks 10 down to 1. The next bucket ends at 30 and covers ticks 21 to 30.\n\nA bucketized Geo Time Series™ is characterized by its **bucketspan**, its **bucketcount** and the **lastbucket**.\nA bucketized Geo Time Series™ has at most one measurement per bucket, there might be buckets with no measurements.\n\nThe `BUCKETIZE` framework is used to convert a non bucketized Geo Time Series™ into a bucketized one. The bucketization process collects\nthe measurements of the original geo time series which fall in each bucket and apply a bucketizer function on those data, thus leading to at most a\nsingle measurement for each bucket.\n\nThe `BUCKETIZE` framework comes with a number of bucketizer which implement very common aggregation functions such as SUM, MIN, MAX, MEAN, etc.\n\nA macro can be used instead of the bucketizer argument. In that case, in each bucket the measurements are collected as a sub Geo Time Series™ which is taken as parameter by the macro.\nThis macro must then push onto the stack its result (see description in signature description below).\n\nIf the bucketizer argument is NULL, then BUCKETIZE do not create any new Geo Time Series™ but instead sets the lastbucket, bucketspan and bucketcount of its inputs without processing their data.\n\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so the first value of the geo time series is at the beginning of the first bucket.\n\n@param `bucketspan` Width in time units of each bucket. If `bucketspan` is 0 but `bucketcount` is set, WarpScript will compute `bucketspan` so `bucketcount` buckets cover the complete set of values from firsttick to lasttick. If this value is set to -1, the number of buckets is computed so the first tick is towards the end of the first bucket.\n\n@param `lastbucket` Specifies the timestamp in time units since the Unix Epoch of the end of the most recent bucket. If you set this value to 0, this timestamp will be computed automatically so it covers the most recent value of the geo time series and falls on a `bucketspan` boundary.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS\n\n",signature:"BUCKETIZE( [ gts:GTS+ bucketizer:AGGREGATOR lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE( [ gtsList:LIST<GTS>+ bucketizer:AGGREGATOR lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE( [ gts:GTS+ macro:MACRO lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE( [ gtsList:LIST<GTS>+ macro:MACRO lastbucket:LONG bucketspan:LONG bucketcount:LONG ] ): result:LIST<GTS>",tags:["framework","bucketize","gts","bucketizer"],since:"1.0.0",OPB64name:"BUCKETIZE"},"BUCKETIZE.CALENDAR":{description:"Creates bucketized Geo Time Series with buckets that span a calendar duration that can be irregular (e.g. taking into account leap years and daylight saving time).\n\nInstead of using a bucketspan like the BUCKETIZE framework, it uses a bucketduration: a STRING in [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) format, as `PyYmMwWdDThHmMsS` similarly to that of ADDDURATION function. However, complex bucketdurations that can be non-positive from some ticks are not allowed.\n\nIn the result, the tick of each bucket is its index, which is equal to the number of buckets that are ended since Unix Epoch. In particular, the tick of the bucket that contains Unix Epoch is always 0. The resulting GTS is considered bucketized for further operations. Then, the function UNBUCKETIZE.CALENDAR can be used to replace bucket indices with their timestamp end boundaries.\n\nThis function answers the limitation of BUCKETIZE to regular buckets. For instance, BUCKETIZE.CALENDAR can be used with a duration of one month (`P1M`) or one year (`P1Y`).\n\nThe delta between Unix Epoch and the first timestamp of bucket 0th is called the bucketoffset. The bucketoffset, bucketduration and buckettimezone are stored in the attributes.\n\n@param `timezone` The timezone to consider. Default to UTC\n\n@param `bucketcount` Number of buckets of the bucketized geo time series. If this value is set to 0, the number of buckets will be computed so every value of the GTS falls in a bucket.\n\n@param `bucketduration` Width in ISO 8601 duration format of each bucket.\n\n@param `lastbucket` Specifies the timestamp in platform time units of the end boundary of the most recent bucket. For coherency with BUCKETIZE, this value can not be set to 0.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `bucketizer` Bucketizer function to apply\n\n@param `macro` Macro to apply. Must expect a GTS as input. Must push onto the stack either [value], or [tick,value], or [tick,elev,value], or [tick,lat,lon,value], or [tick,lat,lon,elev,value], or tick, lat, lon, elev and value.\n\n@param `result` List of bucketized GTS in the new time referential\n\n",signature:"BUCKETIZE.CALENDAR( [ gts:GTS+ bucketizer:AGGREGATOR lastbucket:LONG bucketduration:STRING bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE.CALENDAR( [ gts:GTS+ macro:MACRO lastbucket:LONG bucketduration:STRING bucketcount:LONG ] ): result:LIST<GTS>\nBUCKETIZE.CALENDAR( [ gts:GTS+ bucketizer:AGGREGATOR lastbucket:LONG bucketduration:STRING bucketcount:LONG timezone:STRING ] ): result:LIST<GTS>\nBUCKETIZE.CALENDAR( [ gts:GTS+ macro:MACRO lastbucket:LONG bucketduration:STRING bucketcount:LONG timezone:STRING ] ): result:LIST<GTS>",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"BUCKETIZE.CALENDAR"},BUCKETSPAN:{description:"The function `BUCKETSPAN` consumes a GTS off the stack and pushes its bucketspan onto the stack.\n\n> when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Bucketspan\n\n",signature:"BUCKETSPAN( gts:GTS ): result:LONG",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"BUCKETSPAN"},"BYTES->":{description:"Converts a bytes array into a string with given a charset and put the string on top of the stack.\n\nCharset could be any supported by your java platform. Example: UTF-8 US-ASCII ISO-8859-1 Cp852...\n\n\n@param `charset` Charset to use\n\n@param `bytes` Bytes array to convert\n\n@param `result` String converted byte array\n\n",signature:"BYTES->( bytes:BYTES charset:STRING ): result:STRING",tags:["strings","conversion"],since:"1.0.6",OPB64name:"F__JGKBhEV"},BYTESTOBITS:{description:"Converts a byte array into a bitset.\n\n@param `bytesarray` Bytes array\n\n@param `result` Bitset\n\n",signature:"BYTESTOBITS( bytesarray:BYTES ): result:BITSET",tags:["bitset","conversion","binary"],since:"1.0.6",OPB64name:"BYTESTOBITS"},CALL:{description:'The `CALL` function invokes the external program whose path (relative to the `warpscript.call.directory` directory) is on top of the stack. The calling convention will pass to the external\nprogram the **STRING** object below the path on a line by itself on standard input after having URL encoded the **STRING**. The invoked\nprogram is expected to return a URL encoded **STRING** object if invocation was successful, or a string starting with a space and followed by a URL encoded error message if an error was encoutered.\n\nIf you need to pass complex structures to the invoked program, you can use functions such as [`->JSON`](/doc/AIt9JoxD), [`->PICKLE`](/doc/AItFHJCAI3J)\nand [`->B64`](/doc/AIt1CYF) to encode the input prior to the invocation.\n\nExamples of callable programs are provided in [shell](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/sh/callable.sh)\nand [python](https://github.com/senx/warp10-platform/blob/master/warp10/src/main/python/callable.py).\n\nThe program must be stored in the directory described by the `warpscript.call.directory` configuration parameter.\n\nThe program must first output on the stdout the number of concurrent thread allowed.\n\nExample:\n\n```bash\n#!/bin/bash\necho 5 # 5 threads allowed\nurldecode() {\n  # urldecode <string>\n  local url_encoded="${1//+/ }"\n  printf \'%b\' "${url_encoded//%/\\\\x}"\n}\nwhile true\n\ndo\n  read line\n  line=`urldecode "${line}"` # read the params given by the WarpScript\n  echo $line # Will be pushed on the stack\ndone\n```\n\n@param `program` Program path\n\n@param `params` URL encoded input\n\n@param `result` URL encoded output\n\n',signature:"CALL( params:STRING program:STRING ): result:STRING",tags:["platform"],since:"1.0.7",OPB64name:"CALL"},CBRT:{description:"The `CBRT` function consumes a numeric parameter from the top of the stack and pushes back its cubic root.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Cubic root of the given value.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of cubic root of each given value.\n\n",signature:"CBRT( value:NUMBER ): result:DOUBLE\nCBRT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"CBRT"},CEIL:{description:"The `CEIL` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number bigger than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-up value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-up values, for each given value.\n\n",signature:"CEIL( value:NUMBER ): result:DOUBLE\nCEIL( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"CEIL"},CEVAL:{description:"The `CEVAL` function allows you to execute macros in a concurrent way on a pool of threads.\n\nAll macros will be executed with the maximum parallelism level specified. Each macro is executed on its own stack. The context of the global stack is\nreplicated to each of those stacks so each macro will have access to the existing symbols and the redefined functions. Any modification to the symbol\ntable or redifined functions done in a concurrent macro will not be reflected in the global stack afterwards.\n\nEach macro is invoked with its index in the list on top of the stack.\n\nUpon termination of each macro, the content of their respective stacks is put into a list, with the top of the stack at index 0, and those lists are\nmerged into a global list which is then pushed onto the stack. The resulting list for each macro appears at the index of the macro in the original macro list.\n\nBeware that no synchronization is implicitely performed between the concurrent macros. If you require synchronization between macros, for example because\nyou are modifying a list accessible by all macros via a symbol, you must use the [`SYNC`](/doc/SYNC) function.\n\nIf one of the macros fail, an attempt to interrupt the other running macros will be done and the failure will be propagated to the other macros. For the\ntime being, a call to [`STOP`](/doc/STOP) or [`RETURN`](/doc/RETURN) in one of the macros will stop all of them.\n\nUse of `CEVAL` is not available from within a macro currently executing in a `CEVAL` call.\n\nThe `CEVAL` function is part of the `io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```properties\n// Enable CEVAL and SYNC functions\nwarpscript.extension.concurrent = io.warp10.script.ext.concurrent.ConcurrentWarpScriptExtension\n```\n\n@param `poolSize` Parallelism level\n\n@param `macros` List of macros\n\n@param `result` Result list\n\n",signature:"CEVAL( macros:LIST poolSize:LONG ): result:LIST",tags:["extensions"],since:"1.0.0",OPB64name:"CEVAL"},CHECKMACRO:{description:"The `CHECKMACRO` function checks if a macro is defined and aborts the execution when it encounters an undefined macro.\n\n@param `name` The macro name\n\n",signature:"CHECKMACRO( name:STRING ): ",tags:["logic","control"],since:"2.1.0",OPB64name:"CHECKMACRO"},CHECKSHAPE:{description:"Return a BOOLEAN indicating whether an input list and its nested lists sizes are coherent together to form a tensor (or multidimensional array).\n\n@param `list` The input list.\n\n@param `result` true or false.\n\n",signature:"CHECKSHAPE( list:LIST ): result:LIST\nCHECKSHAPE( { list:LIST  } ): result:LIST",tags:["lists","tensors"],since:"2.1.0",OPB64name:"CHECKSHAPE"},CHRONOEND:{description:"The `CHRONOEND` function ends a stopwatch with the given name previously started with [`CHRONOSTART`](/doc/CHRONOSTART). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\nIt is a good practice to put `CHRONOEND` in the finally clause of a [`TRY`](/doc/TRY) for the timing to work even if exceptions are thrown.\n\n@param `name` A name identifying the stopwatch.\n\n",signature:"CHRONOEND( name:STRING ): ",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOEND"},CHRONOSTART:{description:"The `CHRONOSTART` function starts a stopwatch with the given name. To stop the stopwatch, call [`CHRONOEND`](/doc/CHRONOEND). On top of recording the cumulative time between each start and end of the stopwatch, the number of calls of `CHRONOSTART` is recorded.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\nIf calls of `CHRONOSTART` and [`CHRONOEND`](/doc/CHRONOEND) with the same name are nested, only the top level one is timed but each call to `CHRONOSTART` is counted. This allows the timing of recursive functions.\n\n@param `name` A name identifying the stopwatch.\n\n",signature:"CHRONOSTART( name:STRING ): ",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTART"},CHRONOSTATS:{description:"The `CHRONOSTATS` function \n\n@param `stats` A map with stopwatches names as keys and maps as values. These maps have two keys, `total_calls` and `total_time`. The former gives the number of calls to [`CHRONOSTART`](/doc/CHRONOSTART) and the latter gives the cumulative time between [`CHRONOSTART`](/doc/CHRONOSTART) and [`CHRONOEND`](/doc/CHRONOEND) in **nanoseconds**.\n\n",signature:"CHRONOSTATS(): stats:MAP",tags:["debug"],since:"2.1.0",OPB64name:"CHRONOSTATS"},CHUNK:{description:"The `CHUNK` is used to split a Geo Time Series™ into partial GTS. The split operation is controlled by multiple parameters.\nThe series will be splitted in chunks, each chunks will form a new GTS, with a label value corresponding to its first tick.\n\n@param `keepempty` If true empty chunks are kept\n\n@param `chunklabel` The label name of the label added by the split operation (with a value corresponding to the first tick of the chunk).\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` An overlap duration (in time units) between chunks, this is useful when chunking a GTS to apply an algorithm which operates on a sliding window.\n\n@param `chunkwidth` The width in time units of each chunk.\n\n@param `lastchunkend` The end timestamp of the most recent split to consider.\n\n@param `gts` A single GTS instance.\n\n@param `gtsList` A GTS list to split, each GTS will be splitted individually.\n\n@param `encoder` A single GTS Encoder instance.\n\n@param `lEncoder` A GTS Encoder list to split, each GTS Encoder will be splitted individually.\n\n@param `result` GTS Chunks, a list formed with its partial GTS.\n\n@param `resultEncoders` GTS Encoders Chunks, a list formed with its partial GTS Encoders.\n\n",signature:"CHUNK( gts:GTS lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<GTS>\nCHUNK( gtsList:LIST<GTS> lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<GTS>\nCHUNK( encoder:GTSENCODER lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): resultEncoders:LIST<GTSENCODER>\nCHUNK( lEncoder:LIST<GTSENCODER> lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): resultEncoders:LIST<GTSENCODER>",tags:["gts"],since:"1.0.0",OPB64name:"CHUNK"},CHUNKENCODER:{description:"The `CHUNKENCODER` function is used to split a [GTSEncoder](/doc/NEWENCODER) into partial GTSEncoder. The user defines some parameters that will \nbe applied to the split operation. The series will be splitted in chunks, each chunks will form a new GTSEncoder, with a label value \ncorresponding to its first tick.\n\nDeprecated since 2.1, use CHUNK instead which behaves the same.\n\n@param `keepempty` If true empty chunk are kept\n\n@param `chunklabel` The label name of the label added by this split operation (add a value corresponding to the first tick of the chunk). Could be a regular expression.\n\n@param `chunkcount` The number of chunks to keep (starting from the last chunk).\n\n@param `chunkoverlap` A time overlap for each chunks in time units.\n\n@param `chunkwidth` The width in time unit of each chunks in time units.\n\n@param `lastchunkend` The split operation end when it encounters this timestamp.\n\n@param `GTSEncoder` A single GTSEncoder \n\n@param `GTSEncoderList` A GTSEncoder list to split, each GTSEncoder will be splitted individually.\n\n@param `result` GTSEncoder Chunks, a list formed with its partial GTSEncoder\n\n",signature:"CHUNKENCODER( GTSEncoder:GTSENCODER lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<GTSENCODER>\nCHUNKENCODER( GTSEncoderList:LIST<GTSENCODER> lastchunkend:LONG chunkwidth:LONG chunkoverlap:LONG chunkcount:LONG chunklabel:STRING keepempty:BOOLEAN ): result:LIST<LIST<GTSENCODER>>",tags:["encoder"],since:"1.2.9",OPB64name:"CHUNKENCODER"},CLEAR:{description:"The `CLEAR` function empties the stack.\n\n@param `input` all the input on the stack will be erased from the stack.\n\n",signature:"CLEAR( input:ANY* ): ",tags:["stack"],since:"1.0.0",OPB64name:"CLEAR"},CLEARDEFS:{description:"The `CLEARDEFS` function allows you to clear all [redefined WarpScript functions](/doc/DEF).\n\nBy default, all redefined WarpScript function, will not be available anymore. Set the `warpscript.def.unshadow` \nconfiguration property to change this behaviour.\n\nThis configuration parameter determines if undefining a function (via NULL 'XXX' DEF) will unshadow the original statement \nthus making it available again or if it will replace it with a function that will fail with a message saying the function is undefined.\nThe safest behavior is to leave this undefined or set to **false**.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"CLEARDEFS"},CLEARREGS:{description:"Clears all registers, setting their current value to `NULL`.\n\n@param `value` Value from the designated register.\n\n",signature:"CLEARREGS(): value:ANY",tags:["stack"],since:"2.0.0",OPB64name:"CLEARREGS"},CLEARSYMBOLS:{description:"The `CLEARSYMBOLS` function clears all symbols defined with the function [`STORE`](/doc/STORE).\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"CLEARSYMBOLS"},CLEARTOMARK:{description:"Removes elements from the stack up to and including the first mark encountered.\n\n@param `inputs` all the inputs references on the stack will be erased\n\n@param `mark` the mark will also be erased\n\n",signature:"CLEARTOMARK( mark:MARK inputs:ANY* ): ",tags:["stack"],since:"1.0.0",OPB64name:"CLEARTOMARK"},CLIP:{description:"The `CLIP` function clips a Geo Time Series™, encoders or list thereof according to a series of limits. The limits are lists of pair containing the lower and upper \ntimestamps used to clip. Each pair will generate a clipped GTS or encoder for each instance.\n\n@param `bounds` List of timestamp pairs. Each pair is a list of LONG.\n\n@param `gts` GTS to clip\n\n@param `lgts` List of GTSs to clip\n\n@param `encoder` Emcoder to clip\n\n@param `lencoder` List of encoders to clip\n\n@param `result` List of clipped GTS\n\n",signature:"CLIP( gts:GTS bounds:LIST<LIST<LONG>> ): result:LIST<GTS>\nCLIP( lgts:LIST<GTS> bounds:LIST<LIST<LONG>> ): result:LIST<LIST<GTS>>\nCLIP( encoder:GTSENCODER bounds:LIST<LIST<LONG>> ): result:LIST<GTSENCODER>\nCLIP( lencoder:LIST<GTSENCODER> bounds:LIST<LIST<LONG>> ): result:LIST<LIST<GTS>>",tags:["gts"],since:"1.2.0",OPB64name:"CLIP"},CLONE:{description:"The `CLONE` function does a shallow copy of a given Geo Time Series™, List, Map or Vector. Since 2.1.1 it can also clone Encoders.\n\nAs it makes a shallow copy, be careful when using CLONE on a List of Geo Time Series™ like those generated by the use of [`FETCH`](/doc/FETCH). Modifying a Geo Time Series™ in any of those list will alter the matching Geo Time Series™ in the other List.\nIf you want to use `CLONE` after a [`FETCH`](/doc/FETCH), you will need to extract the Geo Time Series™ from the list, for example by using [`LIST->`](/doc/I3_IK1oy), [`GET`](/doc/GET) or [`LMAP`](/doc/LMAP).\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `list` The List to clone\n\n@param `map` The Map to clone\n\n@param `set` The Set to clone\n\n@param `vector` The Vector to clone\n\n@param `encoder` The Encoder to clone\n\n@param `clone` The cloned Geo Time Series™, List, Map, Vector or Encoder\n\n@param `original` The original Geo Time Series™, List, Map, Vector or Encoder\n\n",signature:"CLONE( gts:GTS ): original:GTS clone:GTS\nCLONE( list:LIST ): original:LIST clone:LIST\nCLONE( map:MAP ): original:MAP clone:MAP\nCLONE( set:SET ): original:SET clone:SET\nCLONE( vector:VECTOR ): original:VECTOR clone:VECTOR\nCLONE( encoder:GTSENCODER ): original:GTSENCODER clone:GTSENCODER",tags:["gts","lists","maps"],since:"1.0.0",OPB64name:"CLONE"},CLONEEMPTY:{description:"Clones a Geo Time Series™, an Encoder or all the instances in a list of Geo Time Series™ or an Encoder, keeping only the metadata and not the values.\n\nThe `CLONEEMPTY` function takes as parameter a Geo Time Series™, an Encoder or a list thereof. It creates an empty clone of the input with only his metadata. The cloned metadata are:\n * Classname\n * Labels\n * Attributes\n * Lastbucket, for Geo Time Series™ only\n * Bucketspan, for Geo Time Series™ only\n * Bucketcount, for Geo Time Series™ only\n * Base timestamp, for Encoders only\n * Wrapping key, for Encoders only\n\nThe input parameter is consumed and the clone or list of clones is left on the stack.\n\n@param `gts` The Geo Time Series™ to clone\n\n@param `gtsList` The list of Geo Time Series™ to clone\n\n@param `result` The cloned Geo Time Series™\n\n@param `resultList` The cloned list of Geo Time Series™\n\n@param `encoder` The encoder to clone\n\n@param `encoderList` The list of encoder to clone\n\n@param `encoderResult` The cloned encoder\n\n@param `encoderResultList` The cloned list of encoders\n\n",signature:"CLONEEMPTY( gts:GTS ): result:GTS\nCLONEEMPTY( gtsList:LIST<GTS> ): resultList:LIST<GTS>\nCLONEEMPTY( encoder:GTSENCODER ): encoderResult:GTSENCODER\nCLONEEMPTY( encoderList:LIST<GTSENCODER> ): encoderResultList:LIST<GTSENCODER>",tags:["gts"],since:"1.0.0",OPB64name:"CLONEEMPTY"},CLONEREVERSE:{description:"The function CLONEREVERSE clone the input and reverses the order of the elements. \nOutput is a reference to a new object.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n@param `input` reference of the list or string to reverse.\n\n@param `output` reference to a new reversed list or string or byte array.\n\n",signature:"CLONEREVERSE( input:LIST ): output:LIST\nCLONEREVERSE( input:STRING ): output:STRING\nCLONEREVERSE( input:BYTES ): output:BYTES",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"CLONEREVERSE"},COMMONTICKS:{description:"Take a list of Geo Time Series™ and output A GTS list with only the set of ticks they have in common compared by timestamp.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with common ticks\n\n",signature:"COMMONTICKS( gtsList:LIST<GTS> ): result:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"COMMONTICKS"},COMPACT:{description:"The `COMPACT` function expects a Geo Time Series™ or a **LIST** of GTS on top of the stack. For each GTS instance it reads, it will \nproduce a GTS whith fewer values, by removing measurements which have the same value, location and elevation as the previous one. The first tick will be the kept, then ticks with value or position change will be kept. The last tick from the original gts will be copied, in order to keep the same LASTTICK.\n\n@param `gts` A GTS to compact\n\n@param `gtsList` A GTS list to compact\n\n@param `result` A compacted GTS\n\n@param `resultList` A compacted GTS list\n\n",signature:"COMPACT( gts:GTS ): result:GTS\nCOMPACT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"COMPACT"},CONTAINS:{description:"The `CONTAINS` function checks if the element on top of the stack is contained by the list on second position. A boolean is pushed on the stack.\n\nIf the parameters are two STRINGs, `CONTAINS` checks if the second STRING is contained in the first one, leaving a boolean on the stack. This latter usage is available since revision 2.1.0.\n\n@param `item` Depending on list construction, could be a number, a string, a boolean, NULL, a GTS...\n\n@param `presence` true if inputlist contains the item. false otherwise or if inputlist is empty.\n\n@param `list` reference to the LIST to search.\n\n@param `set` reference to the SET to search.\n\n@param `str` STRING in which to find `substr`.\n\n@param `substr` STRING to find in `str`.\n\n",signature:"CONTAINS( list:LIST item:ANY ): list:LIST presence:BOOLEAN\nCONTAINS( set:SET item:ANY ): set:LIST presence:BOOLEAN\nCONTAINS( str:STRING substr:STRING ): presence:BOOLEAN",tags:["lists"],since:"1.0.0",OPB64name:"CONTAINS"},CONTAINSKEY:{description:"The `CONTAINSKEY` function checks if the key element on top of the stack is a key \nof the map on second position. \n\nThe key is consumed, and a boolean is pushed on the stack.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this key. Do not trust presence if key is NULL.\n\n",signature:"CONTAINSKEY( inputmap:MAP key:ANY ): outputmap:MAP presence:BOOLEAN",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSKEY"},CONTAINSVALUE:{description:"The `CONTAINSVALUE` function checks if the value element on top of the stack is a value \nof the map on second position. \n\nThe value is consumed, and a boolean is pushed on the stack.\n\n@param `value` Depending on map construction, could be a number, a string, a boolean, NULL.\n\n@param `inputmap` reference to the map to search.\n\n@param `outputmap` copy of input map reference.\n\n@param `presence` true if inputmap has this value in at least one pair of its key-value.\n\n",signature:"CONTAINSVALUE( inputmap:MAP value:ANY ): outputmap:MAP presence:BOOLEAN",tags:["maps"],since:"1.0.0",OPB64name:"CONTAINSVALUE"},CONTINUE:{description:"Immediately stop executing the current iteration of an ongoing loop and start the next one.\n\n",signature:"",tags:["logic","control"],since:"1.0.0",OPB64name:"CONTINUE"},COPYGEO:{description:"The `COPYGEO` function forces the location elements of a GTS onto others. `COPYGEO` expects two parameters on the stack.\nFirst input is GTS or a gts list: those series(s) will have their location overwritten by the one of the second GTS parameter. Geo information will be copied only if they are present in the second paramaters on the same tick otherwise it keep the existing location. See [`COMMONTICKS`](/doc/COMMONTICKS) to keep only commonticks before calling `COPYGEO`.\n\n@param `gts` A GTS\n\n@param `gtsList` A list of GTS\n\n@param `geogts` A GTS with the geo information you want to copy to other (list of) gts.\n\n@param `result` A GTS with the geo information of the geogts input\n\n@param `resultList` A list of GTS with the geo information of the geogts input\n\n",signature:"COPYGEO( gts:GTS geogts:GTS ): result:GTS\nCOPYGEO( gtsList:LIST<GTS> geogts:GTS ): resultList:LIST<GTS>",tags:["gts","geo"],since:"1.0.0",OPB64name:"COPYGEO"},COPYSIGN:{description:"The `COPYSIGN` function copies the sign of a number on another one and pushes back the value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` Numeric parameter on which sign is applied\n\n@param `p2` Numeric parameter on which sign is extracted\n\n@param `list1` List of numeric parameter on wich sign is applied\n\n@param `list2` List of numeric parameter on wich sign is extracted\n\n@param `result` Value of p1 with the sign of p2 s a DOUBLE\n\n@param `lresult` List of results\n\n",signature:"COPYSIGN( p1:NUMBER p2:NUMBER ): result:DOUBLE\nCOPYSIGN( p1:NUMBER list2:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nCOPYSIGN( list1:LIST<NUMBER> p2:NUMBER ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"COPYSIGN"},CORRELATE:{description:"The `CORRELATE` function allows you to compute correlation between one base Geo Time Series™ and a set of others. \nBy putting the base GTS in the set of others, cross correlation can be computed.\n\n@param `baseGTS` The base Geo Time Series\n\n@param `gtsList` A list of Geo Time Series against which to compute the correlation\n\n@param `timeOffsets` A list of time offsets for which the correlation will be computed (expressed in time units of the Warp instance)\n\n@param `result` A list of synthetic Geo Time Series™ whose timestamps are the offsets from the initial offset list and the values are the computed correlations. There is one GTS per GTS in the list at TOP-1.\n\n",signature:"CORRELATE( baseGTS:GTS gtsList:LIST timeOffsets:LIST ): result:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"CORRELATE"},COS:{description:"The `COS` function consumes a floating point number from the top of the stack and pushes back its cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Cosine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of cosine of the given values.\n\n",signature:"COS( value:NUMBER ): result:DOUBLE\nCOS( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COS"},COSH:{description:"The `COSH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic cosine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic cosine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic cosine of the given values.\n\n",signature:"COSH( value:NUMBER ): result:DOUBLE\nCOSH( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"COSH"},COUNTER:{description:"The `COUNTER` function pushes a counter (AtomicLong) initialized with the value 0 onto the stack.\n\nThis atomic counter can be safely shared in multiple concurrent macros (see [`CEVAL`](/doc/CEVAL)).\n\n@param `counter` Counter instance.\n\n",signature:"COUNTER(): counter:COUNTER",tags:["counters"],since:"1.0.0",OPB64name:"COUNTER"},COUNTERDELTA:{description:"The `COUNTERDELTA` function increments a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `increment` Counter increment.\n\n",signature:"COUNTERDELTA( counter:COUNTER increment:LONG ): counter:COUNTER",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERDELTA"},COUNTERSET:{description:"The `COUNTERSET` function set the value of a counter and pushes it back onto the stack.\n\n@param `counter` Counter instance.\n\n@param `value` Counter value.\n\n",signature:"COUNTERSET( counter:COUNTER value:LONG ): counter:COUNTER",tags:["counters"],since:"1.2.22",OPB64name:"COUNTERSET"},COUNTERVALUE:{description:"The `COUNTERVALUE` function pushes the counter value onto the stack.\n\n@param `counter` The counter instance.\n\n@param `value` The value of the counter.\n\n",signature:"COUNTERVALUE( counter:COUNTER ): value:LONG",tags:["counters"],since:"1.0.0",OPB64name:"COUNTERVALUE"},COUNTTOMARK:{description:"Counts the number of elements on the stack up to but excluding the first mark encountered. Neither the mark nor the\nelements on top of it are removed from the stack.\n\n@param `result` Stack depth until `MARK`\n\n",signature:"COUNTTOMARK(): result:LONG",tags:["stack"],since:"1.0.0",OPB64name:"COUNTTOMARK"},CPOPR:{description:"Pops a value from the top of the stack and stores it into the designated register if the register is empty (*i.e.* has `NULL` as its current value).\n\nThe `CPOPR` function is really a family of functions named `CPOPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",signature:"CPOPR( value:ANY ): ",tags:["stack"],since:"2.0.0",OPB64name:"CPOPR"},CPROB:{description:"The function `CPROB` generates a new Geo Time Series™ from an input Geo Time Series™ by computing a conditional probability.\n\nThe function expects a **STRING** separator on top of the stack and expects the input Geo Time Series™ to have \nvalues of the form given1< SEP >given2< SEP >....< SEP >event. It will then emit P(event|given1,given2,...).\n\nIf the separator is **NULL**, `CPROB` behaves like [`PROB`](/doc/PROB).\n\n@param `separator` Value separator\n\n@param `gts` Geo Time Series™\n\n@param `lgts` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `lresult` List of Geo Time Series™\n\n",signature:"CPROB( gts:GTS separator:STRING ): result:GTS\nCPROB( lgts:LIST<GTS> separator:STRING ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.6",OPB64name:"CPROB"},CROP:{description:"The `CROP` function works on bucketized Geo Time Series™ instances, if transforms a GTS into another one whose bucketcount, last bucket parameters span the smallest interval with actual values. Bucket span remains the same.\n\nWhen called on a non bucketized GTS instance, `CROP` simply clones it.\n\nThis function expects a list of GTS instances on the top of the stack.\n\n@param `gts` Bucketized GTS\n\n@param `result` ropped version of GTS or a clone thereof if GTS was not bucketized.\n\n@param `gtsList` List of bucketized GTS\n\n@param `resultList` A list of cropped version of GTS or a clone thereof if GTS was not bucketized.\n\n",signature:"CROP( gts:GTS ): result:GTS\nCROP( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["bucketize"],since:"1.0.0",OPB64name:"CROP"},CSTORE:{description:"The `CSTORE` function stores a value in a symbol or a register only if that symbol or register is not yet defined. The name of this function stands for Conditional STORE.\n\n@param `symbol` Name of symbol under which to store `value`.\n\n@param `register` Number of the register under which to store `value`.\n\n@param `value` Value to store unde `symbol`.\n\n",signature:"CSTORE( value:ANY symbol:STRING ): \nCSTORE( value:ANY register:LONG ): ",tags:["stack"],since:"1.0.0",OPB64name:"CSTORE"},CUDF:{description:"The `CUDF` function invokes a User Defined Function from a Jar as [`UDF`](/doc/UDF) but reuses a cached instance of the function.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",signature:"CUDF( class:STRING ): ",tags:["control"],since:"1.0.0",OPB64name:"CUDF"},DEBUGOFF:{description:"Turns off stack debugging which was turned on by [`DEBUGON`](/doc/DEBUGON) or [`NDEBUGON`](/doc/NDEBUGON).\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGOFF"},DEBUGON:{description:"Turns on stack debugging which returns the stack content in case of error. Stack debugging is off by default.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"DEBUGON"},DECREMENTEXACT:{description:"The `DECREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value decremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be decremented by one\n\n@param `result` The decremented value\n\n@param `lvalue` List of values to be decremented by one\n\n@param `lresult` List of decremented values\n\n",signature:"DECREMENTEXACT( value:NUMBER ): result:DOUBLE\nDECREMENTEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.2.23",OPB64name:"DECREMENTEXACT"},DEDUP:{description:"Removes duplicate ticks.\n\nThe `DEDUP` function consumes a Geo Time Series™ or a **LIST** thereof from the top of the stack and pushes back the Geo Time Series™ with deduplicated ticks.\n\nSince the 2.7.0 version, this function can be given an optional mapper or macro to combine the duplicate data points.\n\n@param `gts` The Geo Time Series™ to deduplicate\n\n@param `result` The Geo Time Series™ with deduplicated ticks\n\n@param `lgts` The list of Geo Time Series™ to deduplicate\n\n@param `lresult` The list of Geo Time Series™ with deduplicated ticks\n\n@param `mapper` Mapper used to aggregate duplicate values\n\n@param `macro` Macro used to aggregate duplicate values given as a GTS\n\n",signature:"DEDUP( gts:GTS ): result:GTS\nDEDUP( gts:GTS mapper:AGGREGATOR ): lresult:GTS\nDEDUP( gts:GTS macro:MACRO ): lresult:GTS\nDEDUP( lgts:LIST<GTS> ): lresult:LIST<GTS>\nDEDUP( lgts:LIST<GTS> mapper:AGGREGATOR ): lresult:LIST<GTS>\nDEDUP( lgts:LIST<GTS> macro:MACRO ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"DEDUP"},DEF:{description:"The `DEF` function allows you to define new WarpScript functions or redefine existing ones for the duration of your script execution.\n\nThe function expects on the stack a macro which will be used as the content of the newly defined function, and a name under which to define the new function.\n\nWhen redefining a function, if the function being redefined is used within the macro, the code which will be executed is the current one, \nas the binding of function to code is done at the time when the macro is defined and not when it is executed.\n\nYou may therefore add limits to the use of an existing function by rewrapping it in a macro which will be associated with the original function name.\n\nTo remove redefined functions see [`CLEARDEFS`](/doc/CLEARDEFS).\n\n@param `name` New function name\n\n@param `newDef` Macro which will be used as the content of the newly defined function\n\n",signature:"DEF( newDef:MACRO name:STRING ): ",tags:["stack"],since:"1.0.0",OPB64name:"DEF"},DEFINED:{description:"The `DEFINED` function checks whether or not a symbol is defined.\n\n@param `name` Symbol name\n\n@param `result` Whether or not the symbol is defined\n\n",signature:"DEFINED( name:STRING ): result:BOOLEAN",tags:["logic","control"],since:"1.0.0",OPB64name:"DEFINED"},DEFINEDMACRO:{description:"The `DEFINEDMACRO` function checks if a macro is defined and pushes true or false on the stack accordingly.\n\n@param `name` The macro name\n\n@param `result` True if the macro is defined, false otherwise\n\n",signature:"DEFINEDMACRO( name:STRING ): result:BOOLEAN",tags:["logic","control"],since:"1.0.16",OPB64name:"DEFINEDMACRO"},DEFLATE:{description:"The `DEFLATE` function compresses a STRING or a byte array using the [Zlib](https://en.wikipedia.org/wiki/Zlib) library. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",signature:"DEFLATE( string:STRING ): compressed:BYTES\nDEFLATE( bytes:BYTES ): compressed:BYTES",tags:["conversion"],since:"2.1.0",OPB64name:"DEFLATE"},DELETE:{description:"The `DELETE` function is used to delete a set of GTS from a Warp 10 platform. A delete endpoint must be set on the Warp 10 configuration.\n\nDelete expects 5 parameters on top of the stack: the write token of the Warp 10 application, a string corresponding to a gts selector, a start \nand a end timestamp and finally the number of GTS expected to be deleted.\n\nFor safety reasons `DELETE` will first perform a dryrun call to the /delete endpoint to retrieve the number of GTS which would be deleted by the call. \nIf this number is above the expected number provided by the user the actual delete will not be performed and instead an error will be raised.\n\nDelete will push as a result the number of GTS really deleted.\n\nIf both end_timestamp and start_timestamp are NULL, Warp 10 will perform a delete all. FETCH won't find anything after a delete all.\n\n```flow\n// Write token\n'TOKEN'\n\n// Gts selector\n'gts.to.delete{}'\n\n// Start Timestamp\n1479372838011043\n\n// End timestamp\nNOW\n\n// DELETE expects a count number (if nb GTS > count, DELETE is stopped)\n1\n\nDELETE \n```\n\n@param `count` Number of GTS expected to be deleted\n\n@param `end_timestamp` End timestamp or NULL\n\n@param `start_timestamp` Start timestamp or NULL\n\n@param `gts_selector` GTS selector\n\n@param `writeToken` Write token\n\n@param `result` Actual deleted GTS count\n\n",signature:"DELETE( writeToken:STRING gts_selector:STRING start_timestamp:LONG end_timestamp:LONG count:LONG ): result:LONG",tags:["gts"],since:"1.0.5",OPB64name:"DELETE"},DELETEOFF:{description:"Disables delete operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a delete operation is attempted.\n\n",signature:"DELETEOFF( message:STRING secret:STRING ): ",tags:["platform"],since:"2.0.3",OPB64name:"DELETEOFF"},DELETEON:{description:"Enables delete operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",signature:"DELETEON( secret:STRING ): ",tags:["platform"],since:"2.0.3",OPB64name:"DELETEON"},DEPTH:{description:"The `DEPTH` function pushes on top of the stack the depth (i.e. number of levels) of the stack prior to the call.\n\n@param `result` Stack depth\n\n",signature:"DEPTH(): result:LONG",tags:["stack"],since:"1.0.0",OPB64name:"DEPTH"},DEREF:{description:"Replaces in a Macro the occurrences of symbol dereferencing (`$x`) or calls to `LOAD` with a `STRING` argument or calls to `PUSHRx` by the values associated with either the symbol name or register number in a parameter map.\n\nValues are used verbatim except for Macros which are inserted as functions, *i.e.* they are inserted followed by a call to `EVAL` so they are executed in the target macro instead of ending up on the stack. If you wish to replace a symbol dereference by a Macro, you need to write the macro inside of another Macro.\n\n\n@param `macro` Macro to transform.\n\n@param `values` Map of symbol name or register number to replacement value.\n\n",signature:"DEREF( macro:MACRO values:MAP ): macro:MACRO",tags:["stack"],since:"2.3.0",OPB64name:"DEREF"},DET:{description:"Computes the [determinant](https://en.wikipedia.org/wiki/Determinant) of a matrix.\n\n@param `matrix` The matrix for which to compute the determinant.\n\n@param `det` The computed determinant.\n\n",signature:"DET( matrix:MATRIX ): det:DOUBLE",tags:["math"],since:"1.0.6",OPB64name:"DET"},DIFFERENCE:{description:"Computes the difference between two sets.\n\nThe `DIFFERENCE` function consumes two sets from the top of the stack and pushes back its mathematical difference (ie: the elements in *A* but not in *B*).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* - *B*, the set of elements in *A* but not in *B*\n\n",signature:"DIFFERENCE( setA:SET setB:SET ): output:SET",tags:["sets"],since:"1.0.0",OPB64name:"DIFFERENCE"},DISCORDS:{description:"The `DISCORDS` function detects discords in a Geo Time Series™. The discord detection algorithm is based on identifying outlier patterns in\nthe Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `DISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0\n\n@param `overlapping` Flag indicating whether or not the `DISCORDS` function should report overlapping discords\n\n@param `maximum` The maximum number of discords to identify\n\n@param `lresult` The list of Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `result` The Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n",signature:"DISCORDS( lgts:LIST<GTS> wsize:LONG length:LONG scale:LONG maximum:LONG overlapping:BOOLEAN distance:DOUBLE ): lresult:LIST<GTS>\nDISCORDS( gts:GTS wsize:LONG length:LONG scale:LONG maximum:LONG overlapping:BOOLEAN distance:DOUBLE ): result:GTS",tags:["gts","outlier"],since:"1.0.0",OPB64name:"DISCORDS"},DOC:{description:"Consumes the String on the stack or leave it there and stop the script if the stack is currently in documentation mode ([`DOCMODE`](/doc/DOCMODE)) \n\nYou can use it to document macros.\n\n@param `string` Text to display in [`DOCMODE`](/doc/DOCMODE)\n\n",signature:"DOC( string:STRING ): string:STRING",tags:["help"],since:"1.0.0",OPB64name:"DOC"},DOCMODE:{description:"Toggle the 'documentation mode' of the stack\n\n",signature:"",tags:["help"],since:"1.0.0",OPB64name:"DOCMODE"},"DOUBLEBITS->":{description:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the **LONG** value as the raw bits of the **DOUBLE**\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",signature:"DOUBLEBITS->( input:LONG ): result:DOUBLE",tags:["conversion","binary"],since:"1.2.3",OPB64name:"G3xKFZl4FZ_JJmoy"},DOUBLEEXPONENTIALSMOOTHING:{description:"The `DOUBLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Double Exponential Smoothing aka Holt's linear trend method](https://www.otexts.org/fpp/7/2) formula.\n\nIt consumes three parameters from the top of the stack:\n * A trend smoothing factor beta (a numeric parameter between 0 < beta < 1)\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** and levels are pushed onto the stack (in this order in the **LIST**).\n\n@param `beta` The trend smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The list within the smoothed Geo Time Series™ and its levels\n\n",signature:"DOUBLEEXPONENTIALSMOOTHING( gts:GTS alpha:DOUBLE beta:DOUBLE ): result:LIST<GTS>",tags:["gts","statistics"],since:"1.0.0",OPB64name:"DOUBLEEXPONENTIALSMOOTHING"},DROP:{description:"The `DROP` function removes the element at the top of the stack.\n\n@param `input` object reference to drop from the top of the stack.\n\n",signature:"DROP( input:ANY ): ",tags:["stack"],since:"1.0.0",OPB64name:"DROP"},DROPN:{description:"The `DROPN` function removes the top N elements of the stack after having consumed N which was on the top of the stack prior to calling `DROPN`.\n\n@param `number` The number of elements to drop\n\n",signature:"DROPN( number:NUMBER ): ",tags:["stack"],since:"1.0.0",OPB64name:"DROPN"},DTW:{description:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) or -1 if the threshold was reached.\n\n",signature:"DTW( gts1:GTS gts2:GTS threshold:DOUBLE ): dtw:DOUBLE",tags:["gts","distance"],since:"1.0.0",OPB64name:"DTW"},DUP:{description:"The `DUP` function duplicates the element on the top of the stack, it doesn’t copy the content. If you apply DUP to a GTS you will\nhave two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `input` any parameter on top of the stack\n\n@param `out` a reference copy of input on top of the stack\n\n",signature:"DUP( input:ANY ): input:ANY out:ANY",tags:["stack"],since:"1.0.0",OPB64name:"DUP"},DUPN:{description:"The `DUPN` function duplicates the top N elements of the stack after having consumed N which is on the top of the stack when calling `DUPN`.\n\nAs the [`DUP`](/doc/DUP) function, `DUPN` duplicates the references of the N elements on the top of the stack, it doesn’t copy the elements.\nIf you apply `DUPN` to a GTS you will have two references to the same GTS object on the stack.\n\nIf you want to make a deep copy of a GTS, i.e. if you want copy the content and not only the reference, you can use the [`CLONE`](/doc/CLONE) function.\n\n@param `number` The number of elements to duplicate\n\n",signature:"DUPN( number:NUMBER ): ",tags:["stack"],since:"1.0.0",OPB64name:"DUPN"},DURATION:{description:"The `DURATION` function consumes a **STRING** representing an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) and pushes back a **LONG** duration in platform time unit.\n\nThe ISO 8601 duration can be expessed as `PwWdDThHmMsS` with:\n- `w` weeks\n- `d` days\n- `h` hours\n- `m` minutes\n- `s` or `s.ssssss...` seconds\nEach of these values can be either positive or negative. Each value/unit couple can be omitted if the value is zero but at least one value/couple should be defined.\n\nIf the consumed ISO 8601 duration has precision under platform time unit, superfluous digits will be ignored. Prior to revision 2.4, precision below milliseconds were always ignored, independently of platform time unit.\n\n@param `isoDuration` A representation of a ISO 8601 duration with some limitations, see the description.\n\n@param `duration` Number of platform time unit corresponding to the duration.\n\n",signature:"DURATION( isoDuration:STRING ): duration:LONG",tags:["time"],since:"1.0.0",OPB64name:"DURATION"},DWTSPLIT:{description:"The `DWTSPLIT` function splits a Geo Time Series™ produced by [`FDWT`](/doc/FDWT) into multiple series, one per resolution level of the Wavelet transform.\n\n\n@param `label-name` Label name used in the generated series to indicate the level of each Geo Time Series™\n\n@param `gts` GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `lgts` List of GTS produced by [`FDWT`](/doc/FDWT)\n\n@param `result` Splited GTS\n\n@param `lresult` List of splited GTS\n\n",signature:"DWTSPLIT( gts:GTS label-name:STRING ): result:GTS\nDWTSPLIT( lgts:LIST<GTS> label-name:STRING ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"DWTSPLIT"},E:{description:"Alias of [e](/doc/OF).\n\nThe `E` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",signature:"E(): eValue:DOUBLE",tags:["math","constants"],since:"1.0.0",OPB64name:"GF"},ECGEN:{description:"The `ECGEN` function generates a public/private key pair parameters suitable for performing [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n\nThe resulting parameters can serve as input to [`ECPRIVATE`](/doc/ECPRIVATE) and [`ECPUBLIC`](/doc/ECPUBLIC) to generate the actual private and public keys.\n\nThe following curves are supported:\n\n`c2pnb272w1`, `c2tnb191v3`, `c2pnb208w1`, `c2tnb191v2`, `c2tnb191v1`, `prime192v3`, `c2tnb359v1`, `prime192v2`, `prime192v1`, `c2tnb239v3`, `c2pnb163v3`, `c2tnb239v2`, `c2pnb163v2`, `c2tnb239v1`, `c2pnb163v1`, `c2pnb176w1`, `prime256v1`, `c2pnb304w1`, `c2pnb368w1`, `c2tnb431r1`, `prime239v3`, `prime239v2`, `prime239v1`, `sect233r1`, `secp112r2`, `secp112r1`, `secp256k1`, `sect113r2`, `secp521r1`, `sect113r1`, `sect409r1`, `secp192r1`, `sect193r2`, `sect131r2`, `sect193r1`, `sect131r1`, `secp160k1`, `sect571r1`, `sect283k1`, `secp384r1`, `sect163k1`, `secp256r1`, `secp128r2`, `secp128r1`, `secp224k1`, `sect233k1`, `secp160r2`, `secp160r1`, `sect409k1`, `sect283r1`, `sect163r2`, `sect163r1`, `secp192k1`, `secp224r1`, `sect239k1`, `sect571k1`, `B-163`, `P-521`, `P-256`, `B-233`, `P-224`, `B-409`, `P-384`, `B-283`, `B-571`, `P-192`, `brainpoolp512r1`, `brainpoolp384t1`, `brainpoolp256r1`, `brainpoolp192r1`, `brainpoolp512t1`, `brainpoolp256t1`, `brainpoolp224r1`, `brainpoolp320r1`, `brainpoolp192t1`, `brainpoolp160r1`, `brainpoolp224t1`, `brainpoolp384r1`, `brainpoolp320t1`, `brainpoolp160t1`\n\n@param `curve` Name of the elliptic curve to use.\n\n@param `public` Map containing the public key parameters.\n\n@param `private` Map containing the private key parameters.\n\n",signature:"ECGEN( curve:STRING ): private:MAP public:MAP",tags:["crypto"],since:"2.6.0",OPB64name:"ECGEN"},ECHOOFF:{description:"Turns off the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"ECHOOFF(): ",tags:["stack"],since:"2.0.0",OPB64name:"ECHOOFF"},ECHOON:{description:"Turns on the automatic display of topmost stack levels after each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of topmost stack levels to display after each WarpScript™ line, truncated if floating-point.\n\n",signature:"ECHOON( levels:NUMBER ): ",tags:["stack"],since:"2.0.0",OPB64name:"ECHOON"},ECPRIVATE:{description:"The `ECPRIVATE` function generates a private key from private key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `private` Map containing ECC private key parameters.\n\n@param `key` ECC private key.\n\n",signature:"ECPRIVATE( private:MAP ): key:KEY",tags:["crypto"],since:"2.6.0",OPB64name:"ECPRIVATE"},ECPUBLIC:{description:"The `ECPUBLIC` function generates a public key from public key parameters generated by [`ECGEN`](/doc/ECGEN).\n\n@param `public` Map containing ECC public key parameters.\n\n@param `key` ECC public key.\n\n",signature:"ECPUBLIC( public:MAP ): key:KEY",tags:["crypto"],since:"2.6.0",OPB64name:"ECPUBLIC"},ECSIGN:{description:"The `ECSIGN` function generates a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) private key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Content to sign.\n\n@param `alg` Signing algorithm to use.\n\n@param `private` Private key to use for signining.\n\n@param `signature` Resulting signature.\n\n",signature:"ECSIGN( data:BYTES alg:STRING private:KEY ): signature:BYTES",tags:["crypto"],since:"2.6.0",OPB64name:"ECSIGN"},ECVERIFY:{description:"The `ECVERIFY` function verifies a cryptographic signature using an [Elliptic Curve Cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) public key.\n\nThe supported signature algorithms are those related to ECC by [Bouncy Castle](https://www.bouncycastle.org/):\n\n```\nECDSAWITHSHA1\nSHA1WITHECDSA\nSHA224WITHECDSA\nSHA256WITHECDSA\nSHA384WITHECDSA\nSHA512WITHECDSA\n```\n\n@param `data` Signed data.\n\n@param `alg` Signing algorithm to use.\n\n@param `public` Public key to use for verification.\n\n@param `signature` Signature to verify.\n\n@param `result` Validity of the signature.\n\n",signature:"ECVERIFY( data:BYTES signature:BYTES alg:STRING public:KEY ): result:BOOLEAN",tags:["crypto"],since:"2.6.0",OPB64name:"ECVERIFY"},ELAPSED:{description:"The `ELAPSED` function pushes onto the stack a list containing timing informations. The first element of the list is the timestamp at which \nthe script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution \nof the associated script line.\n\nTiming informations are only collected after a call to [`TIMINGS`](/doc/TIMINGS) (its line included) and before a call to [`NOTIMINGS`](/doc/NOTIMINGS)\n (its line excluded).\n\n@param `result` The first element of the list is the timestamp at which the script was started (in ns). The other elements are the elapsed nanoseconds from the beginning of the script to the end of the execution of the associated script line.\n\n",signature:"ELAPSED(): result:LIST<LONG>",tags:["stack"],since:"1.0.0",OPB64name:"ELAPSED"},ELEVATIONS:{description:"The `ELEVATIONS` function consumes a Geo Time Series™ or a list thereof from the stack, extracts its elevations, puts them in a list and pushes the list onto the stack.      \n\n@param `gts` The Geo Time Series™ from which to extract the elevations\n\n@param `lgts` The list of Geo Time Series™ from which to extract the elevations\n\n@param `elevations` The elevations of the given Geo Time Series™\n\n@param `lelevations` The list of elevations of the given Geo Time Series™\n\n",signature:"ELEVATIONS( gts:GTS ): elevations:LIST<LONG>\nELEVATIONS( lgts:LIST<GTS> ): lelevations:LIST<LIST<LONG>>",tags:["gts","geo"],since:"1.0.0",OPB64name:"ELEVATIONS"},EMPTY:{description:"Reject GTS instances with values.\n\n@param `gtsList` List of GTS\n\n@param `result` List of GTS with empty values\n\n",signature:"EMPTY( gtsList:LIST<GTS> ): result:LIST<GTS>",tags:["gts"],since:"1.2.5",OPB64name:"EMPTY"},"ENCODER->":{description:"The `ENCODER->` functions convert an encoder into a list of ( timestamp, latitude, longitude, elevation, value ) list. It also pushes attributes, labels and name on the stack.\nFunction also accepts wrapped or raw-wrapped encoders or gts.\n\nAn encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored. An encoder can also have a name, labels and attributes.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` Encoder input.\n\n@param `wrappedinput` Encoder or GTS after WRAP. \n\n@param `rawwrappedinput` Encoder or GTS after WRAPRAW.\n\n@param `output` List of list of ( timestamp, latitude, longitude, elevation, value ). Missing values in the encoder or GTS are replaced by NaN.\n\n@param `name` Name of encoder or GTS. If no name was defined, will be NULL.\n\n@param `attributes` Attributes of encoder or GTS input. If none defined, will be an empty map.\n\n@param `labels` Labels of encoder or GTS input. If none defined, will be an empty map.\n\n",signature:"ENCODER->( encoder:GTSENCODER ): name:STRING attributes:MAP labels:MAP output:LIST\nENCODER->( wrappedinput:STRING ): name:STRING attributes:MAP labels:MAP output:LIST\nENCODER->( rawwrappedinput:BYTES ): name:STRING attributes:MAP labels:MAP output:LIST",tags:["encoder","conversion","gts"],since:"1.2.9",OPB64name:"GJt2IoG4JXoy"},ERROR:{description:"Pushes onto the stack a list containing the current error (as caught by a [`TRY`](/doc/TRY)) and its causes. Each error is a map with the following fields:\n\n| Field | Description |\n| --- | --- |\n| type | Type of the error, the Java class of the underlying exception |\n| message | The message associated with the error |\n| stacktrace | A list of lists, each containing `filename`, `line number`, `class name`, `method name` |      \n\nThe current error is the first element of the list.\n\nIf there is no current error, the returned list will be empty.\n\n@param `error` List of maps describing the current error and its causes.\n\n",signature:"ERROR(): error:LIST<MAP>",tags:["stack"],since:"1.2.11",OPB64name:"ERROR"},ESDTEST:{description:"The `ESDTEST` function detects outliers in a GTS (or a **LIST** of GTS), by applying a [generalized extreme studentized deviate test](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h3.htm).\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nA [Grubbs’](/doc/GRUBBSTEST)test is done for one candidate at a time. Then, the candidate is removed from the set and another [Grubbs’](/doc/GRUBBSTEST)test\nis performed. This process is iterated a given number of times. The detected outliers are the removed values and the current candidate of the last successful\ntest.\n\nA **LIST** of ticks (or a **LIST** of **LIST** of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",signature:"ESDTEST( gts:GTS k:LONG mad:BOOLEAN alpha:DOUBLE ): result:LIST<LONG>\nESDTEST( gts:GTS k:LONG mad:BOOLEAN ): result:LIST<LONG>\nESDTEST( gtsList:LIST<GTS> k:LONG mad:BOOLEAN alpha:DOUBLE ): resultList:LIST<LIST<LONG>>\nESDTEST( gtsList:LIST<GTS> k:LONG mad:BOOLEAN ): resultList:LIST<LIST<LONG>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ESDTEST"},EVAL:{description:"The `EVAL` function evaluates the statements contained in the string at the top of the stack as if they had been entered individually or runs the macro at the top os the stack.\n\n@param `string` String to evaluate\n\n@param `macro` Macro to run\n\n",signature:"EVAL( macro:MACRO ): \nEVAL( string:STRING ): ",tags:["control"],since:"1.0.0",OPB64name:"EVAL"},EVALSECURE:{description:"The `EVALSECURE` function executes a secure script. The script must have been created on a platform with the same secure script cryptographic key as the current platform (note that this is not the *secret* set using [`SECUREKEY`](doc/SECUREKEY)).\n\n@param `secure` String containing the secure script to execute.\n\n@param `return` The return values depend on the actual code of the secure script.\n\n",signature:"EVALSECURE( secure:STRING ): return:ANY",tags:["crypto","stack"],since:"1.0.0",OPB64name:"EVALSECURE"},EVERY:{description:"When called via the `/mobius` endpoint, the `EVERY` function sets the repeat interval for the preceding macro.\n\nWhen called outside of `/mobius`, the `EVERY` function simply executes the macro.\n\n@param `repeat` The repeat interval to enforce, in milliseconds.\n\n@param `macro` The macro to execute.\n\n",signature:"EVERY( macro:MACRO repeat:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"EVERY"},EXP:{description:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a floating point value x consumed from the top of the stack,\n i.e. e<sup>x</sup>.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List where each value is e<sup>x</sup>\n\n",signature:"EXP( value:NUMBER ): result:DOUBLE\nEXP( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"EXP"},EXPM1:{description:"The `EXP` function pushed on the stack the Euler’s number [`e`](/doc/OF) raised to the power of a DOUBLE value x consumed from the top of the stack then subtracts one, i.e. e<sup>x</sup>-1.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Power to raise e to\n\n@param `result` e<sup>x</sup>-1\n\n@param `lvalue` List of power to raise e to\n\n@param `lresult` List of e<sup>x</sup>-1\n\n",signature:"EXPM1( value:NUMBER ): result:DOUBLE\nEXPM1( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"EXPM1"},EXPORT:{description:"The `EXPORT` function allows you to set or update a list of symbols which will be dumped upon script termination. This proves handy when \ndebugging a script as you can visualize, even in the case of errors, the value of specific symbols.\n\nThe function expects either a symbol name (a **STRING**) which will be added to the current list of exported symbols, a list of symbol \nname which will replace the current list of exported symbols, an empty list to disable symbol export altogether, or a list with a single\n**NULL** element to instruct the WarpScript engine to export all existing symbols.\n\nWhen symbols should be exported, the debug mode is implied (see [`DEBUGON`](/doc/DEBUGON)).\n\n@param `symbol` Symbol name\n\n@param `symbols` List of symbols\n\n",signature:"EXPORT( symbol:STRING ): \nEXPORT( symbols:LIST ): ",tags:["stack","debug"],since:"1.0.2",OPB64name:"EXPORT"},EXTLOADED:{description:"Checks if a WarpScript extension is loaded or not and therefore available.      \n\n@param `ext` Name of extension to check.\n\n@param `loaded` Boolean indicating whether or not the specified extension is loaded in the WarpScript environment.\n\n",signature:"EXTLOADED( ext:STRING ): loaded:BOOLEAN",tags:["stack"],since:"1.2.13",OPB64name:"EXTLOADED"},F:{description:"`F` stand for `false`. It is a boolean constant.\n\n\n@param `b` false\n\n",signature:"F(): b:BOOLEAN",tags:["logic","constants"],since:"1.0.0",OPB64name:"F"},FAIL:{description:"The `FAIL` function stops the execution of the WarpScript scripts by throwing an exception.\n\n",signature:"",tags:["control"],since:"1.0.0",OPB64name:"FAIL"},FDWT:{description:"The `FDWT` function performs a [Forward Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Fast_wavelet_transform#Forward_DWT) on a Geo Time Series™.\n\nA number of different [Wavelets](https://en.wikipedia.org/wiki/Wavelet) are available, the list is inspired by that available on \nthe [Wavelet Browser](http://wavelets.pybytes.com/).\n\nThe list of Wavelets which can be used is the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\nThe FDWT can only be applied to Geo Time Series™ with a number of values which is a power of 2.\n\nAssuming the input GTS has 2<sup>n</sup> values, the result of the FDWT transformation is a GTS with 2<sup>n</sup> values (the wavelet coefficients) with timestamps from 0 to 2<sup>n</sup>-1.\n\nThe ticks of the `n` levels are contiguous, with the first tick being for level `n`, the next 2 for level `n-1`, the next 4 for level `n-2`, up to the last 2<sup>n-1</sup> for level 1.\n\nLevel 1 has the finest time resolution but the coarsest frequency resolution. Each level has half (coarser) the time resolution and double (finer) the frequency resolution as the previous level.\n\n@param `wavelet` Name of wavelet to use for the transformation.\n\n@param `gts` Geo Time Series™ instance on which to perform the FDWT.\n\n@param `lgts` List of Geo Time Series™ on which to apply the FDWT.\n\n@param `fdwt` Transformed Geo Time Series™.\n\n@param `lfdwt` List of transformed Geo Time Series™.\n\n",signature:"FDWT( gts:GTS wavelet:STRING ): fdwt:GTS\nFDWT( lgts:LIST<GTS> wavelet:STRING ): lfdwt:LIST<GTS>",tags:["math","gts"],since:"1.0.0",OPB64name:"FDWT"},FETCH:{description:"The `FETCH` function interacts with the Warp 10 Storage Engine to retrieve data according to given criteria.\n\n`FETCH` either accepts a list of 5 parameters or a map with the parameters. Those are defining the **read access rights**, the **concerned Geo Time Series** and the **time window**. Other parameters in the map input are optional. \n\nThe list input is here to keep backward compatibility with old WarpScripts. The map input allows a great flexibility, as described below.\n\n### Access rights\nA valid read token is needed to read data with fetch. If you use a [metaset](/doc/METASET) and also specify a token, the token included in the metaset will be ignored.\n\n### Concerned Geo Time Series\n`FETCH` selects Geo Time Series according to:\n+ The `selectors` parameter, which is a list of selector.\n+ If `selectors` is not found, `FETCH` uses the `selector` parameter which is a single selector.\n+ If `selector` is not found, `FETCH`  uses both `class` and `labels` parameters.  \n\n### Time window\n`FETCH`  begins from the newest value and stop when the oldest value is collected. Thus, `end` must be defined in your request and defines the newest included value in your time window. If `end` is anterior to your oldest value, the result will be empty (no Geo Time Series). The span of the time window ending at `end` is then defined according to:\n+ The `timespan` parameter.\n+ If `timespan` is not defined, `FETCH` collects a maximum of `count` point.\n+ If `count` is not defined, `FETCH` determines `timespan` with `start`. If `start` is more recent than `end`, `end` and `start` are permuted internally. Be careful, this means `end` is included but  **`start` is excluded from the time window**.\n\n### Boundaries\nSince version 2.3.0, you can define *boundaries* around the requested data. When fetching data based on a time range, both a *pre* and *post* boundaries can be specified. When fetching by count, only a *pre* boundary can be requested.\nBoundaries are a number of datapoints which are either before (*pre* boundary) or after (*post* boundary) the fetched data. Fetching boundaries is very useful when storing only the changes of values as they enable you to always fetch datapoints even if the requested time range does not contain any. They can also be used to fetch the first `N` datapoints after a given timestamp.\nNote that fetching *post* boundaries is less efficient than fetching the requested range or a *pre* boundary as the data has to be scanned in reverse order which has an impact on I/Os and ultimately on performance.\n\n### Sampling options\n+ Since version 2.3.0, you can randomly sample points with the `sample` parameter. If `sample` equals 0.1, `FETCH` will randomly return one point out of ten. This implementation is the fastest way to resample data.\n+ Since version 2.3.0, you can `skip` the N newest datapoints in the time window specified.\n\n### Query without looking into directory\nThe fetch time to read one gts among millions of gts recorded with the same classname, the same application and the same owner can take time. Use the `gts` parameter to select if you exactly know the classname and all the labels.\n\nIf you want to read only Geo Time Series attributes or labels, using [FIND](/doc/FIND) is more efficient than fetching the last value.\n\n@param `token` Read token to use to fetch the data.\n\n@param `class` Selector for the GTS classes. Can either be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `labels` Map of labels selectors. The key is the label name, the value a selector which can be an exact match or a regular expression (the value should then start with a *~*).\n\n@param `start` Oldest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `end` Newest timestamp to consider when fetching datapoints. In platform time unit or [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n@param `data` List of fetched Geo Time Series™.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n@param `metaset` A set of Geo Time Series™ produced by the [`METASET`](/doc/METASET) function.\n\n@param `type` Name of type to force for the GTS, either LONG, DOUBLE, BOOLEAN or STRING.\n\n@param `typeattr` Name of label to use for storing the GTS type. This option is incompatible with 'type', when set values of different types are ventilated in separate GTS with the same set of class and labels and an additional *type* label of the given name.\n\n@param `timespan` Depth to consider when fetching the datapoints. If the value is positive then it is interpreted as a duration in time units, if it is negative then as the maximum number of datapoints to fetch. If negative, incompatible with 'count'.\n\n@param `count` Maximum number of datapoints to fetch for each GTS. Incompatible with negative 'timespan'.\n\n@param `extra` List of extraneous classes to fetch. For each GTS matching the selection criteria, GTS with those extra class names will be fetched too (with the *exact* same set of labels).\n\n@param `active.after` Timestamp after which a GTS must have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `quiet.after` Timestamp after which a GTS must not have been updated to be considered for the fetch. This parameter is only considered when activity tracking is enabled.\n\n@param `gts` Explicit list of Geo Time Series™ to fetch. The class and labels will be used as is and not serve as selectors.\n\n@param `boundary` Number of datapoints to include in both *pre* and *post* boundaries.\n\n@param `boundary.pre` Number of datapoints in the *pre* boundary.\n\n@param `boundary.post` Number of datapoints in the *post* boundary.\n\n@param `sampling.ratio` A probability between 0 (excluded, no datapoints returned) and 1.0 (all datapoints returned). The random sampling is done by the storage layer, which is the most efficient.\n\n@param `skip.count` Set fetch to ignore the N newest points in the time window you specified.\n\n",signature:"FETCH( [ token:STRING class:STRING labels:MAP end:LONG timespan:LONG ] ): data:LIST<GTS>\nFETCH( [ token:STRING class:STRING labels:MAP start:STRING end:STRING ] ): data:LIST<GTS>\nFETCH( { token:STRING class:STRING labels:MAP end:LONG start:STRING timespan:LONG count:LONG selector:STRING selectors:LIST<STRING> metaset:STRING type:STRING typeattr:STRING extra:LIST<STRING> active.after:LONG quiet.after:LONG gts:LIST<GTS> boundary.post:LONG boundary.pre:LONG boundary:LONG skip.count:LONG sampling.ratio:DOUBLE  } ): data:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FETCH"},FETCHBOOLEAN:{description:"The `FETCHBOOLEAN` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type BOOLEAN.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"FETCHBOOLEAN( linput:LIST ): data:LIST<GTS>\nFETCHBOOLEAN( minput:MAP ): data:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHBOOLEAN"},FETCHDOUBLE:{description:"The `FETCHDOUBLE` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type DOUBLE.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"FETCHDOUBLE( linput:LIST ): data:LIST<GTS>\nFETCHDOUBLE( minput:MAP ): data:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHDOUBLE"},FETCHLONG:{description:"The `FETCHLONG` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type LONG.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"FETCHLONG( linput:LIST ): data:LIST<GTS>\nFETCHLONG( minput:MAP ): data:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHLONG"},FETCHSTRING:{description:"The `FETCHSTRING` function behaves just like [`FETCH`](doc/FETCH) but forces the resulting Geo Time Series™ to be of type STRING.\n\nPlease read the [`FETCH`](doc/FETCH) documentation for the detailed usage.\n\n@param `linput` List of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `minput` Map of parameters, see [`FETCH`](doc/FETCH) documentation\n\n@param `data` List of fetched Geo Time Series™.\n\n",signature:"FETCHSTRING( linput:LIST ): data:LIST<GTS>\nFETCHSTRING( minput:MAP ): data:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FETCHSTRING"},FFT:{description:"The `FFT` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFT` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe real parts of the `FFT` coefficients, the second the imaginary parts. The scale factor is equal to X/(n * bucketspan) where n is the number\nof elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the number\nof values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFT` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the real parts of the `FFT` coefficients, the second the imaginary parts.\n\n",signature:"FFT( gts:GTS ): result:LIST<GTS>\nFFT( gtsList:LIST<GTS> ): result:LIST<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FFT"},FFTAP:{description:"The `FFTAP` function computes a [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) on a Geo Time Series™ or a list\nthereof it expects on top of the stack.\n\nThe result of the `FFTAP` execution is a list of two Geo Time Series™ and a frequency scale factor per input GTS. The first resulting GTS contains\nthe amplitude of the coefficient at that frequency and the second the associated phase. The scale factor is equal to X/(n * bucketspan) where n is\nthe number of elements in the origin GTS and X is the number of time units per second. The ticks of those Geo Time Series™ are indices from 0 to the\nnumber of values in the original series minus one. The frequency associated with each tick is tick * factor, with the exception of tick 0 which is n * factor.\n\n`FFTAP` can only be applied to [bucketized](/doc/BUCKETIZE) numerical Geo Time Series™ which contains a number of values which is a power of 2.\n\n@param `gts` Bucketized numerical GTS\n\n@param `gtsList` List of bucketized numerical GTS\n\n@param `result` List of GTS: The first resulting GTS contains the amplitude of the coefficient at that frequency and the second the associated phase.\n\n",signature:"FFTAP( gts:GTS ): result:LIST<GTS>\nFFTAP( gtsList:LIST<GTS> ): result:LIST<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"FFTAP"},FFTWINDOW:{description:"The `FFTWINDOW` transforms Geo Time Series™ by applying a [window function](https://en.wikipedia.org/wiki/Window_function) to its values. The function supports the following windows:\n\n| Name | Window |\n| --- | --- |\n| `triangular` | [Triangular](https://en.wikipedia.org/wiki/Window_function#Triangular_window) |\n| `parzen` | [Parzen](https://en.wikipedia.org/wiki/Window_function#Parzen_window) |\n| `welch` | [Welch](https://en.wikipedia.org/wiki/Window_function#Welch_window) |\n| `sine` | [Sine](https://en.wikipedia.org/wiki/Window_function#Sine_window) |\n| `hann` | [Hann](https://en.wikipedia.org/wiki/Window_function#Hann_window) |\n| `hamming` | [Hamming](https://en.wikipedia.org/wiki/Window_function#Hamming_window) |\n| `blackman` | [Blackman](https://en.wikipedia.org/wiki/Window_function#Blackman_window) |\n| `nuttall` | [Nuttall](https://en.wikipedia.org/wiki/Window_function#Nuttall_window,_continuous_first_derivative) | \n| `blackman-nuttall` | [Blackman-Nuttall](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Nuttall_window) |\n| `blackman-harris` | [Blackman-Harris](https://en.wikipedia.org/wiki/Window_function#Blackman%E2%80%93Harris_window) |\n| `flattop` | [Flat top](https://en.wikipedia.org/wiki/Window_function#Flat_top_window) |\n| `rectangular` | [Rectangular](https://en.wikipedia.org/wiki/Window_function#Rectangular_window) |\n\n@param `window` Name of the window function to apply.\n\n@param `gts` Single Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `windowed` Tranformed Geo Time Series™.\n\n@param `lwindowed` List of transformed Geo Time Series™.\n\n",signature:"FFTWINDOW( gts:GTS window:STRING ): windowed:GTS\nFFTWINDOW( lgts:LIST<GTS> window:STRING ): lwindowed:LIST<GTS>",tags:["gts"],since:"1.2.13",OPB64name:"FFTWINDOW"},FILL:{description:"The `FILL` function fills missing values in two Geo Time Series™ so they end up with identical ticks.\n\nThe filling is done using a *filler* function which applies a given strategy. Filler functions can be created using macros via the [`MACROFILLER`](/doc/MACROFILLER) function.\n\n@param `gtsa` First Geo Time Series™ to fill.\n\n@param `gtsb` Second Geo Time Series™ to fill.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:"FILL( gtsa:GTS gtsb:GTS filler:FILLER ): gtsa:GTS gtsb:GTS",tags:["filler"],since:"2.0.0",OPB64name:"FILL"},FILLNEXT:{description:"The `FILLNEXT` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation of the \nnext non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",signature:"FILLNEXT( gts:GTS ): result:GTS\nFILLNEXT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLNEXT"},FILLPREVIOUS:{description:"The `FILLPREVIOUS` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance by re-using the value/location/elevation \nof the previous non empty bucket to fill each empty bucket. It expects a GTS or a list thereof on the top of the stack.\n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n",signature:"FILLPREVIOUS( gts:GTS ): result:GTS\nFILLPREVIOUS( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLPREVIOUS"},FILLTICKS:{description:"The `FILLTICKS` function add values to a Geo Time Series™ instance or a list thereof for ticks in the given **LIST**.\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` Filled GTS\n\n@param `resultList` List of filled GTS\n\n@param `data` List of (latitude, longitude, elevation, ticks) where ticks is a list of ticks.\n\n",signature:"FILLTICKS( gts:GTS data:LIST ): result:GTS\nFILLTICKS( gtsList:LIST<GTS> data:LIST ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FILLTICKS"},FILLVALUE:{description:"The `FILLVALUE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with a fixed value/location/elevation.\n\nIt expects a GTS or a list thereof on the top of the stack after having consumed a list of parameters (latitude, longitude, elevation, value)\nsitting on top of the stack prior to the call.\n\nLocation must be floating point numbers (e.g. 0.0 not 0). Elevation must be an integer. If no location or elevation should be set, **NaN** can\nbe used instead of specific value.\n\nThis function has no effect on non bucketized GTS instances.\n\n\n\nThe value is cast to the type of the GTS value\n\n@param `gts` The Geo Time Series™ to fill\n\n@param `gtsList` The list of Geo Time Series™ to fill\n\n@param `result` The filled Geo Time Series™\n\n@param `resultList` The list of filled Geo Time Series™\n\n@param `data` The list of parameters (latitude, longitude, elevation, value)\n\n",signature:"FILLVALUE( gts:GTS data:LIST ): result:GTS\nFILLVALUE( gtsList:LIST<GTS> data:LIST ): resultList:LIST<GTS>",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"FILLVALUE"},FILTER:{description:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `FILTER` framework allows for advanced filtering using N-ary functions\n(functions which accept N parameters).\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A single list containing only the selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `FILTER`.\n\n",signature:"FILTER( [ gtsList:LIST<GTS> labels:LIST<STRING> filter:FILTER ] ): result:LIST<GTS>",tags:["framework","filter"],since:"1.0.0",OPB64name:"FILTER"},FILTERBY:{description:"The `FILTERBY` function selects elements of a list based on the boolean return value of a macro evaluated for each element.\n\n@param `macro` Macro used for filtering. This macro should consume the element of the list pushed on top of the stack and leave a boolean on the stack. If this boolean is `true`, the element will be retained.\n\n@param `list` List of elements to filter.\n\n@param `sublist` List with the selected elements from `list`.\n\n",signature:"FILTERBY( list:LIST macro:MACRO ): sublist:LIST",tags:["lists"],since:"1.2.22",OPB64name:"FILTERBY"},FIND:{description:"The `FIND` function finds Geo Time Series™ labels and attributes of GTS, not their values. It is the fastest way to read attributes of GTS. `FIND` ask only `directory` component of Warp&nbsp;10™, while [FETCH](/doc/FETCH) first ask `directory`, then ask `store` to read GTS values. \n\nSyntax is close to [FETCH](/doc/FETCH), without time boundaries or data point count.\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `data` List of fetched Geo Time Series™. These GTS does not contain any value.\n\n@param `uuidattribute` Setting this to true add `.uuid` attribute in the output data. This UUID is a hash of class and label.\n\n@param `selector` A Geo Time Series™ selector with the syntax `class{labels}` where `class` is an exact match or a regular expression starting with *~* and `labels` a comma separated list of labels selector of the form `name=exact` or `name~regexp`. Names and values must be percent URL encoded if needed.\n\n@param `selectors` A list of GTS selectors, each with a syntax identical to that of 'selector'.\n\n",signature:"FIND( [ token:STRING classSelector:STRING labelsSelector:MAP ] ): data:LIST<GTS>\nFIND( [ uuidattribute:BOOLEAN token:STRING classSelector:STRING labelsSelector:MAP ] ): data:LIST<GTS>\nFIND( { token:STRING classSelector:STRING labelsSelector:MAP  } ): data:LIST<GTS>\nFIND( { token:STRING selector:STRING  } ): data:LIST<GTS>\nFIND( { token:STRING selectors:LIST<STRING>  } ): data:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"FIND"},FINDSETS:{description:"The `FINDSETS` function returns sets of values for the classes, labels and attributes of the Geo Time Series™ which matched the selection criteria.\n\nThose results can be used for example to update a UI with lists of possible values for labels when exploring a corpus of GTS.\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label names to exact match or regular expression (if the value starts with a *~*) for matching labels and attributes.\n\n@param `attributes` Map of attribute names to value list.\n\n@param `labels` Map of label names to value list.\n\n@param `classes` List of class names.\n\n",signature:"FINDSETS( [ token:STRING classSelector:STRING labelsSelector:MAP ] ): classes:LIST<STRING> labels:MAP attributes:MAP",tags:["gts"],since:"1.0.0",OPB64name:"FINDSETS"},FINDSTATS:{description:"The `FINDSTATS` function computes statistics on matching Geo Time Series™. The estimations are based on the use of [HyperLogLogPlus](https://en.wikipedia.org/wiki/HyperLogLog) estimators.\n\nThe function returns a map containing information about the matching Geo Time Series. The fields of the map are the following:\n\n| Key | Value |\n|-----|-------|\n| `gts.estimate` | Estimation of the number of matching Geo Time Series™ |\n| `classes.estimate` | Estimation of the number of distinct class names |\n| `labelnames.estimate` | Estimation of the number of distinct label names |\n| `labelvalues.estimate` | Estimation of the number of distinct label values |\n| `per.class.estimate` | If the number of matching classes is below the `directory.stats.class.maxcardinality`, this key will be associated with a map containing per class estimate of number of GTS |\n| `per.label.value.estimate` | If the number of label names in the matching GTS is below `directory.stats.labels.maxcardinality`, this key will be associated with a map containing an estimation of distinct label values per label name |\n| `error.rate` | This is the error rate of the estimators used for computing the estimations |\n| `partial.results` | When accessing a sharded Directory, this will be set to `true` if only partial results were collected |\n\n\n@param `token` Read token to use for finding Geo Time Series™.\n\n@param `classSelector` Exact match or regular expression (if the value starts with a *~*) for matching classes.\n\n@param `labelsSelector` Map of label name to exact match or regular expression (if the value strts with a *~*) for matching labels and attributes.\n\n@param `result` Map containing stats such as error rate or whether estimates on classes, gts, or labels.\n\n",signature:"FINDSTATS( [ token:STRING classSelector:STRING labelsSelector:MAP ] ): result:MAP",tags:["gts"],since:"1.0.0",OPB64name:"FINDSTATS"},FIRSTTICK:{description:"The `FIRSTTICK` function pushes on the stack the timestamp of the first tick of the Geo Time Series™ on top of the stack.\n\nWhen applied to a list of GTS, `FIRSTTICK` will return the lowest first tick found across all Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™\n\n@param `gts` Geo Time Series™\n\n@param `result` Timestamp. If the GTS does not have values, **Long.MAX_VALUE** is pushed.\n\n",signature:"FIRSTTICK( gts:GTS ): result:LONG\nFIRSTTICK( lgts:LIST<GTS> ): result:LONG",tags:["gts"],since:"1.0.0",OPB64name:"FIRSTTICK"},FLATTEN:{description:"The function `FLATTEN` inspects the top of the stack.\n\nIf it is a LIST of values,\nit inspects each value and replaces each value which was a LIST with its content.\n`FLATTEN` proceed recursively until all LISTs have been flattened.\n\nIf it is not a LIST, the function exits and let the stack in the same state.\n\n@param `input` Input is a list who may contains lists\n\n@param `notAList` An object which is not a list\n\n@param `output` Output list do not contains anymore nested lists\n\n",signature:"FLATTEN( input:LIST ): output:LIST\nFLATTEN( notAList:ANY ): notAList:ANY",tags:["lists"],since:"1.0.0",OPB64name:"FLATTEN"},"FLOATBITS->":{description:"Converts the **LONG** on top of the stack to a **DOUBLE** by considering the 32 lower bits of the **LONG** value as the raw bits of a **FLOAT**.\n\n@param `input` Value to convert\n\n@param `result` Converted value\n\n",signature:"FLOATBITS->( input:LONG ): result:DOUBLE",tags:["conversion","binary"],since:"1.2.3",OPB64name:"GZlEFKG1HKGIAIs"},FLOOR:{description:"The `FLOOR` function consumes a numeric parameter from the top of the stack and pushes back the nearest long number smaller than the parameter.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Rounded-down value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of rounded-down values, for each given value.\n\n",signature:"FLOOR( value:NUMBER ): result:DOUBLE\nFLOOR( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"FLOOR"},FLOORDIV:{description:"The `FLOORDIV` function consumes two NUMBER values, convert them to LONGs and pushes back largest LONG value that is less than or equal to the algebraic quotient.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fDiv` The largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfDiv` List of largest (closest to positive infinity) int value that is less than or equal to the algebraic quotient\n\n",signature:"FLOORDIV( dividend:NUMBER divisor:NUMBER ): fDiv:LONG\nFLOORDIV( dividend:NUMBER ldivisor:LIST<NUMBER> ): lfDiv:LIST<LONG>\nFLOORDIV( ldividend:LIST<NUMBER> divisor:NUMBER ): lfDiv:LIST<LONG>",tags:["math"],since:"1.2.23",OPB64name:"FLOORDIV"},FLOORMOD:{description:"The `FLOORMOD` function consumes two NUMBER values, convert them to LONGs and pushes back the floor modulus which is x - (floorDiv(x, y) * y).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` The dividend\n\n@param `divisor` The divisor\n\n@param `fMod` The floor modulus x - (floorDiv(x, y) * y)\n\n@param `ldividend` List of dividends\n\n@param `ldivisor` List of divisors\n\n@param `lfMod` List of floor modulus x - (floorDiv(x, y) * y)\n\n",signature:"FLOORMOD( dividend:NUMBER divisor:NUMBER ): fMod:LONG\nFLOORMOD( dividend:NUMBER ldivisor:LIST<NUMBER> ): lfMod:LIST<LONG>\nFLOORMOD( ldividend:LIST<NUMBER> divisor:NUMBER ): lfMod:LIST<LONG>",tags:["math"],since:"1.2.23",OPB64name:"FLOORMOD"},FOR:{description:"The `FOR` function implements a for loop. It takes three arguments from the stack: the initial and the final values of the loop index and a macro to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",signature:"FOR( initial:NUMBER final:NUMBER macro:MACRO ): \nFOR( initial:NUMBER final:NUMBER macro:MACRO index:BOOLEAN ): ",tags:["control"],since:"1.0.0",OPB64name:"FOR"},FOREACH:{description:"The `FOREACH` function implements a for loop on a list or map.\n\nFor each iteration i on a list, the i-th element on the list is put on top of the stack, and the exec macro is then called.\n\nFor each iteration i on a map, the exec macro is called with the i-th value on top of the stack, and the i-th key just below on the stack.\nYou can start your macro with `'value' STORE 'key' STORE`.\n\nSince release 2.1, `FOREACH` has the ability to iterate over Geo Time Series™ and GTS Encoders. When iterating over a GTS or Encoder, the macro is fed with a list of the form `[ tick lat lon elev value ]` where `lat`, `lon` and `elev` may be `NaN` if unset. In the case of an Encoder, `value` can be a byte array or a `BigDecimal` on top of `LONG`, `DOUBLE`, `STRING` or `BOOLEAN`.\n\nSince release 2.4.0, you can force FOREACH to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `exec` Macro to apply\n\n@param `list` List to iterate on\n\n@param `map` Map to iterate on\n\n@param `set` Set to iterate on\n\n@param `vector` Vector to iterate on\n\n@param `gts` GTS to iterate on\n\n@param `string` String to iterate on\n\n@param `encoder` GTSEncoder to iterate on\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",signature:"FOREACH( list:LIST exec:MACRO ): \nFOREACH( map:MAP exec:MACRO ): \nFOREACH( set:SET exec:MACRO ): \nFOREACH( vector:VLIST exec:MACRO ): \nFOREACH( string:STRING exec:MACRO ): \nFOREACH( gts:GTS exec:MACRO ): \nFOREACH( encoder:GTSENCODER exec:MACRO ): \nFOREACH( list:LIST exec:MACRO index:BOOLEAN ): \nFOREACH( map:MAP exec:MACRO index:BOOLEAN ): \nFOREACH( set:SET exec:MACRO index:BOOLEAN ): \nFOREACH( vector:VLIST exec:MACRO index:BOOLEAN ): \nFOREACH( string:STRING exec:MACRO index:BOOLEAN ): \nFOREACH( gts:GTS exec:MACRO index:BOOLEAN ): \nFOREACH( encoder:GTSENCODER exec:MACRO index:BOOLEAN ): ",tags:["control"],since:"1.0.0",OPB64name:"FOREACH"},FORGET:{description:"Removes a symbol from the symbol table.      \n\n@param `symbol` Name of the symbol to remove.\n\n",signature:"FORGET( symbol:STRING ): ",tags:["stack"],since:"1.0.0",OPB64name:"FORGET"},FORSTEP:{description:"The `FORSTEP` function implements for loop with an index step. It takes four arguments from the stack: the initial and the final values of the loop index,\na macro step to evaluate after each iteration and an other one to be executed at each iteration.\n\nFor each iteration the loop index is put on top of the stack, and the exec macro is then called. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` Macro to repeat, the index of the loop is placed on the TOP of the stack\n\n@param `step` Macro step to evaluate after each iteration, typically to compute index\n\n@param `final` Final value\n\n@param `initial` Initial value\n\n@param `index` When set to true, the current index will be on the top of the stack. By default, true.\n\n",signature:"FORSTEP( initial:NUMBER final:NUMBER step:MACRO macro:MACRO ): \nFORSTEP( initial:NUMBER final:NUMBER step:MACRO macro:MACRO index:BOOLEAN ): ",tags:["control"],since:"1.0.0",OPB64name:"FORSTEP"},FROMBIN:{description:"Converts the binary representation on top of the stack into the corresponding long.\n\n@param `input` Binary representation of a signed long, 64 characters max.\n\n@param `output` Signed long of input.\n\n",signature:"FROMBIN( input:STRING ): output:LONG",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBIN"},FROMBITS:{description:"**This function is deprecated. Replace it in your code by the [`DOUBLEBITS->`](/doc/G3xKFZl4FZ_JJmoy) function.**\n\nConverts the **LONG** on top of the stack into a **DOUBLE** by considering it a raw bit representation.\n\n@param `input` Raw bit representation to convert\n\n@param `result` Converted value\n\n",signature:"FROMBITS( input:LONG ): result:DOUBLE",tags:["conversion","binary"],since:"1.0.0",OPB64name:"FROMBITS"},FROMHEX:{description:"Converts an hexadecimal representation into a signed long. 64bits max.\n\n@param `input` Valid hexadecimal string representation.\n\n@param `output` Signed long\n\n",signature:"FROMHEX( input:STRING ): output:LONG",tags:["conversion"],since:"1.0.0",OPB64name:"FROMHEX"},FUNCTIONS:{description:"FUNCTIONS returns a list of every functions available in your Warp 10 environnment, including native and extension functions.\n\nIt could be useful when coding your own extension to check your new functions are correctly registered.\n\n\nFUNCTIONS allow anyone to discover new extensions you created on the platform, so it is deactivated by default.\n\nYou must add `warpscript.extension.inventory=io.warp10.script.ext.inventory.InventoryWarpScriptExtension` in your configuration file for this function to be available.\n\n@param `functions` List of Warp 10 functions available on this instance\n\n",signature:"FUNCTIONS(): functions:LIST<STRING>",tags:["platform","extensions"],since:"1.2.16",OPB64name:"FUNCTIONS"},FUSE:{description:"Fuses Geo Time Series™ chunks. The fusion process attempts to keep the bucketization parameters if all chunks are bucketized with compatible `bucketspan` and `lastbucket` values.\n\nAll chunks must be of the same type.\n\nThe fused GTS will have the common class name of the chunks or no class name if some chunks have a different class name. The labels will be those common to all chunks, so when fusing chunks created with [`CHUNK`](/doc/CHUNK), the chunk id will be dropped.\n\n@param `chunks` List of Geo Time Series™ to fuse.\n\n@param `gts` Geo Time Series™ resulting from the fusion of `chunk`.\n\n",signature:"FUSE( chunks:LIST<GTS> ): gts:GTS",tags:["gts"],since:"1.0.0",OPB64name:"FUSE"},"GEO.BUFFER":{description:"The `GEO.BUFFER` function allows to create [*buffer*](https://en.wikipedia.org/wiki/Buffer_(GIS)) **GEOSHAPE** objects. The function takes a `MAP` instance as input. This map can contain the following entries:\n\n| Key | Description |\n|-----|-------------|\n| `dist` | Distance of the buffer, as a central angle expressed in degrees. |\n| `mdist` | Distance of the buffer expressed in meters. This key is only taken into account if `dist` is not specified. |\n| `cap` | The end cap style to consider, use `SQUARE`, `FLAT` or `ROUND` (default). |\n| `join` | The join style to use, use `BEVEL`, `MITRE` or `ROUND` (default). |\n| `limit` | The mitre limit to use. Defaults to 5.0. |\n| `segments` | Number of segments to use per quadrant, defaults to 8. |\n| `singlesided` | Set to `true` to compute a single sided buffer. If `true`, positive distance will indicate left-hand side and negative distance right-hand side. End cap is ignored for single sided buffers. |\n| `wkb` | Byte array containing a [WKB](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary) definition of a geographic area. |\n| `wkt` | String containing a [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) definition of a geographic area. |\n| `geojson` | String containing a [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) definition of a geographic area. |\n\nIf a geographic area is defined, only one of `wkb`, `wkt` or `geojson` may be specified. The output of the function is a new definition of a geographic area with the buffer added to the original definition.\n\nIf no geographic area is defined, `GEO.BUFFER` will define a buffer which will be used by the next call to either [`GEO.WKT`](/doc/GEO.WKT), [`GEO.WKB`](/doc/GEO.WKB) or [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `params` Parameter map containing keys as defined above.\n\n@param `wkb` Area definition with the buffer added, if `params` had a value for key `wkb`.\n\n@param `area` Area definition with the buffer added, in WKT or GeoJSON depending on the presence of key `wkt` or `geojson` in `params`.\n\n",signature:"GEO.BUFFER( params:MAP ): wkb:BYTES\nGEO.BUFFER( params:MAP ): area:STRING\nGEO.BUFFER( params:MAP ): ",tags:["geo"],since:"2.7.0",OPB64name:"GEO.BUFFER"},"GEO.COVER":{description:"The `GEO.COVER` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* in which the input Geo Time Series™ or GTS Encoder had datapoints.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",signature:"GEO.COVER( gts:GTS resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER( encoder:GTSENCODER resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER( list:LIST resolution:LONG ): geoshapes:LIST<GEOSHAPE>",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER"},"GEO.COVER.RL":{description:"The `GEO.COVER.RL` function creates a WarpScript™ **GEOSHAPE** representing a geographical area at a specified resolution.\n\nThe area is composed of *geo cells* which cover the path of an input Geo Time Series™ or GTS Encoder. The path is considered to follow [rhumb lines](https://en.wikipedia.org/wiki/Rhumb_line), hence the function suffix `.RL`.\n\nThe resolution of the cells is an even number from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `gts` Input Geo Time Series™.\n\n@param `encoder` Input GTS Encoder.\n\n@param `list` Input list of Geo Time Series™ and/or GTS Encoders.\n\n@param `geoshape` Resulting GEOSHAPE coverage.\n\n@param `geoshapes` List of computed GEOSHAPEs.\n\n",signature:"GEO.COVER.RL( gts:GTS resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER.RL( encoder:GTSENCODER resolution:LONG ): geoshape:GEOSHAPE\nGEO.COVER.RL( list:LIST resolution:LONG ): geoshapes:LIST<GEOSHAPE>",tags:["geo"],since:"2.2.0",OPB64name:"GEO.COVER.RL"},"GEO.DIFFERENCE":{description:"The `GEO.DIFFERENCE` function computes the difference between two GEOSHAPE. The resulting GEOSHAPE instance contains cells which cover the part of the first GEOSHAPE which is not in the second. If you need to have cells up to a certain resolution, you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the result.\n\n@param `shapeA` GEOSHAPE instance from which to subtract the second shape.\n\n@param `shapeB` GEOSHAPE to subtract from 'shapeA'.\n\n@param `shape` GEOSHAPE containing 'shapeA' minus 'shapeB'.\n\n",signature:"GEO.DIFFERENCE( shapeA:GEOSHAPE shapeB:GEOSHAPE ): shape:GEOSHAPE",tags:["geo"],since:"1.0.0",OPB64name:"GEO.DIFFERENCE"},"GEO.INTERSECTION":{description:"The `GEO.INTERSECTION` function computes the intersection of two GEOSHAPE instances. The intersection process will produce a GEOSHAPE whose cells are common to the two initial shapes. The common cells will be of various resolutions, depending on the resolutions of the cells from the initial shapes. If you need the resulting shape to contain cells up to a specific resolution, you can call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) either on the result or on the initial shapes.\n\n@param `shapeA` First GEOSHAPE instance.\n\n@param `shapeB` Second GEOSHAPE instance.\n\n@param `shapes` GEOSHAPE instances.\n\n@param `shape` Geographical area (GEOSHAPE) resulting from the intersection of the given shapes.\n\n",signature:"GEO.INTERSECTION( shapeA:GEOSHAPE shapeB:GEOSHAPE ): shape:GEOSHAPE\nGEO.INTERSECTION( shapes:LIST<GEOSHAPE> ): shape:GEOSHAPE",tags:["geo"],since:"1.0.0",OPB64name:"GEO.INTERSECTION"},"GEO.INTERSECTS":{description:"The `GEO.INTERSECTS` function checks if a Geo Time Series or each GTS from a list has at least one data point with a position inside a given geographical area. Since `2.7.1`, the function can also check if two `GEOSHAPE` instances intersect.\n\n@param `shapeA` First `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shapeB` Second `GEOSHAPE` to consider when checking if `GEOSHAPE` instances intersect.\n\n@param `shape` Instance of GEOSHAPE containing the area which the Geo Time Series must intersect.\n\n@param `gts` Single instance of Geo Time Series.\n\n@param `lgts` List of Geo Time Series.\n\n@param `result` Boolean indicating whether or not the Geo Time Series had at least one datapoint in 'shape' or if the two shapes intersect.\n\n@param `results` List of boolean results indicating whether or not each GTS had at least one datapoint in 'shape'.\n\n",signature:"GEO.INTERSECTS( gts:GTS shape:GEOSHAPE ): result:BOOLEAN\nGEO.INTERSECTS( lgts:LIST<GTS> shape:GEOSHAPE ): results:LIST<BOOLEAN>\nGEO.INTERSECTS( shapeA:GEOSHAPE shapeB:GEOSHAPE ): result:BOOLEAN",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.INTERSECTS"},"GEO.JSON":{description:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",signature:"GEO.JSON( GeoJSON:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.JSON( GeoJSON:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",tags:["geo"],since:"1.2.9",OPB64name:"GEO.JSON"},"GEO.JSON.UNIFORM":{description:"The `GEO.JSON` function creates a WarpScript object (GEOSHAPE) representing a geographical area. The description of the geographical area uses the [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even numbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.JSON`](doc/GEO.JSON), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the GeoJSON (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `GeoJSON` Description of the geographical area in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON).\n\n@param `geoshape` Geoshape object.\n\n",signature:"GEO.JSON.UNIFORM( GeoJSON:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.JSON.UNIFORM( GeoJSON:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",tags:["geo"],since:"1.2.13",OPB64name:"GEO.JSON.UNIFORM"},"GEO.NORMALIZE":{description:"The `GEO.NORMALIZE` function ensures that the intersection of two **GEOSHAPE**s is present in both as an identical set of cells.\n\n@param `shapeA` The first GEOSHAPE to normalize.\n\n@param `shapeB` The second GEOSHAPE to normalize.\n\n@param `normalizedA` A normalized copy of the first GEOSHAPE.\n\n@param `normalizedB` A normalized copy of the second GEOSHAPE.\n\n",signature:"GEO.NORMALIZE( shapeA:GEOSHAPE shapeB:GEOSHAPE ): normalizedA:GEOSHAPE normalizedB:GEOSHAPE",tags:["geo"],since:"2.5.0",OPB64name:"GEO.NORMALIZE"},"GEO.OPTIMIZE":{description:"The `GEO.OPTIMIZE` function optimizes a GEOSHAPE instance by modifying its cells to either limit the finest resolution present in the shape or reduce the number of cells by merging cells which cover a whole cell at the coarser resolution.\n\n@param `shape` GEOSHAPE instance to optimize.\n\n@param `resolution` Finest resolution acceptable (even number from 2 to 32) or 0 to reduce the number of cells.\n\n@param `optimized` Optimized GEOSHAPE instance\n\n",signature:"GEO.OPTIMIZE( shape:GEOSHAPE resolution:LONG ): optimized:GEOSHAPE",tags:["geo"],since:"1.2.13",OPB64name:"GEO.OPTIMIZE"},"GEO.REGEXP":{description:"The `GEO.REGEXP` function converts a GEOSHAPE into a regular expression to select hexadecimal [HHCode](https://en.wikipedia.org/wiki/HHCode) STRINGs which are included in the GEOSHAPE.\n\n@param `shape` An instance of GEOSHAPE.\n\n@param `regexp` A regular expression for matching HHCodes covered by 'shape'.\n\n",signature:"GEO.REGEXP( shape:GEOSHAPE ): regexp:STRING",tags:["geo"],since:"1.0.11",OPB64name:"GEO.REGEXP"},"GEO.UNION":{description:"The `GEO.UNION` function computes a GEOSHAPE which is the union of two other shapes. The resulting shape will have cells covering the two original shapes. If you need to have cells up to a certain resolution you should call [`GEO.OPTIMIZE`](doc/GEO.OPTIMIZE) on the resulting shape.\n\n@param `shapeA` First GEOSHAPE instance to merge.\n\n@param `shapeB` Second GEOSHAPE instance to merge.\n\n@param `shapes` GEOSHAPE instances to merge.\n\n@param `shape` Resulting GEOSHAPE which is the union of the given shapes.\n\n",signature:"GEO.UNION( shapeA:GEOSHAPE shapeB:GEOSHAPE ): shape:GEOSHAPE\nGEO.UNION( shapes:LIST<GEOSHAPE> ): shape:GEOSHAPE",tags:["geo"],since:"1.0.0",OPB64name:"GEO.UNION"},"GEO.WITHIN":{description:"The `GEO.WITHIN` function checks whether a Geo Time Series™ or each GTS from a list have all its datapoints with a location inside a given geographical area.\n\n@param `shape` Instance of GEOSHAPE containing the area inside which the Geo Time Series™ must be contained.\n\n@param `gts` Single instance of Geo Time Series™.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `result` Boolean indicating whether or not the Geo Time Series™ had all its datapoints with a location inside 'shape'.\n\n@param `results` List of boolean results indicating whether or not each GTS had all its datapoints with a location inside 'shape'.\n\n",signature:"GEO.WITHIN( gts:GTS shape:GEOSHAPE ): result:BOOLEAN\nGEO.WITHIN( lgts:LIST<GTS> shape:GEOSHAPE ): results:LIST<BOOLEAN>",tags:["geo","gts"],since:"1.0.0",OPB64name:"GEO.WITHIN"},"GEO.WKB":{description:"The `GEO.WKB` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geoshape object.\n\n",signature:"GEO.WKB( WKB:BYTES percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKB( WKB:BYTES resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB"},"GEO.WKB.UNIFORM":{description:"The `GEO.WKB.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKB`](doc/GEO.WKB), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKB (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKB` Description of the geographical area in [Well Known Binary](https://en.wikipedia.org/wiki/Well-known_binary).\n\n@param `geoshape` Geographical area output.\n\n",signature:"GEO.WKB.UNIFORM( WKB:BYTES percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKB.UNIFORM( WKB:BYTES resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",tags:["geo"],since:"2.2.1",OPB64name:"GEO.WKB.UNIFORM"},"GEO.WKT":{description:"The `GEO.WKT` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical area uses the\n[Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using\n[`MAXGEOCELLS`](/doc/MAXGEOCELLS).\n\nSince 2.4.0, you can easily visualize geoshapes in WarpScript editors. See example.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geoshape object.\n\n",signature:"GEO.WKT( WKT:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKT( WKT:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",tags:["geo"],since:"1.0.0",OPB64name:"GEO.WKT"},"GEO.WKT.UNIFORM":{description:"The `GEO.WKT.UNIFORM` function creates a WarpScript object (**GEOSHAPE**) representing a geographical area. The description of the geographical\narea uses the [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text) format.\n\nThe coordinates are assumed to be in [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System).\n\nA GEOSHAPE is a set of cells at various resolutions which cover (or are contained within) the specified area. The resolutions of the cells are even\nnumbers from 2 (coarsest) to 30 (finest) with the following associated precisions at the equator:\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\nThe number of cells that a GEOSHAPE may contain is limited by the platform configuration, this limit can be modified up to the hard limit using [`MAXGEOCELLS`](doc/MAXGEOCELLS).\n\nThis function is nearly identical to [`GEO.WKT`](doc/GEO.WKT), differing only by the fact that the produced GEOSHAPE only contains cells of a single resolution.\n\n@param `inside` Boolean indicating whether the coverage should include only cells which are inside the area described by the WKT (`true`) or also those which simply intersect the area (`false`).\n\n@param `percentage` Precision of the resulting area coverage in percentage of the area bounding box diagonal. This value will determine the resolution of the smallest cells used to cover the area.\n\n@param `resolution` Finest resolution to use for the cells covering the area. Resolution is an even number between 2 and 30.\n\n@param `WKT` Description of the geographical area in [Well Known Text](https://en.wikipedia.org/wiki/Well-known_text).\n\n@param `geoshape` Geographical area output.\n\n",signature:"GEO.WKT.UNIFORM( WKT:STRING percentage:DOUBLE inside:BOOLEAN ): geoshape:GEOSHAPE\nGEO.WKT.UNIFORM( WKT:STRING resolution:LONG inside:BOOLEAN ): geoshape:GEOSHAPE",tags:["geo"],since:"1.2.11",OPB64name:"GEO.WKT.UNIFORM"},"GEOCELL->":{description:"The `GEOCELL->` function converts a **LONG** geocell to a **STRING** HHCode prefix. The resulting string length is half the resolution of the geocell.\n\nThis function cannot convert to **BYTES** because this representation is limited to resolutions multiple of 4.\n\nA geocell is a **LONG** where the 4 MSBs store the resolution and the 60 LSBs store a trimmed HHCode. The value stored in the 4 MSBs must be multiplied by 2 to give the resolution of the trimmed HHCode, thus only even resolutions can be represented in a geocell. A resolution of 0 is considered invalid and the highest resolution is 30. The value stored in the 60 LSBs are the 60 MSBs of a HHCode but only the 2*resolution MSBs must be considered.\n\nHere is an example of the bits representation of a geocell and their meaning:\n\n```\n1001101101010111001001011000100010101111000000000000000000000000\n\\__/\\__________________________________/\\______________________/\n ||                  ||                            ||\nRes: 9*2=18          ||                            ||\n        18*2 relevant bits of HHCode     60-18*2 unrelevant bits\n```\n\nA **GEOSHAPE** is simply a list of geocells, see [->GEOSHAPE](/doc/GoKEFoKBI1oy) to build a **GEOSHAPE** from geocells. \n\n@param `geocell` A geocell.\n\n@param `hhPrefix` A HHCode prefix representing the given cell.\n\n",signature:"GEOCELL->( geocell:LONG ): hhPrefix:STRING",tags:["geo"],since:"2.6.0",OPB64name:"GoKEFoKBI1oy"},"GEOHASH->":{description:"The `GEOHASH->` converts a [Geohash](https://en.wikipedia.org/wiki/Geohash), exposing the latitude and longitude it contains, or transforms a list of Geohashes into a `GEOSHAPE`.\n\n@param `geohash` Geohash to unpack.\n\n@param `geohashes` List of Geohashes defining a geographical area.\n\n@param `lat` Unpacked latitude.\n\n@param `lon` Unpacked longitude.\n\n@param `toHHCodeString` Set to `true` to convert the GeoHash to a HHCode STRING or to `false` to convert it to a LONG HHCode instead of extracting its latitude and longitude.\n\n@param `hhcode` The HHCode for `geohash`, as a LONG or STRING.\n\n@param `shape` Warp 10 `GEOSHAPE` covering the same geographic area as the Geohashes in `geohashes`.\n\n",signature:"GEOHASH->( geohash:STRING ): lat:DOUBLE lon:DOUBLE\nGEOHASH->( geohash:STRING toHHCodeString:BOOLEAN ): hhcode:ANY\nGEOHASH->( geohashes:LIST<STRING> ): shape:GEOSHAPE",tags:["geo"],since:"1.0.11",OPB64name:"GoKEH34IH1oy"},GEOPACK:{description:"The `GEOPACK` function takes a **GEOSHAPE** and packs it into a String.\n\n@param `shape` The GEOSHAPE instance to pack.\n\n@param `packed` The packed string representation of the GEOSHAPE.\n\n",signature:"GEOPACK( shape:GEOSHAPE ): packed:STRING",tags:["geo"],since:"1.0.7",OPB64name:"GEOPACK"},"GEOSHAPE->":{description:"The `GEOSHAPE->` function converts **GEOSHAPE** to a list of **LONG** geocells or **STRING** HHCode prefixes. Conversion to list of **BYTES** is not supported, because this representation only supports resolution multiple of 4.\n\n@param `geoshape` The geoshape to get the cells from.\n\n@param `toString` Whether to convert the cells to **STRING** HHCode prefix (true) or geocells (false).\n\n@param `geocells` List of geocells.\n\n@param `geocellsOrHHPrefixes` List of **LONG** geocells or **STRING** HHCode prefixes.\n\n",signature:"GEOSHAPE->( geoshape:GEOSHAPE ): geocells:LIST<LONG>\nGEOSHAPE->( geoshape:GEOSHAPE toString:BOOLEAN ): geocellsOrHHPrefixes:LIST<ANY>",tags:["geo"],since:"2.6.0",OPB64name:"GoKEJoW0J3JhEV"},GEOSHIFT:{description:"`GEOSHIFT` functions shifts a geoshape on the earth. It is able to safely overlap the poles or the 180th meridian.\n- Longitude shift keeps distances.\n- Latitude shift keeps angles, not distances.\n- When doing latitude shift, you can specify a meridian to shift along this meridian. It means a positive shift became a negative shift behind this meridian +/- 90°.\n\nSet precision parameter to zero for safe shifting operation. See [`GEO.WKT`](/doc/GEO.WKT) for precision encoding.\n\nUse [`->GEOJSON`](/doc/AIt6GJx9JoxD) to visualize shapes and the results. GeoJson could be visualized on the map, if you let a special object on the map. See example.\n\n@param `lon` degrees of longitude to shift (-360 to 360).\n\n@param `lat` degrees of latitude to shift (-180 to 180).\n\n@param `precision` even number from 0 to 30. Set to 0 for automatic resolution. Force to another value if you know the input resolution to be finer and you want a coarser resolution.\n\n@param `shape` The input geoshape.\n\n@param `output` The shifted geoshape.\n\n@param `meridian` When doing latitude shift, you can specify a meridian to shift along this meridian. (-180 to 180)\n\n",signature:"GEOSHIFT( shape:GEOSHAPE lat:DOUBLE lon:DOUBLE precision:LONG ): output:GEOSHAPE\nGEOSHIFT( shape:GEOSHAPE meridian:DOUBLE lat:DOUBLE lon:DOUBLE precision:LONG ): output:GEOSHAPE",tags:["geo"],since:"2.5.0",OPB64name:"GEOSHIFT"},GEOSPLIT:{description:"The `GEOSPLIT` function splits a **GEOSHAPE** into a set of **GEOSHAPE**s which have no adjacent cells (each shape is a connected space).\n\nAdjacent cells share part of their side. Adjacency is not provided by corners and cells on each side of the international date line are not considered adjacent either.\n\n@param `shape` The GEOSHAPE instance to split.\n\n@param `subshapes` The shapes whose union form `shape` and which each form a connected space.\n\n",signature:"GEOSPLIT( shape:GEOSHAPE ): subshapes:LIST<GEOSHAPE>",tags:["geo"],since:"2.5.0",OPB64name:"GEOSPLIT"},GEOUNPACK:{description:"The `GEOUNPACK` function unpacks a GEOSHAPE previously packed using [`GEOPACK`](/doc/GEOPACK).\n\n@param `packed` A packed string representation of a GEOSHAPE.\n\n@param `packedbytes` A byte array representation of a GEOSHAPE.\n\n@param `shape` The decoded instance of GEOSHAPE.\n\n",signature:"GEOUNPACK( packed:STRING ): shape:GEOSHAPE\nGEOUNPACK( packedbytes:BYTES ): shape:GEOSHAPE",tags:["geo"],since:"1.0.7",OPB64name:"GEOUNPACK"},GET:{description:"Retreive a value in a **MAP** or a **list**.\n\nThe `GET` function consumes on the top of the stack a list, a byte array, or a map, and the index (or the key), \nthen put the result on the stack. \n\nIf key is not found, it returns NULL on the stack.\n\nIf index is out of bound, `GET` raises an error.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, GET can operate recursively on nested lists. In this case, the index is a list.\n\n@param `map` The input MAP.\n\n@param `key` Depending on map construction, could be a number, a string, a list, another map, a GTS, a boolean.\n\n@param `mapvalue` The value for the requested key. If key do not exists in map, returns NULL\n\n@param `index` The index number in the list. Valid values in [-size; size-1]\n\n@param `list` The input LIST.\n\n@param `value` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `array` Byte array from which to read a byte.\n\n@param `bytevalue` The value of the byte, always unsigned (from 0 to 255).\n\n",signature:"GET( map:MAP key:ANY ): mapvalue:ANY\nGET( list:LIST index:LONG ): value:ANY\nGET( list:LIST index:LIST ): value:ANY\nGET( array:BYTES index:LONG ): bytevalue:LONG",tags:["lists","maps","binary"],since:"1.0.0",OPB64name:"GET"},GETEXPONENT:{description:"The `GETEXPONENT` function consumes a DOUBLE, a LONG casted as a DOUBLE or a COUNTER caster as DOUBLE and pushes back the unbiased exponent used in the representation of this DOUBLE.\n\n@param `n` The decimal value to get the exponent from, will be converted to DOUBLE if not already the case.\n\n@param `exponent` the unbiased exponent of the argument\n\n",signature:"GETEXPONENT( n:NUMBER ): exponent:LONG",tags:["math"],since:"1.2.23",OPB64name:"GETEXPONENT"},GETHOOK:{description:"Extracts the macro associated with a token hook and pushes it onto the stack wrapped as a secure script.\n\nIf the token does not contain the given hook, an empty macro will be wrapped.\n\n@param `hook` Name of the hook to extract from the token.\n\n@param `token` Read token from which to extract the hook.\n\n@param `secure` Hook macro wrapped in a secure script.\n\n",signature:"GETHOOK( token:STRING hook:STRING ): secure:STRING",tags:["platform"],since:"1.0.8",OPB64name:"GETHOOK"},GETSECTION:{description:"The `GETSECTION` function pushes onto the stack the name of the current section.\n\n@param `section` Name of the current section.\n\n",signature:"GETSECTION(): section:STRING",tags:["stack","debug"],since:"1.2.7",OPB64name:"GETSECTION"},GOLDWRAP:{description:"The `GOLDWRAP` function wraps a Geo Time Series™ or a GTS Encoder in a deterministic way, by sorting on timestamps but also on values, locations and elevations.\n\nThis version of a `WRAP` like function is meant to create a *gold standard* blob from its input. In order to ensure reproducibility of the processs, attributes should be dropped prior to calling `GOLDWRAP`.\n\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `wrap` Wrapped Geo Time Series™ instance to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n@param `list` List of Geo Time Series™ or GTS Encoders to wrap.\n\n",signature:"GOLDWRAP( encoder:GTSENCODER ): wrapped:BYTES\nGOLDWRAP( gts:GTS ): wrapped:BYTES\nGOLDWRAP( wrap:BYTES ): wrapped:BYTES\nGOLDWRAP( list:LIST<GTS> ): lwrapped:LIST<BYTES>\nGOLDWRAP( list:LIST<GTSENCODER> ): lwrapped:LIST<BYTES>\nGOLDWRAP( list:LIST<BYTES> ): lwrapped:LIST<BYTES>",tags:["gts"],since:"2.2.0",OPB64name:"GOLDWRAP"},GROUPBY:{description:"The `GROUPBY` function groups the elements of a list according to the value returned by a macro.\n\n@param `macro` Macro used for grouping, consumes an element off the stack and produces a value on the stack.\n\n@param `list` List of elements to group.\n\n@param `grouped` List of groups, each group is a list whose first element is the group key and whose second element is the sublist of `list` for which `macro` produced the same value.\n\n",signature:"GROUPBY( list:LIST macro:MACRO ): grouped:LIST",tags:["lists"],since:"1.2.22",OPB64name:"GROUPBY"},GRUBBSTEST:{description:"The `GRUBBSTEST` function detects an outlier in a GTS (or a LIST of GTS), by applying a \n[Grubbs’](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h1.htm) test.\n\nThis test is done under the assumption that the GTS follows an approximately normal distribution.\n\nIt tests whether there is exactly a single outlier in a GTS or not. For an iterative version which can detect multiple outliers, use instead\n[`ESDTEST`](/doc/ESDTEST).\n\nThis function only applies to GTS of type **DOUBLE**.\n\n> ### Reference \n> Grubbs, Frank (February 1969). “Procedures for Detecting Outlying Observations in Samples”. Technometrics (Technometrics, Vol. 11, No. 1).\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `mad` A flag indicating whether to use the mean (False), or the median (True) to calculate the Z-score\n\n@param `gts` GTS\n\n@param `gtsList` List of GTS\n\n@param `result` List of ticks corresponding to the outliers\n\n@param `resultList` List of list of ticks corresponding to the outliers\n\n",signature:"GRUBBSTEST( gts:GTS mad:BOOLEAN alpha:DOUBLE ): result:LIST<LONG>\nGRUBBSTEST( gts:GTS mad:BOOLEAN ): result:LIST<LONG>\nGRUBBSTEST( gtsList:LIST<GTS> mad:BOOLEAN alpha:DOUBLE ): resultList:LIST\nGRUBBSTEST( gtsList:LIST<GTS> mad:BOOLEAN ): resultList:LIST<LIST<LONG>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"GRUBBSTEST"},"GTSHHCODE->":{description:"The `GTSHHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude. This function is very similar to [`HHCODE->`](/doc/H3W2IoG4AIs) except that when given the internal value used by Geo Time Series™ for a missing location it pushes back `NaN NaN`.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",signature:"GTSHHCODE->( hhcode:LONG ): lat:DOUBLE lon:DOUBLE\nGTSHHCODE->( hhcode:STRING ): lat:DOUBLE lon:DOUBLE\nGTSHHCODE->( hhcode:BYTES ): lat:DOUBLE lon:DOUBLE",tags:["geo"],since:"2.2.0",OPB64name:"GpGIH3W2IoG4AIs"},GZIP:{description:"The `GZIP` function compresses a STRING or a byte array using the [gzip](https://en.wikipedia.org/wiki/Gzip) algorithm. When compressing a STRING, the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) byte representation is first extracted.\n\n@param `string` STRING instance to compress.\n\n@param `bytes` Byte array to compress.\n\n@param `compressed` Compressed byte array.\n\n",signature:"GZIP( string:STRING ): compressed:BYTES\nGZIP( bytes:BYTES ): compressed:BYTES",tags:["conversion"],since:"1.0.11",OPB64name:"GZIP"},HASH:{description:"Computes a 64 bits hash of the string or byte array on top of the stack.\n\n@param `str` String to hash\n\n@param `bytes` Bytes to hash\n\n@param `result` 64bit hash\n\n",signature:"HASH( str:STRING ): result:LONG\nHASH( bytes:BYTES ): result:LONG",tags:["strings"],since:"1.0.0",OPB64name:"HASH"},HAVERSINE:{description:"The `HAVERSINE` function consumes two coordinates and pushes back a **DOUBLE** [great-circle distance](https://en.wikipedia.org/wiki/Great-circle_distance) in meters.\n\n@param `p2_longitude` Point 2 longitude.\n\n@param `p2_latitude` Point 2 latitude.\n\n@param `p1_longitude` Point 1 longitude.\n\n@param `p1_latitude` Point 1 latitude.\n\n@param `haversineDistance` Great circle distance using the haversine fonction.\n\n",signature:"HAVERSINE( p1_latitude:NUMBER p1_longitude:NUMBER p2_latitude:NUMBER p2_longitude:NUMBER ): haversineDistance:DOUBLE",tags:["geo"],since:"1.0.0",OPB64name:"HAVERSINE"},HEADER:{description:"The `HEADER` function allows you to set custom headers which should be returned in the HTTP response. This obviously works only for the `/exec` Warp 10 endpoint.\n\n@param `name` Name of HTTP header to return, MUST start with `X-`, *i.e.* be a custom header.\n\n@param `value` Value to return for the `name` header. If `NULL`, the specified header is removed from the list of headers to return.\n\n",signature:"HEADER( name:STRING value:STRING ): ",tags:["stack"],since:"1.0.14",OPB64name:"HEADER"},"HEX->":{description:"Converts a hexadecimal string representation into a bytes array.\nBytes array cannot be represented on the stack.\n\n@param `input` A valid hexadecimal string.\n\n@param `output` Bytes Array from input. Seen as null on the stack.\n\n",signature:"HEX->( input:STRING ): output:BYTES",tags:["conversion"],since:"1.0.0",OPB64name:"H3KNAIs"},HEXTOB64:{description:"Decodes the hex encoded content on top of the stack and \nimmediately re-encode it in base64. This enables you to \nconvert encoded content which would not be valid UTF-8 encoding \nfrom hexadecimal to base64.      \n\n@param `input` A valid hexadecimal string\n\n@param `output` Base64 representation of input\n\n",signature:"HEXTOB64( input:STRING ): output:STRING",tags:["conversion"],since:"1.0.0",OPB64name:"HEXTOB64"},HEXTOBIN:{description:"Converts a string representing a hexadecimal number into a string representing a binary number.\n\nThe `HEXTOBIN` function consumes on the top of the stack a string and pushes back its convertion. This enables you to convert encoded content which would not be valid UTF-8 encoding from hexadecimal to binary.\n\n@param `input` The string representing a hexadecimal number\n\n@param `output` The string representing a binary number\n\n",signature:"HEXTOBIN( input:STRING ): output:STRING",tags:["conversion","binary"],since:"1.0.0",OPB64name:"HEXTOBIN"},"HHCODE->":{description:"The `HHCODE->` function splits a [HHCode](https://en.wikipedia.org/wiki/HHCode) into a latitude and a longitude.\n\nThe extracted latitude and longitude are DOUBLE converted from FLOATs.\n\n@param `hhcode` Helical Hyperspatial Code to split, either a **LONG** or a **STRING**. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `lat` Extracted latitude\n\n@param `lon` Extracted longitude\n\n",signature:"HHCODE->( hhcode:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE->( hhcode:STRING ): lat:DOUBLE lon:DOUBLE\nHHCODE->( hhcode:BYTES ): lat:DOUBLE lon:DOUBLE",tags:["geo"],since:"1.0.11",OPB64name:"H3W2IoG4AIs"},"HHCODE.BBOX":{description:"The `HHCODE.BBOX` function returns the bounding box of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the bounding box representing the lat/lon of North-Easth and South-West corners of the bbox.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `latSW` Latitude of the south west corner of the bounding box\n\n@param `lonSW` Longitude of the south west corner of the bounding box\n\n@param `latNE` Latitude of the north east corner of the bounding box\n\n@param `lonNE` Longitude of the north east corner of the bounding box\n\n",signature:"HHCODE.BBOX( hhCode:STRING resolution:LONG ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:LONG resolution:LONG ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:BYTES resolution:LONG ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:STRING ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE\nHHCODE.BBOX( hhCode:BYTES ): latSW:DOUBLE lonSW:DOUBLE latNE:DOUBLE lonNE:DOUBLE",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.BBOX"},"HHCODE.CENTER":{description:"The `HHCODE.CENTER` function returns the center of the given hhcode at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the center and returns its lat/lon.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `hhCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n@param `lat` Latitude of the center of the given HHCode\n\n@param `lon` Longitude of the center of the given HHCode\n\n",signature:"HHCODE.CENTER( hhCode:STRING resolution:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:LONG resolution:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:BYTES resolution:LONG ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:STRING ): lat:DOUBLE lon:DOUBLE\nHHCODE.CENTER( hhCode:BYTES ): lat:DOUBLE lon:DOUBLE",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.CENTER"},"HHCODE.EAST":{description:"The `HHCODE.EAST` function returns the cell east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.EAST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.EAST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.EAST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.EAST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.EAST( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.EAST"},"HHCODE.NORTH":{description:"The `HHCODE.NORTH` function returns the cell north of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.NORTH( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.NORTH( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.NORTH( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.NORTH( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.NORTH( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH"},"HHCODE.NORTH.EAST":{description:"The `HHCODE.NORTH.EAST` function returns the cell north east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.NORTH.EAST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.NORTH.EAST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.NORTH.EAST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.NORTH.EAST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.NORTH.EAST( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.EAST"},"HHCODE.NORTH.WEST":{description:"The `HHCODE.NORTH.WEST` function returns the cell north west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.NORTH.WEST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.NORTH.WEST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.NORTH.WEST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.NORTH.WEST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.NORTH.WEST( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.NORTH.WEST"},"HHCODE.SOUTH":{description:"The `HHCODE.SOUTH` function returns the cell south of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.SOUTH( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.SOUTH( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.SOUTH( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.SOUTH( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.SOUTH( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH"},"HHCODE.SOUTH.EAST":{description:"The `HHCODE.SOUTH.EAST.EAST` function returns the cell south east of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.SOUTH.EAST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.SOUTH.EAST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.SOUTH.EAST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.SOUTH.EAST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.SOUTH.EAST( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.EAST"},"HHCODE.SOUTH.WEST":{description:"The `HHCODE.SOUTH.WEST` function returns the cell south west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.SOUTH.WEST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.SOUTH.WEST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.SOUTH.WEST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.SOUTH.WEST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.SOUTH.WEST( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.SOUTH.WEST"},"HHCODE.WEST":{description:"The `HHCODE.WEST` function returns the cell west of the given one at the given resolution.\n\nIt will first convert the HHCode to the resolution and then compute the new cell.\n\nThe function accepts 3 different types of HHCode and will return the same type for the resulting HHCode.\n\nSince 2.6.0, the resolution is optional. In that case the length of the input is used to determine the resolution.\n\n@param `inputHHCode` HHCode to use as reference, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `outputHHCode` The new HHCode, either a **LONG**, a **STRING** or a bytes array. **STRING** values can contain from 1 to 16 hexadecimal digits.\n\n@param `resolution` Resolution to use for the cells. Resolution is an even number between 2 and 32.\n\n",signature:"HHCODE.WEST( inputHHCode:STRING resolution:LONG ): outputHHCode:STRING\nHHCODE.WEST( inputHHCode:LONG resolution:LONG ): outputHHCode:LONG\nHHCODE.WEST( inputHHCode:BYTES resolution:LONG ): outputHHCode:BYTES\nHHCODE.WEST( inputHHCode:STRING ): outputHHCode:STRING\nHHCODE.WEST( inputHHCode:BYTES ): outputHHCode:BYTES",tags:["geo"],since:"2.4.0",OPB64name:"HHCODE.WEST"},HIDE:{description:"The `HIDE` function hides some levels of the stack to the rest of the executing code. This allows a kind of protection for levels which should not be accessed by a macro call for example. Note that this is not a real protection since a call to [`SHOW`](/doc/SHOW) could reveal the hidden levels.\n\nThe hidden levels are always the deepest. Depending on the `levels` parameter to the call to `HIDE`, the hidden levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there remains at most a certain number ((*abs(`levels`)*) with `levels` < 0).\n\nWhen called with `NULL` as parameter, `HIDE` will hide all the visible levels.\n\nThe number of newly hidden levels is returned.\n\n@param `levels` Number of levels to hide or to remain visible, or `NULL` to hide them all.\n\n@param `hidden` Number of levels actually hidden.\n\n",signature:"HIDE( levels:LONG ): hidden:LONG",tags:["stack"],since:"2.7.1",OPB64name:"HIDE"},HLOCATE:{description:"The `HLOCATE` function locates the HBase regions containing a list of Geo Time Series™.\n\nThis function only works with the distributed version of Warp 10™.\n\nIt outputs a list of lists containing a GTS selector, the host and port of the RegionServer currently serving the region and the region id of a region containing data for this GTS.\n\n@param `gts` List of Geo Time Series™ to locate.\n\n@param `result` List of GTS, RegionServer, region tuples.\n\n",signature:"HLOCATE( gts:LIST<GTS> ): result:LIST",tags:["extensions"],since:"1.2.13",OPB64name:"HLOCATE"},HULLSHAPE:{description:"Return the shape of a tensor (or multidimensional array) that would be able to contain all the values of an input nested list. The size of the returned shape is equal to the deepest level of nesting plus one. Its i-th value is equal to the size of the largest list that is nested i levels deep.\n\n@param `list` The input list.\n\n@param `shape` The hull shape of the input list.\n\n",signature:"HULLSHAPE( list:LIST ): shape:LIST\nHULLSHAPE( { list:LIST  } ): shape:LIST",tags:["lists","tensors"],since:"2.1.0",OPB64name:"HULLSHAPE"},HUMANDURATION:{description:"The `HUMANDURATION` function consumes a **LONG** duration and push back an easily readable **STRING** representation of this duration.\n\nThe format of the pushed back **STRING** is **[Dd][Hh][Mm]S.XXXXXXs** with D as days, H as hours, M as minutes, S as seconds and XXXXXX the number of ms (3 digits), us (6 digits) or ns (9 digits) depending on the platform configuration. If the duration is less than a day, Dd is omitted, sames goes with Hh and Mm.\n\n@param `duration` Duration expressed in the platform time unit.\n\n@param `humanReadableDuration`  A representation of the duration, easily readable for a human.\n\n",signature:"HUMANDURATION( duration:LONG ): humanReadableDuration:STRING",tags:["date","time"],since:"1.0.0",OPB64name:"HUMANDURATION"},HYBRIDTEST:{description:"The `HYBRIDTEST` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\nLike [`STLESDTEST`](/doc/STLESDTEST), `HYBRIDTEST` performs an [`ESDTEST`](/doc/ESDTEST) onto a GTS that have been relieved of its seasonal and trend part. \nBut unlike the mentioned test, [`STL`](/doc/STL) and [`ESDTEST`](/doc/ESDTEST) are performed piecewise. Plus, the trend is approximated with the piecewise \nmedian instead of the trend part of the [`STL`](/doc/STL) decomposition.\n\nA LIST of ticks (or a LIST of LIST of ticks), corresponding to the outliers, is pushed back onto the stack.\n\nThis technique was first developped at [Twitter](https://blog.twitter.com/2015/introducing-practical-and-robust-anomaly-detection-in-a-time-series).\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ## References\n> - Owen Vallis, Jordan Hochenbaum, Arun Kejariwal. “A Novel Technique for Long-Term Anomaly Detection in the Cloud”, Twitter Inc (2014).\n> - Cleveland, Robert B., et al. “STL: A seasonal-trend decomposition procedure based on loess.” Journal of Official Statistics 6.1 (1990): 3-73.\n> - Rosner, Bernard (May 1983), “Percentage Points for a Generalized ESD Many-Outlier Procedure”,Technometrics, 25(2), pp. 165-172.\n\n\n@param `parameters` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `lgts` List of [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n",signature:"HYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG alpha:DOUBLE parameters:MAP ): result:LIST<LONG>\nHYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LONG>\nHYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG ): result:LIST<LONG>\nHYBRIDTEST( gts:GTS period:LONG piece:LONG k:LONG parameters:MAP ): result:LIST<LONG>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG alpha:DOUBLE parameters:MAP ): result:LIST<LIST<LONG>>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LIST<LONG>>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG ): result:LIST<LIST<LONG>>\nHYBRIDTEST( lgts:LIST<GTS> period:LONG piece:LONG k:LONG parameters:MAP ): result:LIST<LIST<LONG>>",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST"},HYBRIDTEST2:{description:"The `HYBRIDTEST2` function detects outliers in a GTS (or a LIST of GTS) which has a seasonal part.\n\n`HYBRIDTEST2` is almost the same procedure than [`HYBRIDTEST`](/doc/HYBRIDTEST) except that it does not use [`STL`](/doc/STL) decomposition for the \nseasonal extract.\n\nThe seasonal part is approximated by pondering each value with the [entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29) of the \n[modified Z-score](http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm) of its seasonal subseries (series with only the values of the \nsame season).\n\nThis test is usually preferred when it is meaningful to think in term of entropy, for example when the GTS represents counters of events. Also as it \ndoes not use [`STL`](/doc/STL) decomposition, it is not prone to border effects, but at the cost of not detecting slight outliers.\n\nThis function only applies to [`bucketized`](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upper-bound of the number of outliers to detect per piece\n\n@param `piece` Number of periods that compose a piece\n\n@param `period` Number of buckets that compose a period\n\n@param `gts` [`Bucketized`](/doc/BUCKETIZE) GTS\n\n@param `result` A LIST of ticks corresponding to the outliers\n\n@param `gtsList` List of GTS\n\n",signature:"HYBRIDTEST2( gts:GTS period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LONG>\nHYBRIDTEST2( gts:GTS period:LONG piece:LONG k:LONG ): result:LIST<LONG>\nHYBRIDTEST2( gtsList:LIST<GTS> period:LONG piece:LONG k:LONG alpha:DOUBLE ): result:LIST<LIST<LONG>>\nHYBRIDTEST2( gtsList:LIST<GTS> period:LONG piece:LONG k:LONG ): result:LIST<LIST<LONG>>",tags:["outlier","gts"],since:"1.0.0",OPB64name:"HYBRIDTEST2"},HYPOT:{description:"HYPOT function returns the radius r from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta), r = sqrt(x²+y²).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` x coordinate.\n\n@param `y` y coordinate.\n\n@param `lx` List of x coordinates.\n\n@param `ly` List of y coordinates.\n\n@param `result` radius r in polar coordinates\n\n@param `lresult` List of radiuses r in polar coordinates\n\n",signature:"HYPOT( x:NUMBER y:NUMBER ): result:DOUBLE\nHYPOT( x:NUMBER ly:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nHYPOT( lx:LIST<NUMBER> y:NUMBER ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"HYPOT"},IDENT:{description:"The `IDENT` function pushes onto the stack the value of the system property `warp.ident`.\n\n@param `ident` The value of the `warp.ident` property.\n\n",signature:"IDENT(): ident:STRING",tags:["stack"],since:"1.0.0",OPB64name:"IDENT"},IDWT:{description:"The `IDWT` function computes an Inverse [Discrete Wavelet Transform](https://en.wikipedia.org/wiki/Discrete_wavelet_transform) on a Geo Time Series™.\n\nThe names of the available Wavelet are the following:\n\n| Name | Wavelet |\n| --- | --- |\n| haar | [Haar](http://wavelets.pybytes.com/wavelet/haar/) |\n| db1 | [Daubechies 1](http://wavelets.pybytes.com/wavelet/db1/) |\n| db2 | [Daubechies 2](http://wavelets.pybytes.com/wavelet/db2/) |\n| db3 | [Daubechies 3](http://wavelets.pybytes.com/wavelet/db3/) |\n| db4 | [Daubechies 4](http://wavelets.pybytes.com/wavelet/db4/) |\n| db5 | [Daubechies 5](http://wavelets.pybytes.com/wavelet/db5/) |\n| db6 | [Daubechies 6](http://wavelets.pybytes.com/wavelet/db6/) |\n| db7 | [Daubechies 7](http://wavelets.pybytes.com/wavelet/db7/) |\n| db8 | [Daubechies 8](http://wavelets.pybytes.com/wavelet/db8/) |\n| db9 | [Daubechies 9](http://wavelets.pybytes.com/wavelet/db9/) |\n| db10 | [Daubechies 10](http://wavelets.pybytes.com/wavelet/db10/) |\n| db11 | [Daubechies 11](http://wavelets.pybytes.com/wavelet/db11/) |\n| db12 | [Daubechies 12](http://wavelets.pybytes.com/wavelet/db12/) |\n| db13 | [Daubechies 13](http://wavelets.pybytes.com/wavelet/db13/) |\n| db14 | [Daubechies 14](http://wavelets.pybytes.com/wavelet/db14/) |\n| db15 | [Daubechies 15](http://wavelets.pybytes.com/wavelet/db15/) |\n| db16 | [Daubechies 16](http://wavelets.pybytes.com/wavelet/db16/) |\n| db17 | [Daubechies 17](http://wavelets.pybytes.com/wavelet/db17/) |\n| db18 | [Daubechies 18](http://wavelets.pybytes.com/wavelet/db18/) |\n| db19 | [Daubechies 19](http://wavelets.pybytes.com/wavelet/db19/) |\n| db20 | [Daubechies 20](http://wavelets.pybytes.com/wavelet/db20/) |\n| sym2 | [Symlets 2](http://wavelets.pybytes.com/wavelet/sym2/) |\n| sym3 | [Symlets 3](http://wavelets.pybytes.com/wavelet/sym3/) |\n| sym4 | [Symlets 4](http://wavelets.pybytes.com/wavelet/sym4/) |\n| sym5 | [Symlets 5](http://wavelets.pybytes.com/wavelet/sym5/) |\n| sym6 | [Symlets 6](http://wavelets.pybytes.com/wavelet/sym6/) |\n| sym7 | [Symlets 7](http://wavelets.pybytes.com/wavelet/sym7/) |\n| sym8 | [Symlets 8](http://wavelets.pybytes.com/wavelet/sym8/) |\n| sym9 | [Symlets 9](http://wavelets.pybytes.com/wavelet/sym9/) |\n| sym10 | [Symlets 10](http://wavelets.pybytes.com/wavelet/sym10/) |\n| sym11 | [Symlets 11](http://wavelets.pybytes.com/wavelet/sym11/) |\n| sym12 | [Symlets 12](http://wavelets.pybytes.com/wavelet/sym12/) |\n| sym13 | [Symlets 13](http://wavelets.pybytes.com/wavelet/sym13/) |\n| sym14 | [Symlets 14](http://wavelets.pybytes.com/wavelet/sym14/) |\n| sym15 | [Symlets 15](http://wavelets.pybytes.com/wavelet/sym15/) |\n| sym16 | [Symlets 16](http://wavelets.pybytes.com/wavelet/sym16/) |\n| sym17 | [Symlets 17](http://wavelets.pybytes.com/wavelet/sym17/) |\n| sym18 | [Symlets 18](http://wavelets.pybytes.com/wavelet/sym18/) |\n| sym19 | [Symlets 19](http://wavelets.pybytes.com/wavelet/sym19/) |\n| sym20 | [Symlets 20](http://wavelets.pybytes.com/wavelet/sym20/) |\n| coif1 | [Coiflets 1](http://wavelets.pybytes.com/wavelet/coif1/) |\n| coif2 | [Coiflets 2](http://wavelets.pybytes.com/wavelet/coif2/) |\n| coif3 | [Coiflets 3](http://wavelets.pybytes.com/wavelet/coif3/) |\n| coif4 | [Coiflets 4](http://wavelets.pybytes.com/wavelet/coif4/) |\n| coif5 | [Coiflets 5](http://wavelets.pybytes.com/wavelet/coif5/) |\n| bior1.1 | [Biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/bior1.1/) |\n| bior1.3 | [Biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/bior1.3/) |\n| bior1.5 | [Biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/bior1.5/) |\n| bior2.2 | [Biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/bior2.2/) |\n| bior2.4 | [Biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/bior2.4/) |\n| bior2.6 | [Biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/bior2.6/) |\n| bior2.8 | [Biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/bior2.8/) |\n| bior3.1 | [Biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/bior3.1/) |\n| bior3.3 | [Biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/bior3.3/) |\n| bior3.5 | [Biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/bior3.5/) |\n| bior3.7 | [Biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/bior3.7/) |\n| bior3.9 | [Biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/bior3.9/) |\n| bior4.4 | [Biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/bior4.4/) |\n| bior5.5 | [Biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/bior5.5/) |\n| bior6.8 | [Biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/bior6.8/) |\n| rbio1.1 | [Reverse biorthogonal 1.1](http://wavelets.pybytes.com/wavelet/rbio1.1/) |\n| rbio1.3 | [Reverse biorthogonal 1.3](http://wavelets.pybytes.com/wavelet/rbio1.3/) |\n| rbio1.5 | [Reverse biorthogonal 1.5](http://wavelets.pybytes.com/wavelet/rbio1.5/) |\n| rbio2.2 | [Reverse biorthogonal 2.2](http://wavelets.pybytes.com/wavelet/rbio2.2/) |\n| rbio2.4 | [Reverse biorthogonal 2.4](http://wavelets.pybytes.com/wavelet/rbio2.4/) |\n| rbio2.6 | [Reverse biorthogonal 2.6](http://wavelets.pybytes.com/wavelet/rbio2.6/) |\n| rbio2.8 | [Reverse biorthogonal 2.8](http://wavelets.pybytes.com/wavelet/rbio2.8/) |\n| rbio3.1 | [Reverse biorthogonal 3.1](http://wavelets.pybytes.com/wavelet/rbio3.1/) |\n| rbio3.3 | [Reverse biorthogonal 3.3](http://wavelets.pybytes.com/wavelet/rbio3.3/) |\n| rbio3.5 | [Reverse biorthogonal 3.5](http://wavelets.pybytes.com/wavelet/rbio3.5/) |\n| rbio3.7 | [Reverse biorthogonal 3.7](http://wavelets.pybytes.com/wavelet/rbio3.7/) |\n| rbio3.9 | [Reverse biorthogonal 3.9](http://wavelets.pybytes.com/wavelet/rbio3.9/) |\n| rbio4.4 | [Reverse biorthogonal 4.4](http://wavelets.pybytes.com/wavelet/rbio4.4/) |\n| rbio5.5 | [Reverse biorthogonal 5.5](http://wavelets.pybytes.com/wavelet/rbio5.5/) |\n| rbio6.8 | [Reverse biorthogonal 6.8](http://wavelets.pybytes.com/wavelet/rbio6.8/) |\n| dmey | [Discrete Meyer, FIR approximation](http://wavelets.pybytes.com/wavelet/dmey/) |\n\n\n@param `wavelet` Wavelet to consider\n\n@param `gts` Geo Time Series™ which contains the wavelet coefficients as is returned by [`FDWT`](/doc/FDWT).\n\n@param `result` Reconstructed Geo Time Series™\n\n",signature:"IDWT( gts:GTS wavelet:STRING ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"IDWT"},IEEEREMAINDER:{description:"The `IEEEREMAINDER` function consumes two parameters, a dividend f1 and a divisor f2. This function push the remainder onto the stack as\nprescribed by the [IEEE 754 standard](https://en.wikipedia.org/wiki/IEEE_754-1985).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `dividend` Dividend, converted as DOUBLE if not already the case.\n\n@param `divisor` Divisor, converted as DOUBLE if not already the case.\n\n@param `result` Remainder\n\n@param `ldividend` List of dividends, converted as DOUBLE if not already the case.\n\n@param `ldivisor` List of divisors, converted as DOUBLE if not already the case.\n\n@param `lresult` List of remainders\n\n",signature:"IEEEREMAINDER( dividend:NUMBER divisor:NUMBER ): result:LONG\nIEEEREMAINDER( dividend:NUMBER ldivisor:LIST<NUMBER> ): lresult:LIST<LONG>\nIEEEREMAINDER( ldividend:LIST<NUMBER> divisor:NUMBER ): lresult:LIST<LONG>",tags:["operators"],since:"1.0.0",OPB64name:"IEEEREMAINDER"},IFFT:{description:"The `IFFT` function computes an Inverse [Fast Fourier Transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) of two Geo Time Series™ \nrepresenting real and imaginary parts of FFT coefficients.\n\nThe result is the reconstructed Geo Time Series™. The ticks of this reconstructed GTS are the coefficient indices. They must be multipled by the original \nbucketspan to space the ticks according to the decomposed Geo Time Series™. The bucketspan is equal to `X / (n * factor)` where `X` is the number of time \nunits in a second, `n` is the number of coefficients and `factor` is the scale factor returned by `FFT`.\n\n@param `im` GTS containing the imaginary part\n\n@param `real` GTS containing the real parts of the `FFT` coefficients\n\n@param `result` Reconstructed Geo Time Series™\n\n",signature:"IFFT( real:GTS im:GTS ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"IFFT"},IFT:{description:"The `IFT` function is a conditional construct which will run a macro only if a boolean condition is true. The condition can either be a boolean on the stack or the result of a macro run.\n\n@param `check` Boolean which will be checked as the conditional test.\n\n@param `if` Macro which will be executed to determine the conditional test. This macro must leave a boolean on the stack.\n\n@param `then` Macro which is executed if the conditional test is `true`.\n\n@param `result` State of the stack after the `then` macro is executed.\n\n",signature:"IFT( if:MACRO then:MACRO ): result:ANY*\nIFT( check:BOOLEAN then:MACRO ): result:ANY*",tags:["control"],since:"1.0.0",OPB64name:"IFT"},IFTE:{description:"The `IFTE` function is a conditional construct which evaluates a condition and executes one of two macros depending on the condition (`true` or `false`). The condition can either be a BOOLEAN value on the stack or a macro which will be executed and must leave a BOOLEAN on the stack.\n\n@param `else` Macro executed if the condition is `false`.\n\n@param `then` Macro executed if the condition is `true`.\n\n@param `if` Macro executed to evaluate the condition. Must leave a BOOLEAN on top of the stack.\n\n@param `condition` Boolean value used as the condition.\n\n@param `result` Result of the execution of either the `then` or `else` macro.\n\n",signature:"IFTE( if:MACRO then:MACRO else:MACRO ): result:ANY*\nIFTE( condition:BOOLEAN then:MACRO else:MACRO ): result:ANY*",tags:["control"],since:"1.0.0",OPB64name:"IFTE"},IMMUTABLE:{description:"Transforms a collection (**LIST**, **MAP**, **VLIST**, **SET**) into an immutable one. Any attempt to modify the immutable collection will fail. The original collection is not modified.\n\n@param `list` List to wrap into an immutable wrapper.\n\n@param `map` Map to wrap into an immutable wrapper.\n\n@param `set` Set to wrap into an immutable wrapper.\n\n@param `vector` Vector to wrap into an immutable wrapper.\n\n@param `immutableList` Immutable version of 'list'.\n\n@param `immutableMap` Immutable version of 'map'.\n\n@param `immutableSet` Immutable version of 'set'.\n\n@param `immutableVector` Immutable version of 'vector'.\n\n",signature:"IMMUTABLE( list:LIST ): immutableList:LIST\nIMMUTABLE( map:MAP ): immutableMap:MAP\nIMMUTABLE( set:SET ): immutableSet:SET\nIMMUTABLE( vector:VLIST ): immutableVector:VLIST",tags:["lists","maps","sets"],since:"1.0.0",OPB64name:"IMMUTABLE"},IMPORT:{description:"The `IMPORT` function allows to create aliases for macro name prefixes. This is handy when accessing macros from WarpFleet™ repositories which might have multiple versions and/or long group and artifact ids. When fetching a macro, the *imported* prefixes will be scanned and the longest matching one will be replaced by the associated alias.\n\n@param `prefix` Original prefix to *import*.\n\n@param `as` Name under which `prefix` will be imported.\n\n",signature:"IMPORT( prefix:STRING as:STRING ): ",tags:["stack"],since:"2.0.3",OPB64name:"IMPORT"},INCREMENTEXACT:{description:"The `INCREMENTEXACT` function consumes one LONG from the top of the stack and puts back the value incremented by one. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be incremented by one\n\n@param `result` The incremented value\n\n@param `lvalue` List of values to be incremented by one\n\n@param `lresult` List of incremented values\n\n",signature:"INCREMENTEXACT( value:NUMBER ): result:DOUBLE\nINCREMENTEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.2.23",OPB64name:"INCREMENTEXACT"},INFLATE:{description:"Decompresses a byte array containing data compressed by [`DEFLATE`](doc/DEFLATE).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",signature:"INFLATE( compressed:BYTES ): uncompressed:BYTES",tags:["conversion"],since:"2.1.0",OPB64name:"INFLATE"},INFO:{description:"Generate documentation of a function or a macro.\n\n@param `conf` String list of related configuration keys existing in the Warp 10 configuration.\n\n@param `examples` String list of WarpScript examples.\n\n@param `related` String list of related functions.\n\n@param `params` Map describing the parameters defined in `sig`.\n\n@param `sig` List of signatures. Each signature is a **LIST** with 2 lists (input and output) which contain parameter definitions: *eg* `param1:STRING` in stack order (top first)\n\n@param `desc` Description of the function or macro.\n\n@param `tags` String list tags (*eg* categories).\n\n@param `version` Version of the Warp 10 distribution on which this funcion is available (`standalone` | `distributed` | `all` | `pkg` | `ext` | `plugin`)\n\n@param `deleted` Version's number of Warp 10 where this function (or macro) was deleted.\n\n@param `deprecated` Version's number of Warp 10 where this function (or macro) was deprecated.\n\n@param `since` Version's number of Warp 10 where this function (or macro) was included.\n\n@param `name` Name of the function or macro.\n\n@param `ext` Fully qualified class name of the WarpScript Extension defining the function.\n\n@param `plugin` Fully qualified class name of the WarpScript Plugin defining the function.\n\n",signature:"INFO( { plugin:STRING ext:STRING name:STRING since:STRING deprecated:STRING deleted:STRING version:STRING tags:LIST desc:STRING sig:LIST params:MAP related:LIST examples:LIST conf:LIST  } ): ",tags:["platform","help"],since:"1.2.14",OPB64name:"INFO"},INFOMODE:{description:"Toggles the info mode ON or OFF depending on its current state. Default is OFF when the stack is created.\n\nWhen info mode is ON, the [`INFO`](/doc/INFO) function pushes its map parameter on the stack and stops the current execution as [`STOP`](/doc/STOP) would do.\n\n",signature:"INFOMODE(): ",tags:["platform","help"],since:"1.2.14",OPB64name:"INFOMODE"},INTEGRATE:{description:"The `INTEGRATE` function takes a GTS or a list thereof and integrates it/them, considering the value at each tick is a rate of change per second.\n\n@param `initial` Initial value\n\n@param `gts` GTS to integrate\n\n@param `lgts` List of GTS to integrate\n\n@param `result` Integrated GTS\n\n@param `lresult` List of integrated GTS\n\n",signature:"INTEGRATE( gts:GTS initial:NUMBER ): result:GTS\nINTEGRATE( lgts:LIST<GTS> initial:NUMBER ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"INTEGRATE"},INTERPOLATE:{description:"The `INTERPOLATE` function fills gaps in a [bucketized](/doc/BUCKETIZE) Geo Time Series™ instance with by interpolating linearly. \n\nThis function has no effect on non bucketized GTS instances.\n\n@param `gts` Bucketized GTS\n\n@param `gtsList` List of bucketized GTS\n\n@param `result` Filled bucketized GTS\n\n@param `resultList` list of filled bucketized GTS\n\n",signature:"INTERPOLATE( gts:GTS ): result:GTS\nINTERPOLATE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["bucketize"],since:"1.0.0",OPB64name:"INTERPOLATE"},INTERSECTION:{description:"Computes the intersection &#x2229; of two sets.\n\nThe `INTERSECTION` function consumes two sets from the top of the stack and pushes back its mathematical intersection (ie: the elements in common).\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x2229; *B*\n\n",signature:"INTERSECTION( setA:SET setB:SET ): output:SET",tags:["sets"],since:"1.0.0",OPB64name:"INTERSECTION"},INV:{description:"Inverts a matrix. The inversion is attempted using the [LU Decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm.\n\nIf the matrix is singular or not square an error will be raised.\n\n@param `matrix` Matrix to invert.\n\n@param `inverse` Inverse of the original matrix.\n\n",signature:"INV( matrix:MATRIX ): inverse:MATRIX",tags:["math"],since:"1.0.6",OPB64name:"INV"},ISAUTHENTICATED:{description:"Returns true or false whether or not the stack is authenticated\n\n@param `result` True if the stack is authenticated, false otherwise\n\n",signature:"ISAUTHENTICATED(): result:BOOLEAN",tags:["stack"],since:"1.2.11",OPB64name:"ISAUTHENTICATED"},ISNULL:{description:"The `ISNULL` function consumes a parameter p from the top of the stack and pushes onto the stack true if p is null, else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p is null\n\n",signature:"ISNULL( p:ANY ): result:BOOLEAN",tags:["math","logic"],since:"1.0.0",OPB64name:"ISNULL"},ISNaN:{description:"The `ISNaN` function consumes a numeric parameter p from the top of the stack and pushes onto the stack true if p is Not a Number (NaN), else it pushes false.\n\n@param `p` Parameter\n\n@param `result` True if p a Double and is NaN, false  otherwise\n\n",signature:"ISNaN( p:ANY ): result:BOOLEAN",tags:["math"],since:"1.0.0",OPB64name:"ISNaN"},ISO8601:{description:"The `ISO8601` function consumes an optional **STRING** timezone and a **LONG** UTC timestamp and pushes back a **STRING** representing the date and time according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.\n\nDepending on the platform time unit, the part representing seconds can have 3, 6 or 9 significant figures respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time representation.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `iso8601dateAndTime` Representation of the date and time of the given timestamp for the givent timezone according to the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard\n\n",signature:"ISO8601( timestamp:LONG ): iso8601dateAndTime:STRING\nISO8601( timestamp:LONG timezone:STRING ): iso8601dateAndTime:STRING",tags:["date","time"],since:"1.0.0",OPB64name:"ISO8601"},ISODURATION:{description:"The `ISODURATION` function consumes a **LONG** duration in platform unit and pushes back a **STRING** reresenting an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). Whatever the platform time unit is, the representation maximum resolution is milliseconds.\n\nThe format of the ISO 8601 representation is `PThHmMs.xS` with `h` as hours, `m` as minutes, `s` as seconds and `x` as milliseconds. If any of these value is zero, the value and unit are omitted. The only exception is for a duration of 0 which is represented as `PT0S`. If the duration is negative, `h`, `m` and `s`, if displayed, are negative numbers. \n\n@param `duration` A duration expressed in platform time unit.\n\n@param `iso8601duration` A representation of the consumed duration according to ISO 8601.\n\n",signature:"ISODURATION( duration:LONG ): iso8601duration:STRING",tags:["time"],since:"1.0.0",OPB64name:"ISODURATION"},ISONORMALIZE:{description:"The `ISONORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between -1 and 1 (i.e. it replaces X by \n(X - mean)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",signature:"ISONORMALIZE( gts:GTS ): result:GTS\nISONORMALIZE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"ISONORMALIZE"},JOIN:{description:"Join N strings with the given separator.\n\n@param `n` Number of elements to join that it needs to take from the top of the stack.\n\n@param `sep` Separator used to join the strings.\n\n@param `string` One or more string on the stack.\n\n@param `objects` List of objects whose string representations are to be joined.\n\n@param `result` Joined string.\n\n",signature:"JOIN( string:STRING* sep:STRING n:LONG ): result:STRING\nJOIN( objects:LIST sep:STRING ): result:STRING",tags:["strings"],since:"1.0.0",OPB64name:"JOIN"},"JSON->":{description:"The `JSON->` function parses a string as [JSON](http://json.org/) from the top of the stack and pushes the result onto the stack.\n\n@param `json` String JSON representation\n\n@param `resultMap` Map JSON representation if it is a JSON object\n\n@param `resultList` List JSON representation if it is a JSON array\n\n",signature:"JSON->( json:STRING ): resultMap:MAP\nJSON->( json:STRING ): resultList:LIST",tags:["conversion"],since:"1.0.0",OPB64name:"H_CEIXoy"},JSONLOOSE:{description:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONLOOSE` function configures the stack to send results in a loose [JSON](http://json.org/) format where `NaN` and `Infinite` are valid values.\n\nIf the [JSON](http://json.org/) parser you’re using is strict, you should either configurate the [`JSONSTRICT`](/doc/JSONSTRICT) mode or dealing with \n`NaN` and `Infinite` values outside the parser.\n\n",signature:"",tags:["platform"],since:"1.0.0",OPB64name:"JSONLOOSE"},JSONSTACK:{description:"Select the JSON format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"JSONSTACK(): ",tags:["stack"],since:"2.0.0",OPB64name:"JSONSTACK"},JSONSTRICT:{description:"In strict [JSON](http://json.org/) format the `NaN` and `Infinite` values aren’t allowed and they are replaced by `null`.\n\nThe `JSONSTRICT` function configures the stack to send results in strict [JSON](http://json.org/) format.\n\n",signature:"",tags:["platform"],since:"1.0.0",OPB64name:"JSONSTRICT"},KEYLIST:{description:"Gets keys from a **MAP**.\n\nThe function `KEYLIST` extracts the keys of a map on the top of the stack and pushes on the stack a list with those keys. The map is consumed.      \n\n@param `map` Map from which you want to extract keys\n\n@param `result` List of keys\n\n",signature:"KEYLIST( map:MAP ): result:LIST",tags:["maps"],since:"1.0.0",OPB64name:"KEYLIST"},KURTOSIS:{description:"The `KURTOSIS` function computes the [kurtosis](https://en.wikipedia.org/wiki/Kurtosis) of a Geo Time Series™ or a list thereof.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the kurtosis.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `kurtosis` Computed kurtosis of the Geo Time Series™ instance.\n\n@param `lkurtosis` List of computed kurtosis of the Geo Time Series™ instances.\n\n",signature:"KURTOSIS( gts:GTS bessel:BOOLEAN ): kurtosis:DOUBLE\nKURTOSIS( lgts:LIST<GTS> bessel:BOOLEAN ): lkurtosis:LIST<DOUBLE>",tags:["gts","statistics"],since:"1.2.13",OPB64name:"KURTOSIS"},LABELS:{description:"The `LABELS` function consumes a GTS from the stack, extracts its labels, puts them in a map and pushes the map onto the stack.\n\n@param `gts` The Geo Time Series™ to get the labels from.\n\n@param `encoder` The Geo Time Series™ Encoder to get the labels from.\n\n@param `return` Labels MAP\n\n",signature:"LABELS( gts:GTS ): return:MAP\nLABELS( encoder:GTSENCODER ): return:MAP",tags:["gts"],since:"1.0.0",OPB64name:"LABELS"},LASTACTIVITY:{description:"Extracts the timestamp of last activity recorded in the Geo Time Series™ metadata.\n\nThe timestamp is expressed as platform time units elapsed since the Unix Epoch.\n\n@param `gts` Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `encoder` Geo Time Series™ encoder from which to extract the last activity timestamp.\n\n@param `lgts` List of Geo Time Series™ from which to extract the last activity timestamp.\n\n@param `lencoder` List of Geo Time Series™ encoders from which to extract the last activity timestamp.\n\n@param `lastactivity` Timestamp of last activity.\n\n@param `llastactivity` List of timestamps of last activity.\n\n",signature:"LASTACTIVITY( gts:GTS ): lastactivity:LONG\nLASTACTIVITY( encoder:GTSENCODER ): lastactivity:LONG\nLASTACTIVITY( lgts:LIST<GTS> ): llastactivity:LONG\nLASTACTIVITY( lencoder:LIST<GTSENCODER> ): llastactivity:LONG",tags:["gts"],since:"2.0.0",OPB64name:"LASTACTIVITY"},LASTBUCKET:{description:"The function `LASTBUCKET` consumes a GTS off the stack and pushes its lastbucket onto the stack.\n\nNote: when called on a non bucketized GTS instance, it returns 0.\n\n@param `gts` Bucketized GTS\n\n@param `result` Last bucket timestamp\n\n",signature:"LASTBUCKET( gts:GTS ): result:LONG",tags:["bucketize","gts"],since:"1.0.0",OPB64name:"LASTBUCKET"},LASTSORT:{description:"Sorts a list of Geo Time Series™ according to their most recent value. If most recent values are identical, ticks will be compared, the most recent \nappearing first. If the ticks are also identical, then metadata (class and labels) will be compared.\n\nUse this function to compute Top N queries.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Sorted list of Geo Time Series™\n\n",signature:"LASTSORT( gtsList:LIST<GTS> ): result:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"LASTSORT"},LASTTICK:{description:"The `LASTTICK` function pushes on the stack the newest tick of the Geo Time Series™ on top of the stack or, if the GTS is bucketized, its last bucket.\n\nWhen applied to a list of GTS, `LASTTICK` will return the greatest last tick found across all Geo Time Series™.\n\nIf the GTS does not have values, `Long.MIN_VALUE` is pushed.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `gts` Geo Time Series™.\n\n@param `result` Last tick value.\n\n",signature:"LASTTICK( gts:GTS ): result:LONG\nLASTTICK( lgts:LIST<GTS> ): result:LONG",tags:["gts"],since:"1.0.0",OPB64name:"LASTTICK"},LBOUNDS:{description:"The `LBOUNDS` function computes bounds which divide a specified interval into `n` intervals of equal length.\n\nThe result of `LBOUNDS` is a list of `n+1` bounds, defining `n` intervals inside the specified range plus the two bounds of this range which define the intervals before and after the range.\n\n@param `n` Number of intervals to generate.\n\n@param `upper` Upper bound of the range to subdivide.\n\n@param `lower` Lower bound of the range to subdivide.\n\n@param `bounds` List of computed bounds.\n\n",signature:"LBOUNDS( lower:DOUBLE upper:DOUBLE n:LONG ): bounds:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"LBOUNDS"},LFLATMAP:{description:"The `LFLATMAP` function applies a macro on each element of a list, producing a list \nwith the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the list index on top and the element \nat that particular index below it. Since Warp 10 2.4.0, you can override this behaviour with a boolean.\n\nDifference with `LMAP`: if the macro returns a list, then LFLATMAP will produce a \nlist with the elements of the macro output list (_i.e._ it will _flatten_ the list). \n\nDifference with `LMAP FLATTEN`: flatten will do the list flattening recursively. \n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count -1) will be on the top of the stack. By default, true.\n\n",signature:"LFLATMAP( inputlist:LIST macro:MACRO ): results:LIST\nLFLATMAP( inputlist:LIST macro:MACRO index:BOOLEAN ): results:LIST",tags:["lists"],since:"1.0.0",OPB64name:"LFLATMAP"},LIMIT:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and \na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `LIMIT` function modifies the maximum number of datapoints which can be fetched during a script execution by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call `AUTHENTICATE` with a valid token.\n\n@param `maxDataPoints` Maximal data points retrieved from database in a single FETCH\n\n",signature:"LIMIT( maxDataPoints:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"LIMIT"},LINEOFF:{description:"The `LINEOFF` function disables the automatic labelling of WarpScript code as enabled by `LINEON`.      \n\n",signature:"",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEOFF"},LINEON:{description:"The `LINEON` function enables the automatic section labelling at the beginning of each line of the input WarpScript code. This handy feature greatly simplifies the debug process as the exact line number where an error happens will appear in the error message embedded as a section name of the form `[Line #xx]`.\n\nThis automatic labelling only works with the `/exec` endpoint of Warp 10.\n\n",signature:"",tags:["stack","debug"],since:"1.2.15",OPB64name:"LINEON"},"LIST->":{description:"The `LIST->` function extracts the elements of the **LIST** at the top of the stack\nand pushes them onto the stack one by one. The function then pushes\nonto the stack the number of elements that were in the **LIST**.\n\n@param `input` The input list, will be consumbed\n\n@param `listlength` The length N of input\n\n@param `elements` N elements pushed on the stack\n\n",signature:"LIST->( input:LIST ): elements:ANY* listlength:LONG",tags:["lists","conversion"],since:"1.0.0",OPB64name:"I3_IK1oy"},LMAP:{description:"The `LMAP` function applies a macro on each element of a **LIST**, producing a **LIST** with the element on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **LIST** index on top and the element at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each element in inputlist.\n\n@param `inputlist` List of items\n\n@param `results` List of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",signature:"LMAP( inputlist:LIST macro:MACRO ): results:LIST\nLMAP( inputlist:LIST macro:MACRO index:BOOLEAN ): results:LIST",tags:["lists"],since:"1.0.0",OPB64name:"LMAP"},LOAD:{description:"The `LOAD` function pushes onto the stack the value currently associated with a symbol name.      \n\nIf the symbol is not defined, an error will be raised.\n\n@param `name` Name of symbol whose value should be retrieved.\n\n@param `register` Register number whose value should be retrieved.\n\n@param `value` Retrieved value.\n\n",signature:"LOAD( name:STRING ): value:ANY\nLOAD( register:LONG ): value:ANY",tags:["stack"],since:"1.0.0",OPB64name:"LOAD"},LOCATIONOFFSET:{description:"The `LOCATIONOFFSET` function downsamples a Geo Time Series™ by retaining the first and last datapoints and only those datapoints which are \nmore than a given distance away.\n\n@param `distance` Distance in meters\n\n@param `gts` Geo Time Series™ to downsample\n\n@param `gtsList` List of Geo Time Series™ to downsample\n\n@param `result` Downsampled Geo Time Series™\n\n@param `resultList` List of downsampled Geo Time Series™\n\n",signature:"LOCATIONOFFSET( gts:GTS distance:NUMBER ): result:GTS\nLOCATIONOFFSET( gtsList:LIST<GTS> distance:NUMBER ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"LOCATIONOFFSET"},LOCATIONS:{description:"The `LOCATIONS` function consumes a Geo Time Series™ from the stack, extracts the locations of a Geo Time Series™, puts them in two lists \n(a list of latitudes and a list of longitudes) and pushes the two lists onto the stack.\n\n@param `gts` GTS\n\n@param `longitudes` List of longitudes\n\n@param `latitudes` List of latitudes\n\n",signature:"LOCATIONS( gts:GTS ): latitudes:LIST<DOUBLE> longitudes:LIST<DOUBLE>",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCATIONS"},LOCSTRINGS:{description:"The `LOCSTRINGS` function extract the locations from a Geo Time Series™ and builds a list of the 64 bits hexadecimal representation of their \n[HHCode](https://en.wikipedia.org/wiki/HHCode).\n\n@param `gts` Geo Time Series™\n\n@param `result` List of [HHCode](https://en.wikipedia.org/wiki/HHCode)\n\n",signature:"LOCSTRINGS( gts:GTS ): result:LIST<STRING>",tags:["gts","geo"],since:"1.0.0",OPB64name:"LOCSTRINGS"},LOG:{description:"The `LOG` function consumes a floating point number x from the top of the stack and pushes back its natural logarithm, log<sub>e</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Natural logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of natural logarithms of the given values\n\n",signature:"LOG( value:NUMBER ): result:DOUBLE\nLOG( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG"},LOG10:{description:"The `LOG10` function consumes a floating point number x from the top of the stack and pushes back its common logarithm, log<sub>10</sub>x.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Common logarithm of the given value\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of common logarithms of the given values\n\n",signature:"LOG10( value:NUMBER ): result:DOUBLE\nLOG10( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","operators"],since:"1.0.0",OPB64name:"LOG10"},LOG1P:{description:"Returns the natural logarithm of the sum of the argument and 1.\n\nThe `LOG1P` function consumes a number from the top of the stack and pushes back the natural logarithm for (arg + 1).\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Logarithm of (value + 1)\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of logarithm of (value + 1)\n\n",signature:"LOG1P( value:NUMBER ): result:DOUBLE\nLOG1P( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"LOG1P"},"LOGEVENT->":{description:"Warp&nbsp;10™ runner execution logs are encrypted. See [this documentation](/content/03_Documentation/06_Operations/05_Logs/).\n\nThe easiest way to read logs is to copy the log output and use this function.\n\n\n@param `logline` The opb64 representation of the aes encrypted log line\n\n@param `decodedlog` The decoded logs.\n\n",signature:"LOGEVENT->( logline:STRING ): decodedlog:STRING",tags:["debug"],since:"1.2.7",OPB64name:"I3x6GKO4I_FhEV"},LOGMSG:{description:"`LOGMSG` function prints millisecond timestamp and input text on the standard output.\n\nThe `LOGMSG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",signature:"LOGMSG( msg:STRING ): ",tags:["extensions"],since:"1.0.0",OPB64name:"LOGMSG"},LOWESS:{description:"The `LOWESS` function consumes a bandwidth (a **LONG**) from the top of the stack, then smooths a GTS or a **LIST** of GTS that are below by using \nlocal regression.\n\nTo obtain a good smoothing, it is advised to choose an odd number of at least 5 as the bandwidth parameter.\n\n@param `bandwidth` The bandwitdth parameter is the number of nearest neighbours to consider when applying the local regression.\n\n@param `gts` Geo Time Series™.\n\n@param `gtsList` List of Geo Time Series™.\n\n@param `lresult` List of Geo Time Series™ result.\n\n@param `result` Geo Time Series™ result.\n\n",signature:"LOWESS( gts:GTS bandwidth:LONG ): result:GTS\nLOWESS( gtsList:LIST<GTS> bandwidth:LONG ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"LOWESS"},LR:{description:"Compute the [simple linear regression](https://en.wikipedia.org/wiki/Linear_regression) parameters `alpha` (y-intercept) and `beta` (line slope) for the given numerical Geo Time Series™.\n\n@param `gts` Geo Time Series™ on which to compute linear regression.\n\n@param `beta` The slope of the line fitted on the GTS values.\n\n@param `alpha` The y-intercept of the lined fitted on the GTS values.\n\n",signature:"LR( gts:GTS ): alpha:DOUBLE beta:DOUBLE",tags:["gts","statistics"],since:"1.0.13",OPB64name:"LR"},LSORT:{description:"The `LSORT` function sorts the list on the top of the stack.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `inputlist` The reference of the list to sort\n\n@param `sortedlist` The original list sorted, this is not a new list object\n\n",signature:"LSORT( inputlist:LIST ): sortedlist:LIST",tags:["lists"],since:"1.0.0",OPB64name:"LSORT"},LTTB:{description:"The `LTTB` function downsamples a Geo Time Series™ or list thereof using the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",signature:"LTTB( gts:GTS samples:LONG ): downsampled:GTS\nLTTB( lgts:LIST<GTS> samples:LONG ): ldownsampled:LIST<GTS>",tags:["gts"],since:"1.0.11",OPB64name:"LTTB"},MACROBUCKETIZER:{description:"`MACROBUCKETIZER` converts a macro into a bucketizer which can be used with the [`BUCKETIZE`](/doc/BUCKETIZE) framework.\n\nFor each tick in the mapped GTS, the macro will be called with a list containing the following elements on the stack:\n\n```js\n[tick_of_computation,[gts_classes],[label_bucketize],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n@param `macro` Macro used as a bucketizer\n\n@param `result` Bucketizer to apply\n\n",signature:"MACROBUCKETIZER( macro:MACRO ): result:AGGREGATOR",tags:["bucketize","bucketizer"],since:"1.0.0",OPB64name:"MACROBUCKETIZER"},MACROCONFIG:{description:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration keys looked up are those built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIG`.\n\n`MACROCONFIG` will check if the keys exists, if not it will remove the part of the macro name after the last `/` and will try that new key. It will successively try all names up to the last part of the macro name.\n\nIf none of those keys existed, the call will end in error.\n\nSo for example, if `MACROCONFIG` is called from a macro `my/test/macro` to retrieve the value associated with `mykey`, it will look up the following keys in the configuration:\n\n```\nmykey@my/test/macro\nmykey@my/test\nmykey@my\n```\n\n@param `key` Configuration key to look up.\n\n",signature:"MACROCONFIG( key:STRING ): ",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIG"},MACROCONFIGDEFAULT:{description:"When called from a macro loaded from a local macro repository, a jar in the class path or via the WarpFleet™ resolver, this function accesses the value of a configuration key present in the Warp 10™ configuration.\n\nThis allows to define macro properties outside of the macro itself, which proves very handy when exposing macros via WarpFleet™ for example.\n\nThe typical use case would be a macro which needs a token to interact with Warp 10™, the token can be set in the configuration file.\n\nThe configuration key looked is built by adding `@` and the macro name to the key specified as parameter to `MACROCONFIGDEFAULT`.\n\n`MACROCONFIGDEFAULT` will check if the keys exists, if not it will push the provided default value onto the stack, or fail with an error if the default was `NULL`. If the key is found, the associated value is pushed on the stack.\n\n@param `key` Configuration key to look up.\n\n@param `default` Default value to use if the key was not found, or `NULL` to fail if the key is absent.\n\n",signature:"MACROCONFIGDEFAULT( key:STRING default:STRING ): ",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGDEFAULT"},MACROCONFIGSECRET:{description:"The `MACROCONFIGSECRET` macro consumes 2 elements on the stack, the current and new secret to be set. If no secret has been set, the function will throw an error.\n\nThe secret set by this function is the secret used by [`SETMACROCONFIG`](/doc/SETMACROCONFIG).\n\n@param `newSecret` New secret to override the current one.\n\n@param `oldSecret` Currently set secret.\n\n",signature:"MACROCONFIGSECRET( oldSecret:STRING newSecret:STRING ): ",tags:["platform"],since:"2.1.0",OPB64name:"MACROCONFIGSECRET"},MACROFILLER:{description:"`MACROFILLER` converts a macro into a *filler* which can be used with the [`FILL`](/doc/FILL) function.\n\nThe macro will find the following elements on the stack when it is called:\n\n```\n6: Geo Time Series™ to fill. Both this GTS and the one above are only meant to expose the metadata\n5: Geo Time Series™ of the *other* GTS with a value at the current tick\n4: list of [ tick latitude longitude elevation value ] for the pre window\n3: [ tick latitude longitude elevation value ] of the *other* Geo Time Series™\n2: list of [ tick latitude longitude elevation value ] for the post window\nTOP: tick which is being filled\n```\n\nIt must leave on the stack a list containing the following elements, in this order:\n\n*tick*, *latitude* or `NaN`, *longitude* or `NaN`, *elevation* or `NaN`, *value*\n\n\n@param `macro` Macro to wrap.\n\n@param `prewindow` Number of datapoints needed ahead of the missing datapoint.\n\n@param `postwindow` Number of datapoints needed after the missing datapoint.\n\n@param `filler` Filler instance.\n\n",signature:"MACROFILLER( macro:MACRO prewindow:LONG postwindow:LONG ): filler:FILLER",tags:["filler"],since:"2.0.0",OPB64name:"MACROFILLER"},MACROFILTER:{description:"`MACROFILTER` converts a macro into a filter which can be used with the [`FILTER`](/doc/FILTER) framework\n\nFor each equivalence classes in the filter set of Geo Time Series™, the macro will be called with the following elements on the stack:\n\n```\n[gts], {labels_equivalence_class}\n```\n\nAfter each call the macro is expected to leave a list on the stack.\n\n@param `macro` Macro to apply\n\n@param `result` Filter to apply\n\n",signature:"MACROFILTER( macro:MACRO ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"MACROFILTER"},MACROMAPPER:{description:"`MACROMAPPER` converts a macro into a mapper which can be used with the [`MAP`](/doc/MAP) framework.\n\nFor each tick in the mapped Geo Time Series™, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROMAPPER` can also create a multivariate mapper, that is, a mapper that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate mapper with MAP, each input GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n\n@param `macro` Macro to convert\n\n@param `result` Mapper to apply\n\n",signature:"MACROMAPPER( macro:MACRO ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"MACROMAPPER"},MACROREDUCER:{description:"`MACROREDUCER` converts a macro into a reducer which can be used with the [`REDUCE`](/doc/REDUCE) framework\n\nFor each tick in the Geo Time Series™ to reduce, the macro will be called with a list containing the following elements on the stack:\n\n```json\n[tick_of_computation,[gts_classes],[label_maps],[ticks],[latitudes],[longitudes],[elevations],[values]]\n```\n\nEach list have a length of the number of GTSs in the partition. Each missing value are replaced by `null`, each missing tick by the minimum value of long and each missing latitude, longitude or elevation by NaN. The `label_maps` list as one more element at the end compared to the other lists: the common labels for the GTSs of the partition.\n\nAfter each call the macro is expected to leave on the stack a list with the following elements:\n\n```json\n[tick, latitude, longitude, elevation, value]\n```\n\n`MACROREDUCER` can also create a multivariate reducer, that is, a reducer that outputs multiple results. To do this, macro calls shall leave on the stack a map:\n\n```json\n{\n'result_1': [tick, latitude, longitude, elevation, value],\n'result_2': [tick, latitude, longitude, elevation, value],\n...\n}\n```\nWhen using a multivariate reducer with REDUCE, each input List of GTS produces as much output GTS in a list, whose classnames are the keys found in the map left by the macro call on the stack.\n\n\n@param `macro` Macro to apply\n\n@param `result` Reducer to apply\n\n",signature:"MACROREDUCER( macro:MACRO ): result:AGGREGATOR",tags:["reducer"],since:"1.0.0",OPB64name:"MACROREDUCER"},MACROTTL:{description:"In a file defining a server side macro, the `MACROTTL` function defines the time to live of the macro code. If the macro is accessed after this delay has expired and ondemand loading of macros is enabled, it will unconditionnaly be reloaded from disk.\n\nThis feature is very useful when you have macros generated dynamically on the server side which change frequently. Using `MACROTTL` you can ensure the newest code is loaded regardless of the rescan interval of the macro directory.\n\nIn a the file defining a server side macro, the call to `MACROTTL` should appear before or after the actual macro definition but not within.\n\nThe time after which the macro will no longer be valid is the time of the call to `MACROTTL` plus its parameter.\n\n@param `ttl` The time to live to apply to the macro, in ms.\n\n",signature:"MACROTTL( ttl:LONG ): ",tags:["platform"],since:"1.2.13",OPB64name:"MACROTTL"},MAKEGTS:{description:"The `MAKEGTS` function builds a Geo Time Series™ from **LIST**s.\n\nThe timestamp and values lists must be of the exact same size.\nHowever, as latitudes, longitudes and elevations are optional in a Geo Time Series™, these lists can be shorter than the timestamps lists or even empty. If there are missing latitudes, longitudes and elevations, use [`NaN`](/doc/NaN).\n\n@param `values` Values of the GTS\n\n@param `elevations` Elevations of the GTS\n\n@param `longitudes` Longitudes of the GTS\n\n@param `latitudes` Latitudes of the GTS\n\n@param `timestamps` Timestamps of the GTS\n\n@param `result` Geo Time Series™\n\n",signature:"MAKEGTS( timestamps:LIST latitudes:LIST longitudes:LIST elevations:LIST values:LIST ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"MAKEGTS"},MAN:{description:"The `MAN` function returns the help link for a function name.\n\nIf the function does not exists, it returns http://www.warp10.io/\n\n\n@param `function` The function name\n\n@param `any` Anything except a function name\n\n@param `url` URL of the online help\n\n",signature:"MAN( function:STRING ): url:STRING\nMAN( any:ANY ): url:STRING\nMAN(): url:STRING",tags:["misc","help"],since:"1.2.18",OPB64name:"MAN"},MAP:{description:"The `MAP` framework applies a function on values of a Geo Time Series™ that fall into a sliding window.\n\nThe `MAP` framework is designed to use an existing MAPPER or a custom MACROMAPPER. It could also accept a macro: the current window is passed as a GTS to the macro. See examples below.\n\n@param `result` List of Geo Time Series™, one for each input, whose values are the results of the function application on each sliding window. If the input series is bucketized, the result series will be too unless outputTicks is non null.\n\n@param `gts` One or more Geo Time Series™\n\n@param `gtsList` One or more lists of Geo Time Series™\n\n@param `mapper` Mapper function to apply\n\n@param `pre` Width of the sliding window before the current tick. This parameter is interpreted as a number of ticks if its value is positive, and as a number of time units if its value is negative. A value of 0 means the sliding window does not cover the past. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the past. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `post` Width of the sliding window after the current tick. Values have the same semantics as for the `pre` parameter. A value of 0 means the sliding window does not cover the future. Use the special values `max.tick.sliding.window` or `max.time.sliding.window` to expand the window the farthest into the future. Defaults to 0.\n\n@param `occurrences` Limit the number of computations to that number. If the value is 0, compute a value for each tick of the input Geo Time Series™. If it is non-negative, compute that many values starting from the oldest to the most recent tick. In the other case, do that many computations in the reverse order. This is useful when you are interested in a single result, like the max or sum of all values. Defaults to 0. When selecting a number of ticks, the value of this parameter is limited to 2**32-1 even if a greater value was provided.\n\n@param `step` The step size in number of ticks. The mapper beggins at the oldest tick and goes to the tick `step` after the current one and so on. Defaults to 1.\n\n@param `overrideTick` If set to true, the tick value returned by the mapper is used to update the current tick, else it is ignored and the original tick is kept. Defaults to false.\n\n@param `outputTicks` If non null, it sets the list of ticks that is traversed to anchor the sliding windows (instead of the ticks of the input Geo Time Series™). In that case, a tick of the input Geo Time Series™ that would be equal to one of these anchor points is counted by a positive `post` if `occurences` is non-negative, or by a positive `pre` if `occurences` is negative.\n\n",signature:"MAP( [ gts:GTS+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG ] ): result:LIST<GTS>\nMAP( [ gtsList:LIST<GTS>+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG ] ): result:LIST<GTS>\nMAP( [ gts:GTS+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG ] ): result:LIST<GTS>\nMAP( [ gtsList:LIST<GTS>+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG ] ): result:LIST<GTS>\nMAP( [ gts:GTS+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN ] ): result:LIST<GTS>\nMAP( [ gtsList:LIST<GTS>+ mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN ] ): result:LIST<GTS>\nMAP( gts:GTS+ { mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN outputTicks:LIST<LONG>  } ): result:LIST<GTS>\nMAP( gtsList:LIST<GTS>+ { mapper:AGGREGATOR pre:LONG post:LONG occurrences:LONG step:LONG overrideTick:BOOLEAN outputTicks:LIST<LONG>  } ): result:LIST<GTS>",tags:["mapper","framework"],since:"1.0.0",OPB64name:"MAP"},"MAP->":{description:"The `MAP->` function expands the **MAP** on top of the stack into pairs of elements followed by the number of elements extracted. If the **MAP** was \ncreated by a call to `->MAP`, the order of the elements will be the same as prior to calling `->MAP`.\n\n@param `map` Map to expand\n\n@param `key` Key of the pair\n\n@param `value` Value of the pair\n\n@param `mapsize` The number of key value pushed on the stack.\n\n",signature:"MAP->( map:MAP ): key:ANY* value:ANY* mapsize:LONG",tags:["maps","conversion"],since:"1.0.0",OPB64name:"IJ4FAIs"},MAPID:{description:"Generates a fingerprint of a map.\n\n@param `input` Input map\n\n@param `result` Fingerprint of the map\n\n",signature:"MAPID( input:MAP ): result:STRING",tags:["maps"],since:"1.0.0",OPB64name:"MAPID"},MARK:{description:"Pushes a mark onto the stack.\n\n@param `mark` A MARK instance.\n\n",signature:"MARK(): mark:MARK",tags:["stack"],since:"1.0.0",OPB64name:"MARK"},"MAT->":{description:"The `MAT->` function converts a Matrix into nested lists.\n\n\n@param `input` Matrix to convert\n\n@param `result` Nested list of values\n\n",signature:"MAT->( input:MATRIX ): [  result:LIST<LIST<DOUBLE>>  ]",tags:["lists","math","conversion"],since:"1.0.6",OPB64name:"IJ4JAIs"},MATCH:{description:"The `MATCH` function applies a regular expression (regexp) to a string.\n\nIt consumes two parameters from the top of the stack: the regexp pattern and the string to test matching with.\n\nIf the string doesn’t match the regexp, the function return an empty list. If it matches, the function will return a list of every matching group.\n\nInstead of using a regular expression **STRING**, you can also use the result of [`MATCHER`](/doc/MATCHER) for improved performance.\n\n@param `regexp` Regular expression to apply\n\n@param `string` String to evaluate\n\n@param `result` List of every matching group.\n\n",signature:"MATCH( string:STRING regexp:STRING ): result:LIST<STRING>\nMATCH( string:STRING regexp:MATCHER ): result:LIST<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"MATCH"},MATCHER:{description:"The `MATCHER` function will compile a regular expression into an efficient object which can be used by [`MATCH`](/doc/MATCH).\n\n@param `regexp` Regular expression to compile\n\n@param `result` Compiled regula expression\n\n",signature:"MATCHER( regexp:STRING ): result:MATCHER",tags:["strings"],since:"1.0.0",OPB64name:"MATCHER"},MAX:{description:"Returns the greater of two numeric values.\n\nThe `MAX` function consumes two numeric parameters from the top of the stack and pushes back the greatest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The larger of p1 and p2.\n\n@param `sresult` The larger of the elements in the given list.\n\n@param `lresult` A list where each value is the max between the element in the list and the given value.\n\n",signature:"MAX( p1:LONG p2:LONG ): result:LONG\nMAX( p1:LONG p2:DOUBLE ): result:DOUBLE\nMAX( p1:DOUBLE p2:LONG ): result:DOUBLE\nMAX( p1:DOUBLE p2:DOUBLE ): result:DOUBLE\nMAX( p1:COUNTER p2:COUNTER ): result:LONG\nMAX( p1:COUNTER p2:DOUBLE ): result:DOUBLE\nMAX( p1:DOUBLE p2:COUNTER ): result:DOUBLE\nMAX( p1:COUNTER p2:LONG ): result:DOUBLE\nMAX( p1:LONG p2:COUNTER ): result:DOUBLE\nMAX( llist:LIST<LONG> ): sresult:LONG\nMAX( dlist:LIST<DOUBLE> ): sresult:DOUBLE\nMAX( clist:LIST<COUNTER> ): sresult:LONG\nMAX( llist:LIST<LONG> value:LONG ): lresult:LIST<LONG>\nMAX( clist:LIST<COUNTER> value:COUNTER ): lresult:LIST<LONG>\nMAX( dlist:LIST<DOUBLE> value:DOUBLE ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"MAX"},MAXBUCKETS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXBUCKETS` function modifies the maximum number of buckets which can be created by a call to [`BUCKETIZE`](/doc/BUCKETIZE) by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXBUCKETS( limit:LONG ): ",tags:["platform","bucketize"],since:"1.0.0",OPB64name:"MAXBUCKETS"},MAXDEPTH:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard \nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXDEPTH` function modifies the maximum depth (number of levels) of the execution stack by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXDEPTH( limit:LONG ): ",tags:["platform","stack"],since:"1.0.0",OPB64name:"MAXDEPTH"},MAXGEOCELLS:{description:"Modifies the maximum number of cells a **GEOSHAPE** created by [`GEO.WKT`](/doc/GEO.WKT) or [`GEO.JSON`](/doc/GEO.JSON) can have. The limit can be modified up to the configured value for `warpscript.maxgeocells.hard`.\n\n@param `maxcells` New limit to set.\n\n",signature:"MAXGEOCELLS( maxcells:LONG ): ",tags:["platform"],since:"1.2.11",OPB64name:"MAXGEOCELLS"},MAXGTS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard limit \nwhich can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe `MAXGTS` function modifies the maximum number of Geo Time Series™ which can be fetched by setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXGTS( limit:LONG ): ",tags:["platform","gts"],since:"1.0.0",OPB64name:"MAXGTS"},MAXJSON:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to\nthe hard limit value.\n\nThe `MAXJSON` function modifies the maximum number of characters in a json produced by [`->JSON`](/doc/AIt9JoxD).\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXJSON( limit:LONG ): ",tags:["platform"],since:"2.5.0",OPB64name:"MAXJSON"},MAXLONG:{description:"Pushes [Long.MAX_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MAX_VALUE) onto the stack.\n\n@param `result` Long.MAX_LONG\n\n",signature:"MAXLONG(): result:LONG",tags:["math","constants"],since:"1.0.0",OPB64name:"MAXLONG"},MAXLOOP:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a hard\nlimit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to the hard limit value.\n\nThe MAXLOOP function modifies the maximum number of milliseconds which can be spent in a loop setting it to the value on top of the stack.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXLOOP( limit:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"MAXLOOP"},MAXOPS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and\na hard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXOPS` function modifies the maximum number of operations which can be performed during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXOPS( limit:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"MAXOPS"},MAXPIXELS:{description:"Modifies the maximum size (in pixels) of images which can be created by [`PGraphics`](/doc/PGraphics). The limit can be modified up to the value configured in `warpscript.maxpixels.hard`.\n\n@param `pixels` Maximum size (in pixels).\n\n",signature:"MAXPIXELS( pixels:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"MAXPIXELS"},MAXRECURSION:{description:"Modifies the maximum nesting depth of macro calls. The limit can be modified up to the value configured in `warpscript.maxrecursion.hard`.\n\n@param `depth` Maximum nesting depth.\n\n",signature:"MAXRECURSION( depth:LONG ): ",tags:["platform"],since:"1.2.13",OPB64name:"MAXRECURSION"},MAXSYMBOLS:{description:"Execution of WarpScript code is performed on a stack which has a set of limits in order to prevent bad things to happen. Those limits have both a soft and a \nhard limit which can be configured on the backend. By default a limit is set to its soft limit value, but it can be modified from within the script up to \nthe hard limit value.\n\nThe `MAXSYMBOLS` function modifies the maximum number of simultaneous symbols which can be defined on the stack during a single WarpScript execution.\n\nPrior to calling this function, you must call [`AUTHENTICATE`](/doc/AUTHENTICATE) with a valid token.\n\n@param `limit` Soft limit to override\n\n",signature:"MAXSYMBOLS( limit:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"MAXSYMBOLS"},MAXURLFETCHCOUNT:{description:"The `MAXURLFETCHCOUNT` function modifies the maximum number of URLs which can be fetched with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.MAXURLFETCHCOUNT.limit.hard`.\n\n@param `limit` The maximum number of URLs which can be fetched.\n\n",signature:"MAXURLFETCHCOUNT( limit:LONG ): ",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHCOUNT"},MAXURLFETCHSIZE:{description:"The `MAXURLFETCHSIZE` function modifies the maximum cumulative size of fetched payloads with [`URLFETCH`](/doc/URLFETCH) during a single WarpScript execution. This cannot exceed `warpscript.urlfetch.maxsize.hard` and is expressed as a number of bytes.\n\n@param `limit` The maximum cumulative size of fetched payloads.\n\n",signature:"MAXURLFETCHSIZE( limit:LONG ): ",tags:["extensions","web"],since:"2.0.2",OPB64name:"MAXURLFETCHSIZE"},MD5:{description:"The `MD5` function digests a byte array on the stack with the cryptographic hash function [`MD5`](https://en.wikipedia.org/wiki/MD5).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",signature:"MD5( input:BYTES ): result:BYTES",tags:["crypto"],since:"1.2.0",OPB64name:"MD5"},MERGE:{description:"Merge several Geo Time Series™ together.\n\nThe `MERGE` function expects a **LIST** of Geo Time Series™ on the top of the stack. It will consume these GTS and push onto the stack a single GTS instance\nwith all measurements found in the GTS instances present in the **LIST**. The name and labels of the resulting GTS instance are those of the first one of the\n**LIST**.\n\n`MERGE` do not override values on the same timestamp, they are appenned.\n\n@param `gtsList` The list of Geo Time Series™\n\n@param `result` The merged Geo Time Series™\n\n",signature:"MERGE( gtsList:LIST<GTS> ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"MERGE"},META:{description:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `META` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",signature:"META( gtsList:LIST<GTS> writeToken:STRING ): ",tags:["gts"],since:"1.0.0",OPB64name:"META"},METADIFF:{description:"Stores the attributes of a list of Geo Time Series™ in the Warp 10 backend in an incremental manner. New attributes are added and already existing attributes are updated or removed if their value is an empty string.\n\nThis function expects on top of the stack a write token which will be used to authenticate with the Warp 10 backend and a Geo Time Series™ or a list thereof.\n\nEvery Geo Time Series™ to which `METADIFF` is applied must have a non empty name and attributes (possibly empty).\n\n@param `writeToken` valid write token for the set of GTS to modify\n\n@param `gtsList` GTS list with new or modified attributes\n\n",signature:"METADIFF( gtsList:LIST<GTS> writeToken:STRING ): ",tags:["gts"],since:"2.3.0",OPB64name:"METADIFF"},METAOFF:{description:"Disables meta operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when a meta operation is attempted.\n\n",signature:"METAOFF( message:STRING secret:STRING ): ",tags:["platform"],since:"2.0.3",OPB64name:"METAOFF"},METAON:{description:"Enables meta operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",signature:"METAON( secret:STRING ): ",tags:["platform"],since:"2.0.3",OPB64name:"METAON"},METASET:{description:"Performs a [`FIND`](/doc/FIND), retrieving a list of Geo Time Series™ and builds a *metaset* which can be distributed to allow access to those GTS without having to give away credentials.\n\nMetaset support is only available if a key has been set for `warp.aes.metasets`.\n\n@param `ttl` Time to live of the produces metaset. It will not be usable after that much time has elapsed since the current time. The ttl is specified in time units.\n\n@param `maxduration` The maximum span of data which can be retrieved using this metaset, in time units.\n\n@param `notafter` Most recent timestamp of the data this metaset can retrieve.\n\n@param `notbefore` Most ancient timestamp of the data this meataset can retrieve.\n\n@param `labels` Map of label selectors.\n\n@param `class` Geo Time Series™ class selector.\n\n@param `token` Read token to use for retrieving the GTS.\n\n@param `metaset` Encrypted metaset which can be used with a [`FETCH`](/doc/FETCH).\n\n",signature:"METASET( [ token:STRING class:STRING labels:MAP notbefore:LONG notafter:LONG maxduration:LONG ttl:LONG ] ): metaset:STRING",tags:["gts"],since:"1.2.5",OPB64name:"METASET"},METASORT:{description:"Sorts a list of Geo Time Series™ according to elements of their metadata. The list of elements to consider for sorting can contain label names or NULL to consider the classname. Elements will be considered in the order in which they appear in the list.\n\n@param `gts` List of Geo Time Series™ to sort.\n\n@param `elements` Metadata elements to consider for sorting.\n\n@param `sorted` Sorted list of GTS.\n\n",signature:"METASORT( gts:LIST<GTS> elements:LIST ): sorted:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"METASORT"},MIN:{description:"Returns the smaller of two numeric values.\n\nThe `MIN` function consumes two numeric parameters from the top of the stack and pushes back the smallest value.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `p1` First numeric parameter\n\n@param `p2` Second numeric parameter\n\n@param `value` Numeric value\n\n@param `llist` List of Longs.\n\n@param `dlist` List of Doubles.\n\n@param `clist` List of Counters.\n\n@param `result` The smaller of p1 and p2.\n\n@param `sresult` The smaller of the elements in the given list.\n\n@param `lresult` A list where each value is the min between the element in the list and the given value.\n\n",signature:"MIN( p1:LONG p2:LONG ): result:LONG\nMIN( p1:LONG p2:DOUBLE ): result:DOUBLE\nMIN( p1:DOUBLE p2:LONG ): result:DOUBLE\nMIN( p1:DOUBLE p2:DOUBLE ): result:DOUBLE\nMIN( p1:COUNTER p2:COUNTER ): result:LONG\nMIN( p1:COUNTER p2:DOUBLE ): result:DOUBLE\nMIN( p1:DOUBLE p2:COUNTER ): result:DOUBLE\nMIN( p1:COUNTER p2:LONG ): result:DOUBLE\nMIN( p1:LONG p2:COUNTER ): result:DOUBLE\nMIN( llist:LIST<LONG> ): sresult:LONG\nMIN( dlist:LIST<DOUBLE> ): sresult:DOUBLE\nMIN( clist:LIST<COUNTER> ): sresult:LONG\nMIN( llist:LIST<LONG> value:LONG ): lresult:LIST<LONG>\nMIN( clist:LIST<COUNTER> value:COUNTER ): lresult:LIST<LONG>\nMIN( dlist:LIST<DOUBLE> value:DOUBLE ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"MIN"},MINLONG:{description:"Pushes [Long.MIN_VALUE](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#MIN_VALUE) onto the stack.\n\n@param `result` Long.MIN_VALUE\n\n",signature:"MINLONG(): result:LONG",tags:["math","constants"],since:"1.0.0",OPB64name:"MINLONG"},MINREV:{description:"The `MINREV` function consumes a string representing a revision on the stack and puts back a boolean indicating if the revision of the current Warp 10™ platform is newer or equal.\n\n@param `revision` A string representing a revision (semantic versioning). Given a version number MAJOR.MINOR.PATCH, .MINOR or .MINOR.PATCH can be omitted.\n\n@param `newer` A boolean indicating wether the revision of the current Warp 10™ platform is newer or equal to the given revision.\n\n",signature:"MINREV( revision:STRING ): newer:BOOLEAN",tags:["platform"],since:"1.2.23",OPB64name:"MINREV"},MMAP:{description:"The `MMAP` function applies a macro on each key/value pair of a **MAP**, producing a **MAP** with the two elements on top of the stack after each macro invocation.\n\nThe macro is called with a stack containing the **MAP** index on top and the key/value pair at that particular index below it. \nSince Warp 10 2.4.0, you can override this behaviour with a boolean.\n\n@param `macro` This macro will be called for each entry in inputmap.\n\n@param `inputmap` Map to iterate on.\n\n@param `results` Map of results left on the top of the stack by each macro\n\n@param `index` When set to true, the current index (=iteration count-1) will be on the top of the stack. By default, true.\n\n",signature:"MMAP( inputmap:MAP macro:MACRO ): results:MAP\nMMAP( inputmap:MAP macro:MACRO index:BOOLEAN ): results:MAP",tags:["maps"],since:"2.7.0",OPB64name:"MMAP"},MODE:{description:"The `MODE` function computes the mode(s) for a given Geo Time Series™ or a GTS **LIST**. Foreach Geo Time Series™ pushes back on the stack a list containing \ntheir mode(s).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Mode of the list (the items that occurs most often)\n\n",signature:"MODE( gts:GTS ): result:LIST\nMODE( gtsList:LIST<GTS> ): [  result:LIST<LIST>  ]",tags:["gts"],since:"1.0.11",OPB64name:"MODE"},MONOTONIC:{description:"Produces a new Geo Time Series™ from an input by modifying the value so the result is monotonous. This is technically applying a ratchet effect on values.\n\nThe `MONOTONIC` function expects a boolean on top of the stack and a Geo Time Series™ or list thereof below the boolean. The boolean indicates whether the\nresult should be monotonically increasing (false) or decreasing (true).\n\n@param `trend` Whether the result should be monotonically increasing (false) or decreasing (true)\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` New Geo Time Series™\n\n@param `resultList` List of new Geo Time Series™\n\n",signature:"MONOTONIC( gts:GTS trend:BOOLEAN ): result:GTS\nMONOTONIC( gtsList:LIST<GTS> trend:BOOLEAN ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"MONOTONIC"},MOTIONSPLIT:{description:'The `MOTIONSPLIT` function splits Geo Time Series™ instances based on several possible motion criteria. Split parameters can be combined to split on multiple criteria.\n\n`MOTIONSPLIT` can split on:\n- stopped state detection\n- moving to stopped transition\n- time difference between two ticks (just as [`TIMESPLIT`](/doc/TIMESPLIT) does).\n- maximal distance between two consecutive positions.\n\n`MOTIONSPLIT` parameters:\n- **timesplit**: LONG value, time in platform time unit. Splits if the time difference between two consecutive ticks is strictly greater than this parameter. If defined, the split type label will be "timesplit".\n- **distance.split**: DOUBLE value, distance in meter. Splits if the orthodromic distance between two consecutive locations is strictly greater than this parameter. If defined, the split type label will be "distancesplit".\n- **stopped.min.time**: LONG value, time in platform time unit. This is the minimum time the consecutive locations should stay in the stopped zone radius to consider a stop state. If defined, the split type label will be "stopped".\n- **stopped.max.radius**: DOUBLE value, distance in meter. As long as consecutive positions remains in the radius during stopped.min.time, `MOTIONSPLIT` detect a stopped state.\n- **stopped.max.speed**: DOUBLE value, speed in m/s. If the speed is greater than this value while in stopped state, `MOTIONSPLIT` exits the stopped state.\n- **stopped.max.mean.speed**: DOUBLE value, speed in m/s. Maximum mean speed in the proximity zone that prevent the split. `MOTIONSPLIT` will split only if there is a full stop during the given time and radius, and if the mean speed in the proximity zone is less than this parameter.\n- **stopped.split**: BOOLEAN value. If true, `MOTIONSPLIT` also splits between stopped and moving sequences. If defined, the split type label will be "stopped" or "moving".\n- **label.stopped.time**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the time in stopped state. If the split source is not a stop detection, this label won\'t be set.\n- **label.split.number**: STRING value. If defined, `MOTIONSPLIT` will add an extra label on each split that contains the split number, starting from 1.\n- **label.split.type**: STRING value. If defined, `MOTIONSPLIT` will add an extra label that contains the split reason. It could be "timesplit", "distancesplit", "end", "stopped" or "moving".\n\n`MOTIONSPLIT` split type priorities:\n- If stopped.min.time and stopped.max.radius are set, the stop detection has the first priority.\n- If `MOTIONSPLIT` does not detect a stopped state, it looks for a distance split.\n- If `MOTIONSPLIT` does not detect a stopped state or a distance split, it looks for a time split.\n\n\n@param `parameters` List of splitting parameters. See the function description.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n',signature:"MOTIONSPLIT( gts:GTS parameters:MAP ): splits:LIST<GTS>\nMOTIONSPLIT( lgts:LIST<GTS> parameters:MAP ): lsplits:LIST<LIST<GTS>>",tags:["gts"],since:"2.3.0",OPB64name:"MOTIONSPLIT"},MSGFAIL:{description:"The `MSGFAIL` function stops the execution of WarpScript code by throwing an exception. \n\n@param `message` The exception message\n\n",signature:"MSGFAIL( message:STRING ): ",tags:["control"],since:"1.0.0",OPB64name:"MSGFAIL"},MSORT:{description:"The function `MSORT` inspects the top of the stack. If it is a **MAP**, it sorts the **MAP** according to its keys. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\n@param `map` Map to sort\n\n@param `result` Sorted map\n\n",signature:"MSORT( map:MAP ): result:MAP",tags:["maps"],since:"1.0.0",OPB64name:"MSORT"},MSTU:{description:"The `MSTU` function pushes onto the stack the number of platform time units in one millisecond. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one millisecond.\n\n",signature:"MSTU(): numberTimeUnits:LONG",tags:["date","time","platform"],since:"1.0.0",OPB64name:"MSTU"},MULTIPLYEXACT:{description:"The `MULTIPLYEXACT` function consumes two LONGs from the top of the stack and puts back the product. If the product overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `prod` The product of x and y\n\n@param `list` List of numeric values\n\n@param `sprod` The product of all the elements of list\n\n@param `lx` List of numeric values\n\n@param `lprod` List of **LONG** where each value is the product of y and an element in lx\n\n",signature:"MULTIPLYEXACT( x:NUMBER y:NUMBER ): prod:LONG\nMULTIPLYEXACT( list:LIST<NUMBER> ): sprod:LONG\nMULTIPLYEXACT( lx:LIST<NUMBER> y:NUMBER ): lprod:LIST<LONG>",tags:["math"],since:"1.2.23",OPB64name:"MULTIPLYEXACT"},MUSIGMA:{description:"The `MUSIGMA` function calculates the mean and the standard deviation of a Geo Time Series. It consumes two parameters from the top of the stack: a boolean \n(to choose if [Bessel's correction](https://en.wikipedia.org/wiki/Bessel%27s_correction) should be applied on the standard deviation) and a numeric GTS, and \nit pushes onto the stack its mean (mu) and its standard deviation (sigma).\n\n@param `bessel` True if apply a [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `sigma` Standard deviation\n\n@param `mu` Mean\n\n@param `gts` A single Geo Time Series\n\n",signature:"MUSIGMA( gts:GTS bessel:BOOLEAN ): mu:DOUBLE sigma:DOUBLE",tags:["gts"],since:"1.0.0",OPB64name:"MUSIGMA"},MUTEX:{description:"Attempts to hold a named lock, creating it if needed, and execute a macro while holding the lock. When the macro execution terminates, either normally or with an error, the lock is released.\n\n@param `mutex` Name of lock to hold.\n\n@param `macro` Macro to execute while holding the lock.\n\n",signature:"MUTEX( macro:MACRO mutex:STRING ): ",tags:["extensions","stack"],since:"2.0.0",OPB64name:"MUTEX"},MVELEVATIONS:{description:"The `MVELEVATIONS` function extracts elevations from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVELEVATIONS` function will emit a list with two elements (a pair), the first element will be the elevation associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the elevations of the Multivariate value itself.\n\nIf a tick has no associated elevation, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted elevations.\n\n",signature:"MVELEVATIONS( input:GTSENCODER ): output:LIST\nMVELEVATIONS( input:GTS ): output:LIST\nMVELEVATIONS( linput:LIST ): output:LIST",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVELEVATIONS"},MVHHCODES:{description:"The `MVHHCODES` function extracts [`HHCodes`](https://en.wikipedia.org/wiki/HHCode) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVHHCODES` function will emit a list with two elements (a pair), the first element will be the HHCode associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the HHCodes of the Multivariate value itself.\n\nIf a tick has no associated location, `NaN` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted HHCodes.\n\n",signature:"MVHHCODES( input:GTSENCODER ): output:LIST\nMVHHCODES( input:GTS ): output:LIST\nMVHHCODES( linput:LIST ): output:LIST",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVHHCODES"},MVINDEXSPLIT:{description:"The `MVINDEXSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVINDEXSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element index (first element being at index 0).\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:INDEX` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of indices or indices ranges can be specified to only produce encoders for the indices which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `indices` List of indices or indices ranges (list of two indices), used to restrict which indices to consider.\n\n@param `renaming` Map of index (LONG) to parameter to `RENAME`. If no entry is present for an index, `+:INDEX` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",signature:"MVINDEXSPLIT( input:GTSENCODER ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTSENCODER indices:LIST ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTSENCODER renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTSENCODER indices:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS indices:LIST ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( input:GTS indices:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> indices:LIST ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTSENCODER> indices:LIST renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> indices:LIST ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>\nMVINDEXSPLIT( linput:LIST<GTS> indices:LIST renaming:MAP ): loutput:LIST<LIST<GTSENCODER>>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVINDEXSPLIT"},MVLOCATIONS:{description:"The `MVLOCATIONS` function extracts location (latitude, longitude) from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVLOCATIONS` function will emit a list with two elements (a pair), the first element will be the latitude and longitude (a list) associated with the tick at which the Multivariate value was encountered, the second element will be a list containing the latitudes and longitudes of the Multivariate value itself.\n\nIf a tick has no associated location, `[ NaN NaN ]` will be emitted.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted locations.\n\n",signature:"MVLOCATIONS( input:GTSENCODER ): output:LIST\nMVLOCATIONS( input:GTS ): output:LIST\nMVLOCATIONS( linput:LIST ): output:LIST",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVLOCATIONS"},MVTICKS:{description:"The `MVTICKS` function extracts ticks from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\nWhen a tick has an associated Multivariate value, the `MVTICKS` function will emit a list with two elements (a pair), the first element will be the tick at which the Multivariate value was encountered, the second element will be a list containing the ticks of the Multivariate value itself.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted ticks.\n\n",signature:"MVTICKS( input:GTSENCODER ): output:LIST\nMVTICKS( input:GTS ): output:LIST\nMVTICKS( linput:LIST ): output:LIST",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKS"},MVTICKSPLIT:{description:"The `MVTICKSPLIT` function transforms an input Geo Time Series™ or Encoder by interpreting its Multi Value values and producing multiple output encoders.\n\nThe transformation works as follows, whenever `MVTICKSPLIT` encounters a value in Multi Value format at `tick` with `lat`, `lon`, `elev` as optional geo components, it decodes that value and adds each of its elements to a separate Encoder identified by the element timestamp.\n\nEach element is added with `tick` as its timestamp and `lat`, `lon`, `elev` as its geo components, unless it has its own geo information.\n\nIf the transformation encounters a value which is not in Multi Value format, its assumes it is an element found at index 0 and adds it to the associated encoder.\n\nOnce the input has been scanned completely, the resulting encoders are renamed, either by looking up the renaming parameter in a map or by appending `:TIMESTAMP` to the original name.\n\nThe labels and attributes from the input are preserved.\n\nOptionaly a list of timestamps or timestamp ranges can be specified to only produce encoders for the timestamps which are specified or fall within a specified range.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `timestamps` List of timestamps or timestamps ranges (list of two timestamps), used to restrict which timestamps to consider.\n\n@param `renaming` Map of timestamp (LONG) to parameter to `RENAME`. If no entry is present for a timestamp, `+:TIMESTAMP` will be assumed.\n\n@param `output` List of resulting encoders.\n\n@param `loutput` List of list of resulting encoders.\n\n",signature:"MVTICKSPLIT( input:GTSENCODER ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTSENCODER timestamps:LIST ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTSENCODER renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTSENCODER timestamps:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS timestamps:LIST ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( input:GTS timestamps:LIST renaming:MAP ): output:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> timestamps:LIST ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> renaming:MAP ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTSENCODER> timestamps:LIST renaming:MAP ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> timestamps:LIST ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> renaming:MAP ): loutput:LIST<GTSENCODER>\nMVTICKSPLIT( linput:LIST<GTS> timestamps:LIST renaming:MAP ): loutput:LIST<GTSENCODER>",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVTICKSPLIT"},MVVALUES:{description:"The `MVVALUES` function extracts values from an input Geo Time Series™ or GTS Encoder, correctly interpreting Multivariate (MV) values. The result is a potentially multidimensional list.\n\n@param `input` Input encoder or Geo Time Series™ to transform.\n\n@param `linput` List of input encoder or Geo Time Series™ to transform.\n\n@param `output` List (potentially multidimensional) of extracted values.\n\n",signature:"MVVALUES( input:GTSENCODER ): output:LIST\nMVVALUES( input:GTS ): output:LIST\nMVVALUES( linput:LIST ): output:LIST",tags:["gts","encoder","conversion","multivariate"],since:"2.1.0",OPB64name:"MVVALUES"},NAME:{description:"The `NAME` function consumes a Geo Time Series™ from the stack, extracts its class name, and pushes it onto the stack.\n\n@param `gts` Geo Time Series™\n\n@param `encoder` Geo Time Series™ Encoder\n\n@param `result` Class name\n\n",signature:"NAME( gts:GTS ): result:STRING\nNAME( encoder:GTSENCODER ): result:STRING",tags:["gts"],since:"1.0.0",OPB64name:"NAME"},NBOUNDS:{description:"The `NBOUNDS` function computes bounds defining a specified number of intervals which have the same area under the curve of a normal distribution with a given mean and standard deviation.\n\n@param `n` Number of desired intervals.\n\n@param `sigma` Positive standard deviation to use for the normal distribution.\n\n@param `mu` Mean to use for the normal distribution.\n\n@param `bounds` List of `n`-1 bounds defining the `n` intervals.\n\n",signature:"NBOUNDS( mu:NUMBER sigma:NUMBER n:LONG ): bounds:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"NBOUNDS"},NDEBUGON:{description:"Turns on stack debugging so up to the given number of stack levels will be returned in case of error. Stack debugging is off by default.\n\n@param `n` Maximum number of stack levels to return in case of error.\n\n",signature:"NDEBUGON( n:NUMBER ): ",tags:["stack"],since:"1.0.0",OPB64name:"NDEBUGON"},NEGATEEXACT:{description:"The `NEGATEEXACT` function consumes one LONG from the top of the stack and puts back the negated value. If the result overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be negated\n\n@param `result` The negated value\n\n@param `lvalue` List of values to be negated\n\n@param `lresult` List of negated values\n\n",signature:"NEGATEEXACT( value:NUMBER ): result:DOUBLE\nNEGATEEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.2.23",OPB64name:"NEGATEEXACT"},NEWENCODER:{description:"The `NEWENCODER` function creates an empty encoder and pushes it onto the stack. An encoder is very similar to a Geo Time Series™, it differs by its ability to store values of all four types (LONG, DOUBLE, BOOLEAN, STRING) where a GTS is limited to the type of the first value stored.\n\nThe set of operations which can be performed on encoders is more limited than those that can be performed on GTS.\n\n@param `encoder` A newly created empty encoder instance.\n\n",signature:"NEWENCODER(): encoder:GTSENCODER",tags:["encoder","multivariate"],since:"1.2.9",OPB64name:"NEWENCODER"},NEWGTS:{description:"The `NEWGTS` function pushes onto the stack an empty Geo Time Series™ instance.\n\n@param `gts` A newly created empty GTS instance.\n\n",signature:"NEWGTS(): gts:GTS",tags:["gts"],since:"1.0.0",OPB64name:"NEWGTS"},NEXTAFTER:{description:"The `NEXTAFTER` function consumes two numeric parameter from the top of the stack and pushes back the **DOUBLE** adjacent to the first argument in the direction of the second argument. In other words, the result is between *from* and *to* and adjacent to *from*.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `from` Starting value\n\n@param `to` Direction used to calculate the adjacent value\n\n@param `result` Next **DOUBLE** from *from* to *to*\n\n@param `lfrom` List of starting values\n\n@param `lto` List of directions used to calculate the adjacent value\n\n@param `lresult` List of next **DOUBLE** from *from* to *to*\n\n",signature:"NEXTAFTER( from:NUMBER to:NUMBER ): result:DOUBLE\nNEXTAFTER( from:NUMBER lto:LIST<NUMBER> ): lresult:LIST<DOUBLE>\nNEXTAFTER( lfrom:LIST<NUMBER> to:NUMBER ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"NEXTAFTER"},NEXTDOWN:{description:"The `NEXTDOWN` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of negative infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of negative infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of negative infinity\n\n",signature:"NEXTDOWN( value:NUMBER ): result:DOUBLE\nNEXTDOWN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.2.23",OPB64name:"NEXTDOWN"},NEXTUP:{description:"The `NEXTUP` function consumes a numeric parameter from the top of the stack and pushes back the next **DOUBLE** in the direction of positive infinity.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Next **DOUBLE** in the direction of positive infinity\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of next **DOUBLE** in the direction of positive infinity\n\n",signature:"NEXTUP( value:NUMBER ): result:DOUBLE\nNEXTUP( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"NEXTUP"},NOLOG:{description:"The `NOLOG` function resets java.util.logging.LogManager.\n\nIt can be useful to do this during developments and tests of an extension.\n\nThe `NOLOG` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n",signature:"NOLOG(): ",tags:["extensions"],since:"1.2.19",OPB64name:"NOLOG"},NONEMPTY:{description:"Filter a list of Geo Time Series™ in order to retain only those that have at least one value.\n\n@param `gtsList` List of Geo Time Series™\n\n@param `results` Filtered list of Geo Time Series™\n\n",signature:"NONEMPTY( gtsList:LIST<GTS> ): results:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"NONEMPTY"},NONNULL:{description:"The `NONNULL` function consumes a list and produces a list containing only the non NULL elements of the argument list.\n\n@param `list` The argument list to filter\n\n@param `nonnulls` A new list with only those elements from `list` which are not NULL\n\n",signature:"NONNULL( list:LIST ): nonnulls:LIST",tags:["math","logic"],since:"1.2.7",OPB64name:"NONNULL"},NOOP:{description:"It does nothing.\n\nWhile it does not have a usefulness of its own, it can be used when generating code from within WarpScript code prior to executing it with [`EVAL`](/doc/EVAL).\n\n",signature:"",tags:["platform"],since:"1.0.0",OPB64name:"NOOP"},NORMALIZE:{description:"The `NORMALIZE` function takes as parameter a numeric GTS or a list of numeric GTS and normalize them between 0 and 1 (i.e. it replaces X by \n(X - min)/(max - min) or by 1 if max == min).\n\n@param `gts` GTS to normalize\n\n@param `gtsList` List of GTS to normalize\n\n@param `result` Normalized GTS\n\n@param `resultList` List of normalized GTS\n\n",signature:"NORMALIZE( gts:GTS ): result:GTS\nNORMALIZE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"NORMALIZE"},NOT:{description:"Negates a boolean.\n\nThe `NOT` function is synonymous for [`!`](/doc/7F). It consumes a boolean value x from the top of the stack and pushes back the result of appying the\n`NOT` logical function.\n\nFor a true input value it returns false, for a false one it returns true.\n\n@param `input` Boolean value to negate\n\n@param `result` Negated boolean value\n\n@param `gts` A boolean Geo Time Series™\n\n@param `negatedgts` A boolean Geo Time Series™\n\n",signature:"NOT( input:BOOLEAN ): result:BOOLEAN\nNOT( gts:GTS ): negatedgts:GTS",tags:["logic"],since:"1.0.0",OPB64name:"NOT"},NOTAFTER:{description:"Checks that the current time is not after the provided timestamp.\n\nThe `NOTAFTER` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not after the provided timestamp.\nIf it is not after the WarpScript execution continues, otherwise it throws an exception.\n\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",signature:"NOTAFTER( timestamp:LONG ): \nNOTAFTER( date:STRING ): ",tags:["date"],since:"1.0.0",OPB64name:"NOTAFTER"},NOTBEFORE:{description:"Checks that the current time is not before the provided timestamp.\n\nThe `NOTBEFORE` function consumes a timestamp (**LONG** or [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) string representation) on the top of the stack. It checks that the current time (NOW) is not before the provided timestamp.\nIf it is not before the WarpScript execution continues, otherwise it throws an exception.\n\n@param `timestamp` The timestamp in Warp 10 unit (micro-second by default)\n\n@param `date` [ISO8601](http://en.wikipedia.org/wiki/ISO_8601) date\n\n",signature:"NOTBEFORE( timestamp:LONG ): \nNOTBEFORE( date:STRING ): ",tags:["date"],since:"1.0.0",OPB64name:"NOTBEFORE"},NOTIMINGS:{description:"Use of the `NOTIMINGS` function disables the collection of timing information for each line of the input script. Use [`TIMINGS`](/doc/TIMINGS) to enable it again.\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"NOTIMINGS"},NOW:{description:"The `NOW` function pushes onto the stack the current **LONG** timestamp expressed in the platform time unit. This timestamp is the number of platform time unit elapsed since 00:00:00 on 1 January 1970 UTC minus the number of leap seconds, see [Unix time](https://en.wikipedia.org/wiki/Unix_time).\n\nThis function is mostly linear with time but this property is violated when the OS resynchronises its clock (ie consecutive calls to `NOW` may 'jump' or 'go backward').\n\n@param `timestamp` The current timestamp in platform time unit.\n\n",signature:"NOW(): timestamp:LONG",tags:["date","time"],since:"1.0.0",OPB64name:"NOW"},NPDF:{description:"The `NPDF` function builds a function which outputs the probability of occurrence of a given value under a specified normal distribution.\n\nThe normal distribution is defined by its mean and standard deviation. The result of the `NPDF` function is itself a function which can be invoked via [`EVAL`](doc/EVAL).\n\n*NPDF* stands for Normal (Gaussian) distribution Probability Density Function.\n\n@param `sigma` Standard deviation of the normal distribution to consider.\n\n@param `mu` Mean of the normal distribution to consider.\n\n@param `npdf` Function which given an input number outputs the probability of its occurence under the given normal distribution.\n\n",signature:"NPDF( mu:NUMBER sigma:NUMBER ): npdf:FUNCTION",tags:["math"],since:"1.0.0",OPB64name:"NPDF"},NPEEK:{description:"Displays a given number of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `levels` Number of stack levels to display.\n\n",signature:"NPEEK( levels:NUMBER ): ",tags:["stack"],since:"2.0.0",OPB64name:"NPEEK"},NRETURN:{description:"Immediately exit a certain number of macros being executed. The `NRETURN` function expects a number of levels on top of the stack.\n\n@param `levelnumber` Number of levels of macro to exit.\n\n",signature:"NRETURN( levelnumber:LONG ): ",tags:["control"],since:"1.0.0",OPB64name:"NRETURN"},NSUMSUMSQ:{description:"Computes the cardinality, sum of values and sum of squared values of a Geo Time Series™. Pushes those results on the stack in the order they were mentioned.\n\nOnly numeric series are allowed.\n\n@param `square` Sum of squared values\n\n@param `sum` Sum of values\n\n@param `cardinality` Values count\n\n@param `gts` Geo Time Series™\n\n",signature:"NSUMSUMSQ( gts:GTS ): cardinality:LONG sum:DOUBLE square:DOUBLE",tags:["gts"],since:"1.0.0",OPB64name:"NSUMSUMSQ"},NULL:{description:"The `NULL` function pushes the symbolic value *null* onto the stack.\n\n@param `result` Symbolic value *null*\n\n",signature:"NULL(): result:NULL",tags:["constants"],since:"1.0.0",OPB64name:"NULL"},NaN:{description:"Pushes the double value *NaN* (Not a Number) onto the stack.\n\n@param `result` Value *NaN*\n\n",signature:"NaN(): result:DOUBLE",tags:["constants"],since:"1.0.0",OPB64name:"NaN"},ONLYBUCKETS:{description:"Only retains ticks from Geo Time Series™ with timestamps which are bucket ends. If an input GTS is not bucketized, a clone of the GTS will be returned.\n\nThe `ONLYBUCKETS` function does not remove duplicate ticks, please consider using [`DEDUP`](/doc/DEDUP) for that purpose.\n\n@param `gts` Single instance of Geo Time Series™ to transform.\n\n@param `lgts` List of Geo Time Series™ to transform.\n\n@param `result` Transformed GTS.\n\n@param `lresult` List of transformed GTS.\n\n",signature:"ONLYBUCKETS( gts:GTS ): result:GTS\nONLYBUCKETS( lgts:LIST<GTS> ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"ONLYBUCKETS"},"OPB64->":{description:"Decode a String in order preserving base64 into a byte array.\n\nBytes array cannot be represented on the stack.\n\n@param `input` Any valid opbbase64 string.\n\n@param `output` Byte array of the input decoded input.\n\n",signature:"OPB64->( input:STRING ): output:BYTES",tags:["conversion"],since:"1.0.7",OPB64name:"Ip01CYFhEV"},OPB64TOHEX:{description:"The OPB64TOHEX function decodes the order preserving base64 string on top of the stack and immediately re-encode it in hex string.\n\n\n@param `input` OPBase64 encoded string\n\n@param `output` hexadecimal representation\n\n",signature:"OPB64TOHEX( input:STRING ): output:STRING",tags:["conversion"],since:"1.0.2",OPB64name:"OPB64TOHEX"},OPS:{description:"Pushes onto the stack the current number of operations which were performed by the WarpScript code execution.\n\n@param `ops` number of operations\n\n",signature:"OPS(): ops:LONG",tags:["platform"],since:"1.0.0",OPB64name:"OPS"},OPTDTW:{description:"The `OPTDTW` function finds the top subsequence matches in a sequence for a given query sequence. The function uses [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping)\nto assess the subsequence similarity with the query.\n\n@param `match` Number of top matches. Use 0 as the number of matches to return to return them all.\n\n@param `query` Query numerical sequence, thr shortest\n\n@param `data` Data sequence in which to find matches\n\n@param `result` List of matches, each match being a pair of (index, distance).\n\n",signature:"OPTDTW( data:LIST query:LIST match:LONG ): result:LIST",tags:["math","distance"],since:"1.0.0",OPB64name:"OPTDTW"},OPTIMIZE:{description:"Optimizes the memory footprint of Geo Time Series™ and GTS Encoder instances.\n\n@param `ratio` Ratio of memory footprint to number of values, if this ratio is not exceeded, no optimization will take place. As a result, optimization is always done when ratio <= 1 or ratio is NaN.\n\n@param `gts` Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `encoder` Instance of GTS Encoder to optimize.\n\n@param `optencoder` Optimized version of the encoder, or the original instance if no optimization occurred.\n\n@param `lgts` List of Geo Time Series™ instance to optimize, the optimized version is the same instance.\n\n@param `lencoder` List of instances of GTS Encoder to optimize.\n\n@param `loptencoder` List of optimized version of the encoders or the original instances if no optimization occurred.\n\n",signature:"OPTIMIZE( gts:GTS ratio:NUMBER ): gts:GTS\nOPTIMIZE( encoder:GTSENCODER ratio:NUMBER ): optencoder:GTSENCODER\nOPTIMIZE( lgts:LIST<GTS> ratio:NUMBER ): lgts:LIST<GTS>\nOPTIMIZE( lencoder:LIST<GTSENCODER> ratio:NUMBER ): loptencoder:LIST<GTSENCODER>",tags:["gts"],since:"1.2.9",OPB64name:"OPTIMIZE"},OR:{description:"The `OR` operator is a synonymous for [`||`](/doc/U6k).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `OR` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",signature:"OR( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\nOR( l:LIST ): result:BOOLEAN\nOR( gts1:GTS gts2:GTS ): gtsresult:GTS",tags:["operators","logic"],since:"1.0.0",OPB64name:"OR"},PACK:{description:"The `PACK` function packs a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n@param `input` List to pack\n\n@param `format` Format used to pack\n\n@param `result` Bytes array\n\n",signature:"PACK( input:LIST format:STRING ): result:BYTES",tags:["lists"],since:"1.0.7",OPB64name:"PACK"},PAPPLY:{description:"The `PAPPLY` function performs operations in a way identical to the [`APPLY`](/doc/APPLY) framework but produces a map of results keyed by the label map of each equivalence class.\n\nAs [`APPLY`](/doc/APPLY), `PAPPLY` provides a way to apply an operation on Geo Time Series™ grouped by equivalence classes. It is somehow similar to the [`REDUCE`](/doc/REDUCE) framework in the sense that everything you can do with `REDUCE` can be done with `APPLY`, but `APPLY` is more flexible and goes way beyond what `REDUCE` can due. The flexibility of `APPLY` comes with a greater complexity and thus both frameworks exist.\n\n`APPLY` operates on multiple lists of Geo Time Series™, `L1` ... `Ln`. The first phase of `APPLY` will partition each of those lists in equivalence classes by inspecting the values of the specified labels. If one of the lists is a singleton (*i.e.* contains a single Geo Time Series™), then it will be included in all equivalence classes, regardless of the values of its labels. If you wish to override this behaviour, simply duplicate the GTS in the list so it is no longer a singleton.\n\nThe second phase of `APPLY` will execute the operation for each equivalence class. The execution will apply the operation to `n` parameters, tick by tick, where the `i`th parameter is a list of lists of `timestamp`, `latitude`, `longitude`, `elevation` and `value`, one for each GTS from the list `Li` which is in the current equivalence class, in the order in which they appear in `Li`. The ticks scanned belong to the set of ticks of all Geo Time Series™ in the equivalence class.\n\nThe number of supported parameters depends on the selected operation, please refer to the documentation of each operation for the details.\n\n@param `gts` One or more list of Geo Time Series™.\n\n@param `labels` A list of label names to use when creating equivalence classes. An empty list means use all labels.\n\n@param `result` Map of resulting GTS, one per equivalence class, keyed with the equivalence class labels.\n\n@param `op` Operation to perform.\n\n",signature:"PAPPLY( [ op:OPERATOR labels:LIST gts:LIST<GTS>+ ] ): result:MAP",tags:["gts","framework","op"],since:"1.0.0",OPB64name:"PAPPLY"},PARSE:{description:"The `PARSE` function parses an input **STRING** containing datapoints in the [Geo Time Series™ input format](/content/03_Documentation/03_Interacting_with_Warp_10/03_Ingesting_data/02_GTS_input_format) and pushes onto the stack the parsed Geo Time Series™.\n\n@param `data` Datapoints in the Geo Time Series™ input format\n\n@param `result` List of parsed Geo Time Series™\n\n",signature:"PARSE( data:STRING ): result:LIST<GTS>",tags:["gts","strings"],since:"1.0.11",OPB64name:"PARSE"},PARSESELECTOR:{description:"The `PARSESELECTOR` function parses a GTS Selector (STRING) returnss the class selector and labels selectors.\n\nIn order for `PARSESELECTOR` to parse correctly a selector, the following characters MUST appear percent-encoded in the `STRING` to parse, the equal sign (`=`, `%3D`), the comma (`,` `%2C`) and closing curly brace (`}` `%7D`). Due to the way WarpScript parses `STRING` constants, the `%` sign MUST be percent-encoded (`%25`) in the `STRING` if it appears in WarpScript code:\n\nThe `STRING` `class{label=comm%2Cequal%3Dsign}` must appear in WarpScript as:\n\n```\n'class{label=comm%252Cequal%253Dsign'\n```\n\nCombined with `TOSELECTOR`, it can be used to build a selector from a subset of GTS.\n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature'\n  { 'sensorId' '=01' }\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\nFETCH\n\n```\nThis can be used to simplify the syntax of a FETCH or FIND request. \n\n```flow\n[\n  'READ_TOKEN'\n  'io.senx.tutorial.sensors.temperature{sensorId=01}' PARSESELECTOR\n  '2014-01-05T00:00:00.000Z'\n  '2014-01-05T23:59:59.999Z'\n]\n\nFETCH\n```\n\n\n\n@param `selector` String selector.\n\n@param `labelselector` MAP of label selectors.\n\n@param `classselector` Class name selector.\n\n",signature:"PARSESELECTOR( selector:STRING ): classselector:STRING labelselector:MAP",tags:["gts"],since:"1.0.0",OPB64name:"PARSESELECTOR"},PARSEVALUE:{description:"The `PARSEVALUE` function parses a STRING representing a valid value in the Geo Time Series™ input format.\n\nThe underlying implementation being the internal WarpScript function, some of the returned types might not be easily handled in the rest of the calling script. Most notably, some floating point representations might lead to BigDecimal instances being produced.\n\n@param `input` String representation of the value to parse.\n\n@param `value` Parsed value, could be a STRING, LONG, DOUBLE, BIGDECIMAL, BOOLEAN or BYTES elements.\n\n",signature:"PARSEVALUE( input:STRING ): value:ANY",tags:["gts"],since:"2.1.0",OPB64name:"PARSEVALUE"},PARTITION:{description:"The `PARTITION` function splits a Geo Time Series™ list in equivalence classes based on label values.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels` plus all labels with common values among the GTS in the equivalence class.\n\n",signature:"PARTITION( lgts:LIST<GTS> labels:LIST<STRING> ): result:MAP",tags:["gts"],since:"1.0.0",OPB64name:"PARTITION"},PATTERNDETECTION:{description:"The `PATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it\n\n@param `lresult` The list of result GTS\n\n",signature:"PATTERNDETECTION( gts:GTS patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nPATTERNDETECTION( lgts:LIST<GTS> patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNDETECTION"},PATTERNS:{description:"The `PATTERNS` function extracts symbolic patterns (or motifs) from a Geo Time Series™. Those patterns are similar to [iSAX](http://www.cs.ucr.edu/~eamonn/iSAX/iSAX.html) symbols.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `PATTERNS` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",signature:"PATTERNS( gts:GTS wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nPATTERNS( lgts:LIST<GTS> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"PATTERNS"},PEEK:{description:"Displays the top of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"PEEK(): ",tags:["stack"],since:"2.0.0",OPB64name:"PEEK"},PEEKN:{description:"Displays the content of the level of the stack at the given distance from the top.\n\nWhen called outside of interactive mode, does nothing.\n\n@param `distance` Distance (in stack levels) between the top of the stack and the level to display.\n\n",signature:"PEEKN( distance:NUMBER ): ",tags:["stack"],since:"2.0.0",OPB64name:"PEEKN"},PERMUTE:{description:"Permute the dimensions of a nested LIST as if it were a tensor or a multidimensional array.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent before operating. Default to false.\n\n@param `pattern` The permutation pattern (a LIST of LONG).\n\n@param `tensor` The resulting nested LIST.\n\n",signature:"PERMUTE( tensor:LIST pattern:LIST ): tensor:LIST\nPERMUTE( { tensor:LIST pattern:LIST fast:BOOLEAN  } ): tensor:LIST",tags:["lists","tensors"],since:"2.1.0",OPB64name:"PERMUTE"},PFILTER:{description:"Used to select Geo Time Series™ from a larger set. It allows you to extract only those Geo Time Series™ which match some criteria.\n\nWhile some filter are trivial, like selecting by name or labels, the `PFILTER framework allows for advanced filtering using N-ary functions \n(functions which accept N parameters). Returned GTS are grouped by equivalence classes.\n\n@param `filter` Filter function to apply.\n\n@param `labels` Assuming there are N input lists, the filter function will then be called for each partition, each time with N parameters. Each parameter is the list of Geo Time Series™ in the partition which were originally in the i-th list. For input lists which contained a single Geo Time Series™, the singleton will always be passed as parameter, the single Geo Time Series™ was not taken into account for partitioning.\n\n@param `gtsList` One or several lists of Geo Time Series™.\n\n@param `result` A map keyed by the label set of each equivalence class whose values are lists of selected Geo Time Series™ from those lists. The returned Geo Time Series™ are not copies of the original ones, which means that changing the name or labels of the original ones will be reflected in the ones returned by the call to `PFILTER`.\n\n",signature:"PFILTER( [ gtsList:LIST<GTS> labels:LIST<STRING> filter:FILTER ] ): result:MAP",tags:["framework","filter"],since:"1.0.0",OPB64name:"PFILTER"},PGraphics:{description:'Warp 10 includes a large subset of the [Processing](http://www.processing.org) drawing library. You can create and manipulate images, then push a base64 encoded png onto the stack.\n\n+ Step 1: create a processing graphic object with `PGraphics` function.\n+ Step 2: manipulate this object with Processing functions.\n+ Step 3: render the processing graphic with `Pencode` function.\n\nDocumentation of every function has a link to original Processing website. Original website includes more examples for each function.\n\nProcessing functions offers a lot of different signatures for colors. The most efficient is to keep the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n\nUp to Warp 10 1.2.18, antialiasing was not available. It is now available, by appending a digit to the **imgtype** string argument. The maximum anti-aliasing level is determined by the hardware of the machine that is running the software, so 2D4 and 2D8 mode will not work with every computer.\n\n+ "2D": no antialiasing\n+ "2D2": bilinear smoothing\n+ "2D3": bicubic smoothing\n+ "2D4": 4x antialiasing\n+ "2D8": 8x antialiasing\n\n\nYou can adjust the maximal number of pixel allowed in Warp 10 configuration file.\n\n@param `imgtype` \'2D\', \'3D\', or \'2Dx\', where x is the level of anti aliasing (2, 3, 4, or 8).\n\n@param `width` Pixel width of the image.\n\n@param `height` Pixel height of the image.\n\n@param `pg` Processing graphic object.\n\n',signature:"PGraphics( width:LONG height:LONG imgtype:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PGraphics"},PI:{description:"Alias of [pi](/doc/R5Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",signature:"PI(): pi:DOUBLE",tags:["math","constants"],since:"1.0.0",OPB64name:"J3Z"},PICK:{description:"The `PICK` function copies on top of the stack the element at level N. Parameter N is consumed off the top of the stack when `PICK` is called.\n\n@param `level` Level of the stack\n\n@param `result` What is on stack at *level*\n\n",signature:"PICK( level:NUMBER ): result:ANY",tags:["stack"],since:"1.0.0",OPB64name:"PICK"},"PICKLE->":{description:"The `PICKLE->` function decodes some Pickle encoded content contained in a byte array.\nThe conversion is done using [Pyrolite v4](https://github.com/irmen/pickle).\n\nIt can read all pickle protocol versions (0 to 4, so this includes\nthe latest additions made in Python 3.4).\n\n```python\n>>> myobject={ 'apple':3.5,'banana':18 }\n>>> pickle.dumps(myobject).encode(\"hex\")\n'286470300a53276170706c65270a70310a46332e350a73532762616e616e61270a70320a4931380a732e'\n```\n\n@param `input` Byte array of a pickle encoded content\n\n@param `output` Warp 10 object\n\n",signature:"PICKLE->( input:BYTES ): output:ANY",tags:["platform"],since:"1.0.7",OPB64name:"J3_2Hol4AIs"},PIGSCHEMA:{description:"The `PIGSCHEMA` function produces on top of the stack a STRING representing the [Pig](https://en.wikipedia.org/wiki/Pig_(programming_tool)) schema definition for the current stack content.\n\n@param `elt` Stack content.\n\n@param `schema` Schema for the current stack, usable when working with WarpScript in Pig.\n\n",signature:"PIGSCHEMA( elt:ANY* ): elt:ANY* schema:STRING",tags:["pig","stack"],since:"1.2.5",OPB64name:"PIGSCHEMA"},PIVOT:{description:"The `PIVOT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick of GTS from the first list, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n1// C3{C1=C} 2\n2// C4{C2=F} 30\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n4// C3{} 5\n4// C4{} 50\n```\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",signature:"PIVOT( input:LIST<GTS> pivot:LIST<GTS> ): result:LIST<GTS>",tags:["gts"],since:"2.2.0",OPB64name:"PIVOT"},PIVOTSTRICT:{description:"The `PIVOTSTRICT` function generates a set of Geo Time Series™ from two lists of input Geo Time Series™ in a way similar to what [`PIVOT`](/doc/PIVOT) does.\n\nGeo Time Series™ from the first list will provide datapoints (value, location and elevation), and those from the second list will generate labels.\n\nFor each tick common to Geo Time Series™ of both lists, the GTS from the second list are inspected. For each value encountered, a label with the GTS class as name and the encountered value is created.\n\nThen for each GTS from the first list with a value at the given tick, the datapoint is copied to a GTS with the same class name and a set of labels equal to those of that GTS merged with the labels created above.\n\nAs an example, consider the following input:\n\n\n| Tick   |  C1    |   C2   |    C3  |   C4   |\n|--------|--------|--------|--------|--------|\n|   0    |  A     |   B    |    1   |   10   |\n|   1    |  C     |        |    2   |        |\n|   2    |        |   F    |        |   30   |\n|   3    |  A     |   B    |    4   |   40   |\n|   4    |        |        |    5   |   50    |\n\nWith the first list of GTS being those with classes `C3` and `C4` and the second list `C1` and `C2`, the result of the `PIVOTSTRICT` function being applied is:\n\n```\n0// C3{C1=A,C2=B} 1\n0// C4{C1=A,C2=B} 10\n3// C3{C1=A,C2=B} 4\n3// C4{C1=A,C2=B} 40\n```\n\nOnly ticks 0 and 3 appear in the result as those are the only ticks present in both `C1` and `C2`.\n\n@param `pivot` List of Geo Time Series™ to use as the pivots.\n\n@param `input` Input list of Geo Time Series™.\n\n@param `result` List of pivoted Geo Time Series™.\n\n",signature:"PIVOTSTRICT( input:LIST<GTS> pivot:LIST<GTS> ): result:LIST<GTS>",tags:["gts"],since:"2.2.0",OPB64name:"PIVOTSTRICT"},POPR:{description:"Pops a value from the top of the stack and stores it into the designated register.\n\nThe `POPR` function is really a family of functions named `POPRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value to store in the specified register.\n\n",signature:"POPR( value:ANY ): ",tags:["stack"],since:"2.0.0",OPB64name:"POPR"},PREDUCE:{description:"Behaves as [`REDUCE`](/doc/REDUCE) but produces a map of results keyed by the label map of each equivalence class.\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` Map keyed by the label map of each equivalence class and whose values are the Geo Time Series™ produced for each class.\n\n",signature:"PREDUCE( [ gts:LIST<GTS>+ labels:LIST<STRING> reducer:AGGREGATOR ] ): result:MAP",tags:["reducer","framework"],since:"1.0.5",OPB64name:"PREDUCE"},PRNG:{description:"The `PRNG` function initializes the stack's seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator). This PRNG can later be used by the [`SRAND`](/doc/SRAND) function to produce random numbers in a deterministic way (!).\n\n@param `seed` The seed to use for initializing the PRNG.\n\n",signature:"PRNG( seed:LONG ): ",tags:["math"],since:"1.2.9",OPB64name:"PRNG"},PROB:{description:"Computes probability for each value of the input Geo Time Series™.\n\nThe function `PROB` consumes a GTS or a list of the GTS from the top of the stack. It pushes back the probability for each value.\n\nThe probabilities are computed using the value histogram.\n\n@param `gts` The input Geo Time Series™\n\n@param `gtslist` The input list of Geo Time Series™\n\n@param `result` The Geo Time Series™ wit probability for each value\n\n@param `resultList` The List of Geo Time Series™ with probability for each value\n\n",signature:"PROB( gts:GTS ): result:GTS\nPROB( gtslist:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts","statistics"],since:"1.0.6",OPB64name:"PROB"},PROBABILITY:{description:"Pushes on the stack a function which computes probabilities according to a provided value histogram.\n\nTo use the function pushed by `PROBABILITY` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function expects a value on top of the stack and will output the probability of occurrence of this value.\n\n",signature:"PROBABILITY( valueHistogram:MAP ): result:STRING",tags:["math","statistics"],since:"1.0.0",OPB64name:"PROBABILITY"},PSTACK:{description:"When in interactive (REPL) mode, prints the content of the stack.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"",tags:["stack"],since:"2.0.0",OPB64name:"PSTACK"},PUSHR:{description:"Pushes onto the stack the value currently contained in the designated register.\n\nThe `PUSHR` function is really a family of functions named `PUSHRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n@param `value` Value from the designated register.\n\n",signature:"PUSHR(): value:ANY",tags:["stack"],since:"2.0.0",OPB64name:"PUSHR"},PUT:{description:"The `PUT` function inserts a new key-value pair in a map.\nIf the key already exists in the input MAP, the value is replaced by the new one.\n\n`PUT` function puts the reference of the MAP on top of the stack.\n\n@param `newkey` Depending on map construction, could be a number, a string, a boolean\n\n@param `newvalue` Depending on list construction, could be a number, a string, a list, a map, a GTS, a boolean.\n\n@param `inputmap` reference to the map to be modified\n\n@param `outputmap` copy of input map reference. Useful to chain other instructions on the same map.\n\n",signature:"PUT( inputmap:MAP newvalue:ANY newkey:ANY ): outputmap:MAP",tags:["maps"],since:"1.0.0",OPB64name:"PUT"},Palpha:{description:"Extracts the alpha value from a color.\n\nThe `Palpha` function is easy to use and understand, but it is slower than bit shifting... \n\n\n[Link to original Processing doc](https://processing.org/reference/alpha_.html)\n\n@param `color` Any value of the color datatype\n\n@param `alpha` Alpha component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"Palpha( pg:PGRAPHICS color:NUMBER ): pg:PGRAPHICS alpha:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Palpha"},Parc:{description:"Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse defined by the **a**, **b**, **c**, and **d** parameters. The origin of the arc's ellipse may be changed with the [`PellipseMode`](/doc/PellipseMode) function. Use the **start** and **stop** parameters to specify the angles (in radians) at which to draw the arc.\n\n\n\nThere are three ways to draw an arc; the rendering technique used is defined by the optional seventh parameter. The three options, depicted in the examples, are PIE, OPEN, and CHORD. The default mode is the OPEN stroke with a PIE fill.\n\n\n\nIn some cases, the `Parc` function isn't accurate enough for smooth drawing. For example, the shape may jitter on screen when rotating slowly. If you're having an issue with how arcs are rendered, you'll need to draw the arc yourself with [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) or a **PShape**.\n\n\n[Link to original Processing doc](https://processing.org/reference/arc_.html)\n\n@param `b` y-coordinate of the arc's ellipse\n\n@param `a` x-coordinate of the arc's ellipse\n\n@param `c` width of the arc's ellipse by default\n\n@param `d` height of the arc's ellipse by default\n\n@param `start` angle to start the arc, specified in radians\n\n@param `stop` angle to stop the arc, specified in radians\n\n@param `mode` closing mode. either PIE, OPEN, or CHORD\n\n@param `pg` Processing graphic object\n\n",signature:"Parc( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE start:DOUBLE stop:DOUBLE ): pg:PGRAPHICS\nParc( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE start:DOUBLE stop:DOUBLE mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Parc"},Pbackground:{description:"The `Pbackground` function sets the color used for the background of the processing graphics object. \n\nAn image object can also be used as the background for a sketch, although the image's width and height must match that of the processing object. Images used with `Pbackground` will ignore the current [`Ptint`](/doc/Ptint) setting. \n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pbackground` calls internally [`Pcolor`](/doc/Pcolor).\n\n\n[Link to original Processing doc](https://processing.org/reference/background_.html)\n\n@param `argb` any argb color value.\n\n@param `rgb` any rgb color value.\n\n@param `alpha` opacity of the background. 0 = transparent, 255 = opaque.\n\n@param `gray` a value between white (255) and black (0)\n\n@param `image` PImage to set as background (must be same size as pg)\n\n@param `v1` red or hue value (depending on the current color mode)\n\n@param `v2` green or saturation value (depending on the current color mode)\n\n@param `v3` blue or brightness value (depending on the current color mode)\n\n@param `pg` Processing graphic object\n\n",signature:"Pbackground( pg:PGRAPHICS argb:LONG ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS gray:DOUBLE ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS image:PIMAGE ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS rgb:LONG alpha:NUMBER ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS gray:DOUBLE alpha:NUMBER ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS\nPbackground( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pbackground"},PbeginContour:{description:"Use the `PbeginContour` and [`PendContour`](/doc/PendContour) function to create negative shapes within shapes such as the center of the letter 'O'. `PbeginContour` begins recording vertices for the shape and [`PendContour`](/doc/PendContour) stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\n\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a `PbeginContour`/[`PendContour`](/doc/PendContour) pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginContour_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PbeginContour( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PbeginContour"},PbeginShape:{description:"Using the `PbeginShape` and [`PendShape`](/doc/PendShape) functions allow creating more complex forms. `PbeginShape` begins recording vertices for a shape and [`PendShape`](/doc/PendShape) stops recording. \n\nThe value of the **kind** parameter tells it which types of shapes to create from the provided vertices. The parameters available for beginShape() are POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the `PbeginShape` function, a series of [`Pvertex`](/doc/Pvertex) commands must follow. To stop drawing the shape, call [`PendShape`](/doc/PendShape). The [`Pvertex`](/doc/Pvertex) function with two parameters specifies a position in 2D. Each shape will be outlined with the current stroke color and filled with the fill color. \n\n\nTransformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within `PbeginShape`. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within `PbeginShape`. \n\n\nThe P2D and P3D renderers allow [`Pstroke`](/doc/Pstroke) and [`Pfill`](/doc/Pfill) to be altered on a per-vertex group basis. Settings such as [`PstrokeWeight`](/doc/PstrokeWeight), [`PstrokeCap`](/doc/PstrokeCap), and [`PstrokeJoin`](/doc/PstrokeJoin) cannot be changed while inside a `PbeginShape`/[`PendShape`](/doc/PendShape) block with any renderer.\n\nUp to Warp 10 1.2.18, `PbeginShape` could be called without the **kind** parameter. It defaults to POLYGON.\n\n\n[Link to original Processing doc](https://processing.org/reference/beginShape_.html)\n\n@param `kind` Either POLYGON, POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP\n\n@param `pg` Processing graphic object\n\n",signature:"PbeginShape( pg:PGRAPHICS kind:STRING ): pg:PGRAPHICS\nPbeginShape( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PbeginShape"},Pbezier:{description:"Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezier_.html)\n\n@param `x1` coordinates for the first anchor point\n\n@param `y1` coordinates for the first anchor point\n\n@param `z1` coordinates for the first anchor point\n\n@param `x2` coordinates for the first control point\n\n@param `y2` coordinates for the first control point\n\n@param `z2` coordinates for the first control point\n\n@param `x3` coordinates for the second control point\n\n@param `y3` coordinates for the second control point\n\n@param `z3` coordinates for the second control point\n\n@param `x4` coordinates for the second anchor point\n\n@param `y4` coordinates for the second anchor point\n\n@param `z4` coordinates for the second anchor point\n\n@param `pg` Processing graphic object\n\n",signature:"Pbezier( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS\nPbezier( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE z1:DOUBLE x2:DOUBLE y2:DOUBLE z2:DOUBLE x3:DOUBLE y3:DOUBLE z3:DOUBLE x4:DOUBLE y4:DOUBLE z4:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pbezier"},PbezierDetail:{description:"Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the **P3D** renderer; the default **P2D** renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierDetail_.html)\n\n@param `detail` resolution of the curves\n\n@param `pg` Processing graphic object\n\n",signature:"PbezierDetail( pg:PGRAPHICS detail:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PbezierDetail"},PbezierPoint:{description:"Evaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierPoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"PbezierPoint( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PbezierPoint"},PbezierTangent:{description:"Calculates the tangent of a point on a Bezier curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/bezierTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"PbezierTangent( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PbezierTangent"},PbezierVertex:{description:"Specifies vertex coordinates for Bezier curves. Each call to `PbezierVertex` defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PbezierVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only with POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/bezierVertex_.html)\n\n@param `x2` The x-coordinate of the 1st control point\n\n@param `y2` The y-coordinate of the 1st control point\n\n@param `x3` The x-coordinate of the 2nd control point\n\n@param `y3` The y-coordinate of the 2nd control point\n\n@param `x4` The x-coordinate of the anchor point\n\n@param `y4` The y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",signature:"PbezierVertex( pg:PGRAPHICS x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PbezierVertex"},Pblend:{description:"Blends a region of pixels from one image into another (or in itself again) with full alpha channel support.\n\nHere are the available modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n\n+ BLEND - linear interpolation of colours: C = A*factor + B\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - Multiply the colors, result will always be darker.\n+ SCREEN - Opposite multiply, uses inverse values of the colors.\n+ OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values,and screens light values.\n+ HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n+ SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n+ DODGE - Lightens light tones and increases contrast, ignores darks.Called \"Color Dodge\" in Illustrator and Photoshop.\n+ BURN - Darker areas are applied, increasing contrast, ignores lights.Called \"Color Burn\" in Illustrator and Photoshop.\n\nAll modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the **src** parameter is not used, the display window is used as the source image.\n\n[Link to original Processing doc](https://processing.org/reference/blend_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `mode` Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n\n@param `pg` Processing graphic object\n\n",signature:"Pblend( pg:PGRAPHICS src:PIMAGE sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG mode:STRING ): pg:PGRAPHICS\nPblend( pg:PGRAPHICS sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pblend"},PblendMode:{description:"Blends the pixels in the display window according to a defined mode. \n\nHere are the available modes to blend the source pixels (A) with the ones of pixels already in the display window (B). \n\n+ BLEND - linear interpolation of colours: C = A*factor + B. This is the default blending mode.\n+ ADD - additive blending with white clip: C = min(A*factor + B, 255)\n+ SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n+ DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n+ LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n+ DIFFERENCE - subtract colors from underlying image.\n+ EXCLUSION - similar to DIFFERENCE, but less extreme.\n+ MULTIPLY - multiply the colors, result will always be darker.\n+ SCREEN - opposite multiply, uses inverse values of the colors.\n+ REPLACE - the pixels entirely replace the others and don't utilize alpha (transparency) values\n\nA pixel's final color is the result of applying one of the above blend modes with each channel of (A) and (B) independently. For example, red is compared with red, green with green, and blue with blue.\n\nWe recommend using `PblendMode` and not the previous [`Pblend`](/doc/Pblend) function. However, unlike [`Pblend`](/doc/Pblend), the `PblendMode` function does not support the following: HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN. On older hardware, the LIGHTEST, DARKEST, and DIFFERENCE modes might not be available as well. \n\n[Link to original Processing doc](https://processing.org/reference/blendMode_.html)\n\n@param `mode` The blending mode to use\n\n@param `pg` Processing graphic object\n\n",signature:"PblendMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PblendMode"},Pblue:{description:"Extracts the blue value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pblue` function is easy to use and understand, but it is slower than bit masking. \n\n\n[Link to original Processing doc](https://processing.org/reference/blue_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `blue` Blue component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"Pblue( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS blue:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pblue"},Pbox:{description:"A box is an extruded rectangle. A box with equal dimensions on all sides is a cube.\n\n\n[Link to original Processing doc](https://processing.org/reference/box_.html)\n\n@param `size` dimension of the box in all dimensions (creates a cube)\n\n@param `w` dimension of the box in the x-dimension\n\n@param `h` dimension of the box in the y-dimension\n\n@param `d` dimension of the box in the z-dimension\n\n@param `pg` Processing graphic object\n\n",signature:"Pbox( pg:PGRAPHICS size:NUMBER ): pg:PGRAPHICS\nPbox( pg:PGRAPHICS w:NUMBER h:NUMBER d:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pbox"},Pbrightness:{description:"Extracts the brightness value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/brightness_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `brightness` Brightness component of input color\n\n@param `pg` Processing graphic object\n\n",signature:"Pbrightness( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS brightness:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pbrightness"},Pclear:{description:"Clears the pixels. This function clears everything in a **PGraphics** object to make all of the pixels 100% transparent.\n\n\n[Link to original Processing doc](https://processing.org/reference/clear_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"Pclear( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pclear"},Pclip:{description:"Limits the rendering to the boundaries of a rectangle defined by the parameters. The boundaries are drawn based on the state of the [`PimageMode`](/doc/PimageMode) function, either CORNER, CORNERS, or CENTER. \n\n\n[Link to original Processing doc](https://processing.org/reference/clip_.html)\n\n@param `a` x-coordinate of the rectangle, by default\n\n@param `b` y-coordinate of the rectangle, by default\n\n@param `c` width of the rectangle, by default\n\n@param `d` height of the rectangle, by default\n\n@param `pg` Processing graphic object\n\n",signature:"Pclip( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pclip"},Pcolor:{description:"`Pcolor` creates colors for storing in ARGB LONG datatype.\n\n+ RGB: The most efficient is to skip Pcolor function, using the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque.\n+ HSB: For Hue Saturation Brightness to RGB conversion, use [`PcolorMode`](/doc/PcolorMode) to specify HSB, then use Pcolor to convert to ARGB.\n\nThe parameters are interpreted as RGB or HSB values depending on the current [`PcolorMode`](/doc/PcolorMode). The default mode is RGB values from 0 to 255.\n\nNote that if only one value is provided to `Pcolor`, it will be interpreted as a grayscale value. Add a second value, and it will be used for alpha transparency. When three values are specified, they are interpreted as either RGB or HSB values. Adding a fourth value applies alpha transparency.\n\n\n[Link to original Processing doc](https://processing.org/reference/color_.html)\n\n@param `gray` int: number specifying value between white and black\n\n@param `alpha` float, or int: relative to current color range\n\n@param `v1` float, or int: red or hue values relative to the current color range\n\n@param `v2` float, or int: green or saturation values relative to the current color range\n\n@param `v3` float, or int: blue or brightness values relative to the current color range\n\n@param `color` ARGB color.\n\n@param `pg` Processing graphic object\n\n",signature:"Pcolor( pg:PGRAPHICS gray:NUMBER ): pg:PGRAPHICS color:LONG\nPcolor( pg:PGRAPHICS gray:NUMBER alpha:NUMBER ): pg:PGRAPHICS color:LONG\nPcolor( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS color:LONG\nPcolor( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS color:LONG",tags:["processing"],since:"1.0.0",OPB64name:"Pcolor"},PcolorMode:{description:"Changes the way Processing interprets color data. By default, the parameters for [`Pfill`](/doc/Pfill), [`Pstroke`](/doc/Pstroke), [`Pbackground`](/doc/Pbackground), and [`Pcolor`](/doc/Pcolor) are defined by values between 0 and 255 using the RGB color model. The `PcolorMode` function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling **colorMode(RGB, 1.0)** will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters **max**, **max1**, **max2**, **max3**, and **maxA**.\n\nWhen using max different from default values, do not work with grayscale.\n\nAfter changing the range of values for colors with code like **colorMode(HSB, 360, 100, 100)**, those ranges remain in use until they are explicitly changed again. For example, after running **colorMode(HSB, 360, 100, 100)** and then changing back to **colorMode(RGB)**, the range for R will be 0 to 360 and the range for G and B will be 0 to 100. To avoid this, be explicit about the ranges when changing the color mode. For instance, instead of **colorMode(RGB)**, write **colorMode(RGB, 255, 255, 255)**. \n\n\n[Link to original Processing doc](https://processing.org/reference/colorMode_.html)\n\n@param `mode` Either 'RGB' or 'HSB', corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n\n@param `max` range for all color elements\n\n@param `max1` range for the red or hue depending on the current color mode\n\n@param `max2` range for the green or saturation depending on the current color mode\n\n@param `max3` range for the blue or brightness depending on the current color mode\n\n@param `maxA` range for the alpha\n\n@param `pg` Processing graphic object\n\n",signature:"PcolorMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS\nPcolorMode( pg:PGRAPHICS mode:STRING max:DOUBLE ): pg:PGRAPHICS\nPcolorMode( pg:PGRAPHICS mode:STRING max1:DOUBLE max2:DOUBLE max3:DOUBLE ): pg:PGRAPHICS\nPcolorMode( pg:PGRAPHICS mode:STRING max1:DOUBLE max2:DOUBLE max3:DOUBLE maxA:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PcolorMode"},Pconstrain:{description:"Constrains a value to not exceed a maximum and minimum value. Also known as clamping a value. \n\nIt could be done with warpscript MIN MAX functions, see example.\n\n[Link to original Processing doc](https://processing.org/reference/constrain_.html)\n\n@param `x` The value to clamp.\n\n@param `low` Minimum limit.\n\n@param `high` Maximum limit.\n\n@param `clamped` Clamped value of x in [low high] range.\n\n@param `pg` Processing graphic object\n\n",signature:"Pconstrain( pg:PGRAPHICS x:DOUBLE low:DOUBLE high:DOUBLE ): pg:PGRAPHICS clamped:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pconstrain"},Pcopy:{description:"Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an image used as the **src** parameter into the display window. If the source and destination regions are not the same size, it will automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/copy_.html)\n\n@param `src` A PIMAGE object referring to the source image. If none, blend the existing image on itself.\n\n@param `sx` X coordinate of the source's upper left corner\n\n@param `sy` Y coordinate of the source's upper left corner\n\n@param `sw` source image width\n\n@param `sh` source image height\n\n@param `dx` X coordinate of the destinations's upper left corner\n\n@param `dy` Y coordinate of the destinations's upper left corner\n\n@param `dw` destination image width\n\n@param `dh` destination image height\n\n@param `img` PIMAGE object, copy of pg\n\n@param `pg` Processing graphic object\n\n",signature:"Pcopy( pg:PGRAPHICS src:PIMAGE sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG ): pg:PGRAPHICS\nPcopy( pg:PGRAPHICS sx:LONG sy:LONG sw:LONG sh:LONG dx:LONG dy:LONG dw:LONG dh:LONG ): pg:PGRAPHICS\nPcopy( pg:PGRAPHICS ): pg:PGRAPHICS img:PIMAGE",tags:["processing"],since:"1.0.0",OPB64name:"Pcopy"},PcreateFont:{description:"Dynamically converts a font to the format used by Processing from a font that is installed on the computer.  Not all fonts can be used and some might work with one operating system and not others.\n\nThe **size** parameter states the font size you want to generate. The **smooth** parameter specifies if the font should be antialiased or not.\n\nSince the 2.5.0 version, the name of the font can be a URI to a OpenType or Type1 font which will be resolved by a macro defined by the `processing.font.resolver` configuration.\n\n[Link to original Processing doc](https://processing.org/reference/createFont_.html)\n\n@param `name` Name of the font to load or URI from where to load the font.\n\n@param `size` Point size of the font\n\n@param `smooth` True for an antialiased font, false for aliased\n\n@param `charset` subset of ascii characters to be generated.\n\n@param `font` Processing font object compatible with PtextFont.\n\n@param `pg` Processing graphic object\n\n",signature:"PcreateFont( pg:PGRAPHICS name:STRING ): pg:PGRAPHICS font:PFONT\nPcreateFont( pg:PGRAPHICS name:STRING size:NUMBER ): pg:PGRAPHICS font:PFONT\nPcreateFont( pg:PGRAPHICS name:STRING size:NUMBER smooth:BOOLEAN ): pg:PGRAPHICS font:PFONT\nPcreateFont( pg:PGRAPHICS name:STRING size:NUMBER smooth:BOOLEAN charset:STRING ): pg:PGRAPHICS font:PFONT",tags:["processing"],since:"1.0.0",OPB64name:"PcreateFont"},Pcurve:{description:"Draws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of `Pcurve` functions together or using [`PcurveVertex`](/doc/PcurveVertex). An additional function called [`PcurveTightness`](/doc/PcurveTightness) provides control for the visual quality of the curve. The `Pcurve` function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n\n[Link to original Processing doc](https://processing.org/reference/curve_.html)\n\n@param `x1` float: coordinates for the beginning control point\n\n@param `y1` float: coordinates for the beginning control point\n\n@param `x2` float: coordinates for the first point\n\n@param `y2` float: coordinates for the first point\n\n@param `x3` float: coordinates for the second point\n\n@param `y3` float: coordinates for the second point\n\n@param `x4` float: coordinates for the ending control point\n\n@param `y4` float: coordinates for the ending control point\n\n@param `z1` float: coordinates for the beginning control point\n\n@param `z2` float: coordinates for the first point\n\n@param `z3` float: coordinates for the second point\n\n@param `z4` float: coordinates for the ending control point\n\n@param `pg` Processing graphic object\n\n",signature:"Pcurve( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS\nPcurve( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE z1:DOUBLE x2:DOUBLE y2:DOUBLE z2:DOUBLE x3:DOUBLE y3:DOUBLE z3:DOUBLE x4:DOUBLE y4:DOUBLE z4:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pcurve"},PcurveDetail:{description:"Sets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveDetail_.html)\n\n@param `detail` Resolution of the curves\n\n@param `pg` Processing graphic object\n\n",signature:"PcurveDetail( pg:PGRAPHICS detail:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PcurveDetail"},PcurvePoint:{description:"Evaluates the curve at point **t** for points **a**, **b**, **c**, **d**. The parameter **t** may range from 0 (the start of the curve) and 1 (the end of the curve). **a** and **d** are points on the curve, and **b** and **c** are the control points. This can be used once with the **x** coordinates and a second time with the **y** coordinates to get the location of a curve at **t**.\n\n\n[Link to original Processing doc](https://processing.org/reference/curvePoint_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of second point on the curve\n\n@param `c` coordinate of third point on the curve\n\n@param `d` coordinate of fourth point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"PcurvePoint( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PcurvePoint"},PcurveTangent:{description:"Calculates the tangent of a point on a curve. There's a good definition of [**tangent** on Wikipedia](http://en.wikipedia.org/wiki/Tangent).\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTangent_.html)\n\n@param `a` coordinate of first point on the curve\n\n@param `b` coordinate of first control point\n\n@param `c` coordinate of second control point\n\n@param `d` coordinate of second point on the curve\n\n@param `t` value between 0 and 1\n\n@param `out` interpolation result\n\n@param `pg` Processing graphic object\n\n",signature:"PcurveTangent( pg:PGRAPHICS a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE t:DOUBLE ): pg:PGRAPHICS out:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTangent"},PcurveTightness:{description:"Modifies the quality of forms created with [`Pcurve`](/doc/Pcurve) and [`PcurveVertex`](/doc/PcurveVertex). The parameter **tightness** determines how the curve fits to the vertex points. The value 0.0 is the default value for **tightness** (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.\n\n\n[Link to original Processing doc](https://processing.org/reference/curveTightness_.html)\n\n@param `tightness` Amount of deformation from the original vertices\n\n@param `pg` Processing graphic object\n\n",signature:"PcurveTightness( pg:PGRAPHICS tightness:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PcurveTightness"},PcurveVertex:{description:"Specifies vertex coordinates for curves. This function may only be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when POLYGON parameter specified to [`PbeginShape`](/doc/PbeginShape). The first and last points in a series of `PcurveVertex` lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with `PcurveVertex` will draw the curve between the second, third, and fourth points. The `PcurveVertex` function is an implementation of Catmull-Rom splines. \n\n[Link to original Processing doc](https://processing.org/reference/curveVertex_.html)\n\n@param `x` The x-coordinate of the vertex\n\n@param `y` The y-coordinate of the vertex\n\n@param `z` The z-coordinate of the vertex\n\n@param `pg` Processing graphic object\n\n",signature:"PcurveVertex( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPcurveVertex( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PcurveVertex"},Pdecode:{description:"`Pdecode` takes the image representation on the stack and pushes a Pimage object on the stack. This object can only be used as an input for [`Pset`](/doc/Pset), [`Pimage`](/doc/Pimage), [`Pbackground`](/doc/Pbackground).\n\nInput string must start with the header `data:image/png;base64,`.\n\nSupported input types: PNG, GIF, JPG.\n\n@param `img` Processing Pimage object.\n\n@param `rawimg` Image bytes.\n\n@param `b64img` Base64 encoded image string\n\n",signature:"Pdecode( b64img:STRING ): img:PIMAGE\nPdecode( rawimg:BYTES ): img:PIMAGE",tags:["processing"],since:"1.0.0",OPB64name:"Pdecode"},Pdist:{description:"Calculates the distance between two points, in 2D or 3D space.\n\n\n[Link to original Processing doc](https://processing.org/reference/dist_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `z1` z-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",signature:"Pdist( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE z1:DOUBLE x2:DOUBLE y2:DOUBLE z2:DOUBLE ): pg:PGRAPHICS\nPdist( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pdist"},Pellipse:{description:"Draws an ellipse (oval) to the screen. An ellipse with equal width and height is a circle. By default, the first two parameters set the location, and the third and fourth parameters set the shape's width and height. The origin may be changed with the [`PellipseMode`](/doc/PellipseMode) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/ellipse_.html)\n\n@param `a` float: x-coordinate of the ellipse\n\n@param `b` float: y-coordinate of the ellipse\n\n@param `c` float: width of the ellipse by default\n\n@param `d` float: height of the ellipse by default\n\n@param `pg` Processing graphic object\n\n",signature:"Pellipse( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pellipse"},PellipseMode:{description:"Modifies the location from which ellipses are drawn by changing the way in which parameters given to [`Pellipse`](/doc/Pellipse) are intepreted.\n\nThe default mode is **ellipseMode(CENTER)**, which interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**ellipseMode(RADIUS)** also uses the first two parameters of [`Pellipse`](/doc/Pellipse) as the shape's center point, but uses the third and fourth parameters to specify half of the shapes's width and height.\n\n**ellipseMode(CORNER)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**ellipseMode(CORNERS)** interprets the first two parameters of [`Pellipse`](/doc/Pellipse) as the location of one corner of the ellipse's bounding box, and the third and fourth parameters as the location of the opposite corner.\n\n[Link to original Processing doc](https://processing.org/reference/ellipseMode_.html)\n\n@param `mode` Either CENTER, RADIUS, CORNER, or CORNERS\n\n@param `pg` Processing graphic object\n\n",signature:"PellipseMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PellipseMode"},Pencode:{description:"`Pencode` function takes a processing graphic object on the top of the stack, render it to a png file, encode it in base64, prefix the result with the standard png header \"data:image/png;base64,\".\n\nThe resulting string is ready to use in an html document.\n\n@param `pg` Processing graphic object.\n\n@param `b64img` Base64 encoded image string, ready to use in an html page.\n\n@param `metadata` Map of metadata to add to the PNG. Accepted keys are 'tEXt', 'zTXt' and 'iTXt', while values are lists of maps with 'keyword' and 'text' keys.\n\n",signature:"Pencode( pg:PGRAPHICS ): b64img:STRING\nPencode( pg:PGRAPHICS metadata:MAP ): b64img:STRING",tags:["processing"],since:"1.0.0",OPB64name:"Pencode"},PendContour:{description:"Use the [`PbeginContour`](/doc/PbeginContour) and `PendContour` function to create negative shapes within shapes such as the center of the letter 'O'. [`PbeginContour`](/doc/PbeginContour) begins recording vertices for the shape and `PendContour` stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counterclockwise.\n\nThese functions can only be used within a [`PbeginShape`](/doc/PbeginShape)/[`PendShape`](/doc/PendShape) pair and transformations such as [`Ptranslate`](/doc/Ptranslate), [`Protate`](/doc/Protate), and [`Pscale`](/doc/Pscale) do not work within a [`PbeginContour`](/doc/PbeginContour)/`PendContour` pair. It is also not possible to use other shapes, such as [`Pellipse`](/doc/Pellipse) or [`Prect`](/doc/Prect) within.\n\n[Link to original Processing doc](https://processing.org/reference/endContour_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PendContour( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PendContour"},PendShape:{description:"The `PendShape` function is the companion to [`PbeginShape`](/doc/PbeginShape) and may only be called after [`PbeginShape`](/doc/PbeginShape). When `Pendshape` is called, all of image data defined since the previous call to [`PbeginShape`](/doc/PbeginShape) is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end). \n\nUp to Warp 10 1.2.18, `PendShape` could be called without the **mode** parameter. It defaults to OPEN.\n\n[Link to original Processing doc](https://processing.org/reference/endShape_.html)\n\n@param `mode` Use CLOSE to close the shape, OPEN otherwise.\n\n@param `pg` Processing graphic object\n\n",signature:"PendShape( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS\nPendShape( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PendShape"},Pfill:{description:'Sets the color used to fill shapes. For example, if you run **fill(204, 102, 0)**, all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current [`PcolorMode`](/doc/PcolorMode). The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\nThe value for the "gray" parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\nTo change the color of an image or a texture, use [`Ptint`](/doc/Ptint).\n\n[Link to original Processing doc](https://processing.org/reference/fill_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n',signature:"Pfill( pg:PGRAPHICS argb:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS gray:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS argb:LONG alpha:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS v1:LONG v2:LONG v3:LONG ): pg:PGRAPHICS\nPfill( pg:PGRAPHICS v1:LONG v2:LONG v3:LONG alpha:LONG ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pfill"},Pfilter:{description:"Filters the display window using a preset filter or with a custom shader. Using a shader with `Pfilter` is much faster than without. Shaders require the P2D or P3D renderer in size().\n\n\nThe presets options are:\n\n+ **THRESHOLD** Converts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The parameter must be between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n+ **GRAY** Converts any colors in the image to grayscale equivalents. No parameter is used.\n+ **OPAQUE** Sets the alpha channel to entirely opaque. No parameter is used.\n+ **INVERT** Sets each pixel to its inverse value. No parameter is used.\n+ **POSTERIZE** Limits each channel of the image to the number of colors specified as the parameter. The parameter can be set to values between 2 and 255, but results are most noticeable in the lower ranges.\n+ **BLUR** Executes a Guassian blur with the level parameter specifying the extent of the blurring. If no parameter is used, the blur is equivalent to Guassian blur of radius 1. Larger values increase the blur.\n+ **ERODE** Reduces the light areas. No parameter is used.\n+ **DILATE** Increases the light areas. No parameter is used.\n\n\n[Link to original Processing doc](https://processing.org/reference/filter_.html)\n\n@param `kind` Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE\n\n@param `param` unique for each, see above\n\n@param `pg` Processing graphic object\n\n",signature:"Pfilter( pg:PGRAPHICS kind:STRING ): pg:PGRAPHICS\nPfilter( pg:PGRAPHICS kind:STRING param:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.2.17",OPB64name:"J5OdQ6G_RV"},Pget:{description:"Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned (same as `Pcopy`). Use the **x** and **y** parameters to get the value of one pixel. Get a section of the display window by specifying additional **w** and **h** parameters. When getting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\nIf the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with **colorMode(HSB)**, the numbers returned will be in RGB format.\n\nGetting the color of a single pixel with **get(x, y)** is easy, but not as fast as grabbing the data directly from [`Ppixels`](/doc/Ppixels).\n\n[Link to original Processing doc](https://processing.org/reference/get_.html)\n\n@param `x` int: x-coordinate of the pixel\n\n@param `y` int: y-coordinate of the pixel\n\n@param `w` int: width of pixel rectangle to get\n\n@param `h` int: height of pixel rectangle to get\n\n@param `img` PIMAGE object\n\n@param `color` Color of the pixel, 32bits ARGB format.\n\n@param `pg` Processing graphic object\n\n",signature:"Pget( pg:PGRAPHICS ): pg:PGRAPHICS img:PIMAGE\nPget( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS color:LONG\nPget( pg:PGRAPHICS x:NUMBER y:NUMBER w:NUMBER h:NUMBER ): pg:PGRAPHICS img:PIMAGE",tags:["processing"],since:"1.0.0",OPB64name:"Pget"},Pgreen:{description:"Extracts the green value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pgreen` function is easy to use and understand, but it is slower than bit shifting. \n\n\n[Link to original Processing doc](https://processing.org/reference/green_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `green` Green component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"Pgreen( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS green:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pgreen"},Phue:{description:"Extracts the hue value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/hue_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `hue` Hue component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",signature:"Phue( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS hue:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Phue"},Pimage:{description:"The `Pimage` function draws a Pimage (see [`Pdecode`](/doc/Pdecode)) on a PGraphic object.\n\nThe **img** parameter specifies the image to display and by default the **a** and **b** parameters define the location of its upper-left corner. The image is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PimageMode`](/doc/PimageMode) function can be used to change the way these parameters draw the image.\n\nThe color of an image may be modified with the [`Ptint`](/doc/Ptint) function. This function will maintain transparency for GIF and PNG images.\n\n[Link to original Processing doc](https://processing.org/reference/image_.html)\n\n@param `img` PImage: the image to display\n\n@param `a` float: x-coordinate of the image by default\n\n@param `b` float: y-coordinate of the image by default\n\n@param `c` float: width to display the image by default\n\n@param `d` float: height to display the image by default\n\n@param `pg` Processing graphic object\n\n",signature:"Pimage( pg:PGRAPHICS img:PIMAGE a:NUMBER b:NUMBER ): pg:PGRAPHICS\nPimage( pg:PGRAPHICS img:PIMAGE a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pimage"},PimageMode:{description:"Modifies the location from which images are drawn by changing the way in which parameters given to [`Pimage`](/doc/Pimage) are intepreted.\n\nThe default mode is **imageMode(CORNER)**, which interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the upper-left corner of the image. If two additional parameters are specified, they are used to set the image's width and height.\n\n**imageMode(CENTER)** interprets the second and third parameters of [`Pimage`](/doc/Pimage) as the image's center point. If two additional parameters are specified, they are used to set the image's width and height.\n\n\n[Link to original Processing doc](https://processing.org/reference/imageMode_.html)\n\n@param `mode` could be CORNER or CENTER\n\n@param `pg` Processing graphic object\n\n",signature:"PimageMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PimageMode"},Plerp:{description:"Calculates a number between two numbers at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for creating motion along a straight path and for drawing dotted lines, or any linear interpolation.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerp_.html)\n\n@param `start` first value\n\n@param `stop` second value\n\n@param `amt` float between 0.0 and 1.0\n\n@param `pg` Processing graphic object\n\n",signature:"Plerp( pg:PGRAPHICS start:NUMBER stop:NUMBER amt:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Plerp"},PlerpColor:{description:"Calculates a color between two colors at a specific increment. The **amt** parameter is the amount to interpolate between the two values where 0.0 is equal to the first point, 0.1 is very near the first point, 0.5 is halfway in between, etc. \n\nAn amount below 0 will be treated as 0. Likewise, amounts above 1 will be capped at 1. This is different from the behavior of `Plerp`, but necessary because otherwise numbers outside the range will produce strange and unexpected colors.\n\n\n[Link to original Processing doc](https://processing.org/reference/lerpColor_.html)\n\n@param `c1` interpolate from this color\n\n@param `c2` interpolate to this color\n\n@param `amt` between 0.0 and 1.0\n\n@param `outcolor` the interpolated result\n\n@param `pg` Processing graphic object\n\n",signature:"PlerpColor( pg:PGRAPHICS c1:NUMBER c2:NUMBER amt:NUMBER ): pg:PGRAPHICS outcolor:LONG",tags:["processing"],since:"1.0.0",OPB64name:"PlerpColor"},Pline:{description:"Draws a line (a direct path between two points) to the screen. The version of `Pline` with four parameters draws the line in 2D.  To color a line, use the [`Pstroke`](/doc/Pstroke) function. A line cannot be filled, therefore the [`Pfill`](/doc/Pfill) function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the [`PstrokeWeight`](/doc/PstrokeWeight) function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the **z** parameter requires the P3D parameter.\n\n\n[Link to original Processing doc](https://processing.org/reference/line_.html)\n\n@param `x1` x-coordinate of the first point\n\n@param `y1` y-coordinate of the first point\n\n@param `x2` x-coordinate of the second point\n\n@param `y2` y-coordinate of the second point\n\n@param `z1` z-coordinate of the first point\n\n@param `z2` z-coordinate of the second point\n\n@param `pg` Processing graphic object\n\n",signature:"Pline( pg:PGRAPHICS x1:NUMBER y1:NUMBER x2:NUMBER y2:NUMBER ): pg:PGRAPHICS\nPline( pg:PGRAPHICS x1:NUMBER y1:NUMBER z1:NUMBER x2:NUMBER y2:NUMBER z2:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pline"},PloadShape:{description:"`PloadShape` can load a [SVG image](https://en.wikipedia.org/wiki/Scalable_Vector_Graphics) and return a PSHAPE object. WarpScript does not support [OBJ files](https://en.wikipedia.org/wiki/Wavefront_.obj_file) yet. \n\nThis feature is experimental, some files may render empty. \n\n@param `svg` A one line or a multiline SVG string.\n\n@param `Pshape` A PSHAPE object which can be used with Pshape.\n\n",signature:"PloadShape( svg:STRING ): Pshape:PSHAPE",tags:["processing"],since:"1.2.18",OPB64name:"PloadShape"},Pmag:{description:'Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly used in computer graphics and linear algebra. Because it has no "start" position, the magnitude of a vector can be thought of as the distance from the coordinate 0,0 to its x,y value. Therefore, `Pmag` is a shortcut for writing **0 0 x y Pdist**. It is exactly the same as warpscript function [`HYPOT`](/doc/HYPOT).\n\n3D is not yet supported.\n\n[Link to original Processing doc](https://processing.org/reference/mag_.html)\n\n@param `a` first value\n\n@param `b` second value\n\n@param `mag` result\n\n@param `pg` Processing graphic object\n\n',signature:"Pmag( pg:PGRAPHICS a:NUMBER b:NUMBER ): pg:PGRAPHICS mag:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pmag"},Pmap:{description:"Re-maps a number from one range to another.\n\nIn the first example, the number 25 is converted from a value in the range of 0 to 100 into a value that ranges from the left edge of the window (0) to the right edge (width).\n\n\nAs shown in the second example, numbers outside of the range are not clamped to the minimum and maximum parameters values, because out-of-range values are often intentional and useful.\n\n\n[Link to original Processing doc](https://processing.org/reference/map_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start1` lower bound of the value's current range\n\n@param `stop1` upper bound of the value's current range\n\n@param `start2` lower bound of the value's target range\n\n@param `stop2` upper bound of the value's target range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",signature:"Pmap( pg:PGRAPHICS value:DOUBLE start1:DOUBLE stop1:DOUBLE start2:DOUBLE stop2:DOUBLE ): pg:PGRAPHICS output:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pmap"},Pmask:{description:"The `Pmask` function copies the blue channel of an image to the alpha channel of an other.\n\nAs **PGRAPHICS** intances are alse **PIMAGE** instances, you can use this fonction with **PGRAPHICS**.\n\n@param `orginal_img` PImage to be masked\n\n@param `mask_image` Pimage to serve as mask\n\n@param `masked_image` Masked Pimage\n\n@param `orginal_grp` PGraphics to be masked\n\n@param `mask_grp` PGraphics to serve as mask\n\n@param `masked_grp` Masked PGraphics\n\n",signature:"Pmask( mask_image:PIMAGE orginal_img:PIMAGE ): masked_image:PIMAGE\nPmask( mask_image:PIMAGE orginal_grp:PGRAPHICS ): masked_grp:PGRAPHICS\nPmask( mask_grp:PGRAPHICS orginal_img:PIMAGE ): masked_image:PIMAGE\nPmask( mask_grp:PGRAPHICS orginal_grp:PGRAPHICS ): masked_grp:PGRAPHICS",tags:["processing"],since:"2.7.0",OPB64name:"Pmask"},PnoClip:{description:"Disables the clipping previously started by the [`Pclip`](/doc/Pclip) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/noClip_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PnoClip( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PnoClip"},PnoFill:{description:"Disables filling geometry. If both [`PnoStroke`](/doc/PnoStroke) and `PnoFill` are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noFill_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PnoFill( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PnoFill"},PnoStroke:{description:"Disables drawing the stroke (outline). If both `PnoStroke` and [`PnoFill`](/doc/PnoFill) are called, nothing will be drawn to the screen.\n\n\n[Link to original Processing doc](https://processing.org/reference/noStroke_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PnoStroke( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PnoStroke"},PnoTint:{description:"Removes the current fill value for displaying images and reverts to displaying images with their original hues.\n\n\n[Link to original Processing doc](https://processing.org/reference/noTint_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PnoTint( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PnoTint"},Pnorm:{description:"Normalizes a number from another range into a value between 0 and 1. Identical to `value low high 0 1 Pmap`.\n\nNumbers outside of the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. \n\n\n[Link to original Processing doc](https://processing.org/reference/norm_.html)\n\n@param `value` the incoming value to be converted\n\n@param `start` lower bound of the value's current range\n\n@param `stop` upper bound of the value's current range\n\n@param `output` linear interpolation of value between specified ranges\n\n@param `pg` Processing graphic object\n\n",signature:"Pnorm( pg:PGRAPHICS value:NUMBER start:NUMBER stop:NUMBER ): pg:PGRAPHICS output:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pnorm"},Ppixels:{description:"Returns an array containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. After **pixels** has been modified, the [`PupdatePixels`](/doc/PupdatePixels) function must be run to update the content of the display window.\n\n\n[Link to original Processing doc](https://processing.org/reference/pixels.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",signature:"Ppixels( pg:PGRAPHICS ): pg:PGRAPHICS pixels:LIST<LONG>\nPpixels( img:PIMAGE ): img:PIMAGE pixels:LIST<LONG>",tags:["processing"],since:"1.0.0",OPB64name:"Ppixels"},Ppoint:{description:"Draws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point.\n\nUse [`Pstroke`](/doc/Pstroke) to set the color of a `Ppoint`.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight.\n\n\n[Link to original Processing doc](https://processing.org/reference/point_.html)\n\n@param `x` x-coordinate of the point\n\n@param `y` y-coordinate of the point\n\n@param `z` z-coordinate of the point\n\n@param `pg` Processing graphic object\n\n",signature:"Ppoint( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPpoint( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Ppoint"},PpopMatrix:{description:"Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The [`PpushMatrix`](/doc/PpushMatrix) function saves the current coordinate system to the stack and `PpopMatrix` restores the prior coordinate system. [`PpushMatrix`](/doc/PpushMatrix) and `PpopMatrix` are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/popMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PpopMatrix( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PpopMatrix"},PpopStyle:{description:"The [`PpushStyle`](/doc/PpushStyle) function saves the current style settings and `PpopStyle` restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with [`PpushStyle`](/doc/PpushStyle), it builds on the current style information. The [`PpushStyle`](/doc/PpushStyle) and `PpopStyle` functions can be nested to provide more control (see example for a demonstration.)\n\n\n[Link to original Processing doc](https://processing.org/reference/popStyle_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PpopStyle( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PpopStyle"},PpushMatrix:{description:"Pushes the current transformation matrix onto the matrix stack. Understanding `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) requires understanding the concept of a matrix stack. The `PpushMatrix` function saves the current coordinate system to the stack and [`PpopMatrix`](/doc/PpopMatrix) restores the prior coordinate system. `PpushMatrix` and [`PpopMatrix`](/doc/PpopMatrix) are used in conjuction with the other transformation functions and may be nested to control the scope of the transformations.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PpushMatrix( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PpushMatrix"},PpushStyle:{description:"The `PpushStyle` function saves the current style settings and [`PpopStyle`](/doc/PpopStyle) restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with `PpushStyle`, it builds on the current style information. The `PpushStyle` and [`PpopStyle`](/doc/PpopStyle) functions can be nested to provide more control. (See example for a demonstration.)\n\n\nThe style information controlled by the following functions are included in the style:fill, stroke, tint, strokeWeight, strokeCap, strokeJoin, imageMode, rectMode, ellipseMode, shapeMode, colorMode, textAlign, textFont, textMode, textSize, textLeading, emissive, specular, shininess, ambient.\n\n\n[Link to original Processing doc](https://processing.org/reference/pushStyle_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PpushStyle( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PpushStyle"},Pquad:{description:"A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n\n\n[Link to original Processing doc](https://processing.org/reference/quad_.html)\n\n@param `x1` float: x-coordinate of the first corner\n\n@param `y1` float: y-coordinate of the first corner\n\n@param `x2` float: x-coordinate of the second corner\n\n@param `y2` float: y-coordinate of the second corner\n\n@param `x3` float: x-coordinate of the third corner\n\n@param `y3` float: y-coordinate of the third corner\n\n@param `x4` float: x-coordinate of the fourth corner\n\n@param `y4` float: y-coordinate of the fourth corner\n\n@param `pg` Processing graphic object\n\n",signature:"Pquad( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE x4:DOUBLE y4:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pquad"},PquadraticVertex:{description:"Specifies vertex coordinates for quadratic Bezier curves. Each call to `PquadraticVertex` defines the position of one control point and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time `PquadraticVertex` is used within a [`PbeginShape`](/doc/PbeginShape) call, it must be prefaced with a call to [`Pvertex`](/doc/Pvertex) to set the first anchor point. This function must be used between [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) and only when there is no MODE parameter specified to [`PbeginShape`](/doc/PbeginShape). \n\n\n[Link to original Processing doc](https://processing.org/reference/quadraticVertex_.html)\n\n@param `cx` the x-coordinate of the control point\n\n@param `cy` the y-coordinate of the control point\n\n@param `x3` the x-coordinate of the anchor point\n\n@param `y3` the y-coordinate of the anchor point\n\n@param `pg` Processing graphic object\n\n",signature:"PquadraticVertex( pg:PGRAPHICS cx:DOUBLE cy:DOUBLE x3:DOUBLE y3:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PquadraticVertex"},Prect:{description:"Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. The way these parameters are interpreted, however, may be changed with the [`PrectMode`](/doc/PrectMode) function.\n\n\n\nTo draw a rounded rectangle, add a fifth parameter, which is used as the radius value for all four corners.\n\n\n\nTo use a different radius value for each corner, include eight parameters. When using eight parameters, the latter four set the radius of the arc at each corner separately, starting with the top-left corner and moving clockwise around the rectangle.\n\n\n[Link to original Processing doc](https://processing.org/reference/rect_.html)\n\n@param `a` float: x-coordinate of the rectangle by default\n\n@param `b` float: y-coordinate of the rectangle by default\n\n@param `c` float: width of the rectangle by default\n\n@param `d` float: height of the rectangle by default\n\n@param `r` float: radii for all four corners\n\n@param `tl` float: radius for top-left corner\n\n@param `tr` float: radius for top-right corner\n\n@param `br` float: radius for bottom-right corner\n\n@param `bl` float: radius for bottom-left corner\n\n@param `pg` Processing graphic object\n\n",signature:"Prect( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER ): pg:PGRAPHICS\nPrect( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER r:NUMBER ): pg:PGRAPHICS\nPrect( pg:PGRAPHICS a:NUMBER b:NUMBER c:NUMBER d:NUMBER tl:NUMBER tr:NUMBER br:NUMBER bl:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Prect"},PrectMode:{description:"Modifies the location from which rectangles are drawn by changing the way in which parameters given to [`Prect`](/doc/Prect) are intepreted.\n\nThe default mode is **CORNER**, which interprets the first two parameters of [`Prect`](/doc/Prect) as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\n**CORNERS** interprets the first two parameters of [`Prect`](/doc/Prect) as the location of one corner, and the third and fourth parameters as the location of the opposite corner.\n\n**CENTER** interprets the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, while the third and fourth parameters are its width and height.\n\n**RADIUS** also uses the first two parameters of [`Prect`](/doc/Prect) as the shape's center point, but uses the third and fourth parameters to specify half of the shape's width and height.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n\n[Link to original Processing doc](https://processing.org/reference/rectMode_.html)\n\n@param `mode` either CORNER, CORNERS, CENTER, or RADIUS\n\n@param `pg` Processing graphic object\n\n",signature:"PrectMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PrectMode"},Pred:{description:"Extracts the red value from a color, scaled to match current [`PcolorMode`](/doc/PcolorMode). The value is always returned as a double.\n\nThe `Pred` function is easy to use and understand, but it is slower than bit shifting. \n\n[Link to original Processing doc](https://processing.org/reference/red_.html)\n\n@param `rgb` Any value of the color datatype\n\n@param `red` Red component of the input color\n\n@param `pg` Processing graphic object\n\n",signature:"Pred( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS red:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Pred"},PresetMatrix:{description:"Replaces the current matrix with the identity matrix. \n\n\n[Link to original Processing doc](https://processing.org/reference/resetMatrix_.html)\n\n@param `pg` Processing graphic object\n\n",signature:"PresetMatrix( pg:PGRAPHICS ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PresetMatrix"},Protate:{description:"Rotates the amount specified by the **angle** parameter. Angles must be specified in radians (values from **0** to **2 PI**). \n\nThe coordinates are always rotated around their relative position to the origin. Positive numbers rotate objects in a clockwise direction and negative numbers rotate in the couterclockwise direction. Transformations apply to everything that happens afterward, and subsequent calls to the function compound the effect. For example, calling `pi 2.0 / Protate` once and then calling `pi 2.0 / Protate` a second time is the same as a single `pi Protate`. \n \n\nTechnically, `Protate` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/rotate_.html)\n\n@param `angle` angle of rotation specified in radians\n\n@param `pg` Processing graphic object\n\n",signature:"Protate( pg:PGRAPHICS angle:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Protate"},Psaturation:{description:"Extracts the saturation value from a color.\n\n\n[Link to original Processing doc](https://processing.org/reference/saturation_.html)\n\n@param `rgb` int: any value of the color datatype\n\n@param `saturation` Saturation component of HSB color representation\n\n@param `pg` Processing graphic object\n\n",signature:"Psaturation( pg:PGRAPHICS rgb:NUMBER ): pg:PGRAPHICS saturation:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"Psaturation"},Pscale:{description:"Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call `2.0 Pscale` increases the dimension of a shape by 200%.\n\n\n\nTransformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling `2.0 Pscale` and then `1.5 Pscale` is the same as `3.0 Pscale`. This function can be further controlled with [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/scale_.html)\n\n@param `s` percentage to scale the object\n\n@param `x` percentage to scale the object in the x-axis\n\n@param `y` percentage to scale the object in the y-axis\n\n@param `z` percentage to scale the object in the z-axis\n\n@param `pg` Processing graphic object\n\n",signature:"Pscale( pg:PGRAPHICS s:NUMBER ): pg:PGRAPHICS\nPscale( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPscale( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pscale"},Pset:{description:"Changes the color of any pixel, or writes an image directly to the display window.\n\n\n\nThe **x** and **y** parameters specify the pixel to change and the **c** parameter specifies the color value. The **c** parameter is interpreted according to the current color mode.  (The default color mode is RGB values from 0 to 255.)  When setting an image, the **x** and **y** parameters define the coordinates for the upper-left corner of the image.\n\n\n\nSetting the color of a single pixel with **set(x, y)** is easy, but not as fast as putting the data directly into the list of pixels returned by  [`Ppixels`](/doc/Ppixels).\n\n\n[Link to original Processing doc](https://processing.org/reference/set_.html)\n\n@param `x` X-coordinate of the pixel\n\n@param `y` Y-coordinate of the pixel\n\n@param `c` Any value of the color datatype\n\n@param `img` Image to copy into the original image\n\n@param `pg` Processing graphic object\n\n",signature:"Pset( pg:PGRAPHICS x:NUMBER y:NUMBER c:NUMBER ): pg:PGRAPHICS\nPset( pg:PGRAPHICS x:NUMBER y:NUMBER img:PIMAGE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pset"},Pshape:{description:"Draws shapes to the display window. Shapes must be loaded with [`PloadShape`](/doc/PloadShape). Processing currently works with SVG, OBJ, and custom-created shapes. WrapScript only support SVG. The **shape** parameter specifies the shape to display and the coordinate parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the **c** and **d** parameters specify a different size. The [`PshapeMode`](/doc/PshapeMode) function can be used to change the way these parameters are interpreted.\n\n\n[Link to original Processing doc](https://processing.org/reference/shape_.html)\n\n@param `shape` the shape to display\n\n@param `x` x-coordinate of the shape\n\n@param `y` y-coordinate of the shape\n\n@param `a` x-coordinate of the shape\n\n@param `b` y-coordinate of the shape\n\n@param `c` width to display the shape\n\n@param `d` height to display the shape\n\n@param `pg` Processing graphic object\n\n",signature:"Pshape( pg:PGRAPHICS shape:PSHAPE ): pg:PGRAPHICS\nPshape( pg:PGRAPHICS shape:PSHAPE x:DOUBLE y:DOUBLE ): pg:PGRAPHICS\nPshape( pg:PGRAPHICS shape:PSHAPE a:DOUBLE b:DOUBLE c:DOUBLE d:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.2.18",OPB64name:"Pshape"},PshapeMode:{description:"Modifies the location from which shapes draw. The default mode is **shapeMode(CORNER)**, which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. The syntax **shapeMode(CORNERS)** uses the first and second parameters of [`Pshape`](/doc/Pshape) to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax **shapeMode(CENTER)** draws the shape from its center point and uses the third and forth parameters of [`Pshape`](/doc/Pshape) to specify the width and height. \n\n\n[Link to original Processing doc](https://processing.org/reference/shapeMode_.html)\n\n@param `mode` int: either CORNER, CORNERS, CENTER\n\n@param `pg` Processing graphic object\n\n",signature:"PshapeMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PshapeMode"},PshearX:{description:"Shears a shape around the x-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearX` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearX_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",signature:"PshearX( pg:PGRAPHICS angle:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PshearX"},PshearY:{description:"Shears a shape around the y-axis the amount specified by the **angle** parameter. Angles should be specified in radians (values from 0 to 2 PI). Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect.  \n\nTechnically, `PshearY` multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/shearY_.html)\n\n@param `angle` angle of shear specified in radians\n\n@param `pg` Processing graphic object\n\n",signature:"PshearY( pg:PGRAPHICS angle:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PshearY"},Psize:{description:"The `Psize` function returns the pixel `width` and `height` of a Pimage or PGraphics object.\n\n@param `img` PImage instance to measure.\n\n@param `pg` PGraphics instance to measure.\n\n@param `height` Object height in pixels.\n\n@param `width` Object height in pixels.\n\n",signature:"Psize( img:PIMAGE ): width:LONG height:LONG\nPsize( pg:PGRAPHICS ): width:LONG height:LONG",tags:["processing"],since:"2.6.0",OPB64name:"Psize"},Psphere:{description:"A sphere is a hollow ball made from tessellated triangles.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphere_.html)\n\n@param `r` the radius of the sphere\n\n@param `pg` Processing graphic object\n\n",signature:"Psphere( pg:PGRAPHICS r:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Psphere"},PsphereDetail:{description:"Controls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you are going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until `PsphereDetail` is called again with a new parameter and so should **not** be called prior to every [`Psphere`](/doc/Psphere) statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.\n\n\n[Link to original Processing doc](https://processing.org/reference/sphereDetail_.html)\n\n@param `res` int: number of segments (minimum 3) used per full circle revolution\n\n@param `ures` int: number of segments used longitudinally per full circle revolutoin\n\n@param `vres` int: number of segments used latitudinally from top to bottom\n\n@param `pg` Processing graphic object\n\n",signature:"PsphereDetail( pg:PGRAPHICS res:NUMBER ): pg:PGRAPHICS\nPsphereDetail( pg:PGRAPHICS ures:NUMBER vres:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PsphereDetail"},Pstroke:{description:"Sets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current **colorMode** The default color space is RGB, with each value in the range from 0 to 255.\n\nThe most efficient is to use the raw ARGB format: 0x102030FF means Red 32, Green 48, Blue 255 with alpha=16/255. Alpha 0xFF means fully opaque. When using v1, v2, v3, gray, alpha, `Pstroke` calls internally [`Pcolor`](/doc/Pcolor).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n[Link to original Processing doc](https://processing.org/reference/stroke_.html)\n\n@param `argb` color value in hexadecimal notation\n\n@param `alpha` opacity of the stroke\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",signature:"Pstroke( pg:PGRAPHICS argb:LONG ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS gray:DOUBLE ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS argb:LONG alpha:DOUBLE ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS gray:DOUBLE alpha:DOUBLE ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS\nPstroke( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pstroke"},PstrokeCap:{description:"Sets the style for rendering line endings. These ends are either squared, extended, or rounded, each of which specified with the corresponding parameters: SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n\n\n[Link to original Processing doc](https://processing.org/reference/strokeCap_.html)\n\n@param `cap` Either SQUARE, PROJECT, or ROUND\n\n@param `pg` Processing graphic object\n\n",signature:"PstrokeCap( pg:PGRAPHICS cap:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeCap"},PstrokeJoin:{description:"Sets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER. \n\n\n[Link to original Processing doc](https://processing.org/reference/strokeJoin_.html)\n\n@param `join` Either MITER, BEVEL, ROUND\n\n@param `pg` Processing graphic object\n\n",signature:"PstrokeJoin( pg:PGRAPHICS join:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeJoin"},PstrokeWeight:{description:"Sets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.\n\n**Warning**: There is a known rounding bug inside Processing. Size 1 pixels may not draw. Use a 1.01 stroke weight. See [`Ppoint`](/doc/Ppoint) example.\n\n[Link to original Processing doc](https://processing.org/reference/strokeWeight_.html)\n\n@param `weight` The weight (in pixels) of the stroke.\n\n@param `pg` Processing graphic object\n\n",signature:"PstrokeWeight( pg:PGRAPHICS weight:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PstrokeWeight"},Ptext:{description:"Draws text to the screen. Displays the information specified in the first parameter on the screen in the position specified by the additional parameters. A default font will be used unless a font is set with the [`PtextFont`](/doc/PtextFont) function and a default size will be used unless a font is set with [`PtextSize`](/doc/PtextSize). Change the color of the text with the [`Pfill`](/doc/Pfill) function. The text displays in relation to the [`PtextAlign`](/doc/PtextAlign) function, which gives the option to draw to the left, right, and center of the coordinates.\n\n\n\nThe **x2** and **y2** parameters define a rectangular area to display within and may only be used with string data. When these parameters are specified, they are interpreted based on the current [`PrectMode`](/doc/PrectMode) setting. Text that does not fit completely within the rectangle specified will not be drawn to the screen.\n\n\n\nNote that Processing now lets you call `Ptext` without first specifying a PFont with [`PtextFont`](/doc/PtextFont). In that case, a generic sans-serif font will be used instead.\n\n\n[Link to original Processing doc](https://processing.org/reference/text_.html)\n\n@param `s` the string to be displayed\n\n@param `x` by default, x-coordinate of text\n\n@param `y` by default, y-coordinate of text\n\n@param `x1` by default, the x-coordinate of text, see PrectMode for more info\n\n@param `y1` by default, the y-coordinate of text, see PrectMode for more info\n\n@param `x2` by default, the width of the text box, see PrectMode for more info\n\n@param `y2` by default, the height of the text box, see PrectMode for more info\n\n@param `pg` Processing graphic object\n\n",signature:"Ptext( pg:PGRAPHICS s:STRING x:DOUBLE y:DOUBLE ): pg:PGRAPHICS\nPtext( pg:PGRAPHICS s:STRING x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Ptext"},PtextAlign:{description:"Sets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the **x** and **y** parameters of the [`Ptext`](/doc/Ptext) function.\n\n\n\nAn optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current [`PtextDescent`](/doc/PtextDescent). For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.\n\n\n\nWhen using [`Ptext`](/doc/Ptext) with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)\n\n\n\nThe vertical alignment is based on the value of [`PtextAscent`](/doc/PtextAscent), which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of [`PtextAscent`](/doc/PtextAscent) or [`PtextDescent`](/doc/PtextDescent) so that the hack works even if you change the size of the font.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAlign_.html)\n\n@param `alignX` Horizontal alignment, either LEFT, CENTER, or RIGHT\n\n@param `alignY` Vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n\n@param `pg` Processing graphic object\n\n",signature:"PtextAlign( pg:PGRAPHICS alignX:STRING ): pg:PGRAPHICS\nPtextAlign( pg:PGRAPHICS alignX:STRING alignY:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PtextAlign"},PtextAscent:{description:"Returns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the `PtextAscent` and [`PtextDescent`](/doc/PtextDescent) values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textAscent_.html)\n\n@param `ascent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",signature:"PtextAscent( pg:PGRAPHICS ): pg:PGRAPHICS ascent:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PtextAscent"},PtextDescent:{description:"Returns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the [`PtextAscent`](/doc/PtextAscent) and `PtextDescent` values will give you the total height of the line.\n\n\n[Link to original Processing doc](https://processing.org/reference/textDescent_.html)\n\n@param `descent` ascent of the current font at its current size\n\n@param `pg` Processing graphic object\n\n",signature:"PtextDescent( pg:PGRAPHICS ): pg:PGRAPHICS descent:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PtextDescent"},PtextFont:{description:"Sets the current font that will be drawn with the [`Ptext`](/doc/Ptext) function. Fonts must be created for Processing with [`PcreateFont`](/doc/PcreateFont) before they can be used. The font set through `PtextFont` will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.\n\n\n[Link to original Processing doc](https://processing.org/reference/textFont_.html)\n\n@param `font` Any variable of the type PFont\n\n@param `size` the size of the letters in pixel.\n\n@param `pg` Processing graphic object\n\n",signature:"PtextFont( pg:PGRAPHICS font:PFONT ): pg:PGRAPHICS\nPtextFont( pg:PGRAPHICS font:PFONT size:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PtextFont"},PtextLeading:{description:"Sets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function.  Note, however, that the leading is reset by [`PtextSize`](/doc/PtextSize). For example, if the leading is set to 20 with `20 PtextLeading`, then if `48 PtextSize` is run at a later point, the leading will be reset to the default for the text size of 48.\n\n\n[Link to original Processing doc](https://processing.org/reference/textLeading_.html)\n\n@param `leading` The size in pixels for spacing between lines\n\n@param `pg` Processing graphic object\n\n",signature:"PtextLeading( pg:PGRAPHICS leading:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PtextLeading"},PtextMode:{description:"Sets the way text draws to the screen, either as texture maps or as vector geometry. The default **textMode(MODEL)**, uses textures to render the fonts. The **textMode(SHAPE)** mode draws text using the glyph outlines of individual characters rather than as textures. This mode is only supported with the **PDF** and **P3D** renderer settings. With the **PDF** renderer, you must call **textMode(SHAPE)** before any other drawing occurs. If the outlines are not available, then **textMode(SHAPE)** will be ignored and **textMode(MODEL)** will be used instead.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/textMode_.html)\n\n@param `mode` int: either MODEL or SHAPE\n\n@param `pg` Processing graphic object\n\n",signature:"PtextMode( pg:PGRAPHICS mode:STRING ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PtextMode"},PtextSize:{description:"Sets the current font size. This size will be used in all subsequent calls to the [`Ptext`](/doc/Ptext) function. Font size is measured in units of pixels.\n\n\n[Link to original Processing doc](https://processing.org/reference/textSize_.html)\n\n@param `size` float: the size of the letters in units of pixels\n\n@param `pg` Processing graphic object\n\n",signature:"PtextSize( pg:PGRAPHICS size:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"PtextSize"},PtextWidth:{description:"Calculates and returns the width of any character or text string.\n\n\n[Link to original Processing doc](https://processing.org/reference/textWidth_.html)\n\n@param `str` The String of characters to measure\n\n@param `w` The width of the input string\n\n@param `pg` Processing graphic object\n\n",signature:"PtextWidth( pg:PGRAPHICS str:STRING ): pg:PGRAPHICS w:DOUBLE",tags:["processing"],since:"1.0.0",OPB64name:"PtextWidth"},Ptint:{description:"Sets the fill value for displaying images. Images can be tinted to specified colors or made transparent by including an alpha value.\n\n\n\nTo apply transparency to an image without affecting its color, use white as the tint color and specify an alpha value. For instance, **tint(255, 128)** will make an image 50pc transparent (assuming the default alpha range of 0-255, which can be changed with [`PcolorMode`](/doc/PcolorMode)).\n\n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by [`PcolorMode`](/doc/PcolorMode). The default maximum value is 255.\n\n\n\n[Link to original Processing doc](https://processing.org/reference/tint_.html)\n\n@param `argb` any argb color value.\n\n@param `alpha` opacity of the image\n\n@param `gray` specifies a value between white and black\n\n@param `v1` red or hue value (depending on current color mode)\n\n@param `v2` green or saturation value (depending on current color mode)\n\n@param `v3` blue or brightness value (depending on current color mode)\n\n@param `pg` Processing graphic object\n\n",signature:"Ptint( pg:PGRAPHICS argb:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS gray:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS argb:NUMBER alpha:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER ): pg:PGRAPHICS\nPtint( pg:PGRAPHICS v1:NUMBER v2:NUMBER v3:NUMBER alpha:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Ptint"},PtoImage:{description:"The `PtoImage` function transforms a `PGRAPHICS` to a `PIMAGE`.\n\nThe `PGRAPHICS` can still be used after the transformation as this function copies the pixel values. This is equivalent to `Pencode Pdecode` but it is a lot faster.\n\n@param `pg` Processing graphic object.\n\n@param `img` Processing Pimage object.\n\n",signature:"PtoImage( pg:PGRAPHICS ): img:PIMAGE",tags:["processing"],since:"2.1.0",OPB64name:"PtoImage"},Ptranslate:{description:"Specifies an amount to displace objects within the display window. The **x** parameter specifies left/right translation, the **y** parameter specifies up/down translation.\n\n\n\nTransformations are cumulative and apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling **50 0 Ptranslate** and then **20 0 Ptranslate** is the same as **70 0 Ptranslate**. This function can be further controlled by using [`PpushMatrix`](/doc/PpushMatrix) and [`PpopMatrix`](/doc/PpopMatrix).\n\n\n[Link to original Processing doc](https://processing.org/reference/translate_.html)\n\n@param `x` left/right translation\n\n@param `y` up/down translation\n\n@param `pg` Processing graphic object\n\n",signature:"Ptranslate( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Ptranslate"},Ptriangle:{description:"A triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point. \n\n\n[Link to original Processing doc](https://processing.org/reference/triangle_.html)\n\n@param `x1` float: x-coordinate of the first point\n\n@param `y1` float: y-coordinate of the first point\n\n@param `x2` float: x-coordinate of the second point\n\n@param `y2` float: y-coordinate of the second point\n\n@param `x3` float: x-coordinate of the third point\n\n@param `y3` float: y-coordinate of the third point\n\n@param `pg` Processing graphic object\n\n",signature:"Ptriangle( pg:PGRAPHICS x1:DOUBLE y1:DOUBLE x2:DOUBLE y2:DOUBLE x3:DOUBLE y3:DOUBLE ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Ptriangle"},PupdatePixels:{description:"Updates the display window with the data in the **pixels[]** array. Use in conjunction with [`Ppixels`](/doc/Ppixels). If you are only reading pixels from the array, there's no need to call `PupdatePixels` - updating is only necessary to apply changes.\n\n[Link to original Processing doc](https://processing.org/reference/updatePixels_.html)\n\n@param `pixels` List of image pixels, RGBA format.\n\n@param `pg` Processing graphic object\n\n@param `img` PImage object\n\n",signature:"PupdatePixels( pg:PGRAPHICS pixels:LIST<LONG> ): pg:PGRAPHICS\nPupdatePixels( img:PIMAGE pixels:LIST<LONG> ): img:PIMAGE",tags:["processing"],since:"1.0.0",OPB64name:"PupdatePixels"},Pvertex:{description:"All shapes are constructed by connecting a series of vertices. `Pvertex` is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons. It is used exclusively within the [`PbeginShape`](/doc/PbeginShape) and [`PendShape`](/doc/PendShape) functions.\n\n\n[Link to original Processing doc](https://processing.org/reference/vertex_.html)\n\n@param `x` x-coordinate of the vertex\n\n@param `y` y-coordinate of the vertex\n\n@param `z` float: z-coordinate of the vertex\n\n@param `u` float: horizontal coordinate for the texture mapping\n\n@param `v` float: vertical coordinate for the texture mapping\n\n@param `pg` Processing graphic object\n\n",signature:"Pvertex( pg:PGRAPHICS x:NUMBER y:NUMBER ): pg:PGRAPHICS\nPvertex( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER ): pg:PGRAPHICS\nPvertex( pg:PGRAPHICS x:NUMBER y:NUMBER u:NUMBER v:NUMBER ): pg:PGRAPHICS\nPvertex( pg:PGRAPHICS x:NUMBER y:NUMBER z:NUMBER u:NUMBER v:NUMBER ): pg:PGRAPHICS",tags:["processing"],since:"1.0.0",OPB64name:"Pvertex"},"Q->":{description:"The `Q->` function consumes on the stack a [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long and push back the quaternion into\n4 doubles (w, x, y, z, with z being on top).\n\nEach quaternion dimension is encoded with 16 bits.\n\n@param `w` W\n\n@param `x` X\n\n@param `y` Y\n\n@param `z` Z\n\n@param `input` Quaternion representation\n\n",signature:"Q->( input:LONG ): w:DOUBLE x:DOUBLE y:DOUBLE z:DOUBLE",tags:["quaternions"],since:"1.0.0",OPB64name:"JHoy"},QCONJUGATE:{description:"The `QCONJUGATE` function performs a [conjugation](https://en.wikipedia.org/wiki/Quaternion#Conjugation,_the_norm,_and_reciprocal) of a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the quaternion conjugate into a long.\n\n@param `quaternion` The input quaternion\n\n@param `result` The conjugated quaternion\n\n",signature:"QCONJUGATE( quaternion:LONG ): result:LONG",tags:["quaternions"],since:"1.0.0",OPB64name:"QCONJUGATE"},QDIVIDE:{description:"The `QDIVIDE` function divides a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of dividing them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from division *q* by *r*\n\n",signature:"QDIVIDE( q:LONG r:LONG ): result:LONG",tags:["quaternions"],since:"1.0.0",OPB64name:"QDIVIDE"},QMULTIPLY:{description:"The `QMULTIPLY` function multiplies a [quaternion](https://en.wikipedia.org/wiki/Quaternion) *q* by a quaternion *r* and push back the result of multiplying them.\n\n@param `q` The *q* quaternion\n\n@param `r` The *r* quaternion\n\n@param `result` The resulting quaternion from multiplication *q* by *r*\n\n",signature:"QMULTIPLY( q:LONG r:LONG ): result:LONG",tags:["quaternions"],since:"1.0.0",OPB64name:"QMULTIPLY"},QROTATE:{description:"Rotates a vector by a [quaternion](https://en.wikipedia.org/wiki/Quaternion).\n\nThe `QROTATE` function consumes on the top of the stack three doubles representing a vector(x, y, z) and a long representing a [quaternion](https://en.wikipedia.org/wiki/Quaternion) and pushes back the vector rotated into 3 doubles (x, y, z with z being on top).\n\n@param `quaternion` The quaternion used to rotate the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",signature:"QROTATE( x:DOUBLE y:DOUBLE z:DOUBLE quaternion:LONG ): x:DOUBLE y:DOUBLE z:DOUBLE",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATE"},QROTATION:{description:"The `QROTATION` extracts the axis and angle of the rotation represented by the [quaternion](https://en.wikipedia.org/wiki/Quaternion) on the stack.\n\n@param `quaternion` The input quaternion\n\n@param `angle` The angle of rotation\n\n@param `x` The X axis\n\n@param `y` The Y axis\n\n@param `z` The Z axis\n\n",signature:"QROTATION( quaternion:LONG ): x:DOUBLE y:DOUBLE z:DOUBLE angle:DOUBLE",tags:["quaternions"],since:"1.0.0",OPB64name:"QROTATION"},QUANTIZE:{description:'The `QUANTIZE` function produces a quantized version of a Geo Time Series™ by replacing each value with a value from a finite list according to the interval the original value falls in. This function only works on numeric Geo Time Series™.\nThis function can help to "discretify" data before calling [`VALUEHISTOGRAM`](/doc/VALUEHISTOGRAM).\nThe list of intervals is defined as: [-∞,bounds<sub>0</sub>], (bounds<sub>0</sub>,bounds_<sub>1</sub>], (bounds<sub>1</sub>,bounds<sub>2</sub>], ..., (bounds<sub>n-1</sub>,+∞]\n\n@param `values` List of `n+1` values, one for each interval defined by `bounds`. If empty, the list `[ `0` `1` ... `n+1` ]` will be used.\n\n@param `bounds` Sorted list of `n` finite bounds defining `n+1` intervals.\n\n@param `gts` Geo Time Series™ to quantize.\n\n@param `qgts` Quantized GTS.\n\n@param `lgts` List of Geo Time Series™ to quantize.\n\n@param `lqgts` List of quantized GTS.\n\n',signature:"QUANTIZE( gts:GTS bounds:LIST<DOUBLE> values:LIST ): qgts:GTS\nQUANTIZE( lgts:LIST<GTS> bounds:LIST<DOUBLE> values:LIST ): lqgts:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"QUANTIZE"},RAND:{description:"The `RAND` function pushes onto the stack a random floating point number between 0.0 (inclusive) and 1.0 (exlusive) generated by the default random generator.\n\nThis generation is cryptographically secure.\n\n@param `num` Generated random number between 0 and 1.\n\n",signature:"RAND(): num:DOUBLE",tags:["math"],since:"1.0.0",OPB64name:"RAND"},RANDOM:{description:"The `RANDOM` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThis function is very similar to [SRAND](/doc/SRAND) except the seed is choosen pseudorandomly when the function is first called. Subsequent calls use the same generator.\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",signature:"RANDOM(): num:DOUBLE",tags:["math"],since:"1.2.23",OPB64name:"RANDOM"},RANDPDF:{description:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe result if a function pushed onto the stack. This function does not have any arguments.\n\nTo use the function pushed by `RANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",signature:"RANDPDF( valueHistogram:MAP ): result:STRING",tags:["math","statistics"],since:"1.0.7",OPB64name:"RANDPDF"},RANGE:{description:"`RANGE` pushes onto the stack a list of integers in the given range [start included, end excluded[. If start is not in the parameter list, start=0.\n\n`RANGE` also accepts a step parameter in the parameter list.\n\n\n@param `start` The start of range, default is 0\n\n@param `end` The end of range\n\n@param `step` The step between integers, default is 1\n\n@param `output` The list of every integers in the range [start end[\n\n",signature:"RANGE( [ end:LONG ] ): output:LIST<LONG>\nRANGE( [ start:LONG end:LONG ] ): output:LIST<LONG>\nRANGE( [ start:LONG end:LONG step:LONG ] ): output:LIST<LONG>",tags:["counters"],since:"1.0.0",OPB64name:"RANGE"},RANGECOMPACT:{description:"The `RANGECOMPACT` simplifies a Geo Time Series™ by simplifying ranges of identical values (with identical latitude, longitude and elevation), retaining only the first and last ticks of each range.\n\n@param `gts` Geo Time Series™ to compact.\n\n@param `compacted` Compacted GTS.\n\n@param `lgts` List of Geo Time Series™ to compact.\n\n@param `lcompacted` List of compacted GTS.\n\n",signature:"RANGECOMPACT( gts:GTS ): compacted:GTS\nRANGECOMPACT( lgts:LIST<GTS> ): lcompacted:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"RANGECOMPACT"},RAWDTW:{description:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe computation is performed on the raw Geo Time Series™, no transformation is applied to them.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",signature:"RAWDTW( gts1:GTS gts2:GTS threshold:DOUBLE ): dtw:DOUBLE",tags:["gts","distance"],since:"1.2.11",OPB64name:"RAWDTW"},REDEFS:{description:"The `REDEFS` function allows or disallows execution of redefined functions.\n\n@param `flag` Shall we allow or disallow the execution of redefined functions.\n\n",signature:"REDEFS( flag:BOOLEAN ): ",tags:["stack"],since:"1.2.5",OPB64name:"REDEFS"},REDUCE:{description:"The `REDUCE` framework groups Geo Time Series™ by equivalence classes based on label values and applies a function on each equivalence class of Geo Time Series™, considering the values of each tick and producing one GTS per equivalence class.\n\nAs the selected reducer function is applied tick by tick, it is usually wise to [`BUCKETIZE`](/doc/BUCKETIZE) the GTS first with a common value of `lastbucket`.\n\nThe labels whose values are common to all the GTS in an equivalence class will be retained.\n\nSince 2.1 you can make REDUCE override the GTSs ticks. This usage in mainly to be used in conjuction with [`MACROREDUCER`](/doc/MACROREDUCER).\n\n@param `reducer` Reducer function to apply.\n\n@param `labels` List of label names to consider for creating equivalence classes. If the list is empty all Geo Time Series™ will end up in the same equivalence class. If the `labels` parameter `NULL`, all labels will be considered.\n\n@param `gts` One or more lists of Geo Time Series™.\n\n@param `result` List of resulting Geo Time Series™.\n\n@param `overrideTick` Boolean, if true allows the reducer to modify the ticks of the GTSs. If not set, the reducer cannot modify the ticks.\n\n",signature:"REDUCE( [ gts:LIST<GTS>+ labels:LIST<STRING> reducer:AGGREGATOR ] ): result:LIST<GTS>\nREDUCE( [ gts:LIST<GTS>+ labels:LIST<STRING> reducer:AGGREGATOR overrideTick:BOOLEAN ] ): result:LIST<GTS>",tags:["reducer","framework"],since:"1.0.0",OPB64name:"REDUCE"},RELABEL:{description:"Modifies the labels of a Geo Time Series™. The `RELABEL` function expects a parameter MAP whose entries are labels to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `RELABEL` function will use the rest of the MAP as the actual labels to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing labels.\n\nAn entry with an empty STRING value or a NULL value will have the effect of removing the label from the GTS' labels.        \n\n@param `labels` Parameter map of label names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `encoder` Encoder to relabel\n\n@param `lencoder` List of encoders to relabel\n\n",signature:"RELABEL( gts:GTS labels:MAP ): gts:GTS\nRELABEL( lgts:LIST<GTS> labels:MAP ): lgts:LIST<GTS>\nRELABEL( encoder:GTSENCODER labels:MAP ): encoder:GTSENCODER\nRELABEL( lencoder:LIST<GTSENCODER> labels:MAP ): lencoder:LIST<GTSENCODER>",tags:["gts"],since:"1.0.0",OPB64name:"RELABEL"},REMOVE:{description:"Removes an entry from a MAP or from a LIST.\n\nThe `REMOVE` function consumes a list (or a map) and a index (or a key), then remove the entry.\nIt lets the input on the stack and puts the removed item on top of the stack. \nAs a result, the input map or list is modified and the map or list left on top of the stack is *not* a copy. \n\nIf the index is out of bound, the returned value is `NULL` and the list or array is unmodified.\nIf the key does not exist in the map, it returns null as the removed entry.\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **GTS**.\n\nSince 2.7, `REMOVE` can be called on a **GTS**.\n\n@param `key` Depending on map construction, could be a number, a string, a boolean\n\n@param `inputmap` The reference to the map to be modified\n\n@param `index` The index of the list, 0 for the first item\n\n@param `inputlist` The reference to the list to be modified\n\n@param `removeditem` Depending on map or list content, could be any type\n\n@param `outputmap` The input map modified\n\n@param `outputlist` The input list modified\n\n@param `pointindex` Index of the point in the GTS, 0-indexed, handles negative indexing.\n\n@param `inputgts` The GTS to remove the point from.\n\n@param `removedpoint` The removed point. List of timestamp, latitude, longitude, elevation and value.\n\n@param `outputgts` The acopy of the original GTS with the requested point removed.\n\n",signature:"REMOVE( inputlist:LIST index:LONG ): outputlist:LIST removeditem:ANY\nREMOVE( inputmap:MAP key:ANY ): outputmap:MAP removeditem:ANY\nREMOVE( inputgts:GTS pointindex:LONG ): outputgts:GTS removedpoint:LIST",tags:["maps","lists"],since:"1.0.0",OPB64name:"REMOVE"},REMOVETICK:{description:"The `REMOVETICK` function transforms a Geo Time Series™ by removing all occurrences of a tick or ticks.\n\n@param `tick` Tick (timestamp) to remove.\n\n@param `lticks` List or Set of ticks to remove.\n\n@param `gts` Geo Time Series™ to transform.\n\n@param `pruned` Tranformed Geo Time Series™.\n\n",signature:"REMOVETICK( gts:GTS tick:LONG ): pruned:GTS\nREMOVETICK( gts:GTS lticks:LIST<LONG> ): pruned:GTS\nREMOVETICK( gts:GTS lticks:SET<LONG> ): pruned:GTS",tags:["gts"],since:"1.2.19",OPB64name:"REMOVETICK"},RENAME:{description:"The `RENAME` function changes the name of a Geo Time Series™, an Encoder or a list thereof. This operation may be required prior to using some functions. If the name starts with '+', the specified name will be appended to the current name of the GTS or Encoder.\n\nIf you want to rename a Geo Time Series™ or an Encoder so its name starts with a '+', you must first set its name to the empty string then use rename with the desired name prefixed with an additional '+'.\n\n@param `gts` Geo Time Series™ instance to rename.\n\n@param `lgts` List of Geo Time Series™ instances to rename.\n\n@param `encoder` Encoder to rename.\n\n@param `lencoder` Encoder to rename.\n\n@param `name` New name to give to the GTS.\n\n",signature:"RENAME( gts:GTS name:STRING ): gts:GTS\nRENAME( lgts:LIST<GTS> name:STRING ): lgts:LIST<GTS>\nRENAME( encoder:GTSENCODER name:STRING ): encoder:GTSENCODER\nRENAME( lencoder:LIST<GTSENCODER> name:STRING ): lencoder:LIST<GTSENCODER>",tags:["gts","encoder"],since:"1.0.0",OPB64name:"RENAME"},REOPTALT:{description:"Produces a **R**egular **E**xpression **OPT**imized for **ALT**ernation from a list of STRINGs. Large alternations in regular expressions can lead to excessive backtracking and poor matching performance. In order to mitigate this, the `REOPTALT` function will produce a regular expression from a list of STRINGs which reduces the backtracking thus leading to better matching performance.\n\n@param `alternatives` List of STRINGs which should be used in the alternation.\n\n@param `regexp` Regular expression\n\n",signature:"REOPTALT( alternatives:LIST<STRING> ): regexp:STRING",tags:["strings"],since:"1.2.16",OPB64name:"REOPTALT"},REPLACE:{description:"Replaces the first occurrence of a pattern by its substitution.\n\nThe `REPLACE` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with the replaced value if it was found\n\n",signature:"REPLACE( original:ANY pattern:ANY replacement:ANY ): result:STRING",tags:["strings"],since:"1.1.0",OPB64name:"REPLACE"},REPLACEALL:{description:"Replaces all occurrence of a pattern by its substitution.\n\nThe `REPLACEALL` consumes 3 parameters from the stack:\n* the replacement value\n* the pattern to search, could be a regular expression\n* the input value\n\nAll parameters are converted into strings via the toString() method before the replacement is done.\n\n@param `replacement` Value to be substituted to the pattern. Could be a number, a string, a list, ...\n\n@param `pattern` Pattern to search in the original value. Could be a regexp, a number, a string, a list, ...\n\n@param `original` Original value containing the pattern to replace\n\n@param `result` String with all occurrences of pattern replaced by its value\n\n",signature:"REPLACEALL( original:ANY pattern:ANY replacement:ANY ): result:STRING",tags:["strings"],since:"1.1.0",OPB64name:"REPLACEALL"},REPORT:{description:"The `REPORT` function pushes onto the stack a STRING containing configuration and usage informations which can be useful when investigating issues.\n\n@param `secret` Secret configured for using the `REPORT` function.\n\n@param `report` Actual report.\n\n",signature:"REPORT( secret:STRING ): report:STRING",tags:["stack"],since:"2.0.3",OPB64name:"REPORT"},RESET:{description:"The `RESET` function resets the stack to the given depth, discarding any items above those 'depth' items.\n\n@param `depth` Depth at which the stack should be reset.\n\n",signature:"RESET( depth:LONG ): ",tags:["stack"],since:"1.0.0",OPB64name:"RESET"},RESETS:{description:"The `RESETS` functions transforms a numerical Geo Time Series™, shifting values so no offset (*i.e.* a decrease or increase of values) appears after the operation.\n\nThe parameter to `RESETS` determines if the Geo Time Series should be considered as decreasing instead of increasing.\n\n@param `decreasingGTS` Flag set to `true` to indicate the GTS is decreasing.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `lgts` List of Geo Time Series™ or list thereof to transform.\n\n@param `result` GTS with resets compensated.\n\n@param `lresult` List of GTS with resets compensated.\n\n",signature:"RESETS( gts:GTS decreasingGTS:BOOLEAN ): result:GTS\nRESETS( lgts:LIST<GTS> decreasingGTS:BOOLEAN ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"RESETS"},RESHAPE:{description:"The `RESHAPE` function modifies the shape of a list.\n\nThe new shape is specified using a list of dimensions, the first being the outer dimension. Such a shape can be produced by `SHAPE`.\n\nNote that the number of elements in the array must be compatible with the requested shape, i.e. the product of the dimensions must match the number of elements in the input list.\n\n@param `input` List to reshape.\n\n@param `shape` Shape specification, list of dimensions, the first element being the outer list.\n\n@param `output` Reshaped list.\n\n",signature:"RESHAPE( input:LIST shape:LIST<LONG> ): output:LIST",tags:["lists","tensors"],since:"2.1.0",OPB64name:"RESHAPE"},RESTORE:{description:"The `RESTORE` function resets the stack's symbol table to the state recorded in the context passed as parameter.\n\n@param `context` Stack context produced by [`SAVE`](doc/SAVE).\n\n",signature:"RESTORE( context:CONTEXT ): ",tags:["stack"],since:"1.0.0",OPB64name:"RESTORE"},RETHROW:{description:"Inside the *catch* or *finally* macro of a [`TRY`](/doc/TRY), rethrows the last thrown error. If no error was previously thrown, `RETHROW` does nothing.\n\n",signature:"RETHROW(): ",tags:["control"],since:"1.2.11",OPB64name:"RETHROW"},RETURN:{description:"Returns immediately from the currently executing macro. If called outside a macro, `RETURN` will stop the execution of the current script, behaving like [`STOP`](/doc/STOP).\n\n",signature:"RETURN(): ",tags:["control"],since:"1.0.0",OPB64name:"RETURN"},REV:{description:"The `REV` function pushes onto the stack the revision of the Warp 10 instance.`\n\n@param `revision` Revision of the Warp 10 platform.\n\n",signature:"REV(): revision:STRING",tags:["platform"],since:"1.0.0",OPB64name:"REV"},REVBITS:{description:"Reverses the order of the bits of a LONG value.\n\n@param `long` LONG value from which to revert the bits.\n\n@param `gnol` LONG value whose bits are in reverse order compared to those of `long`.\n\n",signature:"REVBITS( long:LONG ): gnol:LONG",tags:["math"],since:"1.0.0",OPB64name:"REVBITS"},REVERSE:{description:"Reverses the order of the elements of the list or the string.\n\nThe `REVERSE` function inverts the order of the elements of the list or the string on the top of the stack.\nBeware, `REVERSE` do not create a new object. Use [`CLONEREVERSE`](/doc/CLONEREVERSE) if you want to keep input.\n\nApplied on a byte array, `REVERSE` reverses the endianness.\n\n\n@param `originalList` The list to reverse\n\n@param `originalString` The string to reverse\n\n@param `reversedObj` The original object with the elements in reverse order\n\n",signature:"REVERSE( originalList:LIST ): reversedObj:LIST\nREVERSE( originalString:STRING ): reversedObj:STRING\nREVERSE( originalString:BYTES ): reversedObj:BYTES",tags:["lists","strings","binary"],since:"1.0.0",OPB64name:"REVERSE"},REXEC:{description:"The `REXEC` function executes some WarpScript code on a remote Warp 10 instance. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",signature:"REXEC( warpscript:STRING endpoint:STRING ): stack:ANY*",tags:["extensions","stack"],since:"1.0.8",OPB64name:"REXEC"},REXECZ:{description:"The `REXECZ` function executes some WarpScript code on a remote Warp 10 instance just like [`REXEC`](/doc/REXEC) does, but compresses the WarpScript code prior to sending it. The stack left by the execution on the remote instance will be snapshotted using [`SNAPSHOT`](/doc/SNAPSHOT) and the result will be re-applied on the local stack.\n\nFor Warp 10™ 1.x, this function is not available if `warpscript.rexec.enable` was not set to `true` in the Warp 10 instance configuration.\n\nStarting with Warp 10™ 2.x, this function has been moved to the `io.warp10.script.ext.rexec.RexecWarpScriptExtension` extension.\n\n@param `endpoint` URL of the remote Warp 10 instance `/exec` endpoint.\n\n@param `warpscript` Code to execute on the remote instance.\n\n@param `stack` Resulting stack.\n\n",signature:"REXECZ( warpscript:STRING endpoint:STRING ): stack:ANY*",tags:["extensions","stack"],since:"1.2.5",OPB64name:"REXECZ"},RINT:{description:"The `RINT` function consumes a numeric parameter from the top of the stack and pushes back the DOUBLE the closest to the parameter and equal to a mathematical integer.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `result` Closest floating-point value to a that is equal to a mathematical integer.\n\n@param `lvalue` List of Numeric values.\n\n@param `lresult` List of closest floating-point values to a that is equal to a mathematical integer.\n\n",signature:"RINT( value:NUMBER ): result:DOUBLE\nRINT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"RINT"},RLOWESS:{description:"The `RLOWESS` function applies an iterative smoothing program on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is done via locally weighted regression, and is robust to outliers.\n\n> ### REFERENCE\n>\n> **Cleveland, W. S.** (1979) Robust locally weighted regression and smoothing scatterplots. J. American Statistical Association 74, 829–836.\n> **Cleveland, W. S.** (1981) LOWESS: A program for smoothing scatterplots by robust locally weighted regression. The American Statistician 35, 54.\n\n@param `p` The degree for the polynomial fit of the regression\n\n@param `d` The delta radius (in time units) whithin which the local regression is computed only once (other points are interpolated). For very large datasets, it can be wise to set `d` > 0 to speed up the computations.\n\n@param `r` The number of robustifying iterations. The higher the value of `r`, the better the program is robust to outliers.\n\n@param `q` The bandwidth of the local regression. To obtain a good smoothing, it is advised to choose an odd number of at least 5.\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",signature:"RLOWESS( gts:GTS q:LONG r:LONG d:LONG p:LONG ): result:GTS\nRLOWESS( gtsList:LIST<GTS> q:LONG r:LONG d:LONG p:LONG ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"RLOWESS"},ROLL:{description:"`ROLL` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element at level *N* to the top of the stack and moving the other elements up one level.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",signature:"ROLL( eltN:ANY elt2:ANY elt1:ANY N:LONG ): elt2:ANY elt1:ANY eltN:ANY",tags:["stack"],since:"1.0.0",OPB64name:"ROLL"},ROLLD:{description:"`ROLLD` consumes a number *N* off the stack then cycles through that number of elements on the stack, moving the element on top of the stack to level *N* and moving the other *N-1* elements down the stack.\n\n@param `N` The number of elements to cycle through\n\n@param `elt1` The first element to move\n\n@param `elt2` The second element to move\n\n@param `eltN` The Nth element to move\n\n",signature:"ROLLD( eltN:ANY elt2:ANY elt1:ANY N:LONG ): elt1:ANY eltN:ANY elt2:ANY",tags:["stack"],since:"1.0.0",OPB64name:"ROLLD"},ROT:{description:"`ROT` cycles through the 3 topmost elements of the stack by moving the element at level 3 to the top of the stack and pushing the other 2 elements up the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n@param `level3` The element at the third level of the stack prior to the function execution\n\n",signature:"ROT( level3:ANY level2:ANY top:ANY ): level2:ANY top:ANY level3:ANY",tags:["stack"],since:"1.0.0",OPB64name:"ROT"},ROTATIONQ:{description:"The `ROTATIONQ` function consumes on the stack 4 doubles representing a rotation vector and pushes back [quaternion](https://en.wikipedia.org/wiki/Quaternion) representation into a long.\n\n@param `quaternion` The quaternion representation\n\n@param `angle` The angle of the vector\n\n@param `x` The X coordinate of the vector\n\n@param `y` The Y coordinate of the vector\n\n@param `z` The Z coordinate of the vector\n\n",signature:"ROTATIONQ( x:DOUBLE y:DOUBLE z:DOUBLE angle:DOUBLE ): quaternion:QUATERNION",tags:["quaternions"],since:"1.0.0",OPB64name:"ROTATIONQ"},ROUND:{description:"The `ROUND` function consumes a numeric parameter from the top of the stack and pushes back the long number the closest to the parameter.\n\n@param `input` Input to round.\n\n@param `output` Input rounded to the nearest Long.\n\n",signature:"ROUND( input:NUMBER ): output:LONG",tags:["math"],since:"1.0.0",OPB64name:"ROUND"},RSADECRYPT:{description:"Decrypts content encrypted with an RSA key.\n\n@param `key` RSA key to use for decryption (a public key if content was encrypted with a private key, a private key otherwise).\n\n@param `cipher` Encrypted data.\n\n@param `data` Cleartext data.\n\n",signature:"RSADECRYPT( cipher:BYTES key:KEY ): data:BYTES",tags:["crypto"],since:"1.0.11",OPB64name:"RSADECRYPT"},RSAENCRYPT:{description:"Encrypts a byte array using an RSA key (either public or private).\n\n@param `key` Instance of the RSA private or public key to use for encryption.\n\n@param `data` Data to encrypt.\n\n@param `encrypted` Ciphered version of `data`.\n\n",signature:"RSAENCRYPT( data:BYTES key:KEY ): encrypted:BYTES",tags:["crypto"],since:"1.0.11",OPB64name:"RSAENCRYPT"},RSAGEN:{description:"Generates an RSA public key pair.\n\n@param `keylen` Key length in bits.\n\n@param `publicExponent` RSA public exponent, typically 65537.\n\n@param `pubkeyparams` Parameters of the generated RSA public key. Can be converted to a public key using [`RSAPUBLIC`](/doc/RSAPUBLIC).\n\n@param `privkeyparams` Parameters of the generated RSA privsate key. Can be converted to a private key using [`RSAPRIVATE`](/doc/RSAPRIVATE)\n\n",signature:"RSAGEN( publicExponent:LONG keylen:LONG ): privkeyparams:MAP pubkeyparams:MAP",tags:["crypto"],since:"1.0.11",OPB64name:"RSAGEN"},RSAPRIVATE:{description:"Creates an RSA private key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `privkeyparams` Map of private key parameters.\n\n@param `privkey` RSA private key instance.\n\n",signature:"RSAPRIVATE( privkeyparams:MAP ): privkey:KEY",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPRIVATE"},RSAPUBLIC:{description:"Creates an RSA public key from a map of key parameters such as the one generated by [`RSAGEN`](/doc/RSAGEN).\n\n@param `pubkeyparams` Map of public key parameters.\n\n@param `pubkey` RSA public key instance.\n\n",signature:"RSAPUBLIC( pubkeyparams:MAP ): pubkey:KEY",tags:["crypto"],since:"1.0.11",OPB64name:"RSAPUBLIC"},RSASIGN:{description:"Signs a byte array with an RSA private key.\n\n@param `privkey` RSA private key to use for signing.\n\n@param `alg` Name of algorithm to use for computing the data fingerprint. Supported algorithms are those provided by [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `data` Data to sign.\n\n@param `signature` Computed signature.\n\n",signature:"RSASIGN( data:BYTES alg:STRING privkey:KEY ): signature:BYTES",tags:["crypto"],since:"1.0.11",OPB64name:"RSASIGN"},RSAVERIFY:{description:"The `RSAVERIFY` function verify a signature generated with [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) cryptosystem and a hash algorithm.\n\nAlgorithms are those supported by [BouncyCastle](http://stackoverflow.com/questions/8778531/bouncycastle-does-not-find-algorithms-that-it-provides).\n\n@param `pubkey` RSA public key to use for verifying the signature.\n\n@param `alg` Algorithm used for generating the signature. See [BouncyCastle](https://people.eecs.berkeley.edu/~jonah/bc/org/bouncycastle/jce/provider/JDKDigestSignature.html).\n\n@param `signature` Signature to verify.\n\n@param `content` Signed content.\n\n@param `verified` Status of the signature verification.\n\n",signature:"RSAVERIFY( content:BYTES signature:BYTES alg:STRING pubkey:KEY ): verified:BOOLEAN",tags:["crypto"],since:"1.0.11",OPB64name:"RSAVERIFY"},RSORT:{description:"Sort Geo Time Series™ values (and associated locations/elevations) by reverse order of their ticks (i.e. most recent ticks first).\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",signature:"RSORT( gts:GTS ): result:GTS\nRSORT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"RSORT"},RTFM:{description:"The `RTFM` function pushes onto the stack the URL of the Warp 10 documentation, so whenever you are lost you can rapidly retrieve the URL you need to get back on track!\n\n@param `url` URL of the Warp 10 documentation.\n\n",signature:"RTFM(): url:STRING",tags:["misc","help"],since:"1.0.7",OPB64name:"RTFM"},RUN:{description:"The `RUN` function attempts to execute the macro whose name is on top of the stack. It is equivalent to `@macro` if called with `macro` on top of the stack.\n\n@param `macroName` Name of macro to execute, without a leading '@'\n\n@param `macroRegister` Register number in which the macro is stored, without a leading '@'\n\n",signature:"RUN( macroName:STRING ): \nRUN( macroRegister:LONG ): ",tags:["platform"],since:"1.0.0",OPB64name:"RUN"},RUNNERNONCE:{description:"The `RUNNERNONCE` function decrypts the content of a runner *nonce* as generated when a script is executed by a Warp 10 runner instance.\n\nWhen a script is executed by a runner instance, the following symbols are defined when the script is invoked:\n\n| Symbol | Description |\n| --- | --- |\n| `runner.periodicity` | Periodicity at which the script is supposed to run, in ms. |\n| `runner.path` | Path of the script. |\n| `runner.scheduledat` | Time at which the current execution was scheduled, in ms since the [UNIX Epoch](). |\n| `runner.nonce` | Encrypted time of execution, in time units since the [UNIX Epoch](). |\n\nNote that if the runner pre-shared key is not configured via `runner.psk`, the `RUNNERNONCE` function will push `NULL` onto the stack. Note that in this case, the `runner.nonce` symbol will not be defined.\n\n@param `nonce` Runner *nonce* as stored in `runner.nonce`.\n\n@param `time` Time retrieved from the *nonce*.\n\n",signature:"RUNNERNONCE( nonce:STRING ): time:LONG",tags:["stack"],since:"1.2.7",OPB64name:"RUNNERNONCE"},RUNR:{description:"Run the macro currently contained in the designated register.\n\nThe `RUNR` function is really a family of functions named `RUNRx` where `x` is a register number. The default registers supported by Warp 10™ are numbered 0 to 255.\n\n",signature:"RUNR(): ",tags:["maps"],since:"2.7.0",OPB64name:"RUNR"},RVALUESORT:{description:"Sort Geo Time Series™ values (and associated locations/elevations) by by reverse order of their values.\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `result` A sorted Geo Time Series™\n\n@param `resultList` A list of sorted Geo Time Series™\n\n",signature:"RVALUESORT( gts:GTS ): result:GTS\nRVALUESORT( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"RVALUESORT"},SAVE:{description:"The `SAVE` function pushes onto the stack a *context* object which contains all the symbols currently defined in the current stack. This context can be passed as a parameter to the [`RESTORE`](doc/RESTORE) function to later reset the symbol table to the state store in the context. Any symbol created after the context was saved and before it is restored will be discarded when `RESTORE` is called.\n\n@param `context` Stack context, suitable as a parameter to [`RESTORE`](doc/RESTORE).\n\n",signature:"SAVE(): context:CONTEXT",tags:["stack"],since:"1.0.0",OPB64name:"SAVE"},SCALB:{description:'The `SCALB` function consumes a scale factor *scaleFactor* and a numeric parameter *d* and pushes back <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi><mo>&#xD7;</mo><msup><mn>2</mn><mi>scaleFactor</mi></msup></math>. The scale factor must fit into an INT.\n\n@param `scaleFactor` The scaling factor, must fit into an INT\n\n@param `d` The value to be scaled\n\n@param `result` The scaled value\n\n',signature:"SCALB( d:NUMBER scaleFactor:LONG ): result:TYPE",tags:["math"],since:"1.2.23",OPB64name:"SCALB"},SECTION:{description:"The `SECTION` function modifies the value of the *section* attribute of the stack. This value appears in the error messages and can therefore help you debug your WarpScript code. Typically, the `SECTION` function is used to separate your code in different logical units.\n\n@param `section` Name to assign to the *section* attribute.\n\n",signature:"SECTION( section:STRING ): ",tags:["stack","debug"],since:"1.2.7",OPB64name:"SECTION"},SECURE:{description:"The `SECURE` function encrypts a STRING representing a WarpScript code fragment using the platform's secure script cryptographic key and the current secret set via [`SECUREKEY`](doc/SECUREKEY).\n\nSecure scripts can also be created using the `<S .... S>` syntax.\n\n@param `script` Cleartext version of the WarpScript fragment to encrypt.\n\n@param `encrypted` Encrypted secure script.\n\n",signature:"SECURE( script:STRING ): encrypted:STRING",tags:["crypto","stack"],since:"1.2.11",OPB64name:"SECURE"},SECUREKEY:{description:"The `SECUREKEY` function sets the secret which will be used to decrypt further secure scripts.\n\nSecure scripts are WarpScript fragments which are encrypted with a cryptographic key specific to the platform they were created on. They can be executed on a platform configured with the same cryptographic key.\n\n@param `key` Secret to use for unlocking the cleartext versions of future secure scripts.\n\n",signature:"SECUREKEY( key:STRING ): ",tags:["crypto","stack"],since:"1.0.0",OPB64name:"SECUREKEY"},"SENSISION.DUMP":{description:"The `SENSISION.DUMP` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) metrics in the JVM.\n\nThe STRING produced by `SENSISION.DUMP` can be parsed using `PARSE`.\n\n@param `valueTimestamp` Flag indicating whether to dump the Geo Time Series™ with the timestamp of last updates or the timestamp at which the value is read.\n\n@param `dump` Latest values of all Geo Time Series™ known to Sensision in Geo Time Series™ output input.\n\n",signature:"SENSISION.DUMP( valueTimestamp:BOOLEAN ): dump:STRING",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMP"},"SENSISION.DUMPEVENTS":{description:"The `SENSISION.DUMPEVENTS` function produces a STRING representing the current values of all [Sensision](https://github.com/senx/sensision) events in the events history.\n\nThe STRING produced by `SENSISION.DUMPEVENTS` can be parsed using `PARSE`.\n\nNote that if the system property `sensision.events.history` is not set to a value greater than 0, the function will always return an empty STRING.\n\nThe Sensision event history is a circular buffer.\n\n@param `dump` Latest values of all events in the Sensision event history.\n\n",signature:"SENSISION.DUMPEVENTS(): dump:STRING",tags:["extensions"],since:"2.1.0",OPB64name:"SENSISION.DUMPEVENTS"},"SENSISION.EVENT":{description:"The `SENSISION.EVENT` function creates a [Sensision](https://github.com/senx/sensision) event.\n\n@param `class` Name of the class of the Sensision event to emit.\n\n@param `labels` Map of label names to values, both STRINGs of the Sensision event.\n\n@param `value` Value associated with the event.\n\n@param `ts` Optional timestamp for the event (in Sensision time units), if omitted, the current timestamp will be used.\n\n",signature:"SENSISION.EVENT( [ value:LONG labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:STRING labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:BOOLEAN labels:MAP class:STRING ] ): \nSENSISION.EVENT( [ value:LONG labels:MAP class:STRING ts:LONG ] ): \nSENSISION.EVENT( [ value:DOUBLE labels:MAP class:STRING ts:LONG ] ): \nSENSISION.EVENT( [ value:STRING labels:MAP class:STRING ts:LONG ] ): \nSENSISION.EVENT( [ value:BOOLEAN labels:MAP class:STRING ts:LONG ] ): ",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.EVENT"},"SENSISION.GET":{description:"The `SENSISION.GET` function reads the current value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to read.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to read.\n\n@param `selector` Geo Time Series™ selector (`class{labels}`) of the Sensision metric to read.\n\n@param `gts` A Geo Time Series™ containing the current value of the Sensision metric. If the metric does not exist, the resulting GTS will be empty.\n\n",signature:"SENSISION.GET( selector:STRING ): gts:GTS\nSENSISION.GET( class:STRING labels:MAP ): gts:GTS",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.GET"},"SENSISION.SET":{description:"The `SENSISION.SET` function sets a value for a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `value` Value to assign to the Sensision metric.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",signature:"SENSISION.SET( [ value:LONG labels:MAP class:STRING ] ): \nSENSISION.SET( [ value:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.SET( [ value:STRING labels:MAP class:STRING ] ): \nSENSISION.SET( [ value:BOOLEAN labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:LONG labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:STRING labels:MAP class:STRING ] ): \nSENSISION.SET( [ ttl:LONG value:BOOLEAN labels:MAP class:STRING ] ): ",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.SET"},"SENSISION.UPDATE":{description:"The `SENSISION.UPDATE` function updates the numerical value of a [Sensision](https://github.com/senx/sensision) metric.\n\n@param `class` Name of the class of the Sensision metric to set.\n\n@param `labels` Map of label names to values, both STRINGs for the Sensision metric to set.\n\n@param `delta` Delta to add to the current value of the Sensision metric. If the metric does not exist it will be created with this value.\n\n@param `ttl` Optional Time To Live of the metric, if the metric is not updated/set within that number of milliseconds, Sensision will discard it.\n\n",signature:"SENSISION.UPDATE( [ delta:LONG labels:MAP class:STRING ] ): \nSENSISION.UPDATE( [ delta:DOUBLE labels:MAP class:STRING ] ): \nSENSISION.UPDATE( [ ttl:LONG delta:LONG labels:MAP class:STRING ] ): \nSENSISION.UPDATE( [ ttl:LONG delta:DOUBLE labels:MAP class:STRING ] ): ",tags:["extensions"],since:"1.1.0",OPB64name:"SENSISION.UPDATE"},SET:{description:"The `SET` function replaces item at specified index in a list.\nIf the index is greater than the size of the list, it will raise an error.\n\nWhen used on a **BYTE ARRAY**, SET replaces the byte by the byte value. The byte value, signed or not, must be in the range of [-128,255].\n\nSince 2.1, the index can be negative. In this case the effective index is index + size of the **LIST** or **BYTE ARRAY**.\n\nSince 2.1, SET can set an element in a nested list. In this case, the index is a list.\n\n@param `index` The index in the list, 0 for the first item.\n\n@param `inputlist` The input list to modified.\n\n@param `outputlist` The input list modified,  this is not a new list object.\n\n@param `item` The item to update in the inputlist at index, could be any type.\n\n@param `array` Byte array to which write a byte.\n\n@param `bytevalue` The value of the byte, signed or unsigned (from -128 to 255).\n\n@param `outputarray` The input byte array modified, this is not a new byte array.\n\n",signature:"SET( inputlist:LIST item:ANY index:LONG ): outputlist:LIST\nSET( inputlist:LIST item:ANY index:LIST ): outputlist:LIST\nSET( array:BYTES bytevalue:LONG index:LONG ): outputarray:LIST",tags:["lists","binary"],since:"1.0.0",OPB64name:"SET"},"SET->":{description:"The `SET->` function converts the set on top of the stack into a **LIST**.\n\n@param `input` Input set.\n\n@param `output` A list containing input elements.\n\n",signature:"SET->( input:SET ): output:LIST",tags:["sets"],since:"1.0.0",OPB64name:"JoKJAIs"},SETATTRIBUTES:{description:"Modifies the attributes of a Geo Time Series™, an encoder or a list thereof. The `SETATTRIBUTES` function expects a parameter MAP whose entries are attributes to set or alter.\n\nIf the parameter MAP has an entry with a NULL key, the `SETATTRIBUTES` function will use the rest of the MAP as the actual attributes to set for the GTS. If no NULL key exist, then the other entries of the MAP will alter the existing attributes.\n\nAn entry with an empty STRING value will have the effect of removing the attribute from the attributes of the GTSs or encoders.   \n\n@param `attributes` Parameter map of attributes names to values.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lencoder` List of Encoders.\n\n@param `encoder` Encoder to relabel\n\n",signature:"SETATTRIBUTES( gts:GTS attributes:MAP ): gts:GTS\nSETATTRIBUTES( lgts:LIST<GTS> attributes:MAP ): lgts:LIST<GTS>\nSETATTRIBUTES( encoder:GTSENCODER attributes:MAP ): encoder:GTSENCODER\nSETATTRIBUTES( lencoder:LIST<GTS> attributes:MAP ): lencoder:LIST<GTS>",tags:["gts","encoder"],since:"1.0.0",OPB64name:"SETATTRIBUTES"},SETMACROCONFIG:{description:"The `SETMACROCONFIG` function allows you to set or modify the value of a configuration key accessible via the [`MACROCONFIG`](/doc/MACROCONFIG) or [`MACROCONFIGDEFAULT`](/doc/MACROCONFIGDEFAULT) functions or via the runner script variable expansion.\n\nThis function can only be used if the `warpscript.macroconfig.secret` is set in the Warp 10™ configuration.\n\nThe configuration keys which can be set using `SETMACROCONFIG` must have the format `key@path/tomacro` or `key@/path/to/runner/script`.\n\nSetting the value of a configuration key to `NULL` has the effect of removing the configuration key altogether.\n\n@param `key` Configuration key to set.\n\n@param `secret` Macro config secret.\n\n@param `value` String value to set for the key or `NULL`.\n\n",signature:"SETMACROCONFIG( value:STRING key:STRING secret:STRING ): ",tags:["platform"],since:"2.1.0",OPB64name:"SETMACROCONFIG"},SETVALUE:{description:"The `SETVALUE` function adds a value to a GTS or override an existing value. If the tick already exists, this function will overwrite the first one it encounters in the GTS. If the tick does not exist, it is appended. \nThe [`ADDVALUE`](/doc/ADDVALUE) function adds a value to a GTS but do not override an existing value.\n\nThe `SETVALUE` function only works on GTS, not on lists of GTS like those generated by the use of [`FETCH`](/doc/FETCH).\nIf you want to use `SETVALUE` after a [`FETCH`](/doc/FETCH), you will need to extract the GTS from the list, using [`GET`](/doc/GET) for instance.\n\n@param `value` Value of the tick\n\n@param `gts` Geo Time Serie\n\n@param `tick` Timestamp\n\n@param `latitude` Latitude or NaN\n\n@param `longitude` Longitude or NaN\n\n@param `elevation` Elevation or NaN\n\n@param `result` modified Geo Time Series™\n\n",signature:"SETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:STRING ): result:GTS\nSETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:BOOLEAN ): result:GTS\nSETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:DOUBLE ): result:GTS\nSETVALUE( gts:GTS tick:LONG latitude:DOUBLE longitude:DOUBLE elevation:LONG value:LONG ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"SETVALUE"},SHA1:{description:"The `SHA1` function digests a byte array on the stack with the cryptographic hash function [SHA-1](https://en.wikipedia.org/wiki/SHA-1).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",signature:"SHA1( input:BYTES ): result:BYTES",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1"},SHA1HMAC:{description:"The `SHA1HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-1](https://en.wikipedia.org/wiki/SHA-1) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",signature:"SHA1HMAC( message:BYTES secret:BYTES ): result:BYTES",tags:["crypto"],since:"1.2.0",OPB64name:"SHA1HMAC"},SHA256:{description:"The `SHA256` function digests a byte array on the stack with the cryptographic hash function [SHA-256](https://en.wikipedia.org/wiki/SHA-2).\n\n@param `input` Byte array\n\n@param `result` Byte array\n\n",signature:"SHA256( input:BYTES ): result:BYTES",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256"},SHA256HMAC:{description:"The `SHA256HMAC` function computes a Hash-based Message Authentication Code [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) \nthat uses a key in conjunction with a [SHA-256](https://en.wikipedia.org/wiki/SHA-2) cryptographic hash function.\n\n@param `secret` Secret key into byte array\n\n@param `message` Message string into byte array\n\n@param `result` MAC (message authentication code) byte array\n\n",signature:"SHA256HMAC( message:BYTES secret:BYTES ): result:BYTES",tags:["crypto"],since:"1.2.0",OPB64name:"SHA256HMAC"},SHAPE:{description:"Return the shape of an input list if it could be a tensor (or multidimensional array), or raise an Exception.\n\n@param `fast` If true, it does not check if the sizes of the nested lists are coherent and it returns a shape based on the first nested lists at each level. Default to false.\n\n@param `list` The input list.\n\n@param `shape` The shape of the input list.\n\n",signature:"SHAPE( list:LIST ): shape:LIST\nSHAPE( { list:LIST fast:BOOLEAN  } ): shape:LIST",tags:["lists","tensors"],since:"2.1.0",OPB64name:"SHAPE"},SHMLOAD:{description:"The `SHMLOAD` function loads data previously stored by [`SHMSTORE`](/doc/SHMSTORE) in shared memory, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the requested shared symbol is not known or if the calling script does not currently hold the mutex associated with the symbol.\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to retrieve.\n\n@param `object` Object currently stored under `symbol`.\n\n",signature:"SHMLOAD( symbol:STRING ): object:ANY",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMLOAD"},SHMSTORE:{description:"The `SHMSTORE` function stores an object in a named shared memory location, *i.e.* in a memory location independent of a given execution context.\n\nThe call will fail if the calling script is not currently holding a mutex (in a call to [`MUTEX`](/doc/MUTEX)). The call will have no effect if the named memory location was already set by a previous call to `SHMSTORE`.\n\nIn order to overwrite a shared memory location, its content must first be cleared by storing [`NULL`](/doc/NULL).\n\n\nIf the calling script currently holds a mutex, this mutex will be associated with the shared memory location, the same mutex will have to be held when retrieving the content of the memory location via [`SHMLOAD`](/doc/SHMLOAD).\n\nThe `shm.ttl` configuration, in millisecond, allow you to tune the retention time in memory. Default value is one hour. Tip: you can call [`SHMLOAD`](/doc/SHMLOAD) in a runner with a period shorter than `shm.ttl` if you want to keep value in memory indefinitely.\n\n\n@param `symbol` Name of shared symbol to store.\n\n@param `object` Object to store under `symbol` or `NULL` to clear its content.\n\n",signature:"SHMSTORE( object:ANY symbol:STRING ): ",tags:["extensions","stack"],since:"2.0.0",OPB64name:"SHMSTORE"},SHOW:{description:"The `SHOW` function makes visible some levels of the stack which were previously hidden by a call to [`HIDE`](/doc/HIDE).\n\nThe levels made visible are the ones closest to the top of the stack. Depending on the `levels` parameter to the call to `SHOW`, the revealed levels could be the whole stack (`levels` == 0), a maximum number of levels (`levels` >= 0) or a number of levels such that there are at most a certain number ((*abs(`levels`)*) with `levels` < 0) of visible levels after the call.\n\nWhen called with `NULL` as parameter, `SHOW` wil reveal all levels currently hidden.\n\n@param `levels` Number of levels to reveal, or `NULL` to reveal them all.\n\n",signature:"SHOW( levels:LONG ): ",tags:["stack"],since:"2.7.1",OPB64name:"SHOW"},SHRINK:{description:"Shrink the number of values of a Geo Time Series™ to `size`. The oldest values are kept if `size` is non negative. The earliest ones are kept in the other case.\n\nThis function has the side effect of sorting the Geo Time Series™. If the Geo Time Series™ has fewer than `size` values the function raises an error.\n\n@param `size` Size used to shrink the Geo Time Series™\n\n@param `gts` A Geo Time Series™\n\n@param `result` A shrinked Geo Time Series™\n\n",signature:"SHRINK( gts:GTS size:LONG ): result:GTS",tags:["gts"],since:"1.0.0",OPB64name:"SHRINK"},SHUFFLE:{description:"The `SHUFFLE` function shuffles a list.\n\nIf it is not a list, it raises an error. The original list is modified.\n\n@param `input` The reference of the list to shuffle\n\n@param `shuffled` The original list shuffled, this is not a new list object\n\n",signature:"SHUFFLE( input:LIST ): shuffled:LIST",tags:["lists"],since:"2.1.0",OPB64name:"SHUFFLE"},SIGNUM:{description:"The `SIGNUM` function consumes a numeric parameter from the top of the stack and pushes back its signum.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Signum, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n@param `lvalue` List of numeric value\n\n@param `lresult` List of signum for each given value, i.e. it returns -1 if the parameter is negative, 1 if positive and 0 if it is 0.\n\n",signature:"SIGNUM( value:NUMBER ): result:DOUBLE\nSIGNUM( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["operators","math"],since:"1.0.0",OPB64name:"SIGNUM"},SIN:{description:"The `SIN` function consumes a floating point number from the top of the stack and pushes back its sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Sine of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of sine of the given values.\n\n",signature:"SIN( value:NUMBER ): result:DOUBLE\nSIN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SIN"},SINGLEEXPONENTIALSMOOTHING:{description:"The `SINGLEEXPONENTIALSMOOTHING` function takes a Geo Time Series™ and smooths it with the\n[additive Simple Exponential Smoothing](https://www.otexts.org/fpp/7/1) formula.\n\nIt consumes two parameters from the top of the stack:\n * A level smoothing factor alpha (a numeric parameter between 0 < alpha < 1)\n * The GTS to smooth\n\n The resulting smoothed **GTS** is pushed onto the stack.\n\n@param `alpha` The level smoothing factor, it should be strictly between 0.0 and 1.0, the lower the smoother\n\n@param `gts` The Geo Time Series™ to smooth\n\n@param `result` The smoothed Geo Time Series™\n\n",signature:"SINGLEEXPONENTIALSMOOTHING( gts:GTS alpha:DOUBLE ): result:GTS",tags:["gts","statistics"],since:"1.0.0",OPB64name:"SINGLEEXPONENTIALSMOOTHING"},SINH:{description:"The `SINH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic sine.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic sine of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic sine of the given values.\n\n",signature:"SINH( value:NUMBER ): result:DOUBLE\nSINH( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"SINH"},SIZE:{description:"Returns the size of the input parameter.\n\nThe `SIZE` function computes the size of a LIST, MAP, GTS or ENCODER (number of values), STRING, byte array of GEOSHAPE (number of cells).\n\n@param `input` The input parameter\n\n@param `size` The size of the input parameter\n\n",signature:"SIZE( input:LIST ): size:LONG\nSIZE( input:MAP ): size:LONG\nSIZE( input:GTS ): size:LONG\nSIZE( input:STRING ): size:LONG\nSIZE( input:BYTES ): size:LONG\nSIZE( input:GEOSHAPE ): size:LONG\nSIZE( input:GTSENCODER ): size:LONG\nSIZE( input:SET ): size:LONG",tags:["strings","lists","maps","gts","geo"],since:"1.0.0",OPB64name:"SIZE"},SKEWNESS:{description:"The `SKEWNESS` function computes the [skewness](https://en.wikipedia.org/wiki/Skewness) of a Geo Time Series™.\n\n@param `bessel` Boolean indicating whether or not to apply [Bessel's correction](https://en.wikipedia.org/wiki/Bessel's_correction) when computing the skewness.\n\n@param `gts` Non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `lgts` List of non empty numerical Geo Time Series™ for which to compute the skewness.\n\n@param `skewness` Computed skewness of the Geo Time Series™ instance.\n\n@param `lskewness` List of computed skewness of the Geo Time Series™ instances.\n\n",signature:"SKEWNESS( gts:GTS bessel:BOOLEAN ): skewness:DOUBLE\nSKEWNESS( lgts:LIST<GTS> bessel:BOOLEAN ): lskewness:LIST<DOUBLE>",tags:["statistics","gts"],since:"1.2.13",OPB64name:"SKEWNESS"},SMARTPARSE:{description:"The `SMARTPARSE` function parses STRING values, either from a single STRING parameter or from STRING Geo Time Series™, and produces a number of GTS from the parsed data.\n\nThe parsing is done according to a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) which contains [named capturing groups](https://www.regular-expressions.info/named.html) with the Java/.NET syntax, *i.e.* `(?<name>...)`.\n\nThe captured group is interpreted differently based on the syntax of the name.\n\n| Syntax | Interpretation |\n| --- | --- |\n| Lxxx | Captured content is used as the value of label `xxx` |\n| TU | Captured group is interpreted as a timestamp in unit `U` from the [UNIX Epoch](https://en.wikipedia.org/wiki/Unix_time) origin. Valid values for U are `s`, `ms`, `us`, `ns` |\n| lat | Captured group is interpreted as the latitude if another group named `lon` is also present |\n| lon | Captured group is interpreted as the longitude if another group named `lat` is also present |\n| elevU | Captured group is interpreted as the elevation in unit `U`, where `U` can be `m`, `cm`, `mm`, `ft`, `km`, `mi`, `nm` (Nautical Mile). The value is parsed as a DOUBLE and converted to a LONG in `mm` |\n| VTxxx | Captured group is interpreted as a value for a GTS with class `xxx`. The type of the value is determined by the value of `T` which can be `B`(oolean) `S`(tring) `L`(ong) or `D`(ouble) |\n\nThis function is ideally suited for parsing log messages and producing Geo Time Series™ from their content.\n\n@param `regexp` Regular expression to use for parsing. See the function description for the syntax to use.\n\n@param `string` String to parse\n\n@param `results` List of Geo Time Series™ created from the parsed data.\n\n@param `lresults` List of list of GTS created from the parsed data.\n\n@param `gts` STRING valued Geo Time Series™ whose values are to be parsed.\n\n@param `lgts` List of STRING valued GTS whose values are to be parsed.\n\n",signature:"SMARTPARSE( string:STRING regexp:STRING ): results:LIST<GTS>\nSMARTPARSE( gts:GTS regexp:STRING ): results:LIST<GTS>\nSMARTPARSE( lgts:LIST<GTS> regexp:STRING ): lresults:LIST<LIST<GTS>>",tags:["gts","strings"],since:"1.2.13",OPB64name:"SMARTPARSE"},SNAPSHOT:{description:"The `SNAPSHOT` functions produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOT` was called.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOT( stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.0.6",OPB64name:"SNAPSHOT"},SNAPSHOTALL:{description:"The `SNAPSHOTALL` functions acts similarly as [`SNAPSHOT`](/doc/SNAPSHOT) and produces a STRING which contains WarpScript code to regenerate the stack in the exact same state as when `SNAPSHOTALL` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTALL( stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALL"},SNAPSHOTALLTOMARK:{description:"The `SNAPSHOTALLTOMARK` functions acts similarly as [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) and produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTALLTOMARK` was called. It differs by the fact that it also adds code to repopulate the symbol table.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTALLTOMARK( mark:MARK stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTALLTOMARK"},SNAPSHOTCOPY:{description:"The `SNAPSHOTCOPY` function behaves like [`SNAPSHOT`](/doc/SNAPSHOT) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPY` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTCOPY( stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPY"},SNAPSHOTCOPYALL:{description:"The `SNAPSHOTCOPYALL` function behaves like [`SNAPSHOTALL`](/doc/SNAPSHOTALL) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALL` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTCOPYALL( stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALL"},SNAPSHOTCOPYALLTOMARK:{description:"The `SNAPSHOTCOPYALLTOMARK` function behaves like [`SNAPSHOTALLTOMARK`](/doc/SNAPSHOTALLTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack and its symbols as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYALLTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTCOPYALLTOMARK( stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYALLTOMARK"},SNAPSHOTCOPYN:{description:"Performs a [`SNAPSHOTCOPY`](/doc/SNAPSHOTCOPY) on the top *N* elements of the stack.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTCOPYN( stack:ANY* n:LONG ): snapshot:STRING",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTCOPYN"},SNAPSHOTCOPYTOMARK:{description:"The `SNAPSHOTCOPYTOMARK` function behaves like [`SNAPSHOTTOMARK`](/doc/SNAPSHOTTOMARK) but does not consume the elements of the stack, instead it produces WarpScript code which will regenerate the stack as it was before the call and pushes this code on top of the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTCOPYTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTCOPYTOMARK( stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.2.5",OPB64name:"SNAPSHOTCOPYTOMARK"},SNAPSHOTN:{description:"Produces a WarpScript code fragment which will regenerate the *N* top levels of the stack. The content of those levels is consumed off the stack.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOT` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\n@param `n` The number of stack levels to snapshot\n\n@param `stack` The content of the stack before the call\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTN( stack:ANY* n:LONG ): snapshot:STRING",tags:["stack"],since:"1.2.13",OPB64name:"SNAPSHOTN"},SNAPSHOTTOMARK:{description:"The `SNAPSHOTTOMARK` functions produces a STRING which contains WarpScript code to regenerate the stack up to the first [`MARK`](/doc/MARK) in the exact same state as when `SNAPSHOTTOMARK` was called.\n\nThe [`MARK`](/doc/MARK) is consumed off the stack but will not be pushed back by the produced WarpScript code.\n\nNote that some types of objects created by third party functions may not be serializable, `SNAPSHOTTOMARK` will emit a STRING of the form `UNSUPPORTED: class xxx` when such a type is encountered.\n\nThe elements of the stack are consumed up to the mark.\n\n@param `stack` The stack elements below [`MARK`](/doc/MARK) which will be regenerated by the produced WarpScript code\n\n@param `mark` [`MARK`](/doc/MARK) which indicates the end of the stack levels to consider\n\n@param `snapshot` The WarpScript code to regenerate the stack\n\n",signature:"SNAPSHOTTOMARK( mark:MARK stack:ANY* ): snapshot:STRING",tags:["stack"],since:"1.0.7",OPB64name:"SNAPSHOTTOMARK"},SORT:{description:"Sorts a Geo Time Series™ or each GTS of a list of GTS in ascending tick order.\n\n@param `gts` Single Geo Time Series™ instance to sort.\n\n@param `sgts` Sorted Geo Time Series™, this is the same instance as `gts`.\n\n@param `lgts` List of Geo Time Series™ instances to sort.\n\n@param `slist` List of sorted Geo Time Series™. Each instance is the same as the input one.\n\n",signature:"SORT( gts:GTS ): sgts:GTS\nSORT( lgts:LIST<GTS> ): slist:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"SORT"},SORTBY:{description:"The `SORTBY` function sorts a **LIST** or a **MAP** according to a value returned by a macro. The macro must return a value of the same type (LONG, DOUBLE or STRING) for each element.\n\nOnly **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nBefore release `1.2.22`, the `SORTBY` function could only sort lists of Geo Time Series™.\n\nBefore release `2.7.0`, the `SORTBY` function could only sort lists but not maps.\n\n@param `macro` Macro used for sorting, consumes a list element off the stack and produces a LONG, DOUBLE or STRING value.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",signature:"SORTBY( list:LIST macro:MACRO ): lsorted:LIST\nSORTBY( map:MAP macro:MACRO ): msorted:MAP",tags:["lists","gts"],since:"1.0.11",OPB64name:"SORTBY"},SORTWITH:{description:"The `SORTWITH` function sorts a **LIST** or a **MAP** according to a value returned by a comparison macro. Only **MAP**s of type [LinkedHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html), which are the most commons in WarpScript, can be sorted.\n\nIn used a on **LIST**, the comparison macro is given 2 elements of the **LIST** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest element in the stack is respectively strictly less than, equal to or strictly more than than the element on the stack.\n\nIn used a on **MAP**, the comparison macro is given 2 entries (key deepest, value shallowest) of the **MAP** and return a **LONG** which can be represented on 32 bits. The returned value must be negative, zero or positive if the deepest entry in the stack is respectively strictly less than, equal to or strictly more than than the shallowest entry on the stack.\n\nBefore release `2.7.0`, the `SORTWITH` function could only sort lists but not maps.\n\n@param `macro` Macro used for comparison, must consume two elements of the stack and produces a LONG.\n\n@param `list` List to sort.\n\n@param `map` Map to sort.\n\n@param `lsorted` Sorted list, same instance as `list`.\n\n@param `msorted` Sorted map, same instance as `map`.\n\n",signature:"SORTWITH( list:LIST macro:MACRO ): lsorted:LIST\nSORTWITH( map:MAP macro:MACRO ): msorted:MAP",tags:["lists","gts"],since:"2.2.0",OPB64name:"SORTWITH"},SPLIT:{description:"The SPLIT function split a string in segments given a delimiter.\n\n\nIt consumes two parameters from the top of the stack: the delimiter and the string to test matching with. The delimiter must be a string of length 1, i.e. only one character.\n\n\nThe function will return a list with all the segments. If delimiter is not found, the output list contains the input string.\n\n@param `delimiter` One character delimiter.\n\n@param `s` The string to split\n\n@param `result` List of strings.\n\n",signature:"SPLIT( s:STRING delimiter:STRING ): result:LIST<STRING>",tags:["strings"],since:"1.0.0",OPB64name:"SPLIT"},SQRT:{description:"The `SQRT` function consumes a numeric parameter from the top of the stack and pushes back its square root.\n\nFor negative numbers, SQRT returns NaN.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value\n\n@param `result` Square root of the given value, NaN if it is negative.\n\n@param `lvalue` List of numeric values\n\n@param `lresult` List of square root of each given value, NaN if it is negative.\n\n",signature:"SQRT( value:NUMBER ): result:DOUBLE\nSQRT( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"SQRT"},SRAND:{description:"The `SRAND` function pushes onto the stack a random DOUBLE between 0.0 (inclusive) and 1.0 (exlusive) generated by the seeded [Pseudorandom Number Generator (PRNG)](https://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\nThe seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThis generation is **NOT** cryptographically secure, use [RAND](/doc/RAND) if you need a secure random number.\n\n@param `num` Generated random number between 0 and 1.\n\n",signature:"SRAND(): num:DOUBLE",tags:["math"],since:"1.2.9",OPB64name:"SRAND"},SRANDPDF:{description:"Pushes on the stack a function which emits values according to a provided value histogram.\n\nThe randomization is seeded. The seeded PRNG must have been initialized beforehand using [`PRNG`](/doc/PRNG).\n\nThe result is a function. This function does not have any arguments.\n\nTo use the function pushed by `SRANDPDF` onto the stack, use [`EVAL`](/doc/EVAL).\n\n@param `valueHistogram` the [value histogram](/doc/VALUEHISTOGRAM). The value histogram is a map whose keys are the values and the elements the cardinality at which they occur or their occurrence probability.\n\n@param `result` A function pushed onto the stack. This function will emits values.\n\n",signature:"SRANDPDF( valueHistogram:MAP ): result:STRING",tags:["math","statistics"],since:"2.2.1",OPB64name:"SRANDPDF"},STACKATTRIBUTE:{description:"Retrieves the value of a stack attribute.\n\n@param `name` Name of the stack attribute to retrieve.\n\n@param `value` Associated value or null if attribute is not set.\n\n",signature:"STACKATTRIBUTE( name:STRING ): value:ANY",tags:["stack"],since:"1.0.0",OPB64name:"STACKATTRIBUTE"},STACKPSSECRET:{description:"Modifies the secret needed for using functions such as `WSPS`, `WSSTOP` and `WSKILL`.\n\nThis function is only useable if a secret was configured using `stackps.secret`.\n\n@param `secret` Current secret for process status operations, initially the value configured via `stackps.secret`.\n\n@param `newsecret` New secret to set for process status operations.\n\n",signature:"STACKPSSECRET( newsecret:STRING secret:STRING ): ",tags:["extensions","platform"],since:"2.5.0",OPB64name:"STACKPSSECRET"},STACKTOLIST:{description:"Converts the whole stack into a list and pushes this list on top of the stack. The elements are consumed off the stack in the way [`->LIST`](/doc/AItBHKCJ) does it.\n\n@param `stack` Content of the stack.\n\n@param `list` List containing the elements of the stack.\n\n",signature:"STACKTOLIST( stack:ANY* ): list:LIST",tags:["stack"],since:"1.0.14",OPB64name:"STACKTOLIST"},STANDARDIZE:{description:"Standardizes a single (or a list of) numeric Geo Time Series™ (i.e. it replaces X by (X-mu)/sd).\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n",signature:"STANDARDIZE( gts:GTS ): result:GTS\nSTANDARDIZE( gtsList:LIST<GTS> ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"STANDARDIZE"},STDERR:{description:"The `STDERR` function prints text to the standard error stream.\n\nThe `STDERR` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `msg` The debug text to print\n\n",signature:"STDERR( msg:STRING ): ",tags:["extensions"],since:"1.0.0",OPB64name:"STDERR"},STDOUT:{description:"The `STDOUT` function prints text to the standard output stream.\n\nThe `STDOUT` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `obj` The object to print. Its `.toString()` method is used to generate the outputed String.\n\n",signature:"STDOUT( obj:ANY ): ",tags:["extensions"],since:"1.0.0",OPB64name:"STDOUT"},STL:{description:'The `STL` function applies a Seasonal Trend decomposition on a Geo Time Series™ or a **LIST** of Geo Time Series™, which is based on multiple calls of [`RLOWESS`](/doc/RLOWESS).\n\nThese Geo Time Series™ are the seasonal part and the trend part of the input Geo Time Series™. Their classnames are suffixed with "_seasonal" and "_trend".\n\nThis function can only be applied to [bucketized](/doc/BUCKETIZE) Geo Time Series™ of numeric type.\n\nThe **MAP** parameter must have at least the field `PERIOD`. You can provide additional optional parameters:\n\n## Optional parameters\n### Global\n- `ROBUST` if TRUE, set defaults of number of inner and outer loops to 1 and 15 instead of 2 and 0. Default is FALSE\n- `PRECISION` number of inner loops (a LONG). Default is 2 or 1\n- `ROBUSTNESS` number of outer loops (a LONG). Default is 0 or 15\n\n### Seasonal extract\n- `BANDWIDTH_S` the bandwidth (a LONG) of the local regression. Default is 7\n- `DEGREE_S` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_S` the number of values interpolated instead of estimated. Default is BANDWIDTH_S/10\n\n### Low frequency filtering\n- `BANDWIDTH_L` the bandwidth (a LONG) of the local regression. Default is nextOdd(PERIOD)\n- `DEGREE_L` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_L` the number of values interpolated instead of estimated. Default is BANDWIDTH_L/10\n\n### Trend extract\n- `BANDWIDTH_T` the bandwidth (a LONG) of the local regression. Default is nextOdd(ceiling(1.5*PERIOD/(1-(1.5/BANDWIDTH_S))))\n- `DEGREE_T` the degree (a LONG) of the polynomial fit. Default is 1\n- `SPEED_T` the number of values interpolated instead of estimated. Default is BANDWIDTH_T/10\n\n### Post seasonal smoothing\n- `BANDWIDTH_P` the bandwidth (a LONG) of the local regression. Default is 0 (i.e. no post smoothing)\n- `DEGREE_P` the degree (a LONG) of the polynomial fit. Default is 2\n- `SPEED_P` the number of values interpolated instead of estimated. Default is BANDWIDTH_P/10\n\n### Additional fields\n- `BANDWIDT` value of all BANDWIDTH_X fields that are not set\n- `DEGREE` value of all DEGREE_X fields that are not set\n- `SPEED` value of all SPEED_X fields that are not set\n\n> ### REFERENCE\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n\n\n@param `gts`  A numeric Geo Time Series™\n\n@param `p` The number of buckets that compose a period\n\n@param `gtsList`  A list of numeric Geo Time Series™\n\n@param `result` A standardized Geo Time Series™\n\n@param `resultList` A list of standardized Geo Time Series™\n\n',signature:"STL( gts:GTS { p:LONG  } ): result:GTS\nSTL( gtsList:LIST<GTS> { p:LONG  } ): resultList:LIST<GTS>",tags:["gts","bucketize"],since:"1.0.0",OPB64name:"STL"},STLESDTEST:{description:'The \'STLESDTEST\' function detects outliers in a Geo Time Series™ (or a **LIST** of Geo Time Series™) which has a seasonal part.\n\nThe seasonal part and the trend part of the Geo Time Series™ are extracted using [`STL`](/doc/STL) decomposition, then an [`ESDTEST`](/doc/ESDTEST) is performed on the remainder.\n\nThis function only applies to [bucketized](/doc/BUCKETIZE) GTS of type **DOUBLE**.\n\n> ### References\n> **Cleveland, Robert B., et al.** "STL: A seasonal-trend decomposition procedure based on loess." Journal of Official Statistics 6.1 (1990): 3-73.\n> **Rosner, Bernard (May 1983)**, "Percentage Points for a Generalized ESD Many-Outlier Procedure",Technometrics, 25(2), pp. 165-172.\n\n@param `STLOption` Optional parameters of the [`STL`](/doc/STL) call\n\n@param `alpha` Optional significance level for the statistical test. Default value is 0.05\n\n@param `k` Upperbound of the number of outliers to detect\n\n@param `p` The number of buckets that compose a period\n\n@param `gts` A Geo Time Series™\n\n@param `gtsList` A list of Geo Time Series™\n\n@param `resultList` A **LIST** of ticks corresponding to the outliers\n\n@param `result` A **LIST** of LIST of ticks corresponding to the outliers\n\n',signature:"STLESDTEST( gts:GTS p:LONG k:LONG alpha:DOUBLE STLOption:MAP ): result:LIST<LONG>\nSTLESDTEST( gts:GTS p:LONG k:LONG alpha:DOUBLE ): result:LIST<LONG>\nSTLESDTEST( gts:GTS p:LONG k:LONG STLOption:MAP ): result:LIST<LONG>\nSTLESDTEST( gts:GTS p:LONG k:LONG ): result:LIST<LONG>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG alpha:DOUBLE STLOption:MAP ): resultList:LIST<LIST<LONG>>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG alpha:DOUBLE ): resultList:LIST<LIST<LONG>>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG STLOption:MAP ): resultList:LIST<LIST<LONG>>\nSTLESDTEST( gtsList:LIST<GTS> p:LONG k:LONG ): resultList:LIST<LIST<LONG>>",tags:["outlier","gts"],since:"1.0.0",OPB64name:"STLESDTEST"},STOP:{description:"The `STOP` function stops the current execution by throwing a `WarpScriptStopException`. This means that the current script execution will be aborted unless the call to `STOP` was in a macro invoked via [`TRY`](/doc/TRY).\n\n",signature:"",tags:["stack","debug"],since:"1.0.0",OPB64name:"STOP"},STORE:{description:"The `STORE` function stores a value in a symbol.\n\nSince 2.7, when the list of symbols contains duplicates only the last occurence in the list is assigned to its corresponding value.\n\n@param `symbol` Name of the symbol to modify.\n\n@param `register` Index of the register to modify.\n\n@param `symbols` List of symbols or registers to modify. The last element of the list will contain the top of the stack.\n\n@param `value` Value to store under `symbol`.\n\n@param `values` Multiple values to store in `symbols`.\n\n",signature:"STORE( value:ANY symbol:STRING ): \nSTORE( value:ANY register:LONG ): \nSTORE( values:ANY* symbols:LIST<STRING> ): ",tags:["stack"],since:"1.0.0",OPB64name:"STORE"},STRICTMAPPER:{description:"Wraps a *mapper* in such a way that the mapper will only be called if the number of ticks in the window is in the specified range.\n\nSince 2.1 STRICTMAPPER can also take a timespan definition by inputing negative numbers. Number of ticks and timespan can also be mixed to specify, for instance, more than 2 points but less than 5 seconds.\n\n@param `max` If positive, maximum number of ticks in the window. If negative, maximum timespan of the window.\n\n@param `min` If positive, minimum number of ticks in the window. If negative, minimum timespan of the window.\n\n@param `mapper` Mapper to wrap.\n\n@param `wrapped` Wrapped mapper.\n\n",signature:"STRICTMAPPER( mapper:AGGREGATOR min:NUMBER max:NUMBER ): wrapped:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"STRICTMAPPER"},STRICTPARTITION:{description:"The `STRICTPARTITION` splits a Geo Time Series™ list in equivalence classes based on label values just like [`PARTITION`](/doc/PARTITION) but only retains in each equivalence class key the labels on which the partitioning was done.\n\n@param `labels` List of labels to consider for creating equivalence classes.\n\n@param `lgts` List of Geo Time Series™ to partition.\n\n@param `result` Map of equivalence classes, keyed by the map of label names to values for the labels in `labels`.\n\n",signature:"STRICTPARTITION( lgts:LIST<GTS> labels:LIST<STRING> ): result:MAP",tags:["gts"],since:"1.0.0",OPB64name:"STRICTPARTITION"},STRICTREDUCER:{description:"Wraps a *reducer* so it is only applied if there are values for all the Geo Time Series™ being reduced.\n\n@param `reducer` Reducer to wrap.\n\n@param `wrapped` Wrapped version of the reducer.\n\n",signature:"STRICTREDUCER( reducer:AGGREGATOR ): wrapped:AGGREGATOR",tags:["reducer"],since:"1.0.6",OPB64name:"STRICTREDUCER"},STRINGFORMAT:{description:"The STRINGFORMAT function format a String in the same ways as Java [String.format](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.util.Locale-java.lang.String-java.lang.Object...-) does.\n\nThis fonction consumes an optional locale in [ISO 639](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry), a list of Objects to be used in the format string and a [format string](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax).\n\nIf no locale is specified, it defaults to the default JVM locale.\n\n@param `format` A format string.\n\n@param `args` Arguments referenced by the format specifiers in the format string.\n\n@param `locale` The locale to apply during formatting.\n\n@param `formattedString` A formatted string.\n\n",signature:"STRINGFORMAT( format:STRING args:LIST ): formattedString:STRING\nSTRINGFORMAT( format:STRING args:LIST locale:STRING ): formattedString:STRING",tags:["strings"],since:"2.2.0",OPB64name:"STRINGFORMAT"},STU:{description:"The `STU` function pushes onto the stack the number of platform time units in one second. This allows WarpScript scripts to be compatible with any platform, regardless of their configured time units (millisecond, microsecond or nanosecond).\n\n@param `numberTimeUnits` Number of platform time units in one second.\n\n",signature:"STU(): numberTimeUnits:LONG",tags:["date","time","platform"],since:"1.0.0",OPB64name:"STU"},SUBLIST:{description:"It creates a new list with the elements of the base list whose indices are in the argument list.\n\nIf the argument list contains two indices [a,b] then `SUBLIST` returns the list of elements from index a to index b (included). If the argument list contains more than two indices, the result of `SUBLIST` contains all the elements at the specified indices, with possible duplicates.\n\nNegative indexing is allowed, with negative index effectively refering to index + size.\n\nSince 2.1 a new signature allowing the step to be defined has been introduced. Instead of specifying a list has range, you can put the start, end (optional) and step (optional) as **LONG** values.\n\n@param `arguments` List of indices. Negative indices are considered to be calculated from the end of the list.\n\n@param `base` Base list\n\n@param `result` Filtred list\n\n@param `start` The first index to consider, will be included.\n\n@param `end` The last index to consider, will be included. If not specified, defaults to -1.\n\n@param `step` The delta between two consecutive indexes to consider. If end is after start in the list, step must be strictly positive. If start is after end in the list, step must be strictly negative. If not specified, defaults to 1 or -1 depending on start and end.\n\n",signature:"SUBLIST( base:LIST<ANY> arguments:LIST<LONG> ): result:LIST<ANY>\nSUBLIST( base:LIST<ANY> start:NUMBER ): result:LIST<ANY>\nSUBLIST( base:LIST<ANY> start:NUMBER end:NUMBER ): result:LIST<ANY>\nSUBLIST( base:LIST<ANY> start:NUMBER end:NUMBER step:NUMBER ): result:LIST<ANY>",tags:["lists"],since:"1.0.0",OPB64name:"SUBLIST"},SUBMAP:{description:"It creates a new map with the key-value pairs from the base map whose keys are in the argument list.\n\n@param `arguments` List of indices.\n\n@param `base` Base map\n\n@param `result` Filtred map\n\n",signature:"SUBMAP( base:MAP arguments:LIST<STRING> ): result:MAP",tags:["maps"],since:"1.0.0",OPB64name:"SUBMAP"},SUBSTRING:{description:"Extract a substring from a **STRING** input, or a subarray from a **BYTE ARRAY** input.  \nIf the length is ommitted, it extracts until the end of the string or byte array. If length is greater than max length, extract stops at the input end.\n\nIf the start is greater than the input size, `SUBSTRING` raises an error.\n\nSince 2.1, the start index can be negative. In this case the effective index is index + size of the **STRING**.\n\n@param `len` Length of substring to extract.\n\n@param `start` First character to include in the substring (0 based).\n\n@param `str` String from which to extract a substring.\n\n@param `substr` Extracted substring.\n\n@param `array` Byte array from which to extract a sub array.\n\n@param `subarray` Extracted sub array.\n\n",signature:"SUBSTRING( str:STRING start:LONG len:LONG ): substr:STRING\nSUBSTRING( str:STRING start:LONG ): substr:STRING\nSUBSTRING( array:BYTES start:LONG len:LONG ): subarray:BYTES\nSUBSTRING( array:BYTES start:LONG ): subarray:BYTES",tags:["strings","binary"],since:"1.0.0",OPB64name:"SUBSTRING"},SUBTRACTEXACT:{description:"The `SUBTRACTEXACT` function consumes two LONGs from the top of the stack and puts back the difference between them. If the difference overflows a LONG, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `x` Numeric value\n\n@param `y` Numeric value\n\n@param `diff` The difference of x and y\n\n@param `list` List of numeric values\n\n@param `sdiff` The first element of the list minus all the others\n\n@param `lx` List of numeric values\n\n@param `ldiff` List of **LONG** where each value is the difference of y and an element in lx\n\n",signature:"SUBTRACTEXACT( x:NUMBER y:NUMBER ): diff:LONG\nSUBTRACTEXACT( list:LIST<NUMBER> ): sdiff:LONG\nSUBTRACTEXACT( lx:LIST<NUMBER> y:NUMBER ): ldiff:LIST<LONG>",tags:["math"],since:"1.2.23",OPB64name:"SUBTRACTEXACT"},SWAP:{description:"Exchanges the positions of the top two elements of the stack.\n\n@param `top` The element on top of the stack prior to the function execution\n\n@param `level2` The element at the second level of the stack prior to the function execution\n\n",signature:"SWAP( level2:ANY top:ANY ): top:ANY level2:ANY",tags:["stack"],since:"1.0.0",OPB64name:"SWAP"},SWITCH:{description:"Performs a [switch statement](https://en.wikipedia.org/wiki/Switch_statement) allowing to select a macro execution based on a series of condition macros or to fallback on to the execution of a default macro.\n\n@param `n` Number of cases to consider. The `SWITCH` function will expect `n` pairs of condition/execution macros plus a default macro on the stack.\n\n@param `default` Macro which will be executed if all condition macros returned false.\n\n@param `cond1` First condition macro. All condition macros are expected to push a boolean on the stack.\n\n@param `condn` `n`th condition macro.\n\n@param `exec1` First execution macro, this macro will be executed if `cond1` left `true` on the stack.\n\n@param `execn` `n`th execution macro.\n\n",signature:"SWITCH( cond1:MACRO exec1:MACRO condn:MACRO execn:MACRO default:MACRO n:LONG ): ",tags:["control"],since:"1.0.0",OPB64name:"SWITCH"},SYMBOLS:{description:"The `SYMBOLS` function outputs the list of all defined symbols.\n\n@param `symbols` The list of the names of all defined symbols.\n\n",signature:"SYMBOLS(): symbols:LIST",tags:["stack"],since:"2.2.1",OPB64name:"SYMBOLS"},SYNC:{description:"Executes a macro in a synchronized way while in a parallel execution triggered by a call to [`CEVAL`](/doc/CEVAL). If `SYNC` is called outside of a parallel execution, it simply executes the macro.\n\nWhen called within a `CEVAL` execution, the use of `SYNC` guarantees that only one of the concurrently executing threads will execute the specified macro at any given time.\n\n@param `macro` Macro to execute in a synchronized way.\n\n",signature:"SYNC( macro:MACRO ): ",tags:["extensions"],since:"1.0.0",OPB64name:"SYNC"},T:{description:"`T` stand for `true`. It is a boolean constant.\n\n\n@param `b` true\n\n",signature:"T(): b:BOOLEAN",tags:["logic","constants"],since:"1.0.0",OPB64name:"T"},TAN:{description:"The `TAN` function consumes a floating point number from the top of the stack and pushes back its tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value in radians\n\n@param `result` Tangent of the given value\n\n@param `lvalue` List of numeric values in radians\n\n@param `lresult` List of tangent of the given values.\n\n",signature:"TAN( value:NUMBER ): result:DOUBLE\nTAN( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TAN"},TANH:{description:"The `TANH` function consumes a floating point number from the top of the stack and pushes back its hyperbolic tangent.\n\nThe parameter is considered to be in radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Value, in radians.\n\n@param `result` Hyperbolic tangent of the gien value.\n\n@param `lvalue` List of numeric values, in radians.\n\n@param `lresult` List of hyperbolic tangent of the given values.\n\n",signature:"TANH( value:NUMBER ): result:DOUBLE\nTANH( lvalue:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["math","trigonometry"],since:"1.0.0",OPB64name:"TANH"},TDESCRIBE:{description:"The `TDESCRIBE` function is a recursive [`TYPEOF`](/doc/TYPEOF).\n\nWhen `TDESCRIBE` finds a LIST, it takes the first element of the list to look for his type. When `TDESCRIBE` finds a MAP, it takes a random key in the map to look for the type of the key and the type of the value.\n\n**By design, TDESCRIBE cannot describe heterogeneous lists or maps.**\n\nTDESCRIBE output is subject to change in the future. Do not try to parse it. This function is here to help you during Warpscript development.\n\n\nThe `TDESCRIBE` function is part of the `io.warp10.script.ext.debug.DebugWarpScriptExtension`, this extenstion must be specified in the\n`warpscript.extensions` configuration parameter for it to be available.\n\nAdd the following line to your Warp 10 configuration:\n```\nwarpscript.extension.debug=io.warp10.script.ext.debug.DebugWarpScriptExtension\n```\n\n@param `object` Any kind of reference\n\n@param `description` The description of the object\n\n",signature:"TDESCRIBE( object:ANY ): description:STRING",tags:["extensions","debug"],since:"1.2.19",OPB64name:"TDESCRIBE"},TEMPLATE:{description:"`TEMPLATE` fills a template with values contained in a map. See example for syntax help.\n\nThe `TEMPLATE` function expects the map of values on top of the stack and will operate on the string template below it.\n\nValues speficied with `{{key}}` will be url-escaped. If you do not want that behavior, use `{{{key}}}`.\n\n@param `dictionnary` Each key will be replaced in a {{key}} template. Value could be string long, double, boolean, or a list of maps. If Value is a list of maps, each subkey/value will be replaced in a {{#key}}{{subkey}}{{/key}} template. \n\n@param `listofmaps` Contains a list of subkey/value map. Will be replaced in a {{#key}}{{subkey}}{{/key}} template.\n\n@param `template` Input template.\n\n@param `output` Result of substitution.\n\n",signature:"TEMPLATE( template:STRING dictionnary:MAP ): output:STRING\nTEMPLATE( template:STRING listofmaps:LIST<MAP> ): output:STRING",tags:["strings"],since:"1.0.0",OPB64name:"TEMPLATE"},THRESHOLDTEST:{description:"Analyzes Geo Time Series™, identifying ticks where values are outliers above the given threshold.\n\n@param `threshold` Threshold above which values are considered outliers.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `ticks` List of ticks where outliers were found.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lticks` List of lists of ticks where outliers were found.\n\n",signature:"THRESHOLDTEST( gts:GTS threshold:DOUBLE ): ticks:LIST<LONG>\nTHRESHOLDTEST( lgts:LIST<GTS> threshold:DOUBLE ): lticks:LIST<LIST<LONG>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"THRESHOLDTEST"},TICKINDEX:{description:"Creates a clone of a Geo Time Series™, replacing each tick with the index (0 based) at which it appears at the moment of the call.\n\n@param `gts` Geo Time Series™ instance to transform.\n\n@param `encoder` Geo Time Series™ Encoder instance to transform.\n\n@param `indexed` Transformed GTS.\n\n@param `indexedenc` Transformed GTS Encoder.\n\n@param `lgts` List of Geo Time Series™ instances to transform.\n\n@param `lencoder` List of Geo Time Series™ Encoder instances to transform.\n\n@param `lindexed` List of indexed Geo Time Series™.\n\n@param `lindexedenc` List of indexed Geo Time Series™ Encoder.\n\n",signature:"TICKINDEX( gts:GTS ): indexed:GTS\nTICKINDEX( lgts:LIST<GTS> ): lindexed:LIST<GTS>\nTICKINDEX( encoder:GTSENCODER ): indexedenc:GTSENCODER\nTICKINDEX( lencoder:LIST<GTSENCODER> ): lindexedenc:LIST<GTSENCODER>",tags:["gts"],since:"1.0.0",OPB64name:"TICKINDEX"},TICKLIST:{description:"Pushes onto the stack the list of ticks of a Geo Time Series™ or encoder. The ticks appear in the order in which they are found.\n\nIf a list of Geo Time Series™ is given, the result is a list of list of ticks as if the TICKLIST function was applied to each Geo Time Series™ separately.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n@param `encoder` Instance of encoder from which to extract the ticks.\n\n@param `lencoder` List of encoders.\n\n@param `ticks` List of extracted ticks.\n\n@param `lticks` List of lists of ticks.\n\n",signature:"TICKLIST( gts:GTS ): ticks:LIST<LONG>\nTICKLIST( lgts:LIST<GTS> ): lticks:LIST<LIST<LONG>>\nTICKLIST( encoder:GTSENCODER ): ticks:LIST<LONG>\nTICKLIST( lencoder:LIST<GTSENCODER> ): lticks:LIST<LIST<LONG>>",tags:["gts"],since:"1.0.0",OPB64name:"TICKLIST"},TICKS:{description:"Pushes onto the stack the sorted list of **distinct** ticks of a Geo Time Series™. If a list of Geo Time Series™ is given, all the **distinct** ticks are returned in a single sorted list as if all Geo Time Series™ were merged.\n\nThis function is not to be confused with [`TICKLIST`](/doc/TICKLIST) as this function returns **distinct** ticks and acts as it merges Geo Time Series™.\n\n@param `ticks` List of extracted ticks.\n\n@param `gts` Instance of Geo Time Series™.\n\n@param `lgts` List of GTS.\n\n",signature:"TICKS( gts:GTS ): ticks:LIST<LONG>\nTICKS( lgts:LIST<GTS> ): ticks:LIST<LONG>",tags:["gts"],since:"1.0.0",OPB64name:"TICKS"},TIMEBOX:{description:"The `TIMEBOX` executes a macro with a maximum execution time. If the maximum time is reached, an exception will be thrown which can be caught using [`TRY`](/doc/TRY).\n\n@param `maxtime` Maximum execution time, in platform time units.\n\n@param `macro` Macro to execute.\n\n",signature:"TIMEBOX( macro:MACRO maxtime:LONG ): ",tags:["platform"],since:"2.0.3",OPB64name:"TIMEBOX"},TIMECLIP:{description:"Clips Geo Time Series™ instances by restricting their ticks to those within a time interval.      \n\n@param `duration` Width of the time interval to retain, in time units.\n\n@param `end` Most recent timestamp to retain.\n\n@param `start` Start timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `stop` End timestamp to consider, expressed as an [`ISO8601`](/doc/ISO8601) string.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of GTS.\n\n@param `clipped` Clipped Geo Time Series™.\n\n@param `lclipped` List of clipped GTS.\n\n@param `encoder` Single GTS Encoder instance.\n\n@param `lencoder` List of GTS Encoder instances.\n\n@param `clippedEncoder` Clipped GST encoder.\n\n@param `lclippedEncoders` List of clipped GTS encoders.\n\n",signature:"TIMECLIP( gts:GTS end:LONG duration:LONG ): clipped:GTS\nTIMECLIP( lgts:LIST<GTS> end:LONG duration:LONG ): lclipped:LIST<GTS>\nTIMECLIP( gts:GTS stop:STRING start:STRING ): clipped:GTS\nTIMECLIP( lgts:LIST<GTS> stop:STRING start:STRING ): lclipped:LIST<GTS>\nTIMECLIP( encoder:GTSENCODER end:LONG duration:LONG ): clippedEncoder:GTSENCODER\nTIMECLIP( lencoder:LIST<GTSENCODER> end:LONG duration:LONG ): lclippedEncoders:LIST<GTSENCODER>\nTIMECLIP( encoder:GTSENCODER stop:STRING start:STRING ): clippedEncoder:GTSENCODER\nTIMECLIP( lencoder:LIST<GTSENCODER> stop:STRING start:STRING ): lclippedEncoders:LIST<GTSENCODER>",tags:["gts"],since:"1.0.0",OPB64name:"TIMECLIP"},TIMED:{description:"The `TIMED` function converts a macro to a timed macro, recording its execution time and its number of calls.\n\nTo recover the associated statistics, use [`CHRONOSTATS`](/doc/CHRONOSTATS).\n\n@param `name` A name identifying the macro.\n\n@param `macro` The macro you want to monitor.\n\n@param `timedMacro` A macro which, when called, will update the statitics associated with the given name.\n\n",signature:"TIMED( macro:MACRO name:STRING ): timedMacro:MACRO",tags:["debug"],since:"2.1.0",OPB64name:"TIMED"},TIMEMODULO:{description:"Splits Geo Time Series™ into sub-GTS whose timestamps are the original timestamp modulo a given modulus value. Each sub-GTS will bear a label with the quotient of the original timestamps divided by the modulus. The output list order is not guaranteed, use [`SORTBY`](/doc/SORTBY) if you want to order the output by label.\n\nThis function can be used to generate for example one Geo Time Series™ per day with ticks from 0 to 86400 s (excluded).\n\n@param `label` Name of the label which will have the quotient value.\n\n@param `modulus` Value by which to divide the original timestamps.\n\n@param `gts` Geo Time Series™ to split.\n\n@param `splits` Resulting splits.\n\n@param `lgts` List of GTS to split.\n\n@param `lsplits` List of lists of resulting splits.\n\n",signature:"TIMEMODULO( gts:GTS modulus:LONG label:STRING ): splits:LIST<GTS>\nTIMEMODULO( lgts:LIST<GTS> modulus:LONG label:STRING ): lsplits:LIST<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMEMODULO"},TIMEOFF:{description:"Turns off the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"TIMEOFF(): ",tags:["stack"],since:"2.0.0",OPB64name:"TIMEOFF"},TIMEON:{description:"Turns on the display of the execution time of each WarpScript™ line entered in interactive (REPL) mode.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"TIMEON(): ",tags:["stack"],since:"2.0.0",OPB64name:"TIMEON"},TIMESCALE:{description:"Modifies the ticks of Geo Time Series™ instances by multiplying each tick by a provided scale.      \n\nThe resulting tick will be converted to a LONG after multiplication by the scale.\n\nIf the Geo Time Series™ instance is bucketized, the `lastbucket` and `bucketspan` parameters will also be scaled. If the scale would incur a `bucketspan` of 0, the call will end with an error.\n\n@param `scale` Scale by which to multiply each tick.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `scaled` Geo Time Series™ result.\n\n@param `lscaled` List of Geo Time Series™ result.\n\n",signature:"TIMESCALE( gts:GTS scale:DOUBLE ): scaled:GTS\nTIMESCALE( gts:GTS scale:LONG ): scaled:GTS\nTIMESCALE( lgts:LIST<GTS> scale:DOUBLE ): lscaled:LIST<GTS>\nTIMESCALE( lgts:LIST<GTS> scale:LONG ): lscaled:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"TIMESCALE"},TIMESHIFT:{description:"Shifts the ticks of Geo Time Series™ instances by a given amount.\n\n@param `offset` Offset to apply to the ticks, in time units.\n\n@param `gts` Single Geo Time Series™ instance to shift.\n\n@param `lgts` List of GTS to shift.\n\n@param `shifted` Shifted Geo Time Series™.\n\n@param `lshifted` List of shifted Geo Time Series™.\n\n",signature:"TIMESHIFT( gts:GTS offset:LONG ): shifted:GTS\nTIMESHIFT( lgts:LIST<GTS> offset:LONG ): lshifted:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"TIMESHIFT"},TIMESPLIT:{description:"The `TIMESPLIT` functions splits Geo Time Series™ instances based on *quiet periods*, *i.e.* periods during which the GTS has no values.\n\nWhenever a quiet period longer than a minimum duration is encountered, the Geo Time Series™ is split.\n\nIf input gts has no values or if 'label' is already part of the labels of 'gts', then the resulting list of GTS will only contain a clone of 'gts'. **Make sure to test your GTS split size if needed.**\n\n@param `label` Name of label in which to store the sequence number.\n\n@param `minvalues` Minimum number of values a split should contain. Splits with less than that many values will be discarded.\n\n@param `quietperiod` Minimum duration of the silent period (*i.e.* with no values) between splits.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `splits` List of resulting splits.\n\n@param `lsplits` List of lists of resulting splits.\n\n",signature:"TIMESPLIT( gts:GTS quietperiod:LONG minvalues:LONG label:STRING ): splits:LIST<GTS>\nTIMESPLIT( lgts:LIST<GTS> quietperiod:LONG minvalues:LONG label:STRING ): lsplits:LIST<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"TIMESPLIT"},TIMINGS:{description:"Turns on the collection of timing information for each line of the script. The collected timings can be put onto the stack by using [`ELAPSED`](/doc/ELAPSED).\n\n",signature:"",tags:["stack"],since:"1.0.0",OPB64name:"TIMINGS"},TLTTB:{description:"The `TLTTB` function performs downsampling of Geo Time Series™ by applying the [LTTB (Largest Triangle Three Buckets)](http://skemman.is/stream/get/1946/15343/37285/3/SS_MSthesis.pdf) algorithm. This algorithm downsamples a GTS by selecting datapoints from the original GTS which will preserve the overall shape of the graphical representation of the data. It differs from the [`LTTB`](doc/LTTB) function by the fact that it considers time based buckets instead of buckets based on a number of values.\n\n@param `samples` Number of datapoints to keep.\n\n@param `gts` Geo Time Series™ instance to downsample.\n\n@param `downsampled` Downsampled GTS.\n\n@param `lgts` List of Geo Time Series™ to downsample.\n\n@param `ldownsampled` List of downsampled GTS.\n\n",signature:"TLTTB( gts:GTS samples:LONG ): downsampled:GTS\nTLTTB( lgts:LIST<GTS> samples:LONG ): ldownsampled:LIST<GTS>",tags:["gts"],since:"1.0.11",OPB64name:"TLTTB"},TOBIN:{description:"Converts the long on top of the stack to its 64 bits binary representation.\n\n@param `param` value to convert\n\n@param `result` String converted binary representation of param\n\n",signature:"TOBIN( param:LONG ): result:STRING",tags:["conversion","strings","binary"],since:"1.0.0",OPB64name:"TOBIN"},TOBITS:{description:"Converts a number or each numerical value of a Geo Time Series™ into a LONG with the same bits as the DOUBLE ([IEEE754](https://en.wikipedia.org/wiki/IEEE_754)) encoding of the original number.\n\n**Deprecation notice** the `TOBITS` function will be removed, please use `->DOUBLEBITS` or `->FLOATBITS`.\n\n@param `number` Numeric value to represent, will first be converted to a DOUBLE if not already the case.\n\n@param `bits` LONG containing the same bits as the double precision IEEE754 representation of the input.\n\n@param `gts` Numerical Geo Time Series™ to convert.\n\n@param `longgts` Result GTS with LONG values.\n\n",signature:"TOBITS( number:NUMBER ): bits:LONG\nTOBITS( gts:GTS ): longgts:GTS",tags:["math","gts"],since:"1.0.0",OPB64name:"TOBITS"},TOBOOLEAN:{description:"Converts a value of primitive type into a boolean value.\n\nThe `TOBOOLEAN` function consumes a parameter from the top of the stack and pushes back its conversion to boolean.\nNumbers will be false if they are equal to 0 and true otherwise.\nStrings will be false if they are equals to '' and true otherwise.\n\n@param `value` The value of primitive type\n\n@param `result` The boolean conversion of the value\n\n",signature:"TOBOOLEAN( value:BOOLEAN ): result:BOOLEAN\nTOBOOLEAN( value:NUMBER ): result:BOOLEAN\nTOBOOLEAN( value:STRING ): result:BOOLEAN",tags:["conversion"],since:"1.0.5",OPB64name:"TOBOOLEAN"},TODEGREES:{description:"Converts an angle measured in radians to its equivalent in degrees.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from radians to degrees.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in radian to convert in degree\n\n@param `result` Result of the conversion from radians to degrees\n\n@param `langle` List of angles in radian to convert in degree\n\n@param `lresult` List of results of the conversion from radians to degrees\n\n",signature:"TODEGREES( angle:NUMBER ): result:DOUBLE\nTODEGREES( langle:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["conversion"],since:"1.0.0",OPB64name:"TODEGREES"},TODOUBLE:{description:"Converts a value of primitive type into a double value.\n\nThe `TODOUBLE` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to double.\n\n@param `value` The value of primitive type\n\n@param `result` The double conversion of the value\n\n",signature:"TODOUBLE( value:BOOLEAN ): result:DOUBLE\nTODOUBLE( value:NUMBER ): result:DOUBLE\nTODOUBLE( value:STRING ): result:DOUBLE",tags:["conversion"],since:"1.0.0",OPB64name:"TODOUBLE"},TOHEX:{description:"Converts a long to its 64 bits hexadecimal representation.\n\n@param `input` Signed long integer.\n\n@param `output` Hexadecimal string representation of input.\n\n",signature:"TOHEX( input:LONG ): output:STRING",tags:["conversion"],since:"1.0.0",OPB64name:"TOHEX"},TOINTEXACT:{description:"The `TOINTEXACT` function consumes one LONG from the top of the stack and puts back the value. If the result overflows an INT, this function fails.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` The value to be checked not to overflow an INT\n\n@param `result` The given value, converted to Long\n\n@param `lvalue` List of values to be checked not to overflow an INT\n\n@param `lresult` List of given values, converted to Long\n\n",signature:"TOINTEXACT( value:NUMBER ): result:LONG\nTOINTEXACT( lvalue:LIST<NUMBER> ): lresult:LIST<LONG>",tags:["math"],since:"1.2.23",OPB64name:"TOINTEXACT"},TOKENDUMP:{description:"Deciphers a token and outputs a map describing the various elements of the token.\n\nThe map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Original token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| params | MAP | Map of token parameters, can be used as input to [`TOKENGEN`](/doc/TOKENGEN) |\n\nThe `params` map contains the following entries for both `READ` and `WRITE` tokens:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| type  | STRING | `READ` or `WRITE` depending on the type of token |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in ms since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in ms since the Unix Epoch |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nAdditionally, for `READ` tokens, the map contains those entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, those will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nNote that the `TOKENDUMP` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration key was not set.\n\n\n@param `token` Token to decode.\n\n@param `map` Map with the extracted parameters, the original token and its *ident*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENDUMP` from Worf.\n\n",signature:"TOKENDUMP( token:STRING ): map:MAP\nTOKENDUMP( token:STRING secret:STRING ): map:MAP",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENDUMP"},TOKENGEN:{description:"Generates a token given a map of parameters. The `TOKENGEN` function outputs a map.\n\nThe input parameter map contains the following entries:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| id | STRING | Optional identifier that will be put verbatim in the result map |\n| type  | STRING | `READ` or `WRITE` depending on the type of token to generate |\n| owner | STRING | UUID of the owner associated with the token |\n| producer | STRING | UUID of the producer associated with the token |\n| application | STRING | Name of application asociated with the token |\n| issuance | LONG | Issuance timestamp of the token, in **milliseconds** since the Unix Epoch |\n| expiry | LONG | Expiry timestamp of the token, in **milliseconds** since the Unix Epoch |\n| ttl | LONG | If `expiry` is not specified, a time to live can be set with this key. The TTL is expressed in **milliseconds**, the computed expiry timestamp will be the issuance timestamp plus the ttl |\n| labels | MAP | Map of labels which will be added to the pushed Geo Time Series™ int the case of a `WRITE` token, or map of label selectors which will be added to the selection criteria for a `READ` token |\n| attributes | MAP | Map of attributes attached to the token |\n\nWhen generating a `READ` token, the following parameters are needed to ensure data isolation:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| owners | LIST | List of owners the `READ` token can access, they will be added to the selection criteria |\n| producers | LIST | List of producers the `READ` token can access, they will be added to the selection criteria |\n| applications | LIST | List of applications the `READ` token can access, they will be added to the selection criteria |\n\nIf one of these parameter key is not set or set to an empty list, then the generated `READ` token will be granted access to all the scope associated with the parameter key. For example, if `owners` is not set, data from all owners will be accessible to this token.\n\nThe `TOKENGEN` function outputs a map with the following keys:\n\n| Key | Type | Description |\n|-----|------|-------------|\n| token | STRING | Generated token |\n| ident | LONG | TokenIdent associated with `token`, can be used in a [TRL](/content/03_Documentation/05_Security/04_Token_revocation_list) |\n| id | STRING | Optional identifier if the `id` key was specified in the parameter map |\n\nNote that the `TOKENGEN` function can only be called using the [`Worf`](/content/03_Documentation/05_Security/03_Worf#tokengen) tool if the `token.secret` configuration was not set.\n\n@param `params` Map of parameters used to generate the token.\n\n@param `result` Map containing the token, its *ident* and an optional *id*.\n\n@param `secret` Secret configured via `token.secret`. This parameter should not be specified when calling `TOKENGEN` from Worf.\n\n",signature:"TOKENGEN( params:MAP ): result:MAP\nTOKENGEN( params:MAP secret:STRING ): result:MAP",tags:["extensions","platform"],since:"2.0.0",OPB64name:"TOKENGEN"},TOKENINFO:{description:"Retrieves information from token.\n\nThe `TOKENINFO` function consumes a token from the top of the stack and pushes back a map containing the token information:\n* type: type of token 'Read' or 'Write'\n* issuance: timestamp of token creation, in **milliseconds** since the Unix Epoch \n* expiry: timestamp of token expiration, in **milliseconds** since the Unix Epoch \n* application: name of the application accessing the data\n* apps: list of applications whose data can be accessed (usually limited to a single application)\n\n@param `token` Token to extract informations\n\n@param `infos` Token informations extract from the tokens\n\n",signature:"TOKENINFO( token:STRING ): infos:MAP",tags:["platform"],since:"1.0.0",OPB64name:"TOKENINFO"},TOKENSECRET:{description:"Modifies the secret needed for using `TOKENGEN` or `TOKENDUMP`.\n\nThis function is only useable if a secret was configured using `token.secret`.\n\n@param `secret` Current secret for token operations, initially the value configured via `token.secret`.\n\n@param `newsecret` New secret to set for token operations.\n\n",signature:"TOKENSECRET( newsecret:STRING secret:STRING ): ",tags:["extensions","platform"],since:"2.0.3",OPB64name:"TOKENSECRET"},TOLONG:{description:"Converts a value of primitive type or a **BYTE ARRAY** into a long value.\n\nThe `TOLONG` function consumes a parameter (BOOLEAN, LONG, DOUBLE, STRING) from the top of the stack and pushes back its conversion to long.\n\n@param `value` The value of primitive type\n\n@param `result` The long conversion of the value\n\n@param `array` Maximum 8 bytes to convert to a LONG. Sign is kept.\n\n",signature:"TOLONG( value:BOOLEAN ): result:LONG\nTOLONG( value:NUMBER ): result:LONG\nTOLONG( value:STRING ): result:LONG\nTOLONG( array:BYTES ): result:LONG",tags:["conversion","binary"],since:"1.0.0",OPB64name:"TOLONG"},TOLOWER:{description:"Converts the **STRING** on top of the stack to lower case.\n\n@param `input` input string\n\n@param `output` Lower case string\n\n",signature:"TOLOWER( input:STRING ): output:STRING",tags:["strings"],since:"1.0.0",OPB64name:"TOLOWER"},TORADIANS:{description:"Converts an angle measured in degrees to its equivalent in radians.\n\nThe `TORADIANS` function consumes a number from the top of the stack and pushes back its conversion from degrees to radians.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `angle` Angle in degree to convert in radian\n\n@param `result` Result of the conversion from degree to radian\n\n@param `langle` List of angles in degree to convert in radian\n\n@param `lresult` List of results of the conversion from degree to radian\n\n",signature:"TORADIANS( angle:NUMBER ): result:DOUBLE\nTORADIANS( langle:LIST<NUMBER> ): lresult:LIST<DOUBLE>",tags:["conversion"],since:"1.0.0",OPB64name:"TORADIANS"},TOSELECTOR:{description:"The `TOSELECTOR` function takes a Geo Time Series™ or Geo Time Series™ LIST from the top of the stack and, for each encountered GTS, replace it with a selector which would select it.\n\nThis selector can be used as input of [`PARSESELECTOR`](/doc/PARSESELECTOR) for a [`FETCH`](/doc/FETCH).\n\n@param `gts` The input Geo Time Series™.\n\n@param `gtslist` The input list of Geo Time Series™.\n\n@param `encoder` The input encoder.\n\n@param `encoderlist` The input list of encoders.\n\n@param `selector` The selector string.\n\n@param `selectorlist` The list of selector strings, one per GTS in gtslist.\n\n",signature:"TOSELECTOR( gts:GTS ): selector:STRING\nTOSELECTOR( gtslist:LIST<GTS> ): selectorlist:LIST<STRING>\nTOSELECTOR( encoder:GTSENCODER ): selector:STRING\nTOSELECTOR( encoderlist:LIST<GTSENCODER> ): selectorlist:LIST<STRING>",tags:["gts"],since:"1.0.0",OPB64name:"TOSELECTOR"},TOSTRING:{description:"Converts a value of primitive type into a string value.\n\nThe `TOSTRING` function consumes a parameter from the top of the stack and pushes back its conversion to string.\n\nNote that GTS are converted to input format and that the string ends with CRLF to follow HTTP recommendations.\n\n@param `value` The value of primitive type\n\n@param `result` The string conversion of the value\n\n",signature:"TOSTRING( value:NUMBER ): result:STRING\nTOSTRING( value:BOOLEAN ): result:STRING\nTOSTRING( value:STRING ): result:STRING\nTOSTRING( value:GTS ): result:STRING",tags:["strings","conversion"],since:"1.0.0",OPB64name:"TOSTRING"},TOTIMESTAMP:{description:"Converts a date in format ISO8601 into a timestamp in the platform's time unit.\n\nThe `TOTIMESTAMP` function consumes a string parameter (date + time + time zone) from the top of the stack and pushes back its conversion to a number of time units since the Unix Epoch.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nThe supported format is ISO8601 and are:\n* yyyy-mm-dddThh:mm:ss.ssssssZ\n* yyyy-mm-dddThh:mm:ss+hh:mm\n\nAs the string are URL encoded, the symbol + have to be replaced by %2B, otherwise a space will replace the + in the string.\n\n@param `input` ISO8601 string.\n\n@param `result` timestamp in the platform unit.\n\n",signature:"TOTIMESTAMP( input:STRING ): result:LONG",tags:["conversion","date"],since:"1.0.0",OPB64name:"TOTIMESTAMP"},TOUPPER:{description:"Converts the **STRING** on top of the stack to upper case.\n\n@param `input` input string\n\n@param `output` Upper case string\n\n",signature:"TOUPPER( input:STRING ): output:STRING",tags:["strings"],since:"1.0.0",OPB64name:"TOUPPER"},TR:{description:"Computes the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a square matrix. If the input matrix is not square, an error is raised.\n\n@param `matrix` The square matrix for which to compute the trace.\n\n@param `trace` The computed trace.\n\n",signature:"TR( matrix:MATRIX ): trace:DOUBLE",tags:["math"],since:"1.0.6",OPB64name:"TR"},TRANSPOSE:{description:"Computes the [transpose](https://en.wikipedia.org/wiki/Transpose) of a matrix.\n\n@param `matrix` Matrix to transpose.\n\n@param `transpose` The transpose of the original matrix.\n\n",signature:"TRANSPOSE( matrix:MATRIX ): transpose:MATRIX",tags:["math"],since:"1.0.6",OPB64name:"TRANSPOSE"},TRIM:{description:"Trims whitespaces from both ends of the string on top of the stack.\n\n@param `str` String to trim\n\n@param `trimmedstr` String trimmed\n\n",signature:"TRIM( str:STRING ): trimmedstr:STRING",tags:["strings"],since:"1.0.0",OPB64name:"TRIM"},TRY:{description:"The `TRY` function provides a way to execute a macro in a safety harness with [Exception handling](https://en.wikipedia.org/wiki/Exception_handling).\n\nIf an error is thrown, it is recorded and will be available via [`ERROR`](/doc/ERROR).\n\n@param `try` Macro whose execution is *attempted*.\n\n@param `catch` Macro which will be executed if an error is encountered while executing the `try` macro.\n\n@param `finally` Macro which will be executed unconditionally after either the `try` or `try`/`catch` execution.\n\n",signature:"TRY( try:MACRO catch:MACRO finally:MACRO ): ",tags:["control"],since:"1.2.11",OPB64name:"TRY"},TSELEMENTS:{description:"Alias of [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nThe `TSELEMENTS` function consumes an optional **STRING** timezone and a **LONG** timestamp and pushes back information on the day and time it represents as a **LIST** of **LONG**:\n```flow\n[\n    year\n    month\n    day_of_month\n    hours\n    minutes\n    seconds\n    subseconds_in_platform_unit\n    day_of_year\n    day_of_week\n    week_of_year\n  ]\n```\n\nThe indexing is the following: `month`, `day_of_month`, `day_of_year`, `day_of_week` and `week_of_year` use 1-indexing. For `day_of_week`, Monday has the value `1` and Sunday `7`.\n\nDepending on the platform time unit, the part representing subseconds can have 3, 6 or 9 digits respectively for milliseconds, microseconds or nanoseconds platform time unit.\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",signature:"TSELEMENTS( timestamp:LONG ): dateAndTimeElements:LIST<LONG>\nTSELEMENTS( timestamp:LONG timezone:STRING ): dateAndTimeElements:LIST<LONG>",tags:["date","time"],since:"1.0.0",OPB64name:"TSELEMENTS"},"TSELEMENTS->":{description:"The `TSELEMENTS->` function consumes an optional **STRING** timezone and a **LIST** of **LONG** describing a time and date and pushes back the **LONG** timestamp. The **LIST** of **LONG** follows the format given by [`->TSELEMENTS`](/doc/AItJJoKBGJp4I_GI).\n\nValid values for the timezone can be found on the [Joda website](http://joda-time.sourceforge.net/timezones.html) in any of the three columns. If no timezone is specified the pushed back representation is UTC.\n\n@param `timezone` Timezone of the pushed back date and time elements.\n\n@param `timestamp` Timestamp in platform unit, UTC.\n\n@param `dateAndTimeElements` List of long in the format given in the description.\n\n",signature:"TSELEMENTS->( dateAndTimeElements:LIST<LONG> ): timestamp:LONG\nTSELEMENTS->( dateAndTimeElements:LIST<LONG> timezone:STRING ): timestamp:LONG",tags:["date","time"],since:"1.2.0",OPB64name:"K4C4I3KCGJtJJmoy"},TYPEOF:{description:"Gets the type of an element.\n\nThe `TYPEOF` function consumes the top element on the stack and pushes back a string containing the type. The output could be:\n+ AGGREGATOR\n+ BITSET\n+ BOOLEAN\n+ BYTES\n+ CONTEXT\n+ COUNTER\n+ DOUBLE\n+ FILLER\n+ FILTER\n+ GEOSHAPE\n+ GTS\n+ GTSENCODER\n+ KEY\n+ LIST\n+ LONG\n+ MACRO\n+ MAP\n+ MARK\n+ MATCHER\n+ MATRIX\n+ NULL\n+ OPERATOR\n+ PFONT\n+ PGRAPHICS\n+ PIMAGE\n+ PSHAPE\n+ REDUCER\n+ SET\n+ STRING\n+ VECTOR\n+ VLIST\n\nFor any object introduced by a WarpScript extension whose output of TYPEOF is not in the list thereof, the output would be preceded by \"X-\".\n\nNote: since revision 2.5.0, the TYPEOF output of bucketizers, mappers, reducers is changed from 'MAPPER' to 'AGGREGATOR'.\n\n\n@param `object` Any kind of reference\n\n@param `type` The type of the object\n\n",signature:"TYPEOF( object:ANY ): type:STRING",tags:["stack","debug"],since:"1.0.0",OPB64name:"TYPEOF"},UDF:{description:"The `UDF` function invokes a User Defined Function from a Jar. A new function instance is loaded at each invocation.\n\nThe UDF is a Java class implementing `io.warp10.warp.sdk.WarpScriptJavaFunction` or `io.warp10.warp.sdk.WarpScriptRawJavaFunction`. These interfaces will be deprecated in future releases of Warp 10.\n\n@param `class` Fully qualified Java class name of the UDF to invoke.\n\n",signature:"UDF( class:STRING ): ",tags:["control"],since:"1.0.0",OPB64name:"UDF"},ULP:{description:"Returns the size of the [ULP (Unit in the Last Place)](https://en.wikipedia.org/wiki/Unit_in_the_last_place) for the argument. The ulp for a DOUBLE is the positive distance between this floating-point value and the DOUBLE value next larger in magnitude.\n\nSince 2.6.0, this function can be applied to a list of numeric values.\n\n@param `value` Numeric value.\n\n@param `ulp` Computed ULP.\n\n@param `lvalue` List of numeric values.\n\n@param `lulp` List of computed ULPs.\n\n",signature:"ULP( value:NUMBER ): ulp:DOUBLE\nULP( lvalue:LIST<NUMBER> ): lulp:LIST<DOUBLE>",tags:["math"],since:"1.0.0",OPB64name:"ULP"},UNBUCKETIZE:{description:"Transforms a bucketized Geo Time Series™ into a non bucketized one. Note that this function transforms the original GTS, it does not clone it.\n\n@param `gts` Single Geo Time Series™ instance.\n\n@param `lgts` List of Geo Time Series™ instances.\n\n",signature:"UNBUCKETIZE( gts:GTS ): gts:GTS\nUNBUCKETIZE( lgts:LIST<GTS> ): lgts:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"UNBUCKETIZE"},"UNBUCKETIZE.CALENDAR":{description:"On a GTS that is calendar-bucketized, this function replaces the ticks with the timestamp end boundaries of each bucket, and unbucketize it.\n\n@param `gts` One or more Geo Time Series™ or lists of Geo Time Series™\n\n@param `lgts` One or more lists of Geo Time Series™\n\n",signature:"UNBUCKETIZE.CALENDAR( gts:GTS ): gts:GTS\nUNBUCKETIZE.CALENDAR( lgts:LIST<GTS> ): lgts:LIST<GTS>",tags:["framework","bucketize","gts","bucketizer","date"],since:"2.4.1",OPB64name:"UNBUCKETIZE.CALENDAR"},UNGZIP:{description:"Decompresses a byte array containing data compressed by [`GZIP`](doc/GZIP).\n\n@param `compressed` Compressed byte array to decompress.\n\n@param `uncompressed` Byte array resulting from the decompression of 'compressed'.\n\n",signature:"UNGZIP( compressed:BYTES ): uncompressed:BYTES",tags:["conversion"],since:"1.0.11",OPB64name:"UNGZIP"},UNION:{description:"Computes the union &#x222a; of two sets.\n\nThe `UNION` function consumes two sets from the top of the stack and pushes back its mathematical union.\n\n@param `setA` The *A* set\n\n@param `setB` The *B* set\n\n@param `output` The new set containing *A* &#x222a; *B*\n\n",signature:"UNION( setA:SET setB:SET ): output:SET",tags:["sets"],since:"1.0.0",OPB64name:"UNION"},UNIQUE:{description:"The `UNIQUE` function eliminates duplicate elements on the LIST on the top of the stack.\nThe order of the resulting LIST is not the same than the original one.\n\nIt makes elements of a list unique by converting it to a set temporarily. See [()](/doc/91Z) for more informations.\n\n@param `input` The list to parse\n\n@param `output` The new list object, without any duplicates\n\n",signature:"UNIQUE( input:LIST ): output:LIST",tags:["lists"],since:"1.0.0",OPB64name:"UNIQUE"},UNLIST:{description:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`]`](/doc/MF).\n\n@param `list` List to expand.\n\n@param `elts` Elements of `list`.\n\n@param `mark` Instance of MARK.\n\n",signature:"UNLIST( list:LIST ): mark:MARK elts:ANY*",tags:["lists"],since:"1.0.11",OPB64name:"UNLIST"},UNMAP:{description:"Unpacks a map, pushing its keys and values onto the stack along a mark as the deepest stack element such that one can use [`}`](/doc/UF) to rebuild the map.\n\n@param `k1` First map key.\n\n@param `v1` First map value.\n\n@param `kN` Nth map key.\n\n@param `vN` Nth map value.\n\n@param `map` Map to unpack.\n\n@param `mark` Mark indicating the deepest level to consider when building the map.\n\n",signature:"UNMAP( map:MAP ): mark:MARK k1:ANY v1:ANY kN:ANY vN:ANY",tags:["maps"],since:"1.0.11",OPB64name:"UNMAP"},UNPACK:{description:"The `UNPACK` function unpacks a list of numeric or boolean values according to a specified string format.\n\nEndianness is at bit-level and not byte-level.\n\n* **<Lxx**: Little-endian long, `xx` is optional and is the number of bits which must be less or equal to 64.\n* **>Lxx**: Big-endian long, `xx` is optional and is the number of bits which must be less or equal to 64\n* **<Uxx**: Little-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **>Uxx**: Big-endian unsigned long, `xx` is optional and is the number of bits which must be less or equal to 64. U and L only differ when unpacking.\n* **<D**: Little-endian Double length always equals 64 bits.\n* **>D**: Big-endian Double length always equals 64 bits.\n* **B**: Boolean\n* **Sxx**: Any number of bits set to 1, `xx` is mandatory.\n* **sxx**: Any number of bits set to 0, `xx` is mandatory.\n\n* **<**: No bigendian\n* **>**: Bigendian\n* **L**: Long\n* **B**: Boolean\n* **D**: Double length always equals 64.\n* **<L32**: No bigendian 32 bits Long\n\n@param `list` Pqcked list to unpack\n\n@param `format` Format used to unpack\n\n@param `result` Unpacked list\n\n",signature:"UNPACK( list:BYTES format:STRING ): result:LIST<ANY>",tags:["lists"],since:"1.0.7",OPB64name:"UNPACK"},UNSECURE:{description:"The `UNSECURE` function decrypts a secure script. The correct secret MUST have been set unsing [`SECUREKEY`](doc/SECUREKEY) prior to calling this function.\n\n@param `secure` STRING with the secure script to decode.\n\n@param `script` Decoded scripted.\n\n",signature:"UNSECURE( secure:STRING ): script:STRING",tags:["crypto","stack"],since:"1.0.0",OPB64name:"UNSECURE"},UNSET:{description:"Expands a list by pushing a [`MARK`](/doc/MARK) followed by all the lists elements onto the stack.\n\nThe list can be regenerated by calling [`)`](/doc/9F).\n\n@param `set` Set to expand.\n\n@param `elts` Elements of `set`.\n\n@param `mark` Instance of MARK.\n\n",signature:"UNSET( set:SET ): mark:MARK elts:ANY*",tags:["sets"],since:"2.6.0",OPB64name:"UNSET"},UNTIL:{description:"The `UNTIL` function implements an until loop. It takes two macros as arguments from the stack: the code to execute until the condition is true and the condition to evaluate after every iteration.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force UNTIL to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n\n@param `code` Macro executed on each loop\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",signature:"UNTIL( code:MACRO condition:MACRO ): \nUNTIL( code:MACRO condition:MACRO index:BOOLEAN ): ",tags:["control"],since:"1.0.0",OPB64name:"UNTIL"},UNWRAP:{description:"Unwraps packed Geo Time Series™ instances.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",signature:"UNWRAP( wrapped:STRING ): gts:GTS\nUNWRAP( wrappedbytes:BYTES ): gts:GTS\nUNWRAP( lwrapped:LIST<STRING> ): lgts:LIST<GTS>\nUNWRAP( lwrapped:LIST<BYTES> ): lgts:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"UNWRAP"},UNWRAPEMPTY:{description:"Unwraps wrapped Geo Time Series™ instances without unpacking the actual datapoints. This is handy to extract the metadata (class, labels, attributes) from a set of wrapped GTS.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `gts` Decoded Geo Time Series™.\n\n@param `lgts` List of decoded Geo Time Series™.\n\n",signature:"UNWRAPEMPTY( wrapped:STRING ): gts:GTS\nUNWRAPEMPTY( wrappedbytes:BYTES ): gts:GTS\nUNWRAPEMPTY( lwrapped:LIST<STRING> ): lgts:LIST<GTS>\nUNWRAPEMPTY( lwrapped:LIST<BYTES> ): lgts:LIST<GTS>",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPEMPTY"},UNWRAPENCODER:{description:"Unwraps packed Geo Time Series™ into encoders.      \n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `encoder` Encoder with decoded Geo Time Series™ datapoints.\n\n@param `lencoder` List of encoders with decoded Geo Time Series™.\n\n",signature:"UNWRAPENCODER( wrapped:STRING ): encoder:GTSENCODER\nUNWRAPENCODER( wrappedbytes:BYTES ): encoder:GTSENCODER\nUNWRAPENCODER( lwrapped:LIST<STRING> ): lencoder:LIST<GTSENCODER>\nUNWRAPENCODER( lwrapped:LIST<BYTES> ): lencoder:LIST<GTSENCODER>",tags:["gts"],since:"1.2.9",OPB64name:"UNWRAPENCODER"},UNWRAPSIZE:{description:"Extracts the size (number of datapoints) of wrapped Geo Time Series™ instances.\n\n@param `wrapped` String representation of a packed Geo Time Series™ instance.\n\n@param `wrappedbytes` Byte array of a packed GTS.\n\n@param `lwrapped` List of packed representations of Geo Time Series™, either as STRING or byte arrays.\n\n@param `size` Decoded Geo Time Series™ size.\n\n@param `lsize` List of decoded Geo Time Series™ sizes.\n\n",signature:"UNWRAPSIZE( wrapped:STRING ): size:LONG\nUNWRAPSIZE( wrappedbytes:BYTES ): size:LONG\nUNWRAPSIZE( lwrapped:LIST<STRING> ): lsize:LIST<LONG>\nUNWRAPSIZE( lwrapped:LIST<BYTES> ): lsize:LIST<LONG>",tags:["gts"],since:"1.2.5",OPB64name:"UNWRAPSIZE"},UPDATE:{description:"Pushes Geo Time Series™ data to the Warp 10 instance.\n\nThe `UPDATE` function allows you to push data directly from your WarpScript code without having to retrieve the data and use the `/update` endpoint.\n\nThe GTS or Encoder instances to push *MUST* have a non empty name and in the case of Geo Time Series™ *MUST* have been renamed (to avoid pushing data by mistake which could override existing data you just retrieved).\n\n@param `token` Write token to use for pushing the data.\n\n@param `gts` Geo Time Series™ to push.\n\n@param `encoder` GTS Encoder to push.\n\n@param `list` List containing Geo Time Series™ and/or GTS Encoder instances to push.\n\n",signature:"UPDATE( gts:GTS token:STRING ): \nUPDATE( encoder:GTSENCODER token:STRING ): \nUPDATE( list:LIST<GTS> token:STRING ): \nUPDATE( list:LIST<GTSENCODER> token:STRING ): ",tags:["gts","platform"],since:"1.0.0",OPB64name:"UPDATE"},UPDATEOFF:{description:"Disables update operations on the platform. Attempts to perform such operations will fail with the provided message.\n\n@param `secret` Warp 10™ Manager Secret.\n\n@param `message` Message to return when an update operation is attempted.\n\n",signature:"UPDATEOFF( message:STRING secret:STRING ): ",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEOFF"},UPDATEON:{description:"Enables update operations on the platform.\n\n@param `secret` Warp 10™ Manager Secret.\n\n",signature:"UPDATEON( secret:STRING ): ",tags:["platform"],since:"2.0.3",OPB64name:"UPDATEON"},URLDECODE:{description:"Decodes a [URL encoded](https://en.wikipedia.org/wiki/Percent-encoding) STRING.\n\n@param `encoded` Encoded STRING to decode.\n\n@param `decoded` Decoded STRING.\n\n",signature:"URLDECODE( encoded:STRING ): decoded:STRING",tags:["strings"],since:"1.0.0",OPB64name:"URLDECODE"},URLENCODE:{description:"Encodes a STRING using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and replacing occurrences of '+' with '%20'.\n\nThe character set used is [UTF-8](https://en.wikipedia.org/wiki/UTF-8).\n\n@param `string` Input STRING to encode.\n\n@param `encoded` Encoded version of 'string' using the UTF-8 character set.\n\n",signature:"URLENCODE( string:STRING ): encoded:STRING",tags:["strings"],since:"1.0.0",OPB64name:"URLENCODE"},URLFETCH:{description:"The `URLFETCH` function sends HTTP(S) GET requests, waits for the responses and puts them on the stack.\n\nFor security reasons, the stack must be authenticated for this function to work, see [`AUTHENTICATE`](/doc/AUTHENTICATE).\n\nSince 2.7.0, this function also accepts a MAP of headers.\n\n@param `url` The URL to send the GET request to. Must begin with `http://` or `https://`.\n\n@param `urls` The list of URLs to send the GET requests to. Each URL must begin with `http://` or `https://`. \n\n@param `result` A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\n\n@param `headers` \n\n",signature:"URLFETCH( url:STRING ): result:LIST<LIST>\nURLFETCH( url:STRING headers:MAP ): result:LIST<LIST>\nURLFETCH( urls:LIST<STRING> ): result:LIST<LIST>\nURLFETCH( urls:LIST<STRING> headers:MAP ): result:LIST<LIST>",tags:["extensions","web"],since:"1.0.2",OPB64name:"URLFETCH"},UUID:{description:"Pushes onto the stack a randomly generated [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).\n\n@param `uuid` Generated UUID string\n\n",signature:"UUID(): uuid:STRING",tags:["misc"],since:"1.0.0",OPB64name:"UUID"},"V->":{description:"The `V->` function converts a Vector (VLIST) on top of the stack into a list.\n\n@param `list` Input Vector.\n\n@param `result` Result list.\n\n",signature:"V->( list:VLIST ): result:LIST",tags:["lists","conversion","pig"],since:"1.0.11",OPB64name:"KXoy"},VALUEDEDUP:{description:"Deletes duplicated values of the Geo Time Series™.\n\nThe `VALUEDEDUP` function takes as parameter a **GTS** or a **LIST** of **GTS** and it removes its duplicate values.\n\nExpects a boolean indicating whether we keep the oldest or most recent datapoint for a given value.\n\n@param `order` Boolean value, true for keeping the oldest datapoint for a given value, false otherwise.\n\n@param `gts` Geo Time Series™ for which to remove the duplicated values.\n\n@param `lgts` List of Geo Time Series™ for which to remove the duplicated values.\n\n@param `dedupgts` Geo Time Series™ with unique values.\n\n@param `ldedupgts` List of Geo Time Series™ with unique values.\n\n",signature:"VALUEDEDUP( gts:GTS order:BOOLEAN ): dedupgts:GTS\nVALUEDEDUP( lgts:LIST<GTS> order:BOOLEAN ): ldedupgts:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"VALUEDEDUP"},VALUEHISTOGRAM:{description:"Produces the value histogram of a Geo Time Series™ or (since 2.2.0) of a GTS Encoder.\n\nThe histogram is a map with an entry for each value (used as the map key), with an associated value equal to the number of occurrences of the value in the series.\n\nIf the input is a bucketized Geo Time Series™, the `NULL` key will have an associated value which is the number of buckets without values (assuming no datapoints were added at timestamps other than those of buckets).\n\nWhen the input is a GTS Encoder, keys may be BigDecimal, LONG, DOUBLE, BOOLEAN or STRING, binary values are not used as keys, their STRING representation (in ISO-8859-1) is used.\n\n@param `gts` Geo Time Series™ for which to compute the histogram\n\n@param `encoder` GTS Encoder for which to compute the histogram\n\n@param `histogram` The value histogram for the input Geo Time Series™ or GTS Encoder\n\n@param `list` List of Geo Time Series™ or GTS Encoders\n\n@param `lhistogram` The list of value histogram maps\n\n",signature:"VALUEHISTOGRAM( gts:GTS ): histogram:MAP\nVALUEHISTOGRAM( encoder:GTSENCODER ): histogram:MAP\nVALUEHISTOGRAM( list:LIST<GTS> ): lhistogram:LIST<MAP>",tags:["gts"],since:"1.0.0",OPB64name:"VALUEHISTOGRAM"},VALUELIST:{description:"Gets values from a **MAP**.\n\nThe function `VALUELIST` extracts the values of a **MAP** on the top of the stack and pushes on the stack a list with those values. The **MAP** is consumed.\n\n\n@param `map` Map for which to get the values.\n\n@param `values` List of values for the input MAP.\n\n",signature:"VALUELIST( map:MAP ): values:LIST",tags:["maps"],since:"1.0.0",OPB64name:"VALUELIST"},VALUES:{description:"Gets the values of Geo Time Series™ or encoders.\n\nThe `VALUES` function consumes a Geo Time Series™, an encoder or a list thereof from the stack, and it replaces each instance of Geo Time Series™ or encoder by a list of its values.\n\n@param `gts` Geo Time Series™ for which to get the values.\n\n@param `lgts` List of Geo Time Series™ for which to get the values.\n\n@param `encoder` Encoder for which to get the values.\n\n@param `lencoder` List of encoders for which to get the values.\n\n@param `values` List of values from the input Geo Time Series™.\n\n@param `lvalues` List of list of values from the input Geo Time Series™ list.\n\n",signature:"VALUES( gts:GTS ): values:LIST\nVALUES( lgts:LIST<GTS> ): lvalues:LIST<LIST>\nVALUES( encoder:GTSENCODER ): values:LIST\nVALUES( lencoder:LIST<GTSENCODER> ): lvalues:LIST<LIST>",tags:["gts"],since:"1.0.0",OPB64name:"VALUES"},VALUESORT:{description:"Sorts values of the Geo Time Series™ in ascending order.\n\nThe function `VALUESORT` takes the **GTS** on top of the stack and sort its values (and associated locations/elevations) in ascending order.\n\n@param `gts` Geo Time Series™ for which to sort the values.\n\n@param `sortedgts` Geo Time Series™ with sorted values.\n\n@param `lgts` List of Geo Time Series™.\n\n@param `lsortedgts` List of Geo Time Series™ with sorted values.\n\n",signature:"VALUESORT( gts:GTS ): sortedgts:GTS\nVALUESORT( lgts:LIST<GTS> ): lsortedgts:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"VALUESORT"},VALUESPLIT:{description:"Splits Geo Time Series™ by values.\n\nThe function `VALUESPLIT` takes one **STRING** on top of the stack plus one **GTS** or a list of **GTS**. It splits **GTS** by values and creates a **GTS** for each different value. For each new **GTS**, the label specified in parameter will be added.\n\nThe new **GTS** will be sorted by value with `VALUESORT`.\n\n@param `label` Label to add to the new Geo Time Series™.\n\n@param `gts` Geo Time Series™ to split by value.\n\n@param `splitedgts` List of Geo Time Series™ splited by value.\n\n@param `lgts` List of Geo Time Series™ to split by value.\n\n@param `lsplitedgts` List of Geo Time Series™ splited by value.\n\n",signature:"VALUESPLIT( gts:GTS label:STRING ): splitedgts:LIST<GTS>\nVALUESPLIT( lgts:LIST<GTS> label:STRING ): lsplitedgts:LIST<LIST<GTS>>",tags:["gts"],since:"1.0.0",OPB64name:"VALUESPLIT"},"VARINT->":{description:"The `VARINT` function decodes [VarInt](https://developers.google.com/protocol-buffers/docs/encoding#varints) encoded numbers.\n\n@param `numbers` List of decoded numbers.\n\n@param `encoded` Byte array containing the encoded number(s) to decode.\n\n@param `count` Maximum number of `LONG`s to decode.\n\n@param `processed` Number of bytes which were processed to decode the numbers.\n\n",signature:"VARINT->( encoded:BYTES ): numbers:LIST<LONG>\nVARINT->( encoded:BYTES count:LONG ): numbers:LIST<LONG> processed:LONG",tags:["conversion","binary"],since:"2.6.0",OPB64name:"KZ4HHJtJAIs"},VARS:{description:"Extracts all variables used in a macro. The `VARS` function scans the macro for occurrences of `LOAD`, `STORE` or `CSTORE` functions and inspects the associated variable name. If such a name is not an explicit STRING, the call to `VARS` will fail with an error.\n\nThe list of symbols is sorted according to the number of occurrences encountered, decreasing.\n\n@param `macro` Macro to inspect.\n\n@param `vars` List of encountered symbols.\n\n@param `onlyPoprAndStore` Returns only variables used by POPR, CPOPR and STORE. Defaults to false.\n\n",signature:"VARS( macro:MACRO ): vars:LIST<STRING>\nVARS( macro:MACRO onlyPoprAndStore:BOOLEAN ): vars:LIST<STRING>",tags:["stack"],since:"2.0.0",OPB64name:"VARS"},"VEC->":{description:"The `VEC->` function converts a Vector into a list.\n\n\n@param `input` Vector to convert\n\n@param `result` list\n\n",signature:"VEC->( input:VECTOR ): result:LIST",tags:["lists","conversion","math"],since:"1.0.6",OPB64name:"KZK2AIs"},WEBCALL:{description:"Makes an outbound HTTP call.\n\nNote that the hosts which may be reached via `WEBCALL` might have been restricted through the use of the `webcall.host.patterns` Warp&nbsp;10 configuration parameter.\n\nThe write token is here to check you have the right to send a webcall. If the write token is valid, then the request is sent. It will never be sent in the request.\n\nThe call to `WEBCALL` returns a UUID on the stack. The actual request is performed asynchronously, the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`.\n\n@param `body` body of the request.\n\n@param `headers` map of additionnal http headers.\n\n@param `url` supported schemes are http and https.\n\n@param `method` `GET` or `POST` string.\n\n@param `token` valid write token\n\n@param `uuid` the UUID will appear in the `X-Warp10-WebCall` header or the header configured via `http.header.webcall.uuid`\n\n",signature:"WEBCALL( token:STRING method:STRING url:STRING headers:MAP body:STRING ): uuid:STRING",tags:["web"],since:"1.0.0",OPB64name:"WEBCALL"},"WF.ADDREPO":{description:"The `WF.ADDREPO` function allows you to add a repository to the list of repositories taken into account by the WarpFleet™ macro resolver.\n\nIf the URL is valid (syntaxically), then it will be added at the end of the current list of repositories scanned by the resolver. All repository URLs will then be validated by the `validator` macro defined in the configuration (`warpfleet.macros.validator`). Those URLs for which the `validator` macro returned true will be retained.\n\nNote that the repository is only added in the scope of the current stack.\n\n@param `url` URL to add to the list of repositories.\n\n",signature:"WF.ADDREPO( url:STRING ): ",tags:["stack"],since:"2.0.3",OPB64name:"WF.ADDREPO"},"WF.GETREPOS":{description:"Retrieves the current list of repositories used by the WarpFleet™ resolver.\n\nNote that if the configuration disabled the use of this function (via `warpfleet.getrepos.disable`), the returned list will be empty even though it contains repositories.\n\n@param `repos` Current list of repository URLs.\n\n",signature:"WF.GETREPOS(): repos:LIST<STRING>",tags:["stack"],since:"2.0.3",OPB64name:"WF.GETREPOS"},"WF.SETREPOS":{description:"Sets the list of repositories used by the WarpFleet™ resolver to the given value (list of valid URLs).\n\nEach URL is tested against WarpFleet™ validator macro to check if it is allowed. Non-valid ones are discarded.\n\nNote that this changes the list only for the scope of the current WarpScript execution.\n\n@param `repos` List of URLs to use for the WarpFleet™ resolver.\n\n",signature:"WF.SETREPOS( repos:LIST<STRING> ): ",tags:["stack"],since:"2.0.3",OPB64name:"WF.SETREPOS"},WFOFF:{description:"The `WFOFF` function disables the WarpFleet™ Resolver. It can be re-enabled using `WFON`.\n\nThis is useful when you want to ensure that a macro call only looks it up locally.\n\n",signature:"WFOFF(): ",tags:["stack"],since:"2.1.0",OPB64name:"WFOFF"},WFON:{description:"The `WFON` function enables the WarpFleet™ Resolver after it has been disabled by `WFOFF`.\n\n",signature:"WFON(): ",tags:["stack"],since:"2.1.0",OPB64name:"WFON"},WHILE:{description:"The `WHILE` function implements a while loop. It takes two macros as arguments from the stack: the condition macro to evaluate and the macro to execute while the condition is true.\n\nIf one iteration takes too long (`warpscript.maxloop`) the loop will be killed.\n\nSince Warp 10 2.4.0, you can force WHILE to push an index (iteration count, start at 0) on the top of the stack before calling the macro.\n\n@param `condition` Macro evaluated for the loop condition, must leave a boolean on top of the stack\n\n@param `code` Macro executed on each loop\n\n@param `index` When set to true, the current index (iteration count, starts at 0) will be on the top of the stack. By default, false\n\n",signature:"WHILE( condition:MACRO code:MACRO ): \nWHILE( condition:MACRO code:MACRO index:BOOLEAN ): ",tags:["control"],since:"1.0.0",OPB64name:"WHILE"},WRAP:{description:"The `WRAP` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a STRING.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",signature:"WRAP( encoder:GTSENCODER ): wrapped:STRING\nWRAP( lencoder:GTSENCODER ): lwrapped:LIST<STRING>\nWRAP( gts:GTS ): wrapped:STRING\nWRAP( lgts:LIST<GTS> ): lwrapped:LIST<STRING>",tags:["gts","encoder"],since:"1.0.0",OPB64name:"WRAP"},WRAPFAST:{description:"The `WRAPFAST` function packs a Geo Time Series™ (or a list thereof) or a GTS Encoder into a byte array. For fast execution, the content of the GTS is not compressed, so the resulting byte array will be larger than that produced by `WRAPRAW`.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"WRAPFAST( encoder:GTSENCODER ): wrapped:BYTES\nWRAPFAST( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPFAST( gts:GTS ): wrapped:BYTES\nWRAPFAST( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",tags:["gts","encoder"],since:"2.1.0",OPB64name:"WRAPFAST"},WRAPMV:{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPRAWOPT`, `WRAPMV` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"WRAPMV( encoder:GTSENCODER ): wrapped:BYTES\nWRAPMV( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPMV( gts:GTS ): wrapped:BYTES\nWRAPMV( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",tags:["gts","encoder","multivariate"],since:"2.1.0",OPB64name:"WRAPMV"},"WRAPMV!":{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES array as if the input was a Multivariate value.\n\nJust like `WRAPMV`, `WRAPMV!` attempts to optimize the representation of DOUBLE values for Geo Time Series™ but unlike `WARPMV`, it does not increase the compression agressiveness for GTS Encoders.\n\nThe result is also stripped of all Metadata (class, labels, attributes), and no sizing hint is given.        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"WRAPMV!( encoder:GTSENCODER ): wrapped:BYTES\nWRAPMV!( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPMV!( gts:GTS ): wrapped:BYTES\nWRAPMV!( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",tags:["gts","encoder","multivariate"],since:"2.6.0",OPB64name:"Kp80J3pL7F"},WRAPOPT:{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a STRING. The packing performed by `WRAPOPT` differs from that of [`WRAP`](/doc/WRAP) only by the fact that `WRAPOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of STRINGs containing packed GTS or Encoders.\n\n",signature:"WRAPOPT( encoder:GTSENCODER ): wrapped:STRING\nWRAPOPT( lencoder:GTSENCODER ): lwrapped:LIST<STRING>\nWRAPOPT( gts:GTS ): wrapped:STRING\nWRAPOPT( lgts:LIST<GTS> ): lwrapped:LIST<STRING>",tags:["gts"],since:"1.2.3",OPB64name:"WRAPOPT"},WRAPRAW:{description:"The `WRAPRAW` function packs a Geo Time Series™ into a byte array.\n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"WRAPRAW( encoder:GTSENCODER ): wrapped:BYTES\nWRAPRAW( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPRAW( gts:GTS ): wrapped:BYTES\nWRAPRAW( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",tags:["gts","encoder"],since:"1.0.7",OPB64name:"WRAPRAW"},WRAPRAWOPT:{description:"Packs a Geo Time Series™ (or a list thereof) or a GTS Encoder instance into a BYTES. The packing performed by `WRAPRAWOPT` differs from that of [`WRAPRAW`](/doc/WRAPRAW) only by the fact that `WRAPRAWOPT` attempts to optimize the representation of DOUBLE values for Geo Time Series™ and increases the compression agressiveness for GTS Encoders.\n        \n\n@param `encoder` GTS Encoder to pack.\n\n@param `gts` Geo Time Series™ instance to pack.\n\n@param `lgts` List of Geo Time Series™ to pack.\n\n@param `lencoder` List of GTS encoders to pack.\n\n@param `wrapped` String containing the packed Geo Time Series™ or Encoder.\n\n@param `lwrapped` List of byte arrays containing packed GTS or Encoders.\n\n",signature:"WRAPRAWOPT( encoder:GTSENCODER ): wrapped:BYTES\nWRAPRAWOPT( lencoder:GTSENCODER ): lwrapped:LIST<BYTES>\nWRAPRAWOPT( gts:GTS ): wrapped:BYTES\nWRAPRAWOPT( lgts:LIST<GTS> ): lwrapped:LIST<BYTES>",tags:["gts","encoder"],since:"1.2.3",OPB64name:"WRAPRAWOPT"},WSINFO:{description:"Displays informations about WarpScript environments with a given session id. The informations are returned as a map identical to that returned by [`WSPS`](/doc/WSPS):\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `session` Session of the environments to inspect.\n\n@param `infos` List of informations about each WarpScript execution environment with 'session' as their session name.\n\n",signature:"WSINFO( session:STRING ): infos:LIST<MAP>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSINFO"},WSKILL:{description:"Kills the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP) and marking the environment as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to kill.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",signature:"WSKILL( uuid:STRING secret:STRING ): status:BOOLEAN",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILL"},WSKILLSESSION:{description:"Kills the execution WarpScript programs by forcing a call to [`STOP`](/doc/STOP) and marking the environments as forcibly stopped.\n\nAny further attempt to execute a function will also force a call to [`STOP`](/doc/STOP).\n\n@param `session` Session id of the WarpScript execution environments to kill.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",signature:"WSKILLSESSION( session:STRING ): count:LONG",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSKILLSESSION"},WSNAME:{description:"Modifies the name associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stack.name` in the attributes map.\n\nName size is limited to 128 characters.\n\n@param `name` Name to assign to the calling execution environment, or `NULL` to simply read the current name.\n\n@param `current` Name assigned to the execution environment.\n\n",signature:"WSNAME( name:STRING ): current:STRING",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSNAME"},WSPS:{description:"Lists all the registers WarpScript execution environments. For each environment a map is returned with the following fields:\n\n| Key | Description |\n|-----|-------------|\n| `uuid` | Unique id associated with the environment. |\n| `attributes` | Map of exposed stack attributes. |\n\nThe list of exposed attributes may evolve in future releases.\n\n@param `secret` Secret for process status operations.\n\n@param `procs` List of informations about each registered WarpScript execution environment.\n\n",signature:"WSPS( secret:STRING ): procs:LIST<MAP>",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSPS"},WSSESSION:{description:"Modifies the session id associated with the execution environment. This name appears in the informations returned by [`WSPS`](/doc/WSPS) and [`WSINFO`](/doc/WSINFO) under the key `stackps.session` in the attributes map.\n\nSession id size is limited to 128 characters.\n\nSession can also be set by setting the `X-Warp10-WarpScriptSession` header.\n\nOnce the session has been set it cannot be modified.\n\n@param `session` Session id to assign to the calling execution environment, or NULL to simply read the current session id.\n\n@param `current` The session id assigned to the execution environment.\n\n",signature:"WSSESSION( session:STRING ): current:STRING",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSESSION"},WSSTACK:{description:"Select the WarpScript™ (*i.e.* SNAPSHOT) format for the display of stack levels.\n\nWhen called outside of interactive mode, does nothing.\n\n",signature:"WSSTACK(): ",tags:["stack"],since:"2.0.0",OPB64name:"WSSTACK"},WSSTOP:{description:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\n@param `secret` Secret for process status operations.\n\n@param `uuid` UUID of the WarpScript execution environment to stop.\n\n@param `status` `true` if an environment was found with that `uuid`, `false` otherwise.\n\n",signature:"WSSTOP( uuid:STRING secret:STRING ): status:BOOLEAN",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOP"},WSSTOPSESSION:{description:"Stops the execution of a WarpScript program by forcing a call to [`STOP`](/doc/STOP). If the WarpScript program is currently in a [`TRY`](/doc/TRY) call, the execution may continue depending on the *catch* macro.\n\nThe environments to stop are identified by a session id.\n\n@param `session` Session of the WarpScript execution environments to stop.\n\n@param `count` Number of environments which had `session` as their session id.\n\n",signature:"WSSTOPSESSION( session:STRING ): count:LONG",tags:["extensions","platform"],since:"2.5.0",OPB64name:"WSSTOPSESSION"},"Z->":{description:"Unpacks LONG values from a [Morton Code](https://en.wikipedia.org/wiki/Z-order_curve) stored in a byte array.\n\n@param `bitwidth` Size in bits of the LONG values to extract, from 1 to 63.\n\n@param `n` Number of LONG values to extract.\n\n@param `z` Byte array containing the Morton Code to unpack.\n\n@param `longs` List of extracted LONG values.\n\n",signature:"Z->( z:BYTES n:LONG bitwidth:LONG ): longs:LIST<LONG>",tags:["conversion"],since:"1.0.6",OPB64name:"LXoy"},ZDISCORDS:{description:"The `ZDISCORDS` function detects discords in a standardized ([`STANDARDIZE`](/doc/STANDARDIZE) Geo Time Series™. The discord detection\n algorithm is based on identifying outlier patterns in the Geo Time Series™. Outliers are patterns which differ significantly from their nearest neighbor.\n\nThe following constraints are enforced:\n\n- pattern length must divide window size\n- quantization scale must be a power of two from 2 to 65536\n- `ZDISCORDS` can only be applied to numeric Geo Time Series™ which are bucketized and filled (i.e. no bucket with missing values).\n\nGiven the `ZDISCORDS` expects the Geo Time Series™ it operates on to be standardized ([`STANDARDIZE`](/doc/STANDARDIZE), the discord detection \nalgorithm is more sensitive than that of [`DISCORDS`](/doc/DISCORDS).\n\n@param `distance` This ratio is used to ignore patterns whose distance to their nearest neighbor is less than 1/ratio that of the previously selected pattern. This parameter is for advanced users, it is safe to leave it to 0.0.\n\n@param `overlapping` Flag indicating whether or not the `ZDISCORDS` function should report overlapping discords.\n\n@param `maximum` The maximum number of discords to identify.\n\n@param `window_size` Window size which is the width of each interval on which the pattern extraction should be performed, a pattern length which will determine how the window is segmented, and lastly a quantization scale which will determine how many different buckets will be used to ventilate the series values. (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `result` Geo Time Series™ whose ticks are those where discords were detected. The value, location and elevation at each tick are those of the input Geo Time Series™.\n\n",signature:"ZDISCORDS( window_size:LONG maximum:LONG overlapping:BOOLEAN distance:DOUBLE ): result:GTS",tags:["gts","outlier"],since:"1.0.13",OPB64name:"ZDISCORDS"},ZDTW:{description:"The `DTW` function computes a [Dynamic Time Warping](https://en.wikipedia.org/wiki/Dynamic_time_warping) pseudo-distance on two Geo Time Series™.\n\nThe Geo Time Series™ will be Z-normalized prior to the computation.\n\n@param `threshold` Value above which the DTW computation will be aborted. Use 0.0 to disable the abort feature.\n\n@param `gts1` First Geo Time Series™ on which to perform the DTW operation.\n\n@param `gts2` Second Geo Time Series™ on which to perform the DTW operation.\n\n@param `dtw` The computed Dynamic Time Warping or -1 if the threshold was reached.\n\n",signature:"ZDTW( gts1:GTS gts2:GTS threshold:DOUBLE ): dtw:DOUBLE",tags:["gts","distance"],since:"1.2.11",OPB64name:"ZDTW"},ZIP:{description:"The function ZIP takes a list of lists as parameters. Each list which are not singletons must be of same size.\n\nIt returns a list of lists where the i-th list contains the i-th elements of each input list in the same order.\n\nAlso, it considers singletons as a list of the same size with a duplicated value.\n\n@param `input` List of lists\n\n@param `output` List of lists\n\n",signature:"ZIP( input:LIST<LIST> ): output:LIST<LIST>",tags:["lists"],since:"1.0.0",OPB64name:"ZIP"},ZPATTERNDETECTION:{description:"The `ZPATTERNDETECTION` function will detect patterns in a Geo Time Series™. The patterns it is able to detect are those extracted by the [`ZPATTERNS`](/doc/ZPATTERNS) or [`PATTERNS`](/doc/PATTERNS) functions.\n\nThe `ZPATTERNDETECTION` does not standardize the datapoints in the sliding window, assuming (wrongly) they already are.\n\nThe following constraints are enforced:\n\n* pattern length must divide window size\n* quantization scale must be a power of two from 2 to 65536\n* `ZPATTERNDETECTION` can only be applied to numeric Geo Time Series™ which are [bucketized](/doc/BUCKETIZE) and [filled](/doc/FILLVALUE) (i.e. no bucket with missing values).\n* the patterns to detect must have been extracted with the same quantization scale and pattern length, the window size can be different.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `patterns` The list of patterns to detect (see [`PATTERNS`](/doc/PATTERNS))\n\n@param `lgts` The list of Geo Time Series™ to transform.\n\n@param `gts` The single GTS to transform.\n\n@param `result` The new Geo Time Series™ with values only at ticks at which one of the patterns was detected. The actual pattern detected is not available, call `PATTERNDETECTION` with a single pattern if you need to keep track of it.\n\n@param `lresult` The list of result GTS.\n\n",signature:"ZPATTERNDETECTION( gts:GTS patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nZPATTERNDETECTION( lgts:LIST<GTS> patterns:LIST<STRING> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNDETECTION"},ZPATTERNS:{description:"Extracts symbolic patterns from Geo Time Series™ as [`PATTERNS`](/doc/PATTERNS) does, but does not standardize each window, assuming (wrongly) the GTS windows are already standardized.\n\n@param `wsize` The window size which is the width of each interval on which the pattern extraction should be performed\n\n@param `length` The pattern length which will determine how the window is segmented\n\n@param `scale` The quantization scale which will determine how many different buckets will be used to ventilate the series values\n\n@param `lgts` The list of Geo Time Series™ to transform\n\n@param `gts` The single GTS to transform\n\n@param `result` The new Geo Time Series™ of patterns. The value at each tick is the pattern corresponding to the window of window size starting at the given tick\n\n@param `lresult` The list of result GTS\n\n",signature:"ZPATTERNS( gts:GTS wsize:NUMBER length:NUMBER scale:NUMBER ): result:GTS\nZPATTERNS( lgts:LIST<GTS> wsize:NUMBER length:NUMBER scale:NUMBER ): lresult:LIST<GTS>",tags:["gts"],since:"1.0.13",OPB64name:"ZPATTERNS"},ZSCORE:{description:"The 'ZSCORE' function consumes a flag, then normalizes a Geo Time Series™ or a **LIST** of Geo Time Series™ that are below by replacing their values by their [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe flag indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median).\n\nIf the GTS isn’t of type **DOUBLE** or if the deviation equals 0, an exception is raised.\n\n@param `flag` Indicates whether to use the mean (False), or the median (True) to calculate the [Z-score](https://en.wikipedia.org/wiki/Standard_score).\n\n@param `gts` Geo Time Series™\n\n@param `gtsList` List of Geo Time Series™\n\n@param `result` Geo Time Series™\n\n@param `resultList` List of Geo Time Series™\n\n",signature:"ZSCORE( gts:GTS flag:BOOLEAN ): result:GTS\nZSCORE( gtsList:LIST<GTS> flag:BOOLEAN ): resultList:LIST<GTS>",tags:["gts"],since:"1.0.0",OPB64name:"ZSCORE"},ZSCORETEST:{description:"The ZSCORETEST function detects outliers in a GTS by comparing the Z-score of its values with a given threshold.\n\nThe Z-score of a value represents the number of standard deviations (or median absolute deviations) it is away from the mean (or the median). If this value is greater than the given threshold, it is flagged as an outlier.\n\nA LIST of ticks, corresponding to the outliers, is pushed back onto the stack.\n\nThis function only applies to GTS of type **DOUBLE**.\n\n@param `gts` The Geo Time Series™ to test\n\n@param `result` List of the detected outliers timestamps\n\n@param `lgts` The list of Geo Time Series™ to test\n\n@param `lresult` List of list of the detected outliers timestamps\n\n@param `mad` False: use the mean/sigma, true: use the median/mad to calculate the Z-score\n\n@param `trigger` Optional threshold. Default value is 3.5\n\n",signature:"ZSCORETEST( gts:GTS mad:BOOLEAN ): result:LIST<LONG>\nZSCORETEST( lgts:LIST<GTS> mad:BOOLEAN ): lresult:LIST<LIST<LONG>>\nZSCORETEST( gts:GTS mad:BOOLEAN trigger:DOUBLE ): result:LIST<LONG>\nZSCORETEST( lgts:LIST<GTS> mad:BOOLEAN trigger:DOUBLE ): lresult:LIST<LIST<LONG>>",tags:["gts","outlier"],since:"1.0.0",OPB64name:"ZSCORETEST"},"[":{description:"Starts a list creation.\n\nThe `[` function creates a list by pushing a mark onto the stack. This is a syntactic help to better present list constructions. This function behaves like [`MARK`](/doc/MARK).\n\n@param `mark` A MARK object.\n\n",signature:"[(): mark:MARK",tags:["lists","stack"],since:"1.0.0",OPB64name:"Lk"},"[[":{description:"Pushes a MARK on the stack. This is a syntaxic help to better present Vector (VLIST) constructions.\n \n\n@param `mark` A MARK instance.\n\n",signature:"[[(): mark:MARK",tags:["pig"],since:"1.2.13",OPB64name:"Lpg"},"[[]]":{description:"Pushes an empty Vector onto the stack.\n\n@param `vector` Empty Vector.\n\n",signature:"[[]](): vector:VLIST",tags:["lists"],since:"1.2.13",OPB64name:"LphSMF"},"[]":{description:"The [] function creates an empty LIST on the top of the stack.\n\n\n@param `content` 0 to n elements.\n\n@param `newlist` list instance, initialized with content.\n\n",signature:"[]( content:ANY ): newlist:LIST",tags:["lists"],since:"1.0.0",OPB64name:"Lpo"},"]":{description:"Closes a currently open list and pushes it onto the stack.\n\n  The `]` function pops from the stack the elements of the list up to the first mark encountered. The marks are consumed.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",signature:"]( mark:MARK v1:ANY vN:ANY ): list:LIST",tags:["lists"],since:"1.0.0",OPB64name:"MF"},"]]":{description:"Closes a currently open Vector (VLIST) and pushes it onto the stack. The elements on the stack are those up to the first mark encountered. The mark is discarded.\n\nVLIST are represented as lists on the stack.\n\n@param `v1` The first value\n\n@param `vN` The Nth value\n\n@param `list` The built list\n\n@param `mark` The mark indicating the deepest level to consider when building the list\n\n",signature:"]]( mark:MARK v1:ANY vN:ANY ): list:VLIST",tags:["pig"],since:"1.2.13",OPB64name:"MKo"},"^":{description:"Performs a bitwise **XOR** operation.\n\nThe `^` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **XOR**.\n\nSince Warp 10™ 2.1, `^` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be XOR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with XOR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts XOR with mask\n\n",signature:"^( p1:LONG p2:LONG ): result:LONG\n^( inputgts:GTS mask:LONG ): maskedgts:GTS\n^( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["binary","operators"],since:"1.0.0",OPB64name:"MV"},"bucketizer.and":{description:"The `bucketizer.and` function applies the logical operator **AND** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.and(): bucketizer:AGGREGATOR",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.and"},"bucketizer.count":{description:"The `bucketizer.count` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.count(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count"},"bucketizer.count.exclude-nulls":{description:"**Deprecated**: `bucketizer.count.exclude-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.exclude-nulls` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.count.exclude-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.exclude-nulls"},"bucketizer.count.include-nulls":{description:"**Deprecated**: `bucketizer.count.include-nulls` has the same behavior as `bucketizer.count`, use `bucketizer.count` instead.\n\nThe `bucketizer.count.include-nulls function computes the number of values, including null values, found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.count.include-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.include-nulls"},"bucketizer.count.nonnull":{description:"The `bucketizer.count.nonnull` function computes the number of non-null values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.count.nonnull(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.count.nonnull"},"bucketizer.first":{description:"The `bucketizer.first` function returns the first value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.first` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.first(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.first"},"bucketizer.join":{description:"The `bucketizer.join` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"bucketizer.join( separator:STRING ): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join"},"bucketizer.join.forbid-nulls":{description:"**Deprecated**: `bucketizer.join.forbid-nulls` has the same behavior as `bucketizer.join`, use `bucketizer.join` instead.\n\nThe `bucketizer.join.forbid-nulls` function renders the the concatenation of the string representation of values separated by the join string for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"bucketizer.join.forbid-nulls( separator:STRING ): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.join.forbid-nulls"},"bucketizer.last":{description:"The `bucketizer.last` function returns the last value of the interval to bucketize with its associated location and elevation.\n\nThe `bucketizer.last` function can be applied to values of any type.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.last(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.last"},"bucketizer.mad":{description:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) of each bucket.\n\nThe returned location is the median of all the locations in the bucket, and the returned elevation is the median of all the elevations in the bucket.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.mad(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.2.0",OPB64name:"bucketizer.mad"},"bucketizer.max":{description:"The `bucketizer.max` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.max(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max"},"bucketizer.max.forbid-nulls":{description:"**Deprecated**: `bucketizer.max.forbid-nulls` has the same behavior as `bucketizer.max`, use `bucketizer.max` instead.\n\nThe `bucketizer.max.forbid-nulls` function returns the max of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\nThe `bucketizer.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.max.forbid-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.max.forbid-nulls"},"bucketizer.mean":{description:"The `bucketizer.mean` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.mean(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean"},"bucketizer.mean.circular":{description:"The `bucketizer.mean.circular` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`bucketizer.mean.circular.exclude-nulls`](/doc/bucketizer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `bucketizer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"bucketizer.mean.circular( modulo:NUMBER ): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular"},"bucketizer.mean.circular.exclude-nulls":{description:"**Deprecated**: `bucketizer.mean.circular.exclude-nulls` has the same behavior as `bucketizer.mean.circular`, use `bucketizer.mean.circular` instead.\n        \nThe `bucketizer.mean.circular.exclude-nulls` function returns the the circular mean of all the values found in the bucket.  \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned.\n\nThe `bucketizer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"bucketizer.mean.circular.exclude-nulls( modulo:NUMBER ): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.circular.exclude-nulls"},"bucketizer.mean.exclude-nulls":{description:"**Deprecated**: `bucketizer.mean.exclude-nulls` has the same behavior as `bucketizer.mean`, use `bucketizer.mean` instead.\n \nThe `bucketizer.mean.exclude-nulls` function returns the mean of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `bucketizer.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.mean.exclude-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.mean.exclude-nulls"},"bucketizer.median":{description:"The `bucketizer.median` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.median(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.median"},"bucketizer.median.forbid-nulls":{description:"**Deprecated**: `bucketizer.median.forbid-nulls` has the same behavior as `bucketizer.median`, use `bucketizer.median` instead.\n\nThe `bucketizer.median.forbid-nulls` function returns the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.median.forbid-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"2.4.0",OPB64name:"bucketizer.median.forbid-nulls"},"bucketizer.min":{description:"The `bucketizer.min` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.min(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min"},"bucketizer.min.forbid-nulls":{description:"**Deprecated**: `bucketizer.min.forbid-nulls` has the same behavior as `bucketizer.min`, use `bucketizer.min` instead.\n\nThe `bucketizer.min.forbid-nulls` function returns the min of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the selected value. If the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `bucketizer.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value true is considered greater than false.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.min.forbid-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.min.forbid-nulls"},"bucketizer.or":{description:"The `bucketizer.or` function applies the logical operator **OR** on all the values found in the interval to bucketize.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.or(): bucketizer:AGGREGATOR",tags:["bucketizer","logic"],since:"1.0.11",OPB64name:"bucketizer.or"},"bucketizer.percentile":{description:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the bucket.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `bucketizer` Bucketizer to apply\n\n@param `percentile` Percentile to consider\n\n",signature:"bucketizer.percentile( percentile:NUMBER ): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.percentile"},"bucketizer.rms":{description:"The `bucketizer.rms` function returns the root mean square of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe location and elevation returned are the last one encountered for each bucket.\n\nThe `bucketizer.rms` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.rms(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.2.18",OPB64name:"bucketizer.rms"},"bucketizer.sd":{description:"This bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Bucketizer to apply\n\n",signature:"bucketizer.sd( bessel:BOOLEAN ): result:AGGREGATOR",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd"},"bucketizer.sd.forbid-nulls":{description:"**Deprecated**: `bucketizer.sd.forbid-nulls` has the same behavior as `bucketizer.sd`, use `bucketizer.sd` instead.\n\nThis bucketizer function returns the standard deviation of each bucket. The location and elevation returned are those associated with the most recent value in the bucket.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `bucketizer.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"bucketizer.sd.forbid-nulls( bessel:BOOLEAN ): result:AGGREGATOR",tags:["bucketizer"],since:"2.2.1",OPB64name:"bucketizer.sd.forbid-nulls"},"bucketizer.sum":{description:"The `bucketizer.sum` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.sum(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum"},"bucketizer.sum.forbid-nulls":{description:"**Deprecated**: `bucketizer.sum.forbid-nulls` has the same behavior as `bucketizer.sum`, use `bucketizer.sum` instead.\n\nThe `bucketizer.sum.forbid-nulls` function returns the sum of all the values found for each bucket of a [bucketized](/doc/BUCKETIZE) Geo Time Series™.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `bucketizer.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bucketizer` Bucketizer to apply\n\n",signature:"bucketizer.sum.forbid-nulls(): bucketizer:AGGREGATOR",tags:["bucketizer"],since:"1.0.11",OPB64name:"bucketizer.sum.forbid-nulls"},d:{description:"Converts a number of days (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of days from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of days to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of days\n\n",signature:"d( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"d"},e:{description:"Alias of [E](/doc/GF).\n\nThe `e` function pushes the value of *e* (2.718281828459045) onto the stack.\n\n@param `eValue` Value of *e* (2.718281828459045).\n\n",signature:"e(): eValue:DOUBLE",tags:["math","constants"],since:"1.0.0",OPB64name:"OF"},"filler.interpolate":{description:"Pushes onto the stack a *filler* function which fills missing values with a linear interpolation of enclosing values in a Geo Time Series™.\n\nNote that this function will not fill missing leading or trailing ticks as there is no possible interpolation.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:"filler.interpolate(): filler:FILLER",tags:["filler"],since:"2.0.0",OPB64name:"filler.interpolate"},"filler.next":{description:"Pushes onto the stack a *filler* function which fills missing values with the next value in a Geo Time Series™.\n\nNote that this function will not fill missing trailing ticks as there is no next value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:"filler.next(): filler:FILLER",tags:["filler"],since:"2.0.0",OPB64name:"filler.next"},"filler.previous":{description:"Pushes onto the stack a *filler* function which fills missing values with the previous value in a Geo Time Series™.\n\nNote that this function will not fill missing leading ticks as there is no previous value to use.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:"filler.previous(): filler:FILLER",tags:["filler"],since:"2.0.0",OPB64name:"filler.previous"},"filler.trend":{description:"Pushes onto the stack a *filler* function which fills missing values with the centroid of the points computed by projecting trends from both sides of the missing point.\n\nNote that this function will fill all missing points.\n\n@param `filler` Filler function to use for filling missing values.\n\n",signature:"filler.trend(): filler:FILLER",tags:["filler"],since:"2.0.0",OPB64name:"filler.trend"},"filter.all.eq":{description:"This filter function only selects the Geo Time Series™ whose every value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.all.eq( filter-value:LONG ): result:FILTER\nfilter.all.eq( filter-value:DOUBLE ): result:FILTER\nfilter.all.eq( filter-value:BOOLEAN ): result:FILTER\nfilter.all.eq( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.eq"},"filter.all.ge":{description:"This filter function only selects the Geo Time Series™ whose every value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.all.ge( filter-value:LONG ): result:FILTER\nfilter.all.ge( filter-value:DOUBLE ): result:FILTER\nfilter.all.ge( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ge"},"filter.all.gt":{description:"This filter function only selects the Geo Time Series™ whose every value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.all.gt( filter-value:LONG ): result:FILTER\nfilter.all.gt( filter-value:DOUBLE ): result:FILTER\nfilter.all.gt( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.gt"},"filter.all.le":{description:"This filter function only selects the Geo Time Series™ whose every value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.all.le( filter-value:LONG ): result:FILTER\nfilter.all.le( filter-value:DOUBLE ): result:FILTER\nfilter.all.le( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.le"},"filter.all.lt":{description:"This filter function only selects the Geo Time Series™ whose every value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.all.lt( filter-value:LONG ): result:FILTER\nfilter.all.lt( filter-value:DOUBLE ): result:FILTER\nfilter.all.lt( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.lt"},"filter.all.ne":{description:"This filter function only selects the Geo Time Series™ whose every value does not equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.all.ne( filter-value:LONG ): result:FILTER\nfilter.all.ne( filter-value:DOUBLE ): result:FILTER\nfilter.all.ne( filter-value:BOOLEAN ): result:FILTER\nfilter.all.ne( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.all.ne"},"filter.any.eq":{description:"This filter function only selects the Geo Time Series™ whose at least one value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.any.eq( filter-value:LONG ): result:FILTER\nfilter.any.eq( filter-value:DOUBLE ): result:FILTER\nfilter.any.eq( filter-value:BOOLEAN ): result:FILTER\nfilter.any.eq( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.eq"},"filter.any.ge":{description:"This filter function only selects the Geo Time Series™ whose at least one value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.any.ge( filter-value:LONG ): result:FILTER\nfilter.any.ge( filter-value:DOUBLE ): result:FILTER\nfilter.any.ge( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ge"},"filter.any.gt":{description:"This filter function only selects the Geo Time Series™ whose at least one value is strictly greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.any.gt( filter-value:LONG ): result:FILTER\nfilter.any.gt( filter-value:DOUBLE ): result:FILTER\nfilter.any.gt( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.gt"},"filter.any.le":{description:"This filter function only selects the Geo Time Series™ whose at least one value is lower or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.any.le( filter-value:LONG ): result:FILTER\nfilter.any.le( filter-value:DOUBLE ): result:FILTER\nfilter.any.le( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.le"},"filter.any.lt":{description:"This filter function only selects the Geo Time Series™ whose at least one value is strictly lower than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.any.lt( filter-value:LONG ): result:FILTER\nfilter.any.lt( filter-value:DOUBLE ): result:FILTER\nfilter.any.lt( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.lt"},"filter.any.ne":{description:"This filter function only selects the Geo Time Series™ whose at least one value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.any.ne( filter-value:LONG ): result:FILTER\nfilter.any.ne( filter-value:DOUBLE ): result:FILTER\nfilter.any.ne( filter-value:BOOLEAN ): result:FILTER\nfilter.any.ne( filter-value:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.any.ne"},"filter.byattr":{description:"This filter function only selects the Geo Time Series™ whose attributes match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter.byattr( filter:MAP ): result:FILTER",tags:["filter"],since:"1.0.11",OPB64name:"filter.byattr"},"filter.byclass":{description:"This filter function only selects the Geo Time Series™ whose class name matches the filter parameter.\n\n@param `filter` The filter parameter is a **STRING**, if it starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter.byclass( filter:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.byclass"},"filter.bylabels":{description:"This filter function only selects the Geo Time Series™ whose labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter.bylabels( filter:MAP ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.bylabels"},"filter.bylabelsattr":{description:"This filter function only selects the Geo Time Series™ whose attributes or labels match the filter parameter.\n\n@param `filter` The filter parameter is a map of attributes or labels names as key and a selector as value. If the selector starts with `~`, the rest of the string is considered as a regular expression. If it starts with `=`, it is considered as an exact match. If it does not start with `~` or `=`, it is also considered as an exact match.\n\n@param `result` The filter to apply\n\n",signature:"filter.bylabelsattr( filter:MAP ): result:FILTER",tags:["filter"],since:"1.0.11",OPB64name:"filter.bylabelsattr"},"filter.bymetadata":{description:"Filter GTSs by retaining those whose metadata **exactly** match at least one metadata from the given GTS list. \n\nThe metadata consists of the classname and labels.\n\n@param `lgts` List of GTSs to extract the metadata from.\n\n@param `filter` Filter to apply which will keep only GTSs with exact metadata matching.\n\n",signature:"filter.bymetadata( lgts:LIST<GTS> ): filter:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.bymetadata"},"filter.byselector":{description:"This filter allow to select GTS with a standard or an extended selector.\n###### Standard selector: `classname{labelOrAttribute=x}`\n- If classname match, `filter.byselector` looks into input labels to check if labelOrAttribute exists and equals x. If labelOrAttribute is not found among input labels, it looks into input attributes if the label exists and equals x.\n###### Extended selector: `classname{labelname=x}{attributename=y}` matches if:\n- classname matches\n- input have labelname in its labels, and label value matches\n- input have attributename in its labels, and attribute value matches\n\n###### Selectors example:\n- `~.*{}` matches everything.\n- `={}` matches only emtpy classnames, whatever the labels and attributes.\n- `~.*{label=value}{} filter.byselector` is equivalent to `{ 'label' 'value' } filter.bylabels`.\n- `~.*{}{attribute~value} filter.byselector` is equivalent to `{ 'attribute' '~value' } filter.byattr`.\n\n\n@param `selector` The selector parameter. It could be a standard or an extended selector.\n\n@param `result` The filter to apply\n\n",signature:"filter.byselector( selector:STRING ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.byselector"},"filter.bysize":{description:"Filter GTSs by retaining those whose size is contained between specified bounds (inclusive).\n\n@param `min` The minimum size\n\n@param `max` The maximum size\n\n@param `result` The filter to apply\n\n",signature:"filter.bysize( min:LONG max:LONG ): result:FILTER",tags:["filter"],since:"2.4.0",OPB64name:"filter.bysize"},"filter.last.eq":{description:"This filter function only selects the Geo Time Series™ whose last value equals the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.last.eq( filter-value:LONG ): result:FILTER\nfilter.last.eq( filter-value:DOUBLE ): result:FILTER\nfilter.last.eq( filter-value:BOOLEAN ): result:FILTER\nfilter.last.eq( filter-value:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.eq"},"filter.last.ge":{description:"This filter function only selects the Geo Time Series™ whose last value is greater or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.last.ge( filter-value:LONG ): result:FILTER\nfilter.last.ge( filter-value:DOUBLE ): result:FILTER\nfilter.last.ge( filter-value:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ge"},"filter.last.gt":{description:"This filter function only selects the Geo Time Series™ whose last value is greater than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.last.gt( filter-value:LONG ): result:FILTER\nfilter.last.gt( filter-value:DOUBLE ): result:FILTER\nfilter.last.gt( filter-value:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.gt"},"filter.last.le":{description:"This filter function only selects the Geo Time Series™ whose last value is less or equal to the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.last.le( filter-value:LONG ): result:FILTER\nfilter.last.le( filter-value:DOUBLE ): result:FILTER\nfilter.last.le( filter-value:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.le"},"filter.last.lt":{description:"This filter function only selects the Geo Time Series™ whose last value is less than the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.last.lt( filter-value:LONG ): result:FILTER\nfilter.last.lt( filter-value:DOUBLE ): result:FILTER\nfilter.last.lt( filter-value:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.lt"},"filter.last.ne":{description:"This filter function only selects the Geo Time Series™ whose last value does not equal the filter parameter.\n\nThe filter parameter is a **LONG**, a **DOUBLE**, a **BOOLEAN** or a **STRING**.\n\n@param `filter-value` filter parameter\n\n@param `result` Filter to apply\n\n",signature:"filter.last.ne( filter-value:LONG ): result:FILTER\nfilter.last.ne( filter-value:DOUBLE ): result:FILTER\nfilter.last.ne( filter-value:BOOLEAN ): result:FILTER\nfilter.last.ne( filter-value:STRING ): result:FILTER",tags:["filter"],since:"1.0.0",OPB64name:"filter.last.ne"},"filter.latencies":{description:"Pushes onto the stack a *pseudo* FILTER which computes latencies in a network. It uses the [`FILTER`](/doc/FILTER) framework for conveniency but really returns new GTS.\n\nThe input Geo Time Series™ are assumed to have values which are fingerprints of packet payloads. The first GTS is assumed to be the *uplink* and all the other GTS the *downlinks*.\n\nThe ticks are the time at which a packet with the given fingerprint was observed.\n\nThe generated Geo Time Series™ will have the same ticks as the uplink one, except the values will be latencies instead of packet fingerprints.\n\nThe `filter.latencies` function accepts a number of options:\n\n| Option | Description |\n|--------|-------------|\n| uplink.latency.min | Compute minimum latency on the uplink. |\n| uplink.latency.max | Compute maximum latency on the uplink. |\n| downlink.latency.min | Compute minimum latency on each downlink. |\n| downlink.latency.max | Compute maximum latency on each downlink. |\n| downlink.matches | Compute the number of matches for each downlink. |\n| downlinks.totalmatches | Computes the total number of matches across downlinks. |\n| downlinks.bitsets | Computes a bitset of downlinks which saw the packet (limited to 64 downlinks). |\n| downlinks.withmatches | Computes the number of downlinks with matches for the given packet. |\n\nThis pseudo FILTER is very specific to a networking use case, but it is a good demonstration of the power of WarpScript and its frameworks.\n\n@param `options` List of options, see above for their description.\n\n@param `maxLatency` Maximum allowable latency, packets with latency above this threshold are ignored.\n\n@param `minLatency` Minimum latency, packets with a latency below this threshold are ignored.\n\n@param `filter` Instance of `filter.latencies`.\n\n",signature:"filter.latencies( minLatency:LONG maxLatency:LONG options:LIST<STRING> ): filter:FILTER",tags:["filter","gts"],since:"1.0.0",OPB64name:"filter.latencies"},h:{description:"Converts a number of hours (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of hours from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of hours to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of hours\n\n",signature:"h( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"h"},m:{description:"Converts a number of minutes (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of minutes from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of minutes to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of minutes\n\n",signature:"m( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"m"},"mapper.abs":{description:"This mapper function returns the absolute value of single value in a sliding window.\n\nThe `mapper.abs` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.abs(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.abs"},"mapper.add":{description:"This mapper function adds a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.add` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.add` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Value to add\n\n@param `result` Mapper to apply\n\n",signature:"mapper.add( constant:DOUBLE ): result:AGGREGATOR\nmapper.add( constant:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.add"},"mapper.and":{description:"This mapper function applies the logical operator **AND** on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.and(): result:AGGREGATOR",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.and"},"mapper.ceil":{description:"This mapper function rounds the single value in a sliding window to the closests greater **LONG**.\n\nThe `mapper.ceil` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ceil(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.ceil"},"mapper.count":{description:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.count(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count"},"mapper.count.exclude-nulls":{description:"**Deprecated**: `mapper.count.exclude-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.count.exclude-nulls(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.exclude-nulls"},"mapper.count.include-nulls":{description:"**Deprecated**: `mapper.count.include-nulls` has the same behavior as `mapper.count`, use `mapper.count` instead.\n\nThis mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are included.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.count.include-nulls(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.include-nulls"},"mapper.count.nonnull":{description:"This mapper function counts the number of all values found in the sliding window. The associated location and elevation are\nthose of the most recent tick of the window. Null values are excluded.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.count.nonnull(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.count.nonnull"},"mapper.day":{description:"This mapper function returns the day of the tick for which it is computed.\n\nThe `mapper.day` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n@param `timezone` Timezone to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"mapper.day( timezone:STRING ): result:AGGREGATOR\nmapper.day( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.day"},"mapper.delta":{description:"This mapper function computes the delta between the last and first values (delta = last - first) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.delta` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does \nnot return any value.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.delta(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.delta"},"mapper.dotproduct":{description:"The `mapper.dotproduct` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"mapper.dotproduct( vector:LIST ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct"},"mapper.dotproduct.positive":{description:"The `mapper.dotproduct.positive` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it sets all negative results to 0.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"mapper.dotproduct.positive( vector:LIST ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.positive"},"mapper.dotproduct.sigmoid":{description:"The `mapper.dotproduct.sigmoid` function consumes a vector as parameter (a **LIST** of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the sigmoid of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"mapper.dotproduct.sigmoid( vector:LIST ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.sigmoid"},"mapper.dotproduct.tanh":{description:"The `mapper.dotproduct.tanh` function consumes a vector as parameter (a **LIST* of **DOUBLE**) from the top of the stack.\n\nThe resulting mapper computes the dot product of the given vector with the values of the sliding window, then it returns the \n[hyperbolic tangent](https://en.wikipedia.org/wiki/Hyperbolic_function) of this result.\n\nIf the sliding window at a tick does not have the same size as the given vector, then no value is produced.\n\nThe resulting mapper can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `vector` Element of the vector\n\n@param `result` Mapper to apply\n\n",signature:"mapper.dotproduct.tanh( vector:LIST ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.dotproduct.tanh"},"mapper.eq":{description:"This mapper function returns the first value in a sliding window which is equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.eq` function can be applied to data of any type.\n\nThe `mapper.eq` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.eq( parameter:LONG ): result:AGGREGATOR\nmapper.eq( parameter:DOUBLE ): result:AGGREGATOR\nmapper.eq( parameter:BOOLEAN ): result:AGGREGATOR\nmapper.eq( parameter:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.eq"},"mapper.eq.elev":{description:"This mapper function returns the first elevation in a sliding window which is equal to a given value.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.eq.elev` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.eq.elev( parameter:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.elev"},"mapper.eq.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is equal to a given value.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.eq.hhcode` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.eq.hhcode( parameter:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.hhcode"},"mapper.eq.lat":{description:"This mapper function returns the first latitude in a sliding window which is equal to a given value.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.eq.lat` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.eq.lat( parameter:LONG ): result:AGGREGATOR\nmapper.eq.lat( parameter:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lat"},"mapper.eq.lon":{description:"This mapper function returns the first longitude in a sliding window which is equal to a given value.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.eq.lon` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.eq.lon( parameter:LONG ): result:AGGREGATOR\nmapper.eq.lon( parameter:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.lon"},"mapper.eq.tick":{description:"This mapper function returns the first tick in a sliding window which is equal to a given value.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.eq.tick` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.eq.tick( parameter:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.eq.tick"},"mapper.exp":{description:"This mapper function raises a constant to the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.exp` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.exp` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\n> ## Note\n> The `mapper.exp` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n>\n> So you are looking for a way to apply the exponential function, ex, to a series of Geo Time Series™. It’s very easy to do it using `mapper.exp` and the\n> [`e`](/doc/OF) constant.\n\n@param `result` Mapper to apply\n\n@param `constant` Constant to use\n\n",signature:"mapper.exp( constant:LONG ): result:AGGREGATOR\nmapper.exp( constant:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.exp"},"mapper.finite":{description:"Pushes onto the stack an AGGREGATOR which returns its input value only if it is finite (*i.e.* a non DOUBLE or a DOUBLE which is neither NaN nor Infinity).\n\n@param `result` Instance of mapper.finite.\n\n",signature:"mapper.finite(): result:AGGREGATOR",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.finite"},"mapper.first":{description:"This mapper function returns the first value of each sliding window with its associated location and elevation.\n\nThe `mapper.first` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.first(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.first"},"mapper.floor":{description:"This mapper function rounds the *single value* in a sliding window to the closests lower **LONG**.\n\nThe `mapper.floor` function can be applied to data of type **LONG** or **DOUBLE**.      \n\n@param `result` Mapper to apply\n\n",signature:"mapper.floor(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.floor"},"mapper.ge":{description:"This mapper function returns the first value in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ge` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.ge` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ge( threshold:LONG ): result:AGGREGATOR\nmapper.ge( threshold:STRING ): result:AGGREGATOR\nmapper.ge( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ge"},"mapper.ge.elev":{description:"This mapper function returns the first elevation in a sliding window which is greater or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ge.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ge.elev( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.elev"},"mapper.ge.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ge.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ge.hhcode( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.hhcode"},"mapper.ge.lat":{description:"This mapper function returns the first latitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ge.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ge.lat( threshold:LONG ): result:AGGREGATOR\nmapper.ge.lat( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lat"},"mapper.ge.lon":{description:"This mapper function returns the first longitude in a sliding window which is greater or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ge.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ge.lon( threshold:LONG ): result:AGGREGATOR\nmapper.ge.lon( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.lon"},"mapper.ge.tick":{description:"This mapper function returns the first tick in a sliding window which is greater or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ge.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ge.tick( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ge.tick"},"mapper.geo.approximate":{description:"Pushes onto the stack a mapper instance which will transform the input Geo Time Series™ by approximating the location to the givnen resolution.\n\nApproximation is done by clearing lower bits of the location [HHCode](https://en.wikipedia.org/wiki/HHCode). At resolution `R`, the lower `64 - 2R` bits are cleared.\n\n| Resolution | Precision |\n| --- | --- |\n| 2 | 10,000 km |\n| 4 | 2,500 km |\n| 6 | 625 km |\n| 8 | 156 km |\n| 10 | 39 km |\n| 12 | 10 km |\n| 14 |  2.5 km |\n| 16 | 600 m |\n| 18 | 150 m |\n| 20 | 40 m |\n| 22 | 10 m |\n| 24 | 2.5 m |\n| 26 | 60 cm |\n| 28 | 15 cm |\n| 30 | 4 cm |\n\nThe exact precision is 40,000 km divided by 2**resolution.\n\n\n\n@param `resolution` HHCode resolution at which to approximate the locations. Resoluion is an even number between 2 (coarsest) and 32 (finest).\n\n@param `result` Instance of mapper.\n\n",signature:"mapper.geo.approximate( resolution:LONG ): result:AGGREGATOR",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.approximate"},"mapper.geo.clear":{description:"Pushes onto the stack a mapper which will discard location and elevation information when applied to a Geo Time Series™.\n\nThis mapper can only be applied to single values\n\n@param `result` Instance of the `mapper.geo.clear` mapper.\n\n",signature:"mapper.geo.clear(): result:AGGREGATOR",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.geo.clear"},"mapper.geo.fence":{description:"This function produces a `mapper` which outputs a `BOOLEAN` for each point with an associated location. The value of the output is `true` if the location is inside the provided `GEOSHAPE` and `false` otherwise.\nThe geo zone can be defined in [WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using [`GEO.WKT`](/doc/GEO.WKT) or in [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON) using [`GEO.JSON`](/doc/GEO.JSON).\n\n@param `zone` Geographical zone.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.geo.fence( zone:GEOSHAPE ): result:AGGREGATOR",tags:["mapper","geo"],since:"2.7.1",OPB64name:"mapper.geo.fence"},"mapper.geo.outside":{description:"This mapper filters the Geo Time Series™, keeping only the points outside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.geo.outside( geoZone:GEOSHAPE ): result:AGGREGATOR",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.outside"},"mapper.geo.within":{description:"This mapper filters the Geo Time Series™, keeping only the points inside a geographical zone (geo zone). The geo zone can be defined in\n[WKT](http://en.wikipedia.org/wiki/Well-known_text) format by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `geoZone` Geo zone defined by using the [`GEO.WKT`](/doc/GEO.WKT) function.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.geo.within( geoZone:GEOSHAPE ): result:AGGREGATOR",tags:["mapper","geo"],since:"1.0.0",OPB64name:"mapper.geo.within"},"mapper.gt":{description:"This mapper function returns the first value in a sliding window which is greater than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.gt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.gt` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.gt( threshold:LONG ): result:AGGREGATOR\nmapper.gt( threshold:STRING ): result:AGGREGATOR\nmapper.gt( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.gt"},"mapper.gt.elev":{description:"This mapper function returns the first elevation in a sliding window which is greater than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.gt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.gt.elev( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.elev"},"mapper.gt.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is greater than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.gt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.gt.hhcode( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.hhcode"},"mapper.gt.lat":{description:"This mapper function returns the first latitude in a sliding window which is greater than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.gt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.gt.lat( threshold:LONG ): result:AGGREGATOR\nmapper.gt.lat( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lat"},"mapper.gt.lon":{description:"This mapper function returns the first longitude in a sliding window which is greater than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.gt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.gt.lon( threshold:LONG ): result:AGGREGATOR\nmapper.gt.lon( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.lon"},"mapper.gt.tick":{description:"This mapper function returns the first tick in a sliding window which is greater than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.gt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.gt.tick( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.gt.tick"},"mapper.hdist":{description:"The `mapper.hdist` function computes the total distance traveled while going through the points in the sliding window in chronological order. This distance is in meters.\n\nThe distance used is the loxodromic distance aka rhumb line. As a consequence, elevation is not taken into account in the distance.\n\nIf a point has no position in the sliding window, it is ignored.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe `mapper.hdist` function can be applied to data of any type since it only considers locations.\n\n@param `hdistMapper` A function which can be used in a mapper.\n\n",signature:"mapper.hdist(): hdistMapper:AGGREGATOR",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.hdist"},"mapper.highest":{description:"This mapper function returns the value associated with the highest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the most recent is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.highest(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.highest"},"mapper.hour":{description:"This mapper function returns the hour of the tick for which it is computed.\n\nThe `mapper.hour` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"mapper.hour( timezone:STRING ): result:AGGREGATOR\nmapper.hour( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.hour"},"mapper.hspeed":{description:"This mapper function computes the horizontal speed along the path traveled in the sliding window.\n\nThe distance is computed by summing the distances along the rhumb line between two consecutive locations.\n\nIf there is only one tick in the sliding window, the speed is 0.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.hspeed` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.hspeed(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.hspeed"},"mapper.join":{description:"This mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"mapper.join( separator:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join"},"mapper.join.forbid-nulls":{description:"**Deprecated**: `mapper.join.forbid-nulls` has the same behavior as `mapper.join`, use `mapper.join` instead.\n\nThis mapper function renders the the concatenation of the string representation of values separated by the join string of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe location and elevation returned are from the latest measure.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n@param `separator` Separator used for concatenation\n\n",signature:"mapper.join.forbid-nulls( separator:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.join.forbid-nulls"},"mapper.kernel.cosine":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [cosine kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics.\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.cosine( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.cosine"},"mapper.kernel.epanechnikov":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using an [epanechnikov kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.epanechnikov( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.epanechnikov"},"mapper.kernel.gaussian":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [gaussian kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.gaussian( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.gaussian"},"mapper.kernel.logistic":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [logistic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted average](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) algorithm.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.logistic( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.logistic"},"mapper.kernel.quartic":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [quartic kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.quartic( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.quartic"},"mapper.kernel.silverman":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [silverman kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.silverman( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.silverman"},"mapper.kernel.triangular":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triangular kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.triangular( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triangular"},"mapper.kernel.tricube":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [tricube kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.tricube( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.tricube"},"mapper.kernel.triweight":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [triweight kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.triweight( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.triweight"},"mapper.kernel.uniform":{description:"This function pushes onto the stack a [kernel smoothing](https://en.wikipedia.org/wiki/Kernel_smoother) mapper using a [uniform kernel](https://en.wikipedia.org/wiki/Kernel_(statistics)#In_non-parametric_statistics).\nThe mapper applies the [Nadaraya-Watson kernel-weighted](https://en.wikipedia.org/wiki/Kernel_regression#Nadaraya.E2.80.93Watson_kernel_regression) average algorithm.\n\nThe function expects on top of the stack a bandwidth expressed as an odd number of ticks and below it a step expressed in time units. The step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel. The bandwidth in time units is the bandwidth in ticks times the step.\n\n@param `step` Expressed in time units, the step parameter is used to determine the distance of a tick from the tick being computed to feed it into the kernel.\n\n@param `bandwidth` Odd number of ticks, the bandwidth in time units is the bandwidth in ticks times the step\n\n@param `result` Mapper to apply\n\n",signature:"mapper.kernel.uniform( bandwidth:LONG step:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.kernel.uniform"},"mapper.last":{description:"This [`mapper`](/doc/MAP) function returns the last value of each sliding window with its associated location and elevation.\n\nThe `mapper.last` function can be applied to values of any type.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.last(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.last"},"mapper.le":{description:"This mapper function returns the first value in a sliding window which is less or equal to a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.le` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.le` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",signature:"mapper.le( threshold:DOUBLE ): result:AGGREGATOR\nmapper.le( threshold:LONG ): result:AGGREGATOR\nmapper.le( threshold:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.le"},"mapper.le.elev":{description:"This mapper function returns the first elevation in a sliding window which is less or equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.le.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.le.elev( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.elev"},"mapper.le.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less or equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.le.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.le.hhcode( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.hhcode"},"mapper.le.lat":{description:"This mapper function returns the first latitude in a sliding window which is less or equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.le.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.le.lat( threshold:LONG ): result:AGGREGATOR\nmapper.le.lat( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lat"},"mapper.le.lon":{description:"This mapper function returns the first longitude in a sliding window which is less or equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.le.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.le.lon( threshold:LONG ): result:AGGREGATOR\nmapper.le.lon( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.lon"},"mapper.le.tick":{description:"This mapper function returns the first tick in a sliding window which is less or equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.le.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.le.tick( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.le.tick"},"mapper.log":{description:"This mapper function takes the log of the **single value** in a sliding window in the base used as parameter to `mapper.log`.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.log` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.log` function must be parameterized with the constant.\n\nThe result is always of type **DOUBLE**.\n\nThe `mapper.log` mapper needs a single value sliding window, i.e. pre-window and post-window to 0.\n\n@param `constant` Constant parameter\n\n@param `result` Mapper to apply\n\n",signature:"mapper.log( constant:DOUBLE ): result:AGGREGATOR\nmapper.log( constant:LONG ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.log"},"mapper.lowest":{description:"This mapper function returns the value associated with the lowest elevation in the sliding window. The location and elevation returned are those \nassociated with the selected value. In case of multiple occurrences, the one appearing first chronologically is selected.\n\nIf no elevation data was found in the sliding window, no value will be returned.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lowest(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.lowest"},"mapper.lt":{description:"This mapper function returns the first value in a sliding window which is less than a given threshold.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.lt` function can be applied to data of any type except **BOOLEAN**.\n\nThe `mapper.lt` function must be parameterized with the threshold.\n\n\n@param `threshold` Threshold used to compare\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lt( threshold:DOUBLE ): result:AGGREGATOR\nmapper.lt( threshold:LONG ): result:AGGREGATOR\nmapper.lt( threshold:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.lt"},"mapper.lt.elev":{description:"This mapper function returns the first elevation in a sliding window which is less than a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.lt.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lt.elev( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.elev"},"mapper.lt.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is less than a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.lt.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lt.hhcode( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.hhcode"},"mapper.lt.lat":{description:"This mapper function returns the first latitude in a sliding window which is less than a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.lt.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lt.lat( threshold:LONG ): result:AGGREGATOR\nmapper.lt.lat( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lat"},"mapper.lt.lon":{description:"This mapper function returns the first longitude in a sliding window which is less than a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.lt.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lt.lon( threshold:LONG ): result:AGGREGATOR\nmapper.lt.lon( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.lon"},"mapper.lt.tick":{description:"This mapper function returns the first tick in a sliding window which is less than a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.lt.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.lt.tick( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.lt.tick"},"mapper.mad":{description:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) over each sliding window.\n\nThe returned location is the median of all the locations in the sliding window, and the returned elevation is the median of all the elevations in the window.\n\n@param `result` Instance of `mapper.mad`.\n\n",signature:"mapper.mad(): result:AGGREGATOR",tags:["mapper"],since:"1.2.0",OPB64name:"mapper.mad"},"mapper.max":{description:"This mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.max(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max"},"mapper.max.forbid-nulls":{description:"**Deprecated**: `mapper.max.forbid-nulls` has the same behavior as `mapper.max`, use `mapper.max` instead.\n\nThis mapper function returns the max of all the values found in each sliding window. The associated location and elevation are those of the selected value. If the max value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.max.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",signature:"mapper.max.forbid-nulls(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.max.forbid-nulls"},"mapper.max.x":{description:"This mapper function returns the max between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.max.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",signature:"mapper.max.x( constant:DOUBLE ): result:AGGREGATOR\nmapper.max.x( constant:LONG ): result:AGGREGATOR\nmapper.max.x( constant:STRING ): result:AGGREGATOR\nmapper.max.x( constant:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.max.x"},"mapper.mean":{description:"This mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.mean(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean"},"mapper.mean.circular":{description:"This function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`mapper.mean.circular.exclude-nulls`](/doc/mapper.mean.circular.exclude-nulls) if your sliding windows may contain nulls.\n\nThe `mapper.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",signature:"mapper.mean.circular( modulo:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular"},"mapper.mean.circular.exclude-nulls":{description:"**Deprecated**: `mapper.mean.circular.exclude-nulls` has the same behavior as `mapper.mean.circular`, use `mapper.mean.circular` instead.\n\nThis function will push a mapper onto the stack which can then be used to compute the circular mean of all the values found in each sliding window. \nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe mapper function produced by `mapper.mean.circular.exclude-nulls` can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING**\nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `mapper.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be used to determine the span \nof circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `result` Mapper to apply\n\n@param `modulo` The span of circular values\n\n",signature:"mapper.mean.circular.exclude-nulls( modulo:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.circular.exclude-nulls"},"mapper.mean.exclude-nulls":{description:"**Deprecated**: `mapper.mean.exclude-nulls` has the same behavior as `mapper.mean`, use `mapper.mean` instead.\n        \nThis mapper function returns the mean of all the values found in each sliding window. The associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `mapper.mean.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",signature:"mapper.mean.exclude-nulls(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.mean.exclude-nulls"},"mapper.median":{description:"Pushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median`.\n\n",signature:"mapper.median(): result:AGGREGATOR",tags:["mapper","gts"],since:"1.0.11",OPB64name:"mapper.median"},"mapper.median.forbid-nulls":{description:"**Deprecated**: `mapper.median.forbid-nulls` has the same behavior as `mapper.median`, use `mapper.median` instead.\n\nPushes onto the stack an AGGREGATOR which computes the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values in the sliding window.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `result` Instance of `mapper.median.forbid-nulls`.\n\n",signature:"mapper.median.forbid-nulls(): result:AGGREGATOR",tags:["mapper","gts"],since:"2.4.0",OPB64name:"mapper.median.forbid-nulls"},"mapper.min":{description:"This mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.min(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min"},"mapper.min.forbid-nulls":{description:"**Deprecated**: `mapper.min.forbid-nulls` has the same behavior as `mapper.min`, use `mapper.min` instead.\n\nThis mapper function returns the min of all the values found in each sliding window. The associated location and elevation are those of the selected value. \nIf the min value is encountered several times, the selected one is the one that appears first chronologically.\n\nThe `mapper.min.forbid-nulls` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than **true**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `result` Mapper to apply\n\n",signature:"mapper.min.forbid-nulls(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.min.forbid-nulls"},"mapper.min.x":{description:"This mapper function returns the min between a constant passed as parameter and each value. The associated location and elevation are those of the \nselected value.\n\nThe `mapper.min.x` function can be applied to values of any type, when applied to **BOOLEAN** types, the value **false** is considered less than true.\n\n\n@param `constant` Constant used to compare\n\n@param `result` Mapper to apply\n\n",signature:"mapper.min.x( constant:DOUBLE ): result:AGGREGATOR\nmapper.min.x( constant:LONG ): result:AGGREGATOR\nmapper.min.x( constant:STRING ): result:AGGREGATOR\nmapper.min.x( constant:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.min.x"},"mapper.minute":{description:"This mapper function returns the minute of the tick for which it is computed.\n\nThe `mapper.minute` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"mapper.minute( timezone:STRING ): result:AGGREGATOR\nmapper.minute( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.minute"},"mapper.mod":{description:"Pushes onto the stack an AGGREGATOR which computes the remainder of a value given a modulus.\n\nThis MAPPER can only be applied to a single value.\n\n@param `modulus` Modulus to consider when computing the remainder.\n\n@param `result` Instance of `mapper.mod`.\n\n",signature:"mapper.mod( modulus:NUMBER ): result:AGGREGATOR",tags:["mapper","gts"],since:"1.2.3",OPB64name:"mapper.mod"},"mapper.month":{description:"This mapper function returns the month of the tick for which it is computed.\n\nThe `mapper.month` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",signature:"mapper.month( timezone:STRING ): result:AGGREGATOR\nmapper.month( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.month"},"mapper.mul":{description:"This mapper function multiplies by a constant the single value in a sliding window.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.mul` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.mul` function must be parameterized with the constant.\n\nThe result will be of the same type as the constant.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",signature:"mapper.mul( constant:LONG ): result:AGGREGATOR\nmapper.mul( constant:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.mul"},"mapper.ne":{description:"This mapper function returns the first value in a sliding window which is not equal to a given value.\n\nThe associated location and elevation are those of the selected value.\n\nThe `mapper.ne` function can be applied to data of any type.\n\nThe `mapper.ne` function must be parameterized with the value against which to test for equality.\n\n@param `parameter` Parameter to use for comparision\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ne( parameter:LONG ): result:AGGREGATOR\nmapper.ne( parameter:DOUBLE ): result:AGGREGATOR\nmapper.ne( parameter:BOOLEAN ): result:AGGREGATOR\nmapper.ne( parameter:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.ne"},"mapper.ne.elev":{description:"This mapper function returns the first elevation in a sliding window which is not equal to a given threshold.\n\nThe associated location and value are those of the selected elevation.\n\nThe `mapper.ne.elev` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ne.elev( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.elev"},"mapper.ne.hhcode":{description:"This mapper function returns the first location expressed as a hhcode in a sliding window which is not equal to a given threshold.\n\nThe associated elevation and value are those of the selected location.\n\nThe `mapper.ne.hhcode` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ne.hhcode( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.hhcode"},"mapper.ne.lat":{description:"This mapper function returns the first latitude in a sliding window which is not equal to a given threshold.\n\nThe associated longitude, elevation and value are those of the selected latitude.\n\nThe `mapper.ne.lat` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ne.lat( threshold:LONG ): result:AGGREGATOR\nmapper.ne.lat( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lat"},"mapper.ne.lon":{description:"This mapper function returns the first longitude in a sliding window which is not equal to a given threshold.\n\nThe associated latitude, elevation and value are those of the selected longitude.\n\nThe `mapper.ne.lon` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ne.lon( threshold:LONG ): result:AGGREGATOR\nmapper.ne.lon( threshold:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.lon"},"mapper.ne.tick":{description:"This mapper function returns the first tick in a sliding window which is not equal to a given threshold.\n\nThe associated location, elevation and value are those of the selected tick.\n\nThe `mapper.ne.tick` function must be parameterized with the threshold.\n\n@param `threshold` Threshold\n\n@param `result` Mapper to apply\n\n",signature:"mapper.ne.tick( threshold:LONG ): result:AGGREGATOR",tags:["mapper"],since:"2.2.0",OPB64name:"mapper.ne.tick"},"mapper.npdf":{description:"Pushes onto the stack an AGGREGATOR which returns the probability of a value given a normal distribution.\n\n@param `mu` Mean of the normal (Gaussian) distribution to consider.\n\n@param `sigma` Standard deviation of the normal (Gaussian) distribution to consider.\n\n@param `result` Instance of `mapper.npdf`.\n\n",signature:"mapper.npdf( mu:DOUBLE sigma:DOUBLE ): result:AGGREGATOR",tags:["gts","mapper"],since:"1.0.0",OPB64name:"mapper.npdf"},"mapper.or":{description:"This mapper function applies the logical operator OR on all the values found in each sliding window.\n\nThe associated location and elevation are those of the most recent tick of the interval.\n\nThe `mapper.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.or(): result:AGGREGATOR",tags:["mapper","logic"],since:"1.0.11",OPB64name:"mapper.or"},"mapper.parsedouble":{description:"This mapper function converts a **STRING** single value in a sliding window to **DOUBLE**.\n\nThe `mapper.parsedouble` function can be applied to data of type **STRING**.\n\nThis function expects a [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) \nparameter in top of the mapper. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `tag` [IETF BCP 47 language tag string](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#forLanguageTag-java.lang.String-) parameter. This tag is used to parse the **STRING** given as input according to the specified double format of this language.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.parsedouble( tag:STRING ): result:AGGREGATOR",tags:["mapper"],since:"1.2.5",OPB64name:"mapper.parsedouble"},"mapper.percentile":{description:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values in the sliding window.\n\nThe returned location and elevation are those of the chosen value.\n\n@param `percentile` Percentile to consider.\n\n@param `result` Instance of `mapper.percentile`.\n\n",signature:"mapper.percentile( percentile:NUMBER ): result:AGGREGATOR",tags:["mapper","gts"],since:"1.0.0",OPB64name:"mapper.percentile"},"mapper.pow":{description:"This mapper function raises the single value in a sliding window to a constant power.\n\nIf the sliding window is empty, the function does not return any value. If the sliding window contains more than a single value, an error is produced.\n\nThe associated location and elevation are those of the single value.\n\nThe `mapper.pow` function can be applied to data of type **LONG** or **DOUBLE**.\n\nThe `mapper.pow` function must be parameterized with the constant.\n\nThe result is always of type DOUBLE.\n\n@param `constant` Constant to apply\n\n@param `result` Mapper to apply\n\n",signature:"mapper.pow( constant:LONG ): result:AGGREGATOR\nmapper.pow( constant:DOUBLE ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.pow"},"mapper.product":{description:"This mapper function computes the product of all the values found in the sliding window.\n\nThe `mapper.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\nOn [bucketized](/doc/BUCKETIZE) Geo Time Series™, it is necessary to fill gaps with [`FILLVALUE`](/doc/FILLVALUE)\n\n@param `result` Mapper to apply\n\n",signature:"mapper.product(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.product"},"mapper.rate":{description:"This mapper function computes the rate of change between the first and last values (rate = (last - first) / (lastick - firsttick)) of each sliding window. The location and\nelevation returned are those associated with the most recent value in the sliding window.\n\nThe `mapper.rate` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value. If the\nsliding window contains less than 2 values, the rate of change will be 0.0.\n\nThe rate of change is expressed in units per second.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.rate(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.rate"},"mapper.replace":{description:"This mapper function replaces windows with at least one value with a constant. The location and elevation returned are those associated with the most \nrecent value in the sliding window.\n\n@param `constant` constant used for replacement\n\n@param `result` Mapper to apply\n\n",signature:"mapper.replace( constant:LONG ): result:AGGREGATOR\nmapper.replace( constant:DOUBLE ): result:AGGREGATOR\nmapper.replace( constant:STRING ): result:AGGREGATOR\nmapper.replace( constant:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.replace"},"mapper.rms":{description:"This mapper function returns the root mean square of all the values found in each sliding window. The associated location is the last one of the window.\n\nThe `mapper.rms` function can only be applied to values of type **LONG** or **DOUBLE**.\n\n\n@param `result` Mapper to apply\n\n",signature:"mapper.rms(): result:AGGREGATOR",tags:["mapper"],since:"1.2.18",OPB64name:"mapper.rms"},"mapper.round":{description:"This mapper function rounds the *single value* in a sliding window to the closests **LONG**.\n\nThe `mapper.round` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.round(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.round"},"mapper.sd":{description:"This mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"mapper.sd( bessel:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd"},"mapper.sd.forbid-nulls":{description:"**Deprecated**: `mapper.sd.forbid-nulls` has the same behavior as `mapper.sd`, use `mapper.sd` instead.\n\nThis mapper function returns the standard deviation of each sliding window. The location and elevation returned are those associated with the most recent value in the sliding window.\n\nThe standard deviation is the square root of the variance as computed by [`mapper.var`](/doc/mapper.var).\n\nThe `mapper.sd.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"mapper.sd.forbid-nulls( bessel:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sd.forbid-nulls"},"mapper.second":{description:"This mapper function returns the second of the tick for which it is computed.\n\nThe `mapper.second` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"mapper.second( timezone:STRING ): result:AGGREGATOR\nmapper.second( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.second"},"mapper.sigmoid":{description:"This mapper function returns the sigmoid of *single value* in a sliding window.\n\nThe `mapper.sigmoid` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.sigmoid(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sigmoid"},"mapper.sqrt":{description:"This mapper function computes the square root of the single value in a sliding window.\n\nFor negative numerics, this mapper returns **NaN**. For string values, this mapper returns 0.\n\nThe associated location and elevation are those of the single value.\n\n> ### Note\n> The `mapper.sqrt` mapper needs a single value sliding window, i.e. pre-window and post-window to 0\n\n\n@param `result` Mapper to apply\n\n",signature:"mapper.sqrt(): result:AGGREGATOR",tags:["mapper"],since:"1.2.11",OPB64name:"mapper.sqrt"},"mapper.sum":{description:"This mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.sum(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum"},"mapper.sum.forbid-nulls":{description:"**Deprecated**: `mapper.sum.forbid-nulls` has the same behavior as `mapper.sum`, use `mapper.sum` instead.\n\nThis mapper function computes the sum of all the values found in the sliding window. The associated location and elevation are those of the most recent tick of the window.\n\nThe `mapper.sum.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.sum.forbid-nulls(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.sum.forbid-nulls"},"mapper.tanh":{description:"This mapper function returns the hyperbolic tangent of *single value* in a sliding window.\n\nThe `mapper.tanh` function can be applied to data of type **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.tanh(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tanh"},"mapper.tick":{description:"This mapper function returns the tick for which it is computed. The associated location and elevation are those of the selected value.\n\nThe `mapper.tick` function can be applied to values of any type.        \n\n@param `result` Mapper to apply\n\n",signature:"mapper.tick(): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.tick"},"mapper.toboolean":{description:"This mapper function converts the single value in a sliding window to **BOOLEAN**.\n\nThe `mapper.toboolean` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.toboolean(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.toboolean"},"mapper.todouble":{description:"This mapper function converts the single value in a sliding window to **DOUBLE**.\n\nThe `mapper.todouble` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.todouble(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.todouble"},"mapper.tolong":{description:"This mapper function converts the single value in a sliding window to **LONG**.\n\nThe `mapper.tolong` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.tolong(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tolong"},"mapper.tostring":{description:"This mapper function converts the single value in a sliding window to **STRING**.\n\nThe `mapper.tostring` function can be applied to data of type **BOOLEAN**, **STRING**, **LONG** or **DOUBLE**.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.tostring(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.tostring"},"mapper.truecourse":{description:"Pushes onto the stack a mapper which will compute the initial [true course]http://www.edwilliams.org/avform.htm#Crs) on a great circle from the first to the last datapoint in the sliding window.\n\nThe location and elevation of the result is that of the tick being considered.\n\n@param `result` Instance of mapper.truecourse.\n\n",signature:"mapper.truecourse(): result:AGGREGATOR",tags:["mapper","geo"],since:"1.0.11",OPB64name:"mapper.truecourse"},"mapper.var":{description:"This mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"mapper.var( bessel:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var"},"mapper.var.forbid-nulls":{description:"**Deprecated**: `mapper.var.forbid-nulls` has the same behavior as `mapper.var`, use `mapper.var` instead.\n\nThis mapper function returns the variance of all the values found in each sliding window. The location and elevation returned are those associated \nwith the most recent value in the sliding window.\n\nIf the number of values in the sliding window is greater than one, [Bessel’s correction](http://en.wikipedia.org/wiki/Bessel's_correction) is applied. \nThe `mapper.var.forbid-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** or **BOOLEAN** it does not return any value.\n\nIf a value is **NULL** in the bucket, the result is **NULL**.\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n@param `result` Mapper to apply\n\n",signature:"mapper.var.forbid-nulls( bessel:BOOLEAN ): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.var.forbid-nulls"},"mapper.vdist":{description:"This mapper function computes the total distance traveled in the vertical plane in the sliding window.\n\nThe distance is computed by summing the distances between consecutive elevations (this differs from the computation done in [`mapper.vspeed`](/doc/mapper.vspeed))\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed distance is expressed in meters.\n\nThe `mapper.vdist` function can be applied to data of any type since it only considers locations.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.vdist(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vdist"},"mapper.vspeed":{description:"This mapper function computes the vertical speed between the first and last readings of the sliding window. It does not compute the speed based on the total\nvertical distance traveled in the sliding window, it only considers its extrema (it differs significantly of what is done for horizontal speed in\n[`mapper.hspeed`](/doc/mapper.hspeed)), thus the result can be positive or negative.\n\nIf one of the extrema of the sliding window has no elevation, no value is returned.\n\nThe associated location and elevation are those at the tick being computed if it is part of the sliding window.\n\nThe computed speed is expressed in meters per second.\n\nThe `mapper.vspeed` function can be applied to data of any type since it only considers elevations.\n\n@param `result` Mapper to apply\n\n",signature:"mapper.vspeed(): result:AGGREGATOR",tags:["mapper"],since:"1.0.11",OPB64name:"mapper.vspeed"},"mapper.weekday":{description:"This mapper function returns the day of the week of the tick for which it is computed.\n\nThe `mapper.weekday` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `offset` Timezone to use\n\n@param `result` Mapper to apply\n\n",signature:"mapper.weekday( timezone:STRING ): result:AGGREGATOR\nmapper.weekday( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.weekday"},"mapper.year":{description:"This mapper function returns the year of the tick for which it is computed.\n\nThe `mapper.year` function can be applied to values of any type.\n\n@param `timezone` Timezone to use\n\n@param `result` Mapper to apply\n\n@param `offset` Time offset in milliseconds, can be used instead of a named timezone.\n\n",signature:"mapper.year( timezone:STRING ): result:AGGREGATOR\nmapper.year( offset:NUMBER ): result:AGGREGATOR",tags:["mapper"],since:"1.0.0",OPB64name:"mapper.year"},"max.tick.sliding.window":{description:"Pushes onto the stack [`MAXLONG`](/doc/MAXLONG) divided by 2, to serve as the maximum number of ticks left or right of the current tick in a [`MAP`](/doc/MAP) sliding window.\n\nGiven that a Geo Time Series™ can have no more than 2**32 datapoints, this value is sufficient to cover the whole GTS left or right of the current tick.\n\n@param `max` Value pushed onto the stack.\n\n",signature:"max.tick.sliding.window(): max:LONG",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.tick.sliding.window"},"max.time.sliding.window":{description:"Pushes onto the stack half of the minimum LONG value, to serve as a *pre* or *post* extension of a [`MAP`](/doc/MAP) sliding window in time units.\n\nThis value spans a lot of time but may not be enough to cover the entirety of a GTS.\n\n@param `max` Value pushed onto the stack.\n\n",signature:"max.time.sliding.window(): max:LONG",tags:["mapper","framework"],since:"1.0.0",OPB64name:"max.time.sliding.window"},ms:{description:"Converts a number of milliseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of milliseconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of milliseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of milliseconds\n\n",signature:"ms( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"ms"},ns:{description:"Converts a number of nanoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of nanoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of nanoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of nanoseconds\n\n",signature:"ns( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"ns"},"op.add":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter Geo Time Series™.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator forbids null values, *i.e.* if a `null` is encountered, then there will be no result for the given tick.\n\n@param `op` The instance of operator.\n\n",signature:"op.add(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.add"},"op.add.ignore-nulls":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), will add the values of the parameter GTS.\n\nThe type of the result is determined by the first value encountered.\n\nIf the result is of type **STRING**, then the operator acts as a concatenation.\n\nWhen the result is numeric, **STRING** values will cause an error, and **BOOLEAN** values will be converted to 1 (`true`) or 0 (`false`).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:"op.add.ignore-nulls(): op:OPERATOR",tags:["op"],since:"1.2.4",OPB64name:"op.add.ignore-nulls"},"op.and":{description:"To apply an `op.and` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.and(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.and"},"op.and.ignore-nulls":{description:"To apply an `op.and.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.and.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.and.ignore-nulls` operation will applies **AND** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:"op.and.ignore-nulls(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.and.ignore-nulls"},"op.div":{description:"To apply an `op.div` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.div is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.div` operation can only operate on equivalence classes which have two GTS (if the equivalence class has more than two GTS, there is no result guaranted). It will divide at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.div(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.div"},"op.eq":{description:"To apply an `op.eq` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then op.eq is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.eq` operation will check for equality at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.eq(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.eq"},"op.ge":{description:"To apply an `op.ge` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ge` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ge` operation will check at each tick if the value of the current GTS is greater or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.ge(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.ge"},"op.gt":{description:"To apply an `op.gt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.gt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.gt` operation will check at each tick if the value of the current GTS is greater than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n\n@param `op` The instance of operator.\n\n",signature:"op.gt(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.gt"},"op.le":{description:"To apply an `op.le` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.le` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.le` operation will check at each tick if the value of the current GTS is lesser or equals to the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.le(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.le"},"op.lt":{description:"To apply an `op.lt` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.lt` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.lt` operation will check at each tick if the value of the current GTS is lesser than the value of the next GTS. In a recursive way, it will run throw all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.lt(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.lt"},"op.mask":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), retains datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The instance of operator.\n\n",signature:"op.mask(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.mask"},"op.mul":{description:"To apply an `op.mul` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\n@param `op` The instance of operator.\n\n",signature:"op.mul(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.mul"},"op.mul.ignore-nulls":{description:"To apply an `op.mul.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.mul.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.mul.ignore-nulls` operation will multiply at each tick all the values of all the GTS belonging to the same class (if they do have a value for this current tick). To produce a result, all GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\nSome types cannot be multiplied (eg it’s not possible to multiply a **STRING** to a **LONG**).\n\nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:"op.mul.ignore-nulls(): op:OPERATOR",tags:["op"],since:"1.2.4",OPB64name:"op.mul.ignore-nulls"},"op.ne":{description:"To apply an `op.ne` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.ne` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.ne` operation will check for inequality at each tick all the values of all the GTS belonging to the same class. If one GTS doesn’t have a value for the current tick the result for this tick is false.\n\nThe elevation and location are cleared.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.ne(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.ne"},"op.negmask":{description:"Pushes onto the stack an operator which, in an [`APPLY`](/doc/APPLY), removes datapoints in Geo Time Series™ for the ticks where a BOOLEAN *mask* Geo Time Series™ has `true` values.\n\nThis operator can only be applied to pairs of GTS.\n\n@param `op` The operator instance.\n\n",signature:"op.negmask(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.negmask"},"op.or":{description:"To apply an `op.or` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.or(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.or"},"op.or.ignore-nulls":{description:"To apply an `op.or.ignore-nulls` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.or.ignore-nulls` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe `op.or.ignore-nulls` operation will applies an **OR** at each tick on values of all the GTS belonging to the same class (in the order they are passed). The elevation and location are cleared. To produce a result, all GTS of a same class must have a value at a same tick.\n\nIf the first value found isn’t a boolean, all values produced will be false.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n      \nThis operator simply ignores null values.\n\n@param `op` The instance of operator.\n\n",signature:"op.or.ignore-nulls(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.or.ignore-nulls"},"op.sub":{description:"To apply an `op.sub` operation, N parameters are on top of the stack: N-1 Geo Time Series™ lists and one labels List. According to those labels, it produces multiple equivalence classes from the GTS inside those N-1 lists (if they match the same labels as the equivalence class). Then `op.sub` is applyied to the GTS in those classes, building only one result GTS for each class.\n\nThe sub operator can only operate on equivalence classes which have **exactly two GTS**. It will substract at each tick the value of the first GTS by the value of the second GTS. To produce a result, both GTS of a same class must have a value at a same tick.\n\nThe type of the resulting GTS will be determined by the first non null value. It only operates on **LONG** and **DOUBLE**.\n\nThe name of the resulting GTS is the one of the last GTS of the equivalence class. The labels kept are the one of the equivalence class.\n\n@param `op` The instance of operator.\n\n",signature:"op.sub(): op:OPERATOR",tags:["op"],since:"1.0.11",OPB64name:"op.sub"},pi:{description:"Alias of [PI](/doc/J3Z).\n\nPushes &#x03c0; constant on the stack (3.1415...).\n\n@param `pi` Pi constant\n\n",signature:"pi(): pi:DOUBLE",tags:["math","constants"],since:"1.0.0",OPB64name:"R5Z"},ps:{description:"Converts a number of picoseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of picoseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of picoseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of picoseconds\n\n",signature:"ps( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"ps"},"reducer.and":{description:"The `reducer.and` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.and(): reducer:AGGREGATOR",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and"},"reducer.and.exclude-nulls":{description:"The `reducer.and.exclude-nulls` function outputs the result of the logical operator **AND** for each tick value of Geo Time Series™ \nwhich are in the same equivalence class, excluding nulls from the computation.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.and.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, \nthe current value is considered to be **false**.\n\nThe standard version of this reducer, `reducer.and`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.and.exclude-nulls`, will exclude all `null` values when computing the **AND**.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.and.exclude-nulls(): reducer:AGGREGATOR",tags:["reducer","logic"],since:"1.0.11",OPB64name:"reducer.and.exclude-nulls"},"reducer.argmax":{description:"The `reducer.argmax` function outputs for each tick, the tick and the concatenation separated by ‘,’ of the values of the labels for which the\nvalue is the maximum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the maximum to report (use 0 to report all), and a **STRING**\nparameter to choose on which label it operates.\n\n@param `maximum` Maximum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.argmax( label:STRING maximum:LONG ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmax"},"reducer.argmin":{description:"The `reducer.argmin` function outputs for each tick, the tick and the concatenation separated by ‘,’ \nwith the values of the labels for which the value is the minimum of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThere is no location and elevation returned.\n\nThis reducer takes an additional **LONG** parameter to choose the minimum to report (use 0 to report all), and a **STRING** \nparameter to choose on which label it operates.\n\n@param `minimum` Minimum to report (use 0 to report all)\n\n@param `label` Operated label\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.argmin( label:STRING minimum:LONG ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.argmin"},"reducer.count":{description:"The `reducer.count` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe include null version, [`reducer.count.include-nulls`](/doc/reducer.count.include-nulls), will include null values when computing the count. The exclude null version, \n[`reducer.count.exclude-nulls`](/doc/reducer.count.exclude-nulls), will exclude null values when computing the count.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.count(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count"},"reducer.count.exclude-nulls":{description:"The `reducer.count.exclude-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.count.exclude-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.exclude-nulls"},"reducer.count.include-nulls":{description:"The `reducer.count.include-nulls` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are included.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.count.include-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.include-nulls"},"reducer.count.nonnull":{description:"The `reducer.count.nonnull` function computes for each tick the number of measures of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nNull values are excluded.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.count.nonnull(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.count.nonnull"},"reducer.join":{description:"The 'reducer.join' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will exclude all null values when computing the join.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"reducer.join( separator:STRING ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join"},"reducer.join.forbid-nulls":{description:"Alias of [`reducer.join.nonnull`](/doc/reducer.join.nonnull).\n\nThe 'reducer.join.forbid-nulls' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"reducer.join.forbid-nulls( separator:STRING ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.forbid-nulls"},"reducer.join.nonnull":{description:"Alias of [`reducer.join.forbid-nulls`](/doc/reducer.join.forbid-nulls).\n\nThe 'reducer.join.nonnull' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"reducer.join.nonnull( separator:STRING ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.nonnull"},"reducer.join.urlencoded":{description:"The 'reducer.join.urlencoded' function outputs for each tick of Geo Time Series™ which are in the same equivalence class, the concatenation of the string representation of values separated by the join string using [URL Encoding](https://en.wikipedia.org/wiki/Percent-encoding) and the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) charset.\n\nThe location and elevation returned are from the latest measure.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `separator` Separator string\n\n",signature:"reducer.join.urlencoded( separator:STRING ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.join.urlencoded"},"reducer.mad":{description:"Pushes onto the stack an AGGREGATOR which computes the [Median Absolute Deviation](https://en.wikipedia.org/wiki/Median_absolute_deviation) for each ticks. Null values are removed before computing the MAD for each ticks.\n\nThe returned location is the median of all the locations and the returned elevation is the median of all the elevations.\n\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.mad(): reducer:AGGREGATOR",tags:["reducer"],since:"1.2.0",OPB64name:"reducer.mad"},"reducer.max":{description:"The `reducer.max` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will exclude all null values when computing the maximum.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.max(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max"},"reducer.max.forbid-nulls":{description:"Alias of [`reducer.max.nonnull`](/doc/reducer.max.nonnull).\n\nThe `reducer.max.forbid-nulls` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.max.forbid-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.forbid-nulls"},"reducer.max.nonnull":{description:"Alias of [`reducer.max.forbid-nulls`](/doc/reducer.max.forbid-nulls).\n\nThe `reducer.max.nonnull` function outputs for each tick the maximum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first maximum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.max.nonnull(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.max.nonnull"},"reducer.mean":{description:"The `reducer.mean` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.mean(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean"},"reducer.mean.circular":{description:"The `reducer.mean.circular` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, no value will be returned. Use [`reducer.mean.circular.exclude-nulls`](/doc/reducer.mean.circular.exclude-nulls) if your GTS contain nulls.\n\nThe `reducer.mean.circular` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"reducer.mean.circular( modulo:NUMBER ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular"},"reducer.mean.circular.exclude-nulls":{description:"The `reducer.mean.circular.exclude-nulls` function returns the the circular mean of all the values for each value of Geo Time Series™.\nThe associated location is the centroid of all the encountered locations. The associated elevation is the mean of the encountered elevations.\n\nThe `reducer.mean.circular.exclude-nulls` function can only be applied to values of type **LONG** or **DOUBLE**, when applied to **STRING** \nor **BOOLEAN** it does not return any value.\n\nIf any tick is undefined, it is excluded from computing.\n\nThe `reducer.mean.circular.exclude-nulls` function expects a positive, finite, numeric period on top of the stack, this period will be \nused to determine the span of circular values, use for example 360.0 if you wish to compute the circular mean of degree angles.\n\n@param `reducer` Reducer to apply\n\n@param `modulo` The span of circular values\n\n",signature:"reducer.mean.circular.exclude-nulls( modulo:NUMBER ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.circular.exclude-nulls"},"reducer.mean.exclude-nulls":{description:"The `reducer.mean.exclude-nulls` function outputs for each tick the mean of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location returned is the centroid of all the locations, the elevation is the average elevation.\n\nIt will exclude all null values when computing the mean.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.mean.exclude-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.mean.exclude-nulls"},"reducer.median":{description:"The `reducer.median` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.median(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.median"},"reducer.median.forbid-nulls":{description:"The `reducer.median.forbid-nulls` function outputs for each tick the median, as defined by the [NIST](https://www.itl.nist.gov/div898/handbook/eda/section3/eda351.htm), of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE** and it always returns a **DOUBLE**.\n\nIf this reducer encouters a **NULL** value, ie ticks do not match between Geo Times Series™ in the same equivalence class, it throws an error.\n\nAs the median is effectively computed using one or two points, the location/elevation of the result is:\n- not defined is there is no location/elevation\n- the value of the location/elevation if only one point has this info\n- the centroid/mean of the location/elevation if the two points have this info.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.median.forbid-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"2.4.0",OPB64name:"reducer.median.forbid-nulls"},"reducer.min":{description:"The `reducer.min` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will exclude all null values when computing the minimum.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.min(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min"},"reducer.min.forbid-nulls":{description:"Alias of [`reducer.min.nonnull`](/doc/reducer.min.nonnull).\n\nThe `reducer.min.forbid-nulls` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.min.forbid-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.forbid-nulls"},"reducer.min.nonnull":{description:"Alias of [`reducer.min.forbid-nulls`](/doc/reducer.min.forbid-nulls).\n\nThe `reducer.min.nonnull` function outputs for each tick the minimum value of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on any type.\n\nThe location and elevation returned are those of the first minimum value encountered.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.min.nonnull(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.min.nonnull"},"reducer.or":{description:"The `reducer.or` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.or(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or"},"reducer.or.exclude-nulls":{description:"The `reducer.or.exclude-nulls` function outputs the result of the logical operator `OR` for each tick value of Geo Time Series™ which are in the same equivalence class.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe `reducer.or.exclude-nulls` function can be applied to values of any type, when not applied to **BOOLEAN** types, the current value is considered to be false.\n\nThe standard version of this reducer, `reducer.or`, will return `null` for any tick where one or more GTS have `null` values. The *exclude null* version, `reducer.or.exclude-nulls`, will exclude all `null` values when computing the **OR**.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.or.exclude-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.or.exclude-nulls"},"reducer.percentile":{description:"Pushes onto the stack an AGGREGATOR which returns the N^th^ percentile of the values for each tick.\n\nFor this reducer, GTS must be aligned and must have a value for each tick of each GTS. \n\nThe returned location and elevation are those of the chosen value.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.percentile(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.percentile"},"reducer.product":{description:"This reducer function computes the product of all the values for each tick.\n\nThe `reducer.product` function can only be applied to values of type **LONG** or **DOUBLE**, it will produce no value for types **STRING** and **BOOLEAN**.\n\nWarning: with **LONG** values, computation can silently overflow.\n\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.product(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.product"},"reducer.rms":{description:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIf one value is null, there won't be any result for the concerned tick.\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.rms(): reducer:AGGREGATOR",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms"},"reducer.rms.exclude-nulls":{description:"The `reducer.rms` function computes for each tick the root mean square of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **DOUBLE** and **LONG**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nThe exclude null version [`reducer.rms.exclude-nulls`](/doc/reducer.rms.exclude-nulls), will exclude null values before computing the rms. Even if input GTS are misaligned, there will be one result per tick.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.rms.exclude-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.2.18",OPB64name:"reducer.rms.exclude-nulls"},"reducer.sd":{description:"The `reducer.sd` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"reducer.sd( bessel:BOOLEAN ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd"},"reducer.sd.forbid-nulls":{description:"The `reducer.sd.forbid-nulls` function outputs for each tick the standard deviation of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"reducer.sd.forbid-nulls( bessel:BOOLEAN ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sd.forbid-nulls"},"reducer.shannonentropy.0":{description:"The `reducer.shannonentropy.0` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 0 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.shannonentropy.0(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.0"},"reducer.shannonentropy.1":{description:"The `reducer.shannonentropy.1` computes the [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29#Entropy_as_information_content) of the values it receives from the framework [`REDUCE`](/doc/REDUCE) at each tick.\n\nThe values are considerred as occurences of an underlying symbol (or as values of a counter).\n\nThe returned entropy is normalized by being divided by log(N) where N is the number of values.\n\nIf N equals 1, then 1 is returned.\n\nThe input values must be of type **LONG**.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.shannonentropy.1(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.shannonentropy.1"},"reducer.sum":{description:"The `reducer.sum` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.sum(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum"},"reducer.sum.forbid-nulls":{description:"Alias of [`reducer.sum.nonnull`](/doc/reducer.sum.nonnull).\n\nThe `reducer.sum.forbid-nulls` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.sum.forbid-nulls(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.forbid-nulls"},"reducer.sum.nonnull":{description:"Alias of [`reducer.sum.forbid-nulls`](/doc/reducer.sum.forbid-nulls).\n\nThe `reducer.sum.nonnull` function computes at each tick the sum of the values of Geo Time Series™ which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first one encountered, which may vary depending on the order of the parameters.\n\nIt will return **null** for any tick where one or more GTS have **null** values.\n\n@param `reducer` Reducer to apply\n\n",signature:"reducer.sum.nonnull(): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.sum.nonnull"},"reducer.var":{description:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"reducer.var( bessel:BOOLEAN ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var"},"reducer.var.forbid-nulls":{description:"The `reducer.var` function outputs for each tick the variance of the values of Geo Time SeriesTM which are in the same equivalence class.\n\nIt operates on **LONG** and **DOUBLE**.\n\nThe location and elevation returned are the first encountered.\n\nThis reducer takes an additional boolean parameter to choose if Bessel correction should be applied.\n\nIt will exclude all null values when computing the result.\n\n@param `reducer` Reducer to apply\n\n@param `bessel` True if apply a [Basel's correction](https://en.wikipedia.org/wiki/Bessel's_correction)\n\n",signature:"reducer.var.forbid-nulls( bessel:BOOLEAN ): reducer:AGGREGATOR",tags:["reducer"],since:"1.0.11",OPB64name:"reducer.var.forbid-nulls"},s:{description:"Converts a number of seconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of seconds from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of seconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of seconds\n\n",signature:"s( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"s"},us:{description:"Converts a number of microseconds (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of microseconds from the top of the stack and pushes back the number of time units corresponding.\n\nIf you ask for a lower unit than the platform configuration, you will get a long rounded to the closest value.\n\n@param `input` Number of microseconds to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of microseconds\n\n",signature:"us( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"us"},w:{description:"Converts a number of weeks (positive or negative) in the platform's time unit.\n\nThe time unit depends on the platform configuration `warp.timeunits` (microseconds by default on a standalone).\n\nIt consumes a number of weeks from the top of the stack and pushes back the number of time units corresponding.\n\n@param `input` Number of weeks to convert in the platform's time unit\n\n@param `output` Number of time units corresponding to the number of weeks\n\n",signature:"w( input:NUMBER ): output:LONG",tags:["date"],since:"1.0.0",OPB64name:"w"},"{":{description:"Starts a map creation.\n\nThe `{` function creates a map by pushing a mark onto the stack. This is a syntactic help to better present map constructions. This function behaves like [`MARK`].\n\n@param `mark` A MARK object.\n\n",signature:"{(): mark:MARK",tags:["maps"],since:"1.0.0",OPB64name:"Tk"},"{}":{description:"The {} function creates an empty MAP on the top of the stack.\n\n\n@param `newmap` Empty map instance.\n\n",signature:"{}(): newmap:MAP",tags:["maps"],since:"1.0.0",OPB64name:"Tro"},"|":{description:"Performs a bitwise **OR** operation.\n\nThe `|` operator consumes two **LONG** from the top of the stack and pushes back their bitwise **OR**.\n \nSince Warp 10™ 2.1, `|` can be applied on two long GTS, or on one long GTS and a long mask.\n\n@param `p1` The first parameter\n\n@param `p2` The second parameter\n\n@param `result` The bitwise **XOR** result\n\n@param `inputgts` Since 2.1, a GTS with long values\n\n@param `gts1` Since 2.1, a GTS with long values\n\n@param `gts2` Since 2.1, a GTS with long values\n\n@param `mask` Since 2.1, a long which will be OR to every value of inputgts\n\n@param `outputgts` Since 2.1, a new sorted GTS with OR between each input values. Values are presents only for common input ticks.\n\n@param `maskedgts` Since 2.1, a new sorted GTS where values are inputs from inputgts OR with mask\n\n",signature:"|( p1:LONG p2:LONG ): result:LONG\n|( inputgts:GTS mask:LONG ): maskedgts:GTS\n|( gts1:GTS gts2:GTS ): outputgts:GTS",tags:["binary","operators"],since:"1.0.0",OPB64name:"U."},"||":{description:"The `||` operator is a synonymous for [`OR`](/doc/OR).\n\nIt performs a logical **OR** on its parameters. When applied to a list of parameters, the parameter scan stops at the first `true` value encountered.\n\nSince Warp 10™ 2.1, `||` can be applied on two boolean GTS to produce a new GTS.\n\n@param `p1` The first boolean\n\n@param `p2` The second boolean\n\n@param `l` The list containing BOOLEANs or MACROs returning BOOLEANs\n\n@param `result` The boolean result of the logical OR applied to the parameters\n\n@param `gts1` Since 2.1, a boolean GTS input\n\n@param `gts2` Since 2.1, a boolean GTS input\n\n@param `gtsresult` Since 2.1, a new sorted GTS with OR between each common tick input values.\n\n",signature:"||( p1:BOOLEAN p2:BOOLEAN ): result:BOOLEAN\n||( l:LIST ): result:BOOLEAN\n||( gts1:GTS gts2:GTS ): gtsresult:GTS",tags:["operators","logic"],since:"1.0.0",OPB64name:"U6k"},"}":{description:"Closes a currently open map and pushes it onto the stack.\n\nThe `}` function pops from the stack the elements (key/value pairs) of the map up to the first mark. The marks are consumed.\n\n@param `k1` The first key\n\n@param `v1` The first value\n\n@param `kN` The Nth key\n\n@param `vN` The Nth value\n\n@param `map` The built map\n\n@param `mark` The mark indicating the deepest level to consider when building the map\n\n",signature:"}( mark:MARK k1:ANY v1:ANY kN:ANY vN:ANY ): map:MAP",tags:["maps"],since:"1.0.0",OPB64name:"UF"},"~":{description:"Computes the unary bitwise complement of the long value on top of the stack.\n\n@param `param` Value to compute\n\n@param `result` Bitwise result\n\n",signature:"~( param:LONG ): result:LONG",tags:["operators","binary","math"],since:"1.0.0",OPB64name:"UV"},"~=":{description:"The `~=` operator consumes three parameters from the top of the stack, two operands p1 and p2 and a tolerance factor lambda, \nand pushes onto the stack true if *|p1-p2| < lambda*, i.e. the difference between the two operands is lesser than lambda.\n\nThe two parameters must be of numeric types.\n\nThe operator `~=` is useful when making comparaisons between doubles, where floating point operations generate rounding errors.\n\n@param `p1` First number\n\n@param `p2` Second number\n\n@param `lambda` Tolerance factor lambda\n\n@param `result` \n\n",signature:"~=( p2:DOUBLE p1:DOUBLE lambda:DOUBLE ): result:BOOLEAN\n~=( p2:DOUBLE p1:LONG lambda:DOUBLE ): result:BOOLEAN\n~=( p2:LONG p1:DOUBLE lambda:DOUBLE ): result:BOOLEAN\n~=( p2:DOUBLE p1:COUNTER lambda:DOUBLE ): result:BOOLEAN\n~=( p2:COUNTER p1:DOUBLE lambda:DOUBLE ): result:BOOLEAN\n~=( p2:DOUBLE p1:DOUBLE lambda:LONG ): result:BOOLEAN\n~=( p2:DOUBLE p1:LONG lambda:LONG ): result:BOOLEAN\n~=( p2:LONG p1:DOUBLE lambda:LONG ): result:BOOLEAN\n~=( p2:DOUBLE p1:COUNTER lambda:LONG ): result:BOOLEAN\n~=( p2:COUNTER p1:DOUBLE lambda:LONG ): result:BOOLEAN\n~=( p2:DOUBLE p1:DOUBLE lambda:COUNTER ): result:BOOLEAN\n~=( p2:DOUBLE p1:LONG lambda:COUNTER ): result:BOOLEAN\n~=( p2:LONG p1:DOUBLE lambda:COUNTER ): result:BOOLEAN\n~=( p2:DOUBLE p1:COUNTER lambda:COUNTER ): result:BOOLEAN\n~=( p2:COUNTER p1:DOUBLE lambda:COUNTER ): result:BOOLEAN",tags:["math","operators"],since:"1.0.0",OPB64name:"UYo"}},x=function(e){function t(){return e.call(this,v.FLOWS_LANGUAGE)||this}return T(t,e),t.prototype.provideHover=function(t,n,a){return e.prototype._provideHover.call(this,t,n,a,M)},t}(k),H=t.languages.IndentAction,F=function(){function e(){}return e.prototype.getConfiguration=function(){return{wordPattern:/[^\s\t\(]+/,comments:{lineComment:"//",blockComment:["/**","*/"]},brackets:[["{","}"],["[","]"],["(",")"],["<'","'>"],["[[","]]"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"[[",close:"]]"},{open:" '",close:"'",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string"]},{open:"`",close:"`",notIn:["string","comment"]},{open:"/**",close:" */",notIn:["string"]}],autoCloseBefore:";:.,=}])> \n\t",surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"[[",close:"]]"},{open:"'",close:"'"},{open:'"',close:'"'},{open:"`",close:"`"}],indentationRules:{increaseIndentPattern:/^\s*(\[|{|\(|\[\[)\b.*$/,decreaseIndentPattern:/^\s*(]|}|\)|]]|'>)\b.*$/},onEnterRules:[{beforeText:/^\s*\/\*\*(?!\/)([^*]|\*(?!\/))*$/,afterText:/^\s*\*\/$/,action:{indentAction:H.IndentOutdent,appendText:" * "}},{beforeText:/^\s*\/\*\*(?!\/)([^*]|\*(?!\/))*$/,action:{indentAction:H.None,appendText:" * "}},{beforeText:/^(\t|( {2}))* \*( ([^*]|\*(?!\/))*)?$/,action:{indentAction:H.None,appendText:"* "}},{beforeText:/^(\t|( {2}))* \*\/\s*$/,action:{indentAction:H.None,removeText:1}}]}},e}(),W=function(){};W.rules={keywords:["!","!=","%","&","&&","(","()",")","*","**","+","+!","-","->B64","->B64URL","->BIN","->BYTES","->DOUBLEBITS","->ENCODER","->ENCODERS","->FLOATBITS","->GEOCELL","->GEOHASH","->GEOJSON","->GEOSHAPE","->GTS","->GTSHHCODE","->GTSHHCODELONG","->HEX","->HHCODE","->HHCODELONG","->JSON","->LIST","->LONGBYTES","->MAP","->MAT","->MVSTRING","->OPB64","->PICKLE","->Q","->SET","->TSELEMENTS","->V","->VARINT","->VEC","->WKB","->WKT","->Z","/","<","<<","<=","==",">",">=",">>",">>>","ABS","ACCEL.CACHE","ACCEL.NOCACHE","ACCEL.NOPERSIST","ACCEL.PERSIST","ACCEL.REPORT","ACOS","ADDDAYS","ADDDURATION","ADDEXACT","ADDMONTHS","ADDVALUE","ADDYEARS","AESUNWRAP","AESWRAP","AGO","AND","APPEND","APPLY","ASENCODERS","ASIN","ASREGS","ASSERT","ASSERTMSG","ATAN","ATAN2","ATBUCKET","ATINDEX","ATTICK","ATTRIBUTES","AUTHENTICATE","B64->","B64TOHEX","B64URL->","BBOX","BIN->","BINTOHEX","BITCOUNT","BITGET","BITSTOBYTES","BOOTSTRAP","BREAK","BUCKETCOUNT","BUCKETIZE","BUCKETIZE.CALENDAR","BUCKETSPAN","BYTES->","BYTESTOBITS","CALL","CBRT","CEIL","CEVAL","CHECKMACRO","CHECKSHAPE","CHRONOEND","CHRONOSTART","CHRONOSTATS","CHUNK","CHUNKENCODER","CLEAR","CLEARDEFS","CLEARREGS","CLEARSYMBOLS","CLEARTOMARK","CLIP","CLONE","CLONEEMPTY","CLONEREVERSE","COMMONTICKS","COMPACT","CONTAINS","CONTAINSKEY","CONTAINSVALUE","CONTINUE","COPYGEO","COPYSIGN","CORRELATE","COS","COSH","COUNTER","COUNTERDELTA","COUNTERSET","COUNTERVALUE","COUNTTOMARK","CPOPR","CPROB","CROP","CSTORE","DEBUGOFF","DEBUGON","DECREMENTEXACT","DEDUP","DEF","DEFINED","DEFINEDMACRO","DEFLATE","DELETE","DELETEOFF","DELETEON","DEPTH","DEREF","DET","DIFFERENCE","DISCORDS","DOC","DOCMODE","DOUBLEBITS->","DOUBLEEXPONENTIALSMOOTHING","DROP","DROPN","DTW","DUP","DUPN","DURATION","DWTSPLIT","E","ECGEN","ECHOOFF","ECHOON","ECPRIVATE","ECPUBLIC","ECSIGN","ECVERIFY","ELAPSED","ELEVATIONS","EMPTY","ENCODER->","ERROR","ESDTEST","EVALSECURE","EVERY","EXP","EXPM1","EXPORT","EXTLOADED","F","FDWT","FETCH","FETCHBOOLEAN","FETCHDOUBLE","FETCHLONG","FETCHSTRING","FFT","FFTAP","FFTWINDOW","FILL","FILLNEXT","FILLPREVIOUS","FILLTICKS","FILLVALUE","FILTER","FILTERBY","FIND","FINDSETS","FINDSTATS","FIRSTTICK","FLATTEN","FLOATBITS->","FLOOR","FLOORDIV","FLOORMOD","FORGET","FROMBIN","FROMBITS","FROMHEX","FUNCTIONS","FUSE","GEO.BUFFER","GEO.COVER","GEO.COVER.RL","GEO.DIFFERENCE","GEO.INTERSECTION","GEO.INTERSECTS","GEO.JSON","GEO.JSON.UNIFORM","GEO.NORMALIZE","GEO.OPTIMIZE","GEO.REGEXP","GEO.UNION","GEO.WITHIN","GEO.WKB","GEO.WKB.UNIFORM","GEO.WKT","GEO.WKT.UNIFORM","GEOCELL->","GEOHASH->","GEOPACK","GEOSHAPE->","GEOSHIFT","GEOSPLIT","GEOUNPACK","GET","GETEXPONENT","GETHOOK","GETSECTION","GOLDWRAP","GROUPBY","GRUBBSTEST","GTSHHCODE->","GZIP","HASH","HAVERSINE","HEADER","HEX->","HEXTOB64","HEXTOBIN","HHCODE->","HHCODE.BBOX","HHCODE.CENTER","HHCODE.EAST","HHCODE.NORTH","HHCODE.NORTH.EAST","HHCODE.NORTH.WEST","HHCODE.SOUTH","HHCODE.SOUTH.EAST","HHCODE.SOUTH.WEST","HHCODE.WEST","HIDE","HLOCATE","HULLSHAPE","HUMANDURATION","HYBRIDTEST","HYBRIDTEST2","HYPOT","IDENT","IDWT","IEEEREMAINDER","IFFT","IMMUTABLE","IMPORT","INCREMENTEXACT","INFLATE","INFO","INFOMODE","INTEGRATE","INTERPOLATE","INTERSECTION","INV","ISAUTHENTICATED","ISNULL","ISNaN","ISO8601","ISODURATION","ISONORMALIZE","JOIN","JSON->","JSONLOOSE","JSONSTACK","JSONSTRICT","KEYLIST","KURTOSIS","LABELS","LASTACTIVITY","LASTBUCKET","LASTSORT","LASTTICK","LBOUNDS","LFLATMAP","LIMIT","LINEOFF","LINEON","LIST->","LMAP","LOAD","LOCATIONOFFSET","LOCATIONS","LOCSTRINGS","LOG","LOG10","LOG1P","LOGEVENT->","LOGMSG","LOWESS","LR","LSORT","LTTB","MACROBUCKETIZER","MACROCONFIG","MACROCONFIGDEFAULT","MACROCONFIGSECRET","MACROFILLER","MACROTTL","MAKEGTS","MAN","MAP","MAP->","MAPID","MARK","MAT->","MATCH","MATCHER","MAX","MAXBUCKETS","MAXDEPTH","MAXGEOCELLS","MAXGTS","MAXJSON","MAXLONG","MAXLOOP","MAXOPS","MAXPIXELS","MAXRECURSION","MAXSYMBOLS","MAXURLFETCHCOUNT","MAXURLFETCHSIZE","MD5","MERGE","META","METADIFF","METAOFF","METAON","METASET","METASORT","MIN","MINLONG","MINREV","MMAP","MODE","MONOTONIC","MOTIONSPLIT","MSORT","MSTU","MULTIPLYEXACT","MUSIGMA","MUTEX","MVELEVATIONS","MVHHCODES","MVINDEXSPLIT","MVLOCATIONS","MVTICKS","MVTICKSPLIT","MVVALUES","NAME","NBOUNDS","NDEBUGON","NEGATEEXACT","NEWENCODER","NEWGTS","NEXTAFTER","NEXTDOWN","NEXTUP","NOLOG","NONEMPTY","NONNULL","NOOP","NORMALIZE","NOT","NOTAFTER","NOTBEFORE","NOTIMINGS","NOW","NPDF","NPEEK","NSUMSUMSQ","ONLYBUCKETS","OPB64->","OPB64TOHEX","OPS","OPTDTW","OPTIMIZE","OR","PACK","PAPPLY","PARSE","PARSESELECTOR","PARSEVALUE","PARTITION","PATTERNDETECTION","PATTERNS","PEEK","PEEKN","PERMUTE","PFILTER","PGraphics","PI","PICK","PICKLE->","PIGSCHEMA","PIVOT","PIVOTSTRICT","POPR","PREDUCE","PRNG","PROB","PROBABILITY","PSTACK","PUSHR","PUT","Palpha","Parc","Pbackground","PbeginContour","PbeginShape","Pbezier","PbezierDetail","PbezierPoint","PbezierTangent","PbezierVertex","Pblend","PblendMode","Pblue","Pbox","Pbrightness","Pclear","Pclip","Pcolor","PcolorMode","Pconstrain","Pcopy","PcreateFont","Pcurve","PcurveDetail","PcurvePoint","PcurveTangent","PcurveTightness","PcurveVertex","Pdecode","Pdist","Pellipse","PellipseMode","Pencode","PendContour","PendShape","Pfill","Pfilter","Pget","Pgreen","Phue","Pimage","PimageMode","Plerp","PlerpColor","Pline","PloadShape","Pmag","Pmap","Pmask","PnoClip","PnoFill","PnoStroke","PnoTint","Pnorm","Ppixels","Ppoint","PpopMatrix","PpopStyle","PpushMatrix","PpushStyle","Pquad","PquadraticVertex","Prect","PrectMode","Pred","PresetMatrix","Protate","Psaturation","Pscale","Pset","Pshape","PshapeMode","PshearX","PshearY","Psize","Psphere","PsphereDetail","Pstroke","PstrokeCap","PstrokeJoin","PstrokeWeight","Ptext","PtextAlign","PtextAscent","PtextDescent","PtextFont","PtextLeading","PtextMode","PtextSize","PtextWidth","Ptint","PtoImage","Ptranslate","Ptriangle","PupdatePixels","Pvertex","Q->","QCONJUGATE","QDIVIDE","QMULTIPLY","QROTATE","QROTATION","QUANTIZE","RAND","RANDOM","RANDPDF","RANGE","RANGECOMPACT","RAWDTW","REDEFS","REDUCE","RELABEL","REMOVE","REMOVETICK","RENAME","REOPTALT","REPLACE","REPLACEALL","REPORT","RESET","RESETS","RESHAPE","RESTORE","REV","REVBITS","REVERSE","REXEC","REXECZ","RINT","RLOWESS","ROLL","ROLLD","ROT","ROTATIONQ","ROUND","RSADECRYPT","RSAENCRYPT","RSAGEN","RSAPRIVATE","RSAPUBLIC","RSASIGN","RSAVERIFY","RSORT","RTFM","RUN","RUNNERNONCE","RUNR","RVALUESORT","SAVE","SCALB","SECTION","SECURE","SECUREKEY","SENSISION.DUMP","SENSISION.DUMPEVENTS","SENSISION.EVENT","SENSISION.GET","SENSISION.SET","SENSISION.UPDATE","SET","SET->","SETATTRIBUTES","SETMACROCONFIG","SETVALUE","SHA1","SHA1HMAC","SHA256","SHA256HMAC","SHAPE","SHMLOAD","SHMSTORE","SHOW","SHRINK","SHUFFLE","SIGNUM","SIN","SINGLEEXPONENTIALSMOOTHING","SINH","SIZE","SKEWNESS","SMARTPARSE","SNAPSHOT","SNAPSHOTALL","SNAPSHOTALLTOMARK","SNAPSHOTCOPY","SNAPSHOTCOPYALL","SNAPSHOTCOPYALLTOMARK","SNAPSHOTCOPYN","SNAPSHOTCOPYTOMARK","SNAPSHOTN","SNAPSHOTTOMARK","SORT","SORTBY","SORTWITH","SPLIT","SQRT","SRAND","SRANDPDF","STACKATTRIBUTE","STACKPSSECRET","STACKTOLIST","STANDARDIZE","STDERR","STDOUT","STL","STLESDTEST","STOP","STORE","STRICTPARTITION","STRINGFORMAT","STU","SUBLIST","SUBMAP","SUBSTRING","SUBTRACTEXACT","SWAP","SYMBOLS","SYNC","T","TAN","TANH","TDESCRIBE","TEMPLATE","THRESHOLDTEST","TICKINDEX","TICKLIST","TICKS","TIMEBOX","TIMECLIP","TIMED","TIMEMODULO","TIMEOFF","TIMEON","TIMESCALE","TIMESHIFT","TIMESPLIT","TIMINGS","TLTTB","TOBIN","TOBITS","TOBOOLEAN","TODEGREES","TODOUBLE","TOHEX","TOINTEXACT","TOKENDUMP","TOKENGEN","TOKENINFO","TOKENSECRET","TOLONG","TOLOWER","TORADIANS","TOSELECTOR","TOSTRING","TOTIMESTAMP","TOUPPER","TR","TRANSPOSE","TRIM","TSELEMENTS","TSELEMENTS->","TYPEOF","ULP","UNBUCKETIZE","UNBUCKETIZE.CALENDAR","UNGZIP","UNION","UNIQUE","UNLIST","UNMAP","UNPACK","UNSECURE","UNSET","UNWRAP","UNWRAPEMPTY","UNWRAPENCODER","UNWRAPSIZE","UPDATE","UPDATEOFF","UPDATEON","URLDECODE","URLENCODE","URLFETCH","UUID","V->","VALUEDEDUP","VALUEHISTOGRAM","VALUELIST","VALUES","VALUESORT","VALUESPLIT","VARINT->","VARS","VEC->","WEBCALL","WF.ADDREPO","WF.GETREPOS","WF.SETREPOS","WFOFF","WFON","WRAP","WRAPFAST","WRAPMV","WRAPMV!","WRAPOPT","WRAPRAW","WRAPRAWOPT","WSINFO","WSKILL","WSKILLSESSION","WSNAME","WSPS","WSSESSION","WSSTACK","WSSTOP","WSSTOPSESSION","Z->","ZDISCORDS","ZDTW","ZIP","ZPATTERNDETECTION","ZPATTERNS","ZSCORE","ZSCORETEST","[","[[","[[]]","[]","]","]]","^","bucketizer.and","bucketizer.or","d","e","filler.interpolate","filler.next","filler.previous","filler.trend","filter.latencies","h","m","mapper.and","mapper.finite","mapper.geo.approximate","mapper.geo.clear","mapper.geo.fence","mapper.geo.outside","mapper.geo.within","mapper.hdist","mapper.median","mapper.median.forbid-nulls","mapper.mod","mapper.npdf","mapper.or","mapper.percentile","mapper.truecourse","max.tick.sliding.window","max.time.sliding.window","ms","ns","op.add","op.add.ignore-nulls","op.and","op.and.ignore-nulls","op.div","op.eq","op.ge","op.gt","op.le","op.lt","op.mask","op.mul","op.mul.ignore-nulls","op.ne","op.negmask","op.or","op.or.ignore-nulls","op.sub","pi","ps","reducer.and","reducer.and.exclude-nulls","s","us","w","{","{}","|","||","}","~","~="],constants:["E","F","MAXLONG","MINLONG","NULL","NaN","PI","T","e","pi"],functions:["BUCKETIZE","BUCKETIZE.CALENDAR","FILTER","MACROBUCKETIZER","MACROFILTER","MACROMAPPER","MACROREDUCER","MAP","PFILTER","PREDUCE","REDUCE","STRICTMAPPER","STRICTREDUCER","UNBUCKETIZE.CALENDAR","bucketizer.and","bucketizer.count","bucketizer.count.exclude-nulls","bucketizer.count.include-nulls","bucketizer.count.nonnull","bucketizer.first","bucketizer.join","bucketizer.join.forbid-nulls","bucketizer.last","bucketizer.mad","bucketizer.max","bucketizer.max.forbid-nulls","bucketizer.mean","bucketizer.mean.circular","bucketizer.mean.circular.exclude-nulls","bucketizer.mean.exclude-nulls","bucketizer.median","bucketizer.median.forbid-nulls","bucketizer.min","bucketizer.min.forbid-nulls","bucketizer.or","bucketizer.percentile","bucketizer.rms","bucketizer.sd","bucketizer.sd.forbid-nulls","bucketizer.sum","bucketizer.sum.forbid-nulls","filter.all.eq","filter.all.ge","filter.all.gt","filter.all.le","filter.all.lt","filter.all.ne","filter.any.eq","filter.any.ge","filter.any.gt","filter.any.le","filter.any.lt","filter.any.ne","filter.byattr","filter.byclass","filter.bylabels","filter.bylabelsattr","filter.bymetadata","filter.byselector","filter.bysize","filter.last.eq","filter.last.ge","filter.last.gt","filter.last.le","filter.last.lt","filter.last.ne","filter.latencies","mapper.abs","mapper.add","mapper.and","mapper.ceil","mapper.count","mapper.count.exclude-nulls","mapper.count.include-nulls","mapper.count.nonnull","mapper.day","mapper.delta","mapper.dotproduct","mapper.dotproduct.positive","mapper.dotproduct.sigmoid","mapper.dotproduct.tanh","mapper.eq","mapper.eq.elev","mapper.eq.hhcode","mapper.eq.lat","mapper.eq.lon","mapper.eq.tick","mapper.exp","mapper.finite","mapper.first","mapper.floor","mapper.ge","mapper.ge.elev","mapper.ge.hhcode","mapper.ge.lat","mapper.ge.lon","mapper.ge.tick","mapper.geo.approximate","mapper.geo.clear","mapper.geo.fence","mapper.geo.outside","mapper.geo.within","mapper.gt","mapper.gt.elev","mapper.gt.hhcode","mapper.gt.lat","mapper.gt.lon","mapper.gt.tick","mapper.hdist","mapper.highest","mapper.hour","mapper.hspeed","mapper.join","mapper.join.forbid-nulls","mapper.kernel.cosine","mapper.kernel.epanechnikov","mapper.kernel.gaussian","mapper.kernel.logistic","mapper.kernel.quartic","mapper.kernel.silverman","mapper.kernel.triangular","mapper.kernel.tricube","mapper.kernel.triweight","mapper.kernel.uniform","mapper.last","mapper.le","mapper.le.elev","mapper.le.hhcode","mapper.le.lat","mapper.le.lon","mapper.le.tick","mapper.log","mapper.lowest","mapper.lt","mapper.lt.elev","mapper.lt.hhcode","mapper.lt.lat","mapper.lt.lon","mapper.lt.tick","mapper.mad","mapper.max","mapper.max.forbid-nulls","mapper.max.x","mapper.mean","mapper.mean.circular","mapper.mean.circular.exclude-nulls","mapper.mean.exclude-nulls","mapper.median","mapper.median.forbid-nulls","mapper.min","mapper.min.forbid-nulls","mapper.min.x","mapper.minute","mapper.mod","mapper.month","mapper.mul","mapper.ne","mapper.ne.elev","mapper.ne.hhcode","mapper.ne.lat","mapper.ne.lon","mapper.ne.tick","mapper.npdf","mapper.or","mapper.parsedouble","mapper.percentile","mapper.pow","mapper.product","mapper.rate","mapper.replace","mapper.rms","mapper.round","mapper.sd","mapper.sd.forbid-nulls","mapper.second","mapper.sigmoid","mapper.sqrt","mapper.sum","mapper.sum.forbid-nulls","mapper.tanh","mapper.tick","mapper.toboolean","mapper.todouble","mapper.tolong","mapper.tostring","mapper.truecourse","mapper.var","mapper.var.forbid-nulls","mapper.vdist","mapper.vspeed","mapper.weekday","mapper.year","max.tick.sliding.window","max.time.sliding.window","reducer.and","reducer.and.exclude-nulls","reducer.argmax","reducer.argmin","reducer.count","reducer.count.exclude-nulls","reducer.count.include-nulls","reducer.count.nonnull","reducer.join","reducer.join.forbid-nulls","reducer.join.nonnull","reducer.join.urlencoded","reducer.mad","reducer.max","reducer.max.forbid-nulls","reducer.max.nonnull","reducer.mean","reducer.mean.circular","reducer.mean.circular.exclude-nulls","reducer.mean.exclude-nulls","reducer.median","reducer.median.forbid-nulls","reducer.min","reducer.min.forbid-nulls","reducer.min.nonnull","reducer.or","reducer.or.exclude-nulls","reducer.percentile","reducer.product","reducer.rms","reducer.rms.exclude-nulls","reducer.sd","reducer.sd.forbid-nulls","reducer.shannonentropy.0","reducer.shannonentropy.1","reducer.sum","reducer.sum.forbid-nulls","reducer.sum.nonnull","reducer.var","reducer.var.forbid-nulls"],control:["BREAK","CHECKMACRO","CONTINUE","CUDF","DEFINED","DEFINEDMACRO","EVAL","FAIL","FOR","FOREACH","FORSTEP","IFT","IFTE","MSGFAIL","NRETURN","RETHROW","RETURN","SWITCH","TRY","UDF","UNTIL","WHILE"],operators:["!","!=","%","&","&&","*","**","+","+!","-","/","<","<<","<=","==",">",">=",">>",">>>","AND","NOT","OR","^","|","||","~","~="],escapes:"\\\\(?:[abfnrtv\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})",tokenizer:{root:[["\\@[A-Za-z0-9._\\/]+","variable"],["\\$[A-Za-z0-9._\\/]+","variable"],["true|false","number"],["[A-Za-z_][.\\w$]*",{cases:{"@constants":"regexp","@keywords":"keyword","@functions":"type","@control":"metatag","@default":"identifier"}}],["[{}()[\\]]","@brackets"],["\\d*\\.\\d+([eE][-+]?\\d+)?[fFdD]?","number.float"],["0[xX][0-9a-fA-F_]*[0-9a-fA-F][Ll]?","number.hex"],["0[0-7_]*[0-7][Ll]?","number.octal"],["0[bB][0-1_]*[0-1][Ll]?","number.binary"],["\\d+[lL]?","number"],{include:"@whitespace"},['"([^"\\\\]|\\\\.)*$',"string.invalid"],['"',"string","@string"],["'([^'\\\\]|\\\\.)*$","string.invalid"],["'","string","@string2"],["<'","string","@string3"]],whitespace:[["[ \\t\\r\\n]+","white"],["\\/\\*","comment","@comment"],["\\/\\/.*$","comment"]],comment:[["[^\\/*]+","comment"],["\\/\\*","comment.invalid"],["\\*/","comment","@pop"],["[\\/*]","comment"]],string:[['[^\\"]+',"string"],["@escapes","string.escape"],["\\.","string.escape.invalid"],['"',"string","@pop"]],string2:[["[^\\']+","string"],["@escapes","string.escape"],["\\.","string.escape.invalid"],["'","string","@pop"]],string3:[["[^\\(<')]+","string"],["'>","string","@pop"]]}};var z=t.languages.registerCompletionItemProvider,Y=t.languages.setMonarchTokensProvider,_=t.languages.getLanguages,K=t.languages.register,V=t.languages.setLanguageConfiguration,q=t.languages.registerHoverProvider,X=function(){function e(){}return e.register=function(){_().find((function(e){return e.id===v.WARPSCRIPT_LANGUAGE}))||(K({id:v.WARPSCRIPT_LANGUAGE}),V(v.WARPSCRIPT_LANGUAGE,(new y).getConfiguration()),Y(v.WARPSCRIPT_LANGUAGE,I.rules),z(v.WARPSCRIPT_LANGUAGE,new R),q(v.WARPSCRIPT_LANGUAGE,new B)),_().find((function(e){return e.id===v.FLOWS_LANGUAGE}))||(K({id:v.FLOWS_LANGUAGE}),V(v.FLOWS_LANGUAGE,(new F).getConfiguration()),Y(v.FLOWS_LANGUAGE,W.rules),z(v.FLOWS_LANGUAGE,new U),q(v.FLOWS_LANGUAGE,new x))},e}(),j=t.editor.create,Z=function(){function e(t,a){this.el=t,this.http=a,this.url="",this.lang="warpscript",this._showExecute=!0,this.warpViewEditorStatusEvent=new n.EventEmitter,this.warpViewEditorErrorEvent=new n.EventEmitter,this.warpViewEditorWarpscriptChanged=new n.EventEmitter,this.warpViewEditorWarpscriptResult=new n.EventEmitter,this.warpViewEditorLoaded=new n.EventEmitter,this.warpViewEditorSize=new n.EventEmitter,this.warpViewEditorBreakPoint=new n.EventEmitter,this.warpViewEditorCtrlClick=new n.EventEmitter,this.warpViewEditorDatavizRequested=new n.EventEmitter,this.loading=!1,this.selectedResultTab=-1,this.headers=this.getItems(),this.innerConfig=new m,this._theme="light",this._debug=!1,this._displayMessages=!0,this._showDataviz=!1,this._showResult=!0,this._imageTab=!1,this.monacoTheme="vs",this.breakpoints={},this.decoration=[],this.previousParentHeight=-1,this.previousParentWidth=-1,this.LOG=new E(e,this._debug)}return Object.defineProperty(e.prototype,"debug",{get:function(){return this._debug},set:function(e){"string"==typeof e&&(e="true"===e),this._debug=e,this.LOG.setDebug(e)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"theme",{get:function(){return this._theme},set:function(e){this.LOG.debug(["themeHandler"],"The new value of theme is: ",e),this.monacoTheme="dark"===e?"vs-dark":"vs",this.LOG.debug(["themeHandler"],"The new value of theme is: ",this.monacoTheme),this._theme=e,t.editor&&t.editor.setTheme(this.monacoTheme)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"warpscript",{get:function(){return this._warpscript},set:function(e){this.LOG.debug(["warpscriptHandler"],"The new value of warpscript is: ",e),this.ed&&this.ed.setValue(e),this._warpscript=e,this.loading=!1},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"showDataviz",{get:function(){return this._showDataviz},set:function(e){this._showDataviz=""+e!="false"},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"showExecute",{get:function(){return this._showExecute},set:function(e){this._showExecute=""+e!="false"},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"showResult",{get:function(){return this._showResult},set:function(e){this._showResult=""+e!="false"},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"config",{get:function(){return this.innerConfig},set:function(e){var t="string"==typeof e?JSON.parse(e||"{}"):e||{};this.innerConfig=h.mergeDeep(this.innerConfig,t),this.LOG.debug(["config"],this.innerConfig,t),this.ed&&(this.LOG.debug(["config"],this.innerConfig),this.ed.updateOptions(this.setOptions()))},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"displayMessages",{get:function(){return this._displayMessages},set:function(e){this._displayMessages=""+e!="false"},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"widthPx",{get:function(){return this._widthPx},set:function(e){this._widthPx=parseInt(""+e,10)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"heightLine",{get:function(){return this._heightLine},set:function(e){this._heightLine=parseInt(""+e,10)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"heightPx",{get:function(){return this._heightPx},set:function(e){this._heightPx=parseInt(""+e,10)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"imageTab",{get:function(){return this._imageTab},set:function(e){this._imageTab=""+e!="false"},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"initialSize",{get:function(){return this._initialSize},set:function(e){this._initialSize="string"==typeof e?JSON.parse(e):e},enumerable:!1,configurable:!0}),e.prototype.ngOnInit=function(){this.LOG.debug(["ngOnInit"],"innerConfig: ",this.innerConfig),"dark"===this._theme&&(this.monacoTheme="vs-dark"),this.LOG.debug(["ngOnInit"],"ngOnInit theme is: ",this._theme),self.MonacoEnvironment={getWorkerUrl:function(){return URL.createObjectURL(new Blob(["\n\tself.MonacoEnvironment = {\n\t\tbaseUrl: 'https://unpkg.com/monaco-editor@0.18.1/min/'\n\t};\n\timportScripts('https://unpkg.com/monaco-editor@0.18.1/min/vs/base/worker/workerMain.js');\n"],{type:"text/javascript"}))}},X.register()},e.prototype.resizeWatcher=function(){var t=this.editor.nativeElement.parentElement.clientWidth,n=this.editor.nativeElement.parentElement.clientHeight-parseInt(window.getComputedStyle(this.editor.nativeElement.parentElement).getPropertyValue("padding-top"),10)-parseInt(window.getComputedStyle(this.editor.nativeElement.parentElement).getPropertyValue("padding-bottom"),10),a=this.el.nativeElement.parentElement.clientHeight-parseInt(window.getComputedStyle(this.el.nativeElement.parentElement).getPropertyValue("padding-top"),10)-parseInt(window.getComputedStyle(this.el.nativeElement.parentElement).getPropertyValue("padding-bottom"),10);if(a=Math.max(a,e.MIN_HEIGHT),Math.abs(this.wrapper.nativeElement.clientHeight-a)>30&&(this.wrapper.nativeElement.style.height=a+"px"),n!==this.previousParentHeight||t!==this.previousParentWidth){this.previousParentHeight=n,this.previousParentWidth=t;var i=Math.floor(n)-(this.buttons?this.buttons.nativeElement.clientHeight:0),o=Math.floor(this.editor.nativeElement.parentElement.clientWidth);this.ed.layout({height:i,width:o}),this.editor.nativeElement.style.overflow="hidden"}},e.prototype.setOptions=function(){return{quickSuggestionsDelay:this.innerConfig.editor.quickSuggestionsDelay,quickSuggestions:this.innerConfig.editor.quickSuggestions,suggestOnTriggerCharacters:this.innerConfig.editor.quickSuggestions,automaticLayout:!!this._heightPx,hover:{enabled:this.innerConfig.hover},readOnly:this.innerConfig.readOnly,fixedOverflowWidgets:!0,folding:!0,glyphMargin:this.innerConfig.editor.enableDebug}},e.prototype.ngAfterViewInit=function(){var e=this;this.LOG.debug(["ngAfterViewInit"],"height",this._heightPx),this._heightPx?(this.el.nativeElement.style.height=this._heightPx+"px",this.wrapper.nativeElement.style.height=this._heightPx+"px",this.resize(!0)):this.resizeWatcherInt=setInterval(this.resizeWatcher.bind(this),200);try{this.innerCode=this.contentWrapper.nativeElement.textContent;for(var n=this.innerCode.split("\n").length;n<this.innerConfig.editor.minLineNumber;n++)this.innerCode+="\n";for(var a=0;" "===this.innerCode[a]||"\n"===this.innerCode[a];)a++;this.innerCode=this.innerCode.substring(a),this.LOG.debug(["ngAfterViewInit"],"warpscript",this._warpscript),this.LOG.debug(["ngAfterViewInit"],"inner: ",this.innerCode.split("\n")),this.LOG.debug(["ngAfterViewInit"],"innerConfig: ",this.innerConfig);var i=this.setOptions();this.lastKnownWS=this._warpscript||this.innerCode,t.editor.setTheme(this.monacoTheme),this.LOG.debug(["ngAfterViewInit"],"edOpts: ",i),this.ed=j(this.editor.nativeElement,i),this.ed.setValue(this.lastKnownWS),t.editor.setModelLanguage(this.ed.getModel(),this.lang),this.innerConfig.editor.enableDebug&&this.ed.onMouseDown((function(t){t.event.leftButton&&(2!==t.target.type&&3!==t.target.type&&4!==t.target.type||e.toggleBreakPoint(t.target.position.lineNumber))})),this.ed.getModel().updateOptions({tabSize:this.innerConfig.editor.tabSize}),this.ed&&(this.warpViewEditorLoaded.emit("loaded"),O.emitBubblingEvent(this.el,"warpViewEditorLoaded","loaded"),this.LOG.debug(["ngAfterViewInit"],"loaded"),this.ed.getModel().onDidChangeContent((function(t){e.lastKnownWS!==e.ed.getValue()&&(e.LOG.debug(["ngAfterViewInit"],"ws changed",t),e.warpViewEditorWarpscriptChanged.emit(e.ed.getValue()),O.emitBubblingEvent(e.el,"warpViewEditorWarpscriptChanged",e.ed.getValue()))})),this.ed.onMouseDown((function(t){if(!e.isMac()&&t.event.ctrlKey||e.isMac()&&t.event.metaKey){var n=(e.ed.getModel().getWordAtPosition(t.target.range.getStartPosition())||{word:void 0}).word,a=e.ed.getValue(),i=G.extractSpecialComments(a),o=[],s=G.parseWarpScriptStatements(a);s.forEach((function(e,t){if("WF.ADDREPO"===e&&t>0){var n=s[t-1];(n.startsWith('"')&&n.endsWith('"')||n.startsWith("'")&&n.endsWith("'"))&&o.push(n.substring(1,n.length-1))}}));var r={endpoint:i.endpoint||e.url,macroName:n,wfRepos:o};e.warpViewEditorCtrlClick.emit(r),O.emitBubblingEvent(e.el,"warpViewEditorCtrlClick",r)}})))}catch(e){this.LOG.error(["ngAfterViewInit"],"componentDidLoad",e)}},e.prototype.ngOnDestroy=function(){this.LOG.debug(["ngOnDestroy"],"Component removed from the DOM"),this.resizeWatcherInt&&clearInterval(this.resizeWatcherInt),this.ed&&this.ed.dispose(),this.ro&&this.ro.disconnect(),this.request&&this.request.unsubscribe()},e.prototype.abort=function(t){var n=this;if(this.request)if(t){var a=G.extractSpecialComments(this.ed.getValue()).endpoint||this.url;this.http.post(a,"<% '"+t+"' 'WSKILLSESSION' EVAL %> <% -1 %> <% %> TRY",{observe:"response",responseType:"text",Accept:"application/json"}).pipe(i.catchError(this.handleError(void 0))).subscribe((function(i){if(i){n.LOG.debug(["abort"],"response",i.body);var o=JSON.parse(i.body);o[0]?(0===o[0]?n.sendError("It appears that your Warp 10 is running on multiple backend"):-1===o[0]&&n.sendError("Unable to WSABORT on "+a+". Did you activate StackPSWarpScriptExtension?"),n.sendStatus({message:e.getLabel(n.lang)+" aborted.",ops:parseInt(i.headers.get("x-warp10-ops"),10),elapsed:parseInt(i.headers.get("x-warp10-elapsed"),10),fetched:parseInt(i.headers.get("x-warp10-fetched"),10)})):n.sendError("An error occurs for session: "+t)}n.request.unsubscribe(),delete n.request,n.loading=!1}))}else this.sendStatus({message:e.getLabel(this.lang)+" aborted.",ops:0,elapsed:0,fetched:0}),this.request.unsubscribe(),delete this.request,this.loading=!1},e.prototype.highlight=function(e){var n=this,a="hl-"+e;Object.keys(this.breakpoints).forEach((function(e){e.startsWith("hl")&&delete n.breakpoints[e]})),this.breakpoints[a]={range:new t.Range(e,1,e,1),options:{isWholeLine:!0,className:"warpviewContentClass"}},this.decoration=this.ed.deltaDecorations(this.decoration,h.toArray(this.breakpoints))},e.prototype.toggleBreakPoint=function(e){var n="bp-"+e;this.breakpoints[n]?delete this.breakpoints[n]:this.breakpoints[n]={range:new t.Range(e,1,e,1),options:{isWholeLine:!0,glyphMarginClassName:"warpviewGlyphMarginClass"}},this.warpViewEditorBreakPoint.emit(this.breakpoints),O.emitBubblingEvent(this.el,"warpViewEditorBreakPoint",this.breakpoints),this.decoration=this.ed.deltaDecorations(this.decoration,h.toArray(this.breakpoints))},e.prototype.handleError=function(e){var t=this;return function(n){return t.LOG.error(["handleError"],{e:n}),0===n.status?t.error="Unable to reach "+n.url:n.headers.get("X-Warp10-Error-Message")&&n.headers.get("X-Warp10-Error-Line")?t.error="line #"+n.headers.get("X-Warp10-Error-Line")+": "+n.headers.get("X-Warp10-Error-Message"):t.error=n.statusText,t.warpViewEditorErrorEvent.emit(t.error),O.emitBubblingEvent(t.el,"warpViewEditorErrorEvent",t.error),t.loading=!1,o.of(e)}},e.prototype.execute=function(t){var n=this;if(this.ed){this.result=void 0,this.status=void 0,this.error=void 0,this.LOG.debug(["execute"],"this.ed.getValue()",t,this.ed.getValue()),this.loading=!0;var a=G.extractSpecialComments(this.ed.getValue());"I"===(a.displayPreviewOpt||"none")?this.selectedResultTab=2:2===this.selectedResultTab&&(this.selectedResultTab=0);var o=a.endpoint||this.url,s={"Content-Type":"text/plain;charset=UTF-8"};t&&(s["X-Warp10-WarpScriptSession"]=t);var r=this.ed.getValue().replace(/ /gi," ");v.FLOWS_LANGUAGE===this.lang&&(r="<'\n"+r+"\n'>\nFLOWS\n"),this.request=this.http.post(o,r,{observe:"response",responseType:"text",headers:s}).pipe(i.catchError(this.handleError(void 0))).subscribe((function(t){if(t){n.LOG.debug(["execute"],"response",t.body),n.warpViewEditorWarpscriptResult.emit(t.body),O.emitBubblingEvent(n.el,"warpViewEditorWarpscriptResult",t.body),n.sendStatus({message:"Your script execution took\n "+v.formatElapsedTime(parseInt(t.headers.get("x-warp10-elapsed"),10))+"\n serverside, fetched\n "+t.headers.get("x-warp10-fetched")+" datapoints and performed\n "+t.headers.get("x-warp10-ops")+"  "+e.getLabel(n.lang)+" operations.",ops:parseInt(t.headers.get("x-warp10-ops"),10),elapsed:parseInt(t.headers.get("x-warp10-elapsed"),10),fetched:parseInt(t.headers.get("x-warp10-fetched"),10)});try{n.result=t.body}catch(e){e.name&&e.message&&e.at&&e.text?n.error=e.name+": "+e.message+" at char "+e.at+" => "+e.text:n.error=e.toString(),n.result=t.body,n.LOG.error(["execute 1"],n.error),n.sendError(n.error)}}n.loading=!1}))}else this.loading=!1,this.LOG.error(["execute"],"no active editor")},e.prototype.requestDataviz=function(){this.warpViewEditorDatavizRequested.emit(this.result),O.emitBubblingEvent(this.el,"warpViewEditorDatavizRequested",this.result)},e.prototype.onResized=function(e){this.LOG.debug(["onResized"],e.detail.editor),this.warpViewEditorSize.emit(e.detail.editor)},e.prototype.isMac=function(){return navigator.platform.toUpperCase().indexOf("MAC")>=0},e.prototype.onKeyDown=function(e){this.LOG.debug(["onKeyDown"],e),(!this.isMac()&&e.ctrlKey||this.isMac()&&e.metaKey)&&Array.from(this.editor.nativeElement.getElementsByClassName("mtk8")).concat(Array.from(this.editor.nativeElement.getElementsByClassName("mtk22"))).concat(Array.from(this.editor.nativeElement.getElementsByClassName("mtk23"))).forEach((function(e){e.textContent.startsWith("$")||e.classList.add("mouseOver")}))},e.prototype.onKeyUp=function(e){this.LOG.debug(["onKeyUp"],e),Array.from(this.editor.nativeElement.getElementsByClassName("mtk8")).concat(Array.from(this.editor.nativeElement.getElementsByClassName("mtk22"))).concat(Array.from(this.editor.nativeElement.getElementsByClassName("mtk23"))).forEach((function(e){return e.classList.remove("mouseOver")}))},e.prototype.resize=function(e){var t=this;window.setTimeout((function(){e&&t._heightPx&&(t.editor.nativeElement.style.height="calc(100% - "+(t.buttons?t.buttons.nativeElement.clientHeight:100)+"px )"),e&&(t.warpViewEditorLoaded.emit(),O.emitBubblingEvent(t.el,"warpViewEditorLoaded","loaded"),t.LOG.debug(["resize"],"loaded"))}),e?500:100)},e.prototype.getItems=function(){var e=[];return this._showResult?(e.push({name:"editor",size:this._initialSize&&this._initialSize.p||50}),e.push({name:"result",size:this._initialSize&&100-this._initialSize.p||50})):e.push({name:"editor",size:100}),e},e.prototype.responsiveStyle=function(){return{height:"100%",width:"100%",overflow:"hidden"}},e.prototype.sendError=function(e){this.error=e,O.emitBubblingEvent(this.el,"warpViewEditorErrorEvent",this.error),this.warpViewEditorErrorEvent.emit(this.error)},e.prototype.sendStatus=function(e){this.status=Object.assign({},e),O.emitBubblingEvent(this.el,"warpViewEditorStatusEvent",this.status),this.warpViewEditorStatusEvent.emit(this.status)},e.getLabel=function(e){switch(e){case"flows":return"FLoWS";case"warpscript":return"WarpScript"}},e}();Z.MIN_HEIGHT=250,Z.decorators=[{type:n.Component,args:[{selector:"warpview-editor",template:'\x3c!--\n  ~  Copyright 2020 SenX S.A.S.\n  ~\n  ~  Licensed under the Apache License, Version 2.0 (the "License");\n  ~  you may not use this file except in compliance with the License.\n  ~  You may obtain a copy of the License at\n  ~\n  ~    http://www.apache.org/licenses/LICENSE-2.0\n  ~\n  ~  Unless required by applicable law or agreed to in writing, software\n  ~  distributed under the License is distributed on an "AS IS" BASIS,\n  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  ~  See the License for the specific language governing permissions and\n  ~  limitations under the License.\n  --\x3e\n<div [class]="\'warp-view-editor wrapper-main \' + _theme" #wrapper >\n  <div class="warpscript" #content>\n    <ng-content ngProjectAs="input"></ng-content>\n  </div>\n  <div class="loader" *ngIf="loading">\n    <div class="spinner"></div>\n  </div>\n  <wc-split [items]="getItems()" style="height: 100%">\n    <div slot="editor" class="editor-wrapper" style="height: 100%">\n      <div #editor (keydown)="onKeyDown($event)" (keyup)="onKeyUp($event)"></div>\n      <div [class]="\'warpview-buttons \' + innerConfig.buttons.class" #buttons>\n        <button type=\'button\' [class]="innerConfig.datavizButton.class"\n                *ngIf="showDataviz && result"\n                (click)="requestDataviz()" [innerHTML]="innerConfig.datavizButton.label">\n        </button>\n        <button type=\'button\' [class]="innerConfig.execButton.class"\n                *ngIf="showExecute"\n                (click)="execute()" [innerHTML]="innerConfig.execButton.label"></button>\n        <div class=\'messages\' *ngIf="error || result || status">\n          <div *ngIf="status && _displayMessages" [class]="innerConfig.messageClass" [innerHTML]="status.message"></div>\n          <div *ngIf="error && _displayMessages" [class]="innerConfig.errorClass" [innerHTML]="error"></div>\n        </div>\n      </div>\n    </div>\n    <div slot="result" *ngIf="showResult" style="height: 100%">\n      <wc-tabs class=\'wctabs\' [selection]="selectedResultTab" style="height: 100%">\n        <wc-tabs-header slot=\'header\' name=\'tab1\'>Results</wc-tabs-header>\n        <wc-tabs-header slot=\'header\' name=\'tab2\'>Raw JSON</wc-tabs-header>\n\n        <wc-tabs-header slot=\'header\' name=\'tab3\' *ngIf="imageTab">Images</wc-tabs-header>\n\n        <wc-tabs-content slot=\'content\' name=\'tab1\'>\n          <div class="tab-wrapper">\n            <warpview-result [theme]="theme" [result]="result" [config]=\'innerConfig\'></warpview-result>\n          </div>\n        </wc-tabs-content>\n\n        <wc-tabs-content slot=\'content\' name=\'tab2\' [responsive]="true">\n          <div class="tab-wrapper" [ngStyle]="responsiveStyle()">\n            <warpview-raw-result [theme]="theme" [result]="result" [config]="innerConfig" [debug]="debug"></warpview-raw-result>\n          </div>\n        </wc-tabs-content>\n\n        <wc-tabs-content slot=\'content\' name=\'tab3\' *ngIf="imageTab">\n          <div class="tab-wrapper">\n            <warpview-image-result [theme]="theme" [result]="result" [config]="innerConfig" [debug]="_debug"></warpview-image-result>\n          </div>\n        </wc-tabs-content>\n\n      </wc-tabs>\n    </div>\n  </wc-split>\n</div>\n',encapsulation:n.ViewEncapsulation.Emulated,styles:['/*!\n *  Copyright 2020 SenX S.A.S.\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */:host{height:100%;width:100%}:host .warpview-buttons{align-items:flex-start;display:flex}:host>div{height:100%;width:100%}:host .warpscript{display:none}:host .editor-wrapper{height:100%;overflow:auto}:host .wctabs{height:100%}:host .editor{height:100%;left:0;margin:0;max-height:100%!important;padding:0;position:absolute;top:0;width:100%}:host .tab-wrapper,:host div[slot]{height:100%}:host .messages{padding:5px;width:100%}:host .messages>*{font-size:12px;margin:0;padding:5px}:host .warp-view-editor.wrapper-main{bottom:0;left:0;margin:10px;position:relative;right:0;top:0;width:calc(100% - 20px)}:host .warp-view-editor.wrapper-main .loader{background-color:rgba(0,0,0,.3);bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}:host .warp-view-editor.wrapper-main .loader .spinner{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite;border-bottom-color:transparent;border-left-color:transparent;border-radius:50%;border-right-color:transparent;border-style:solid;border-top-color:var(--warp-view-spinner-color,#5899da);bottom:calc(50% - 25px);height:50px;left:calc(50% - 25px);margin:auto;overflow:visible;position:absolute;right:calc(50% - 25px);top:calc(50% - 25px);width:50px;z-index:999}:host .warp-view-editor.wrapper-main.dark{--warp-view-image-border-color:#a0a0a0;--warp-view-spinner-color:#f3f3f3;--wc-split-gutter-color:#343a40;--wc-tab-header-bg-color:transparent;--wc-tab-header-border-color:#343a40;--wc-tab-header-color:#f8f9fa;--wc-tab-header-disabled-bg-color:rgba(0,0,0,0.5);--wc-tab-header-disabled-color:hsla(0,0%,100%,0.5);--wc-tab-header-selected-bg-color:#f8f9fa;--wc-tab-header-selected-border-color:#343a40;--wc-tab-header-selected-color:#1e1e1e;background-color:#1e1e1e;color:#f8f9fa}:host .warp-view-editor.wrapper-main.light{background-color:#fff!important;color:#000}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}:host wc-tabs{height:100%}']}]}],Z.ctorParameters=function(){return[{type:n.ElementRef},{type:a.HttpClient}]},Z.propDecorators={url:[{type:n.Input}],lang:[{type:n.Input}],debug:[{type:n.Input}],theme:[{type:n.Input}],warpscript:[{type:n.Input,args:["warpscript"]}],showDataviz:[{type:n.Input,args:["showDataviz"]}],showExecute:[{type:n.Input,args:["showExecute"]}],showResult:[{type:n.Input,args:["showResult"]}],config:[{type:n.Input,args:["config"]}],displayMessages:[{type:n.Input,args:["displayMessages"]}],widthPx:[{type:n.Input,args:["widthPx"]}],heightLine:[{type:n.Input,args:["heightLine"]}],heightPx:[{type:n.Input,args:["heightPx"]}],imageTab:[{type:n.Input,args:["imageTab"]}],initialSize:[{type:n.Input,args:["initialSize"]}],warpViewEditorStatusEvent:[{type:n.Output,args:["warpViewEditorStatusEvent"]}],warpViewEditorErrorEvent:[{type:n.Output,args:["warpViewEditorErrorEvent"]}],warpViewEditorWarpscriptChanged:[{type:n.Output,args:["warpViewEditorWarpscriptChanged"]}],warpViewEditorWarpscriptResult:[{type:n.Output,args:["warpViewEditorWarpscriptResult"]}],warpViewEditorLoaded:[{type:n.Output,args:["warpViewEditorLoaded"]}],warpViewEditorSize:[{type:n.Output,args:["warpViewEditorSize"]}],warpViewEditorBreakPoint:[{type:n.Output,args:["warpViewEditorBreakPoint"]}],warpViewEditorCtrlClick:[{type:n.Output,args:["warpViewEditorCtrlClick"]}],warpViewEditorDatavizRequested:[{type:n.Output,args:["warpViewEditorDatavizRequested"]}],wrapper:[{type:n.ViewChild,args:["wrapper",{static:!0}]}],editor:[{type:n.ViewChild,args:["editor",{static:!0}]}],buttons:[{type:n.ViewChild,args:["buttons",{static:!0}]}],contentWrapper:[{type:n.ViewChild,args:["content",{static:!0}]}],abort:[{type:n.Input}],highlight:[{type:n.Input}],execute:[{type:n.Input}],onResized:[{type:n.HostListener,args:["document:resize",["$event"]]},{type:n.HostListener,args:["resized",["$event"]]}],resize:[{type:n.Input}]};var J=function(){function e(){this.color=["#4D4D4D","#5DA5DA","#FAA43A","#60BD68","#F17CB0","#B2912F","#B276B2","#DECF3F","#F15854","#607D8B"]}return e.prototype.getColor=function(e){return this.color[e%this.color.length]},e.prototype.unique=function(e){for(var t={},n=[],a=0,i=e.length;a<i;++a)t.hasOwnProperty(e[a])||(n.push(e[a]),t[e[a]]=1);return n},e.prototype.hexToRgb=function(e){var t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]:null},e.prototype.transparentize=function(e,t){return"rgba("+this.hexToRgb(e).concat(t).join(",")+")"},e.prototype.isArray=function(e){return e&&"object"==typeof e&&e instanceof Array&&"number"==typeof e.length&&"function"==typeof e.splice&&!e.propertyIsEnumerable("length")},e.prototype.isEmbeddedImage=function(e){return!("string"!=typeof e||!/^data:image/.test(e))},e.prototype.isEmbeddedImageObject=function(e){return!(null===e||null===e.image||null===e.caption||!this.isEmbeddedImage(e.image))},e.prototype.gtsFromJSON=function(e,t){return{gts:{c:e.c,l:e.l,a:e.a,v:e.v,id:t}}},e.prototype.gtsFromJSONList=function(e,t){var n,a=this,i=[];return e.forEach((function(e,o){var s=e;e.gts&&(s=e.gts),n=void 0!==t&&""!==t?t+"-"+o:""+o,a.isArray(s)&&i.push(a.gtsFromJSONList(s,n)),a.isGts(s)&&i.push(a.gtsFromJSON(s,n)),a.isEmbeddedImage(s)&&i.push({image:s,caption:"Image",id:n}),a.isEmbeddedImageObject(s)&&i.push({image:s.image,caption:s.caption,id:n})})),{content:i}},e.prototype.flatDeep=function(e){var t=this;return e.reduce((function(e,n){Array.isArray(n)?e.concat(t.flatDeep(n)):e.concat(n)}),[])},e.prototype.isGts=function(e){return!(!e||null===e.c||null===e.l||null===e.a||null===e.v||!this.isArray(e.v))},e.prototype.isObject=function(e){return e&&"object"==typeof e&&!Array.isArray(e)},e}();J.decorators=[{type:n.Injectable}];var Q=function(){function e(){this.escapee={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"}}return e.prototype.error=function(e){throw{name:"SyntaxError",message:e,at:this.at,text:this.text}},e.prototype.next=function(){return this.ch=this.text.charAt(this.at++)},e.prototype.check=function(e){e!==this.ch&&this.error("Expected '"+e+"' instead of '"+this.ch+"'"),this.ch=this.text.charAt(this.at++)},e.prototype.number=function(){var e="";if("-"===this.ch&&(e="-",this.check("-")),"I"===this.ch)return this.check("I"),this.check("n"),this.check("f"),this.check("i"),this.check("n"),this.check("i"),this.check("t"),this.check("y"),-1/0;for(;this.ch>="0"&&this.ch<="9";)e+=this.ch,this.next();if("."===this.ch)for(e+=".";this.next()&&this.ch>="0"&&this.ch<="9";)e+=this.ch;if("e"===this.ch||"E"===this.ch)for(e+=this.ch,this.next(),"-"!==this.ch&&"+"!==this.ch||(e+=this.ch,this.next());this.ch>="0"&&this.ch<="9";)e+=this.ch,this.next();return this.testBigInt(e)},e.prototype.testBigInt=function(e){return e.replace("-","").split(".")[0].length>16?new u.default(e):+e},e.prototype.string=function(){var e,t,n="";if('"'===this.ch)for(;this.next();){if('"'===this.ch)return this.next(),n;if("\\"===this.ch)if(this.next(),"u"===this.ch){t=0;for(var a=0;a<4&&(e=parseInt(this.next(),16),isFinite(e));a++)t=16*t+e;n+=String.fromCharCode(t)}else{if(!this.escapee[this.ch])break;n+=this.escapee[this.ch]}else n+=this.ch}this.error("Bad string")},e.prototype.white=function(){for(;this.ch&&this.ch<=" ";)this.next()},e.prototype.word=function(){switch(this.ch){case"t":return this.check("t"),this.check("r"),this.check("u"),this.check("e"),!0;case"f":return this.check("f"),this.check("a"),this.check("l"),this.check("s"),this.check("e"),!1;case"n":return this.check("n"),this.check("u"),this.check("l"),this.check("l"),null;case"N":return this.check("N"),this.check("a"),this.check("N"),NaN;case"I":return this.check("I"),this.check("n"),this.check("f"),this.check("i"),this.check("n"),this.check("i"),this.check("t"),this.check("y"),1/0}this.error("Unexpected '"+this.ch+"'")},e.prototype.array=function(){var e=[];if("["===this.ch){if(this.check("["),this.white(),"]"===this.ch)return this.check("]"),e;for(;this.ch;){if(e.push(this.value()),this.white(),"]"===this.ch)return this.check("]"),e;this.check(","),this.white()}}this.error("Bad array")},e.prototype.object=function(){var e,t={};if("{"===this.ch){if(this.check("{"),this.white(),"}"===this.ch)return this.check("}"),t;for(;this.ch;){if(e=this.string(),this.white(),this.check(":"),Object.hasOwnProperty.call(t,e)&&this.error('Duplicate key "'+e+'"'),t[e]=this.value(),this.white(),"}"===this.ch)return this.check("}"),t;this.check(","),this.white()}}this.error("Bad object")},e.prototype.value=function(){switch(this.white(),this.ch){case"{":return this.object();case"[":return this.array();case'"':return this.string();case"-":return this.number();default:return this.ch>="0"&&this.ch<="9"?this.number():this.word()}},e.prototype.parse=function(e,t){var n;return this.text=e,this.at=0,this.ch=" ",n=this.value(),this.white(),this.ch&&this.error("Syntax error"),"function"==typeof t?function e(n,a){var i,o,s=n[a];if(s&&"object"==typeof s)for(i in s)Object.prototype.hasOwnProperty.call(s,i)&&(void 0!==(o=e(s,i))?s[i]=o:delete s[i]);return t.call(n,a,s)}({"":n},""):n},e}(),$=function(){function e(t){this.gtsLib=t,this.config={},this._theme="light",this._debug=!1,this.loading=!1,this.imageList=[],this.LOG=new E(e,this._debug)}return Object.defineProperty(e.prototype,"debug",{get:function(){return this._debug},set:function(e){"string"==typeof e&&(e="true"===e),this._debug=e,this.LOG.setDebug(e)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"result",{get:function(){return this._res},set:function(e){this._res=e,this._result=(new Q).parse(e||"[]",void 0),this.loading=!0,this.LOG.debug(["isArray"],"The new value of result is: ",e),e&&this.gtsLib.isArray(this._result)?this.imageList=this._result.filter((function(e){return"string"==typeof e&&String(e).startsWith("data:image/png;base64,")})):this.imageList=[],this.loading=!1},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"theme",{get:function(){return this._theme},set:function(e){this._theme=e},enumerable:!1,configurable:!0}),e.prototype.isArray=function(e){return this.gtsLib.isArray(e)},e}();$.decorators=[{type:n.Component,args:[{selector:"warpview-image-result",template:'\x3c!--\n  ~  Copyright 2020 SenX S.A.S.\n  ~\n  ~  Licensed under the Apache License, Version 2.0 (the "License");\n  ~  you may not use this file except in compliance with the License.\n  ~  You may obtain a copy of the License at\n  ~\n  ~    http://www.apache.org/licenses/LICENSE-2.0\n  ~\n  ~  Unless required by applicable law or agreed to in writing, software\n  ~  distributed under the License is distributed on an "AS IS" BASIS,\n  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  ~  See the License for the specific language governing permissions and\n  ~  limitations under the License.\n  --\x3e\n<div [class]="\'wrapper-result \' + _theme">\n  <div *ngIf="_result && isArray(_result)" [class]="_theme + \' image\'">\n    <div *ngFor="let img of imageList; let i = index" class="image"><h2>Image {{i + 1}}</h2>\n      <img [src]="img" alt="Image"/>\n    </div>\n  </div>\n</div>\n',encapsulation:n.ViewEncapsulation.Emulated,styles:['/*!\n *  Copyright 2020 SenX S.A.S.\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */:host .wrapper-result{padding:10px}:host img{background-color:#fff;background-image:linear-gradient(45deg,#efefef 25%,transparent 0,transparent 75%,#efefef 0,#efefef),linear-gradient(45deg,#efefef 25%,transparent 0,transparent 75%,#efefef 0,#efefef);background-position:0 0,10px 10px;background-size:21px 21px;border:1.1px solid var(--warp-view-image-border-color,#404040)}']}]}],$.ctorParameters=function(){return[{type:J}]},$.propDecorators={debug:[{type:n.Input}],result:[{type:n.Input}],theme:[{type:n.Input}],config:[{type:n.Input}]};var ee=function(){function e(e){this.gtsLib=e,this.theme="light",this.config={},this.loading=!1}return Object.defineProperty(e.prototype,"result",{get:function(){return this._res},set:function(e){this._res=e,this._result=(new Q).parse(e||"[]",void 0),this._resultStr=(this._result||[]).map((function(e){var t=JSON.stringify(e);return t.startsWith("[")||t.startsWith("{")?t:e}))},enumerable:!1,configurable:!0}),e.prototype.isArray=function(e){return this.gtsLib.isArray(e)},e}();ee.decorators=[{type:n.Component,args:[{selector:"warpview-result",template:'\x3c!--\n  ~  Copyright 2020 SenX S.A.S.\n  ~\n  ~  Licensed under the Apache License, Version 2.0 (the "License");\n  ~  you may not use this file except in compliance with the License.\n  ~  You may obtain a copy of the License at\n  ~\n  ~    http://www.apache.org/licenses/LICENSE-2.0\n  ~\n  ~  Unless required by applicable law or agreed to in writing, software\n  ~  distributed under the License is distributed on an "AS IS" BASIS,\n  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  ~  See the License for the specific language governing permissions and\n  ~  limitations under the License.\n  --\x3e\n\n<div [class]="\'wrapper-result \' + theme">\n  <div *ngIf="_result && isArray(_result)" [class]="theme + \' raw\'">\n    <span *ngFor="let line of _resultStr; let index= index; let isFirst = first;" class="line">\n      <pre class="line-num">{{isFirst? \'[TOP]\' : index + 1}}</pre>\n      <pre class="line-content" [innerHTML]="line"></pre>\n    </span>\n  </div>\n</div>\n',encapsulation:n.ViewEncapsulation.Emulated,styles:['/*!\n *  Copyright 2020 SenX S.A.S.\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */:host,warpview-result{overflow-y:auto;position:relative}:host .wrapper-result,warpview-result .wrapper-result{width:100%}:host .loader .spinner,warpview-result .loader .spinner{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite;border:5px solid #f3f3f3;border-radius:50%;border-top-color:#555;bottom:0;height:50px;left:0;margin:auto;overflow:visible;position:fixed;right:0;top:0;width:50px;z-index:999}:host .loader:after,warpview-result .loader:after{background-color:rgba(0,0,0,.3);content:"";display:block;height:100%;left:0;position:absolute;top:0;width:100%}:host .wrapper.dark,warpview-result .wrapper.dark{--warp-view-spinner-color:#f3f3f3;background-color:#1e1e1e!important;color:#fff}:host .wrapper.light,warpview-result .wrapper.light{background-color:#fff!important;color:#000}:host .wrapper .loader,warpview-result .wrapper .loader{background-color:rgba(0,0,0,.3);bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}:host .wrapper .loader .spinner,warpview-result .wrapper .loader .spinner{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite;border-bottom-color:transparent;border-left-color:transparent;border-radius:50%;border-right-color:transparent;border-style:solid;border-top-color:var(--warp-view-spinner-color,#5899da);height:50px;left:calc(50% - 25px);margin:auto;overflow:visible;position:absolute;top:calc(50% - 25px);width:50px;z-index:999}:host .raw,warpview-result .raw{display:flex;flex-flow:column;font-family:Droid Sans Mono,Courier New,monospace,Droid Sans Fallback;font-size:14px;font-weight:400;letter-spacing:0;line-height:19px}:host .raw.light,warpview-result .raw.light{background-color:#fff!important;color:#343a40}:host .raw.light pre,warpview-result .raw.light pre{color:#343a40;font-family:Droid Sans Mono,Courier New,monospace,Droid Sans Fallback;font-size:14px;font-weight:400;height:auto;line-height:19px;min-height:19px;white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}:host .raw.light .line-num,warpview-result .raw.light .line-num{color:#2b91af}:host .raw.dark,warpview-result .raw.dark{background-color:#1e1e1e!important;color:#fff}:host .raw.dark pre,warpview-result .raw.dark pre{color:#fff;font-size:14px;height:auto;line-height:19px;min-height:19px;white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}:host .raw.dark .line-num,warpview-result .raw.dark .line-num{color:#5a5a5a}:host .raw .line,warpview-result .raw .line{display:block;max-width:calc(100% - 4em)}:host .raw .line-num,warpview-result .raw .line-num{float:left;margin:0;padding:.3em .5em .3em .3em;text-align:right;width:4em}:host .raw .line-content,warpview-result .raw .line-content{border-left:1px solid #5a5a5a;display:block;margin:0 0 0 5em;max-width:calc(100% - 4em);padding:.3em .3em .3em 1em}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}']}]}],ee.ctorParameters=function(){return[{type:J}]},ee.propDecorators={theme:[{type:n.Input}],config:[{type:n.Input}],loading:[{type:n.Input}],result:[{type:n.Input}]};var te=function(){this.quickSuggestionsDelay=10,this.quickSuggestions=!0,this.tabSize=2,this.minLineNumber=10,this.enableDebug=!1,this.rawResultsReadOnly=!0},ne=t.editor.setTheme,ae=t.editor.create,ie=function(){function e(){this.loading=!1,this._theme="light",this._config={editor:new te,messageClass:"",errorClass:""},this._debug=!1,this.LINE_HEIGHT=18,this.CONTAINER_GUTTER=10,this.monacoTheme="vs",this.LOG=new E(e,this._debug)}return Object.defineProperty(e.prototype,"debug",{get:function(){return this._debug},set:function(e){"string"==typeof e&&(e="true"===e),this._debug=e,this.LOG.setDebug(e)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"theme",{get:function(){return this._theme},set:function(e){this.LOG.debug(["WarpViewRawResult"],"The new value of theme is: ",e),this.monacoTheme="dark"===e?"vs-dark":"vs",this.LOG.debug(["WarpViewRawResult"],"The new value of theme is: ",this.monacoTheme),this._theme=e,ne(this.monacoTheme)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"result",{get:function(){return this._result},set:function(e){this.loading=!0,this._result=e,this.LOG.debug(["WarpViewRawResult"],"The new value of result is: ",e),this.buildEditor(this._result||""),this.loading=!1},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"config",{get:function(){return this._config},set:function(e){var t="string"==typeof e?JSON.parse(e||"{}"):e||{};this._config=h.mergeDeep(this._config,t),this.LOG.debug(["config"],this._config,t),this.resEd&&(this.LOG.debug(["config"],this._config),this.resEd.updateOptions(this.setOptions()))},enumerable:!1,configurable:!0}),e.prototype.ngOnInit=function(){this._config=h.mergeDeep(this._config,this.config),"dark"===this.theme&&(this.monacoTheme="vs-dark"),this.LOG.debug(["ngOnInit"],this.result)},e.prototype.buildEditor=function(e){this.LOG.debug(["buildEditor"],"buildEditor",e,this._config),!this.resEd&&e&&(this.resEd=ae(this.editor.nativeElement,this.setOptions())),this.resEd&&this.resEd.setValue(e||""),this.loading=!1},e.prototype.adjustHeight=function(){var e=this;if(this.editor){var t=this.editor.nativeElement,n=t.getElementsByClassName("view-lines")[0],a=n.offsetHeight,i=0;a?setTimeout((function(){var a=n.childElementCount>i?n.offsetHeight:n.childElementCount*e.LINE_HEIGHT+e.CONTAINER_GUTTER;i=n.childElementCount,t.style.height=a+"px",e.resEd.layout()}),0):setTimeout((function(){return e.adjustHeight()}),0)}},e.prototype.ngAfterViewInit=function(){this.LOG.debug(["ngAfterViewInit"],this._result),this.loading=!0,this.buildEditor(JSON.stringify(this._result)),this.loading=!1},e.prototype.setOptions=function(){return{value:"",language:"json",minimap:{enabled:!0},automaticLayout:!0,scrollBeyondLastLine:!1,theme:this.monacoTheme,readOnly:!!this._config.editor.rawResultsReadOnly,fixedOverflowWidgets:!0,lineNumbers:"on",wordWrap:"on"}},e}();ie.decorators=[{type:n.Component,args:[{selector:"warpview-raw-result",template:'\x3c!--\n  ~  Copyright 2020 SenX S.A.S.\n  ~\n  ~  Licensed under the Apache License, Version 2.0 (the "License");\n  ~  you may not use this file except in compliance with the License.\n  ~  You may obtain a copy of the License at\n  ~\n  ~    http://www.apache.org/licenses/LICENSE-2.0\n  ~\n  ~  Unless required by applicable law or agreed to in writing, software\n  ~  distributed under the License is distributed on an "AS IS" BASIS,\n  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  ~  See the License for the specific language governing permissions and\n  ~  limitations under the License.\n  --\x3e\n\n<div [class]="\'wrapper \' + _theme">\n  <div *ngIf="loading" class="loader">\n    <div class="spinner"></div>\n  </div>\n  <div #editor></div>\n</div>\n',encapsulation:n.ViewEncapsulation.Emulated,styles:['/*!\n *  Copyright 2020 SenX S.A.S.\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */:host,warpview-raw-result{height:100%}:host .decorationsOverviewRuler,warpview-raw-result .decorationsOverviewRuler{display:none}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}:host .editor-res,warpview-raw-result .editor-res{height:100%;min-height:500px;width:100%}:host .wrapper,warpview-raw-result .wrapper{height:100%;overflow:hidden;width:100%}:host .wrapper .loader,warpview-raw-result .wrapper .loader{background-color:rgba(0,0,0,.3);bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}:host .wrapper .loader .spinner,warpview-raw-result .wrapper .loader .spinner{-webkit-animation:spin 1s linear infinite;animation:spin 1s linear infinite;border-bottom-color:transparent;border-left-color:transparent;border-radius:50%;border-right-color:transparent;border-style:solid;border-top-color:var(--warp-view-spinner-color,#5899da);height:50px;left:calc(50% - 25px);margin:auto;overflow:visible;position:absolute;top:calc(50% - 25px);width:50px;z-index:999}:host .wrapper.dark,warpview-raw-result .wrapper.dark{--warp-view-spinner-color:#f3f3f3;background-color:#1e1e1e;color:#f8f9fa}:host .wrapper.light,warpview-raw-result .wrapper.light{background-color:#fff!important;color:#000}:host .wrapper>div,warpview-raw-result .wrapper>div{height:100%;width:100%!important}']}]}],ie.ctorParameters=function(){return[]},ie.propDecorators={editor:[{type:n.ViewChild,args:["editor",{static:!0}]}],debug:[{type:n.Input}],theme:[{type:n.Input}],result:[{type:n.Input}],config:[{type:n.Input,args:["config"]}],heightLine:[{type:n.Input}],heightPx:[{type:n.Input}]};var oe=function(){};oe.decorators=[{type:n.NgModule,args:[{declarations:[Z,$,ee,ie],imports:[r.CommonModule,c.BrowserModule,a.HttpClientModule,l.FormsModule],exports:[Z,$,ee,ie],providers:[J],schemas:[n.CUSTOM_ELEMENTS_SCHEMA],entryComponents:[Z,$,ee,ie]}]}];var se=function(){};e.ButtonConfig=se,e.Config=m,e.EditorConfig=te,e.WarpViewEditorAngularModule=oe,e.WarpViewEditorComponent=Z,e.WarpViewImageResult=$,e.WarpViewRawResultComponent=ie,e.WarpViewResult=ee,e.ɵa=J,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=warpview-editor.umd.min.js.map